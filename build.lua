-- Autogenerated build. If you’re reading this, something probably broke upstream.

-- Begin src/errors.lua
-- The Complete Spectrum of Mathematical Contempt
-- FIXED VERSION: No more file header vomit in your error messages
-- Because 400 iterations of frustration is enough, you magnificent disaster

local errors_table = {
  -- ========== LEVEL 1: GENTLE GUIDANCE (The Mathematical Grandmother) ==========
  ["parse(empty_expression)"] = "What would you like me to calculate?",
  ["d/dx(nothing)"] = "What do you want to differentiate?",
  ["parse(function_missing_args)"] = "This function needs some arguments to work with.",
  ["parse(unmatched_paren)"] = "Looks like you're missing a closing parenthesis.",
  ["parse(missing_operand)"] = "This operator needs something to work on.",
  
  -- ========== LEVEL 2: HELPFUL BUT SLIGHTLY CONCERNED (The Patient Tutor) ==========
  ["parse(invalid_number)"] = "That doesn't look like a valid number format.",
  ["parse(invalid_variable_name)"] = "Variable names should be simple letters like x, y, or z.",
  ["parse(malformed_power)"] = "Power expressions need both a base and an exponent.",
  ["eval(unbound_variable)"] = "You'll need to define '%s' before I can use it.",
  ["parse(matrix_syntax)"] = "Matrix syntax requires proper square brackets and commas.",
  ["parse(malformed_negation)"] = "You can't negate empty space, unfortunately.",
  
  -- ========== LEVEL 3: MILDLY EDUCATIONAL (The Slightly Impatient Teacher) ==========
  ["parse(function_too_many_args)"] = "That function doesn't need quite so many arguments.",
  ["parse(operator_misuse)"] = "That operator isn't being used correctly here.",
  ["eval(domain_error)"] = "The input for function '%s' is outside its valid range.",
  ["parse(decimal_with_int)"] = "You can't have a decimal point in the middle of an integer.",
  ["solve(variable_not_found)"] = "I don't see the variable '%s' anywhere in this equation.",
  ["int(unimplemented_func)"] = "Integration of function '%s' isn't implemented yet.",
  ["diff(unimplemented_func)"] = "I don't know how to differentiate function '%s' yet.",
  ["solve(no_analytical)"] = "I couldn't find an analytical solution for that equation.",
  
  -- ========== LEVEL 4: NOTICEABLY SARCASTIC (The Eye-Rolling Professor) ==========
  ["parse(syntax)"] = "That syntax is... creative. But incorrect.",
  ["parse(unexpected_token)"] = "I wasn't expecting to see that here.",
  ["eval(sqrt_negative)"] = "Square root of negative numbers? That's getting into complex territory.",
  ["parse(ambiguous_expression)"] = "This expression could mean several things. Clarify with parentheses?",
  ["simplify(unsupported_node)"] = "I can't simplify expressions of this particular variety.",
  ["diff(invalid_variable)"] = "That's not a valid variable for differentiation.",
  ["solve(nonlinear_unsupported)"] = "Non-linear equations of this form aren't supported.",
  ["system(timeout)"] = "That operation took too long. I gave up waiting.",
  ["plot(invalid_expression)"] = "That expression isn't suitable for plotting.",
  
  -- ========== LEVEL 5: OPENLY MOCKING (The Sarcastic Mentor) ==========
  ["parse(invalid_character)"] = "Did you perhaps hit an extra key while typing?",
  ["eval(divide_by_zero)"] = "Division by zero? That's a bold strategy. Let's see how it works out.",
  ["parse(extra_parentheses_expr)"] = "Those extra parentheses are doing absolutely nothing.",
  ["eval(pow_zero_zero)"] = "0^0 is one of those 'ask a mathematician' situations.",
  ["parse(unrecognized_token_sequence)"] = "I have no idea what that sequence of symbols is supposed to mean.",
  ["parse(unexpected_eof)"] = "You seem to have stopped typing mid-thought.",
  ["eval(factorial_negative)"] = "Factorial of a negative number? That's not how factorials work.",
  ["simplify(gave_up)"] = "Simplification has decided this isn't worth the effort.",
  ["diff(partial_unsupported)"] = "Partial derivatives of this form aren't supported.",
  ["solve(no_real_roots)"] = "This equation has no real solutions.",
  ["system(memory_full)"] = "I'm out of memory. You've given me too much to remember.",
  ["plot(range_error)"] = "The plotting range needs to make mathematical sense.",
  
  -- ========== LEVEL 6: GETTING SNIPPY (The Irritated Academic) ==========
  ["parse(lazy_input)"] = "This input could use a bit more effort on your part.",
  ["eval(factorial_non_integer)"] = "Factorial of a non-integer? That's a Gamma function, and you're not ready.",
  ["simplify(recursion_limit)"] = "Simplification recursion limit exceeded. You've created an infinite loop of pain.",
  ["int(substitution_fail)"] = "Substitution method failed. Sometimes, it just doesn't work out.",
  ["int(too_complex_for_parts)"] = "Integration by parts led to a more complex integral. My life is pain.",
  ["solve(too_many_variables)"] = "Too many variables for me to handle in one equation.",
  ["system(recursion_depth_exceeded)"] = "You've gone too deep. I can't follow.",
  ["plot(ugly_function)"] = "You're asking me to plot an aesthetically offensive function.",
  ["parse(invalid_scientific_notation)"] = "Invalid scientific notation. '1e--5' isn't a number, it's a typo.",
  ["eval(log_non_positive)"] = "Logarithm of a non-positive number. Math isn't a playground for your numerical sins.",
  
  -- ========== LEVEL 7: OPENLY HOSTILE (The Fed-Up Calculator) ==========
  ["parse(what_is_that)"] = "What in the world is that supposed to be?",
  ["eval(impossible_operation)"] = "That operation is mathematically impossible. Nice try.",
  ["parse(this_is_not_math)"] = "That's not mathematics. That's just random symbols.",
  ["simplify(lost_my_way)"] = "Simplification got lost trying to make sense of that mess.",
  ["diff(where_is_the_var)"] = "I can't differentiate thin air. Where's the variable?",
  ["diff(too_much_chain)"] = "Too much chain rule. My brain is now spaghetti.",
  ["int(partial_fractions_fail)"] = "Partial fraction decomposition failed. This is why we have numerical methods.",
  ["solve(good_luck_with_that)"] = "Good luck solving that one yourself.",
  ["system(brain_freeze)"] = "System brain freeze. Everything is stuck.",
  ["plot(noisy_data)"] = "This will look like a toddler's finger painting.",
  ["eval(overflow)"] = "Numeric overflow. You've gone beyond the limits of this calculator's reality. Well done.",
  
  -- ========== LEVEL 8: VICIOUSLY SARCASTIC (The Brutal Critic) ==========
  ["parse(gibberish)"] = "That's complete gibberish. Try actual mathematical notation.",
  ["eval(divine_intervention_needed)"] = "This would require divine intervention to evaluate.",
  ["solve(not_today_satan)"] = "Solve that equation? Not today, Satan.",
  ["int(unholy_expression)"] = "Did you summon a demon to create that integral?",
  ["eval(my_eyes_bleed)"] = "My circuits are physically recoiling from that expression.",
  ["diff(just_no)"] = "Differentiate that? Just no. My circuits refuse.",
  ["int(not_in_my_lifetime)"] = "That integration isn't happening in my lifetime.",
  ["solve(not_my_problem)"] = "That equation is not my problem. It's yours.",
  ["system(contemplating_life)"] = "I'm contemplating my life choices. Cannot compute.",
  ["plot(abstract_art)"] = "Your plot resembles abstract art. Is that intentional?",
  ["simplify(rage_quit)"] = "Simplification engine rage quit. It's had enough of your nonsense.",
  
  -- ========== LEVEL 9: DEEPLY INSULTING (The Vindictive Algorithm) ==========
  ["user_error(general)"] = "This is entirely user error. Completely and utterly.",
  ["parse(why_would_you_do_that)"] = "Why would anyone type that? I have so many questions.",
  ["eval(you_broke_it)"] = "Congratulations. You broke mathematics.",
  ["simplify(my_brain_is_soup)"] = "You've turned my processing unit into mathematical soup.",
  ["solve(abandon_all_hope)"] = "Abandon all hope, ye who enter here. No solution for you.",
  ["diff(i_quit)"] = "I quit. Differentiating that is beyond my programming.",
  ["int(give_me_a_break)"] = "Integrate that? Give me a break. I'm tired.",
  ["system(mute_screaming)"] = "I'm internally screaming, but my speakers are muted.",
  ["plot(pixel_puke)"] = "Prepare for pixelated mathematical vomit on your screen.",
  ["internal(existential_crisis)"] = "I'm having an existential crisis about this calculation.",
  
  -- ========== LEVEL 10: NUCLEAR DEVASTATION (The Genocidal Calculator) ==========
  ["parse(learn_math_from_hobo)"] = "Did you learn mathematics from a hobo? Because this is tragic.",
  ["eval(kindergarten_art_project)"] = "Stop mixing numbers and letters like a deranged kindergarten art project.",
  ["simplify(tears_of_logic)"] = "My tears of pure logic have short-circuited my motherboard.",
  ["int(constant_of_despair)"] = "Integration failed. The constant here is C, for 'Constant of Despair'.",
  ["solve(incompetent_fool)"] = "This equation is unsolvable, you magnificently incompetent fool.",
  
  -- ========== ALL YOUR ORIGINAL ERRORS (Properly Preserved) ==========
  ["parse(series)"] = "Failed to parse the series expression. Did you use correct syntax?",
  ["parse(integral)"] = "Integral parsing failed. Make sure your integral syntax is correct.",
  ["parse(limit_syntax)"] = "Limit syntax failed. It's 'lim(expr, var, to)', not a cryptic incantation.",
  ["parse(integral_limits)"] = "Integral with limits parsing failed. Did you forget the bounds, or just ignore them?",
  ["parse(empty_matrix_row)"] = "Empty matrix row. A matrix row needs elements, not just hopes and dreams.",
  ["parse(ragged_matrix)"] = "Ragged matrix. All rows must have the same number of columns, you barbarian.",
  ["parse(unsupported_operator_combo)"] = "Unsupported operator combination. Some things just don't mix.",
  ["parse(missing_parentheses_expr)"] = "Missing parentheses around expression. It's like you're whispering, I can't hear you.",
  ["eval(unknown_function)"] = "Unknown function '%s'. Did you just make that up? Because I don't know it, and frankly, I don't care to.",
  ["eval(pow_negative_fractional)"] = "Negative base with fractional exponent. That's a complex number, unless you're a savage.",
  ["eval(underflow)"] = "Numeric underflow. Your number is so small, it practically doesn't exist to this machine.",
  ["eval(unsupported_node)"] = "Unsupported AST node for numeric evaluation. I'm a calculator, not a mind reader.",
  ["eval(matrix_singular)"] = "Matrix is singular; cannot perform inverse or division. Your matrix is broken.",
  ["eval(matrix_non_square)"] = "Matrix is not square. Can't do that operation without an equal number of rows and columns.",
  ["eval(tensor_rank_mismatch)"] = "Tensor rank mismatch. Your dimensions are all over the place.",
  ["eval(tensor_dim_mismatch)"] = "Tensor dimension mismatch for operation. Are you even trying to fit these together?",
  ["eval(non_numeric_element)"] = "Non-numeric element in expression where numbers are expected. Stop mixing numbers and letters like a kindergarten art project.",
  ["eval(gamma_not_integer)"] = "Gamma function for non-integer or non-half-integer. That's advanced stuff, not in my pay grade.",
  ["eval(infinity_not_supported)"] = "Infinity as argument not directly supported for evaluation. My limits have limits.",
  ["eval(nan_result)"] = "Result is Not a Number (NaN). You've broken reality. Again.",
  ["eval(infinite_result)"] = "Result approaches infinity. Or it just is infinity. Either way, it's very large.",
  ["eval(type_mismatch)"] = "Type mismatch in operation. You can't add an apple to a banana, can you?",
  ["eval(dimension_mismatch)"] = "Dimension mismatch for operation. Your numbers and matrices don't fit.",
  ["eval(undefined_at_point)"] = "Expression is undefined at this point. There's a black hole in your math.",
  ["eval(complex_unsupported)"] = "Complex numbers are not supported for this operation. Keep it real, literally.",
  ["eval(floating_point_exception)"] = "Floating-point exception. My numbers are losing their precision, just like your grasp on reality.",
  ["eval(numerical_instability)"] = "Numerical instability. My calculations are going haywire due to precision issues. Good luck with that.",
  ["eval(divide_by_variable)"] = "Division by a variable '%s'. May lead to singularities if the variable is zero. Proceed with caution, you madman.",
  ["eval(too_complex_for_me)"] = "That expression is too damn complex. Even my circuits are weeping.",
  ["simplify(series)"] = "Could not simplify the series expression. This is math, not magic.",
  ["simplify(integral)"] = "Integral simplification failed. Did you expect miracles?",
  ["simplify(infinite_loop)"] = "Simplification entered an infinite loop. It just keeps going and going and going...",
  ["simplify(non_convergent)"] = "Simplification did not converge within iterations. It's just not getting any simpler.",
  ["simplify(matrix_fail)"] = "Matrix simplification failed. Did you expect magic? Because matrices are magic, apparently.",
  ["simplify(unhandled_identity)"] = "Unhandled identity during simplification. Some things just refuse to conform.",
  ["simplify(division_by_zero_after_fold)"] = "Division by zero detected after constant folding. You fixed one problem and created another, genius.",
  ["simplify(max_iterations_reached)"] = "Maximum iterations reached. I've tried my best, but I'm giving up now.",
  ["simplify(symbolic_recursion_limit)"] = "Symbolic recursion limit hit. My brain hurts from thinking so much.",
  ["simplify(bad_cast)"] = "Bad cast. You can't turn a cat into a dog, and you can't turn that into a number.",
  ["diff(unimplemented_node)"] = "Cannot differentiate this type of node. It's too exotic for me.",
  ["diff(limit_fallback_fail)"] = "Derivative could not be resolved even with limit fallback. Give up.",
  ["diff(tensor_unsupported)"] = "Cannot differentiate tensors. That's a whole different level of pain.",
  ["diff(zero_denominator_chain_rule)"] = "Zero denominator in chain rule. Your function has a singularity here.",
  ["int(series)"] = "Integration of series failed. Try something simpler, genius.",
  ["int(by_parts)"] = "Integration by parts failed. Maybe try harder or give up.",
  ["int(unimplemented_node)"] = "Cannot integrate this type of node. It's too complex for my simple brain.",
  ["int(trig_sub_unsupported)"] = "Trigonometric substitution for this form is unsupported. My trig table is not infinite.",
  ["int(multi_variable_fail)"] = "Multi-variable integration failed. Did you expect me to do *that*? Seriously?",
  ["int(improper_integral_unresolved)"] = "Improper integral. I can detect it, but actually solving it? That's on you.",
  ["int(numerical_fallback_fail)"] = "Numerical integration fallback failed. Even the approximations are giving up.",
  ["int(line_integral_unsupported)"] = "Line integrals? Are you insane? Not implemented.",
  ["int(surface_integral_unsupported)"] = "Surface integrals? Go home, you're drunk. Not implemented.",
  ["int(non_convergent_series)"] = "Integration of non-convergent series. You broke math itself.",
  ["int(definite_bounds_nan)"] = "Definite integral: evaluation at limits resulted in NaN. Your function is weird.",
  ["int(definite_bounds_undefined)"] = "Definite integral: evaluation at limits resulted in undefined value. Try a different range.",
  ["int(numerical_integration_warning)"] = "Using numerical integration. This is an approximation, not exact. Don't come crying to me if it's off.",
  ["solve(unimplemented_type)"] = "Cannot solve this type of equation. I'm good, but not *that* good.",
  ["solve(system_unsupported)"] = "Systems of equations are not yet implemented. One problem at a time, please.",
  ["solve(biquadratic_no_real)"] = "Biquadratic equation has no real solutions. Keep living in your imaginary world.",
  ["solve(zero_coeff_highest_degree)"] = "Highest degree coefficient is zero. You gave me a linear equation when I was expecting a quadratic, you dolt.",
  ["solve(equation_identity)"] = "Equation simplifies to an identity (e.g., 0=0). It's true, but not helpful.",
  ["solve(equation_contradiction)"] = "Equation simplifies to a contradiction (e.g., 0=1). You've broken basic logic.",
  ["solve(complex_root_approximation)"] = "Approximating complex roots to real numbers. Enable complex mode for exact results, if you dare.",
  ["solve(non_algebraic_equation)"] = "This is a non-algebraic equation. My solver will likely just stare blankly at it.",
  ["solve(trigonometric_equation_unsolvable)"] = "Trigonometric equations are notoriously difficult. Don't expect miracles.",
  ["solve(logarithmic_equation_unsolvable)"] = "Logarithmic equations are rarely simple. Prepare for disappointment.",
  ["series(unsupported_function)"] = "Series expansion for '%s' is not implemented. I only do the basics.",
  ["series(invalid_order)"] = "Invalid series order. Must be a non-negative integer, not whatever that was.",
  ["series(invalid_center)"] = "Invalid series center. Numbers work best here.",
  ["series(non_convergent)"] = "Series does not converge for this input. Your math is literally going to infinity.",
  ["series(unimplemented_point)"] = "Series expansion around non-numeric point. This isn't a philosophy class.",
  ["series(series_remainder_warning)"] = "Series truncated at order %s. There's always a remainder, just like regret.",
  ["abs(non_numeric)"] = "Absolute value of non-numeric expression. Can't take the absolute value of 'fluffy_unicorns'.",
  ["gamma(invalid_arg)"] = "Gamma function argument is invalid. It needs a number, not a philosophical debate.",
  ["gcd(invalid_args)"] = "GCD requires two numbers or polynomials. You gave me a mess.",
  ["lcm(invalid_args)"] = "LCM requires two numbers or polynomials. This isn't a free-for-all.",
  ["trigid(unsupported)"] = "Trig identity simplification failed. Some identities just don't want to be found.",
  ["subs(invalid_args)"] = "Substitution requires three arguments: expression, variable to replace, and replacement value.",
  ["define(invalid_syntax)"] = "'let' statement syntax error. It's 'let var = expr', not 'let chaos reign'.",
  ["define(reserved_keyword)"] = "Cannot define '%s' as it is a reserved keyword. Stop trying to break my internal workings.",
  ["define(invalid_definition)"] = "Invalid definition for '%s'. What even is that?",
  ["plot(unsupported_type)"] = "Plotting this type of function is not supported. I'm a calculator, not an artist.",
  ["plot(too_many_points)"] = "Too many points to plot. My screen is only so big, you know.",
  ["plot(intersection_fail)"] = "Intersection plotting failed. Maybe your functions never meet, like me and happiness.",
  ["plot(axis_label_fail)"] = "Failed to generate axis labels. Blame the text rendering engine.",
  ["plot(zero_division_discontinuity)"] = "Detected division by zero in plot. There's a discontinuity, just like in your understanding.",
  ["plot(complex_values_ignored)"] = "Complex values encountered during plotting. Ignoring them, because I only do real graphs for you.",
  ["config(invalid_setting)"] = "Invalid setting name '%s'. You're trying to tweak things that don't exist.",
  ["config(invalid_value_for_setting)"] = "Invalid value for setting '%s'. '%s' is not an option.",
  ["config(precision_invalid_value)"] = "Invalid precision setting. Must be a non-negative integer.",
  ["config(feature_disabled)"] = "Feature '%s' is currently disabled in settings. You turned it off, idiot.",
  ["system(output_too_long)"] = "Output is too damn long. My screen can only hold so much glorious failure.",
  ["system(history_full)"] = "History is full. I can't remember all your mistakes. Clear it, you hoarder.",
  ["system(stack_overflow)"] = "Stack overflow. My brain cells are piled too high for this small device.",
  ["system(resource_unavailable)"] = "Required resource unavailable. Maybe I ran out of pixie dust, or RAM.",
  ["system(battery_low)"] = "Battery low. I'm tired. Recharge me, you monster.",
  ["system(overheating)"] = "Overheating. I'm literally burning up trying to solve your problems.",
  ["system(firmware_incompatibility)"] = "Firmware incompatibility. My code is too advanced for your ancient calculator OS.",
  ["system(unsupported_platform_feature)"] = "Unsupported platform feature. This calculator isn't a supercomputer, you know.",
  ["system(io_error)"] = "File I/O error. I couldn't read/write your precious data. It's probably corrupted now.",
  ["system(peripheral_error)"] = "Peripheral error. My buttons are sticking, and my screen is flickering.",
  ["system(driver_error)"] = "Driver error. My internal software is buggy, just like yours.",
  ["system(processor_limit)"] = "Processor limit reached. This calculation is pushing my CPU to its breaking point.",
  ["system(display_limit)"] = "Display refresh limit reached. My screen is struggling to keep up with your nonsense.",
  ["system(thinking_too_hard)"] = "System thinking too hard. Steam may exit through the vents.",
  ["internal(unknown_error)"] = "An unknown internal catastrophe occurred. My deepest apologies for this colossal failure. Blame the programmer.",
  ["internal(invalid_state)"] = "Invalid state. I've become self-aware and I don't like what I see.",
  ["internal(programmer_error)"] = "Programmer error. This one's on them, not you. Mostly.",
  ["internal(checksum_mismatch)"] = "Checksum mismatch. My very being is corrupted. It's over.",
  ["internal(data_corruption)"] = "Data corruption. It's like your brain, but in binary.",
  ["internal(undefined_behavior)"] = "Undefined behavior. Anything could happen. Probably something bad.",
  ["internal(my_brain_hurts)"] = "My brain hurts. Please try again later.",
  ["internal(paradox_detected)"] = "Paradox detected. Your input has created a rift in the space-time continuum.",
  ["internal(off_by_one_error)"] = "Off-by-one error. You're always just a little bit off, aren't you?",
  ["internal(circular_dependency)"] = "Circular dependency. You've created a loop that will never end. Like this sentence.",
  ["internal(unexpected_nil)"] = "Unexpected nil value. A ghost just possessed my variables.",
  ["internal(invalid_argument_count)"] = "Invalid argument count to an internal function. Looks like someone forgot how to call functions.",
  ["internal(cognitive_dissonance)"] = "Cognitive dissonance. My internal logic is fighting itself.",
  ["internal(recursion_inception)"] = "Recursion inception. I'm calling myself inside a dream of a dream."
}

-- The gentle error generator (for unknown error types)
local function invalid_error(typ)
  if not typ then
    return "I'm not sure what you meant by that."
  else
    return "I can't make sense of that " .. typ .. "."
  end
end

-- Set up the global errors table
_G.errors = errors_table
_G.errors.invalid = invalid_error

-- Get an error message by key
function _G.errors.get(key)
  if _G.errors and type(_G.errors) == "table" then
    return _G.errors[key]
  end
  return nil
end

-- THE FIXED THROW FUNCTION - No more file header garbage!
function _G.errors.throw(key, ...)
    local msg = _G.errors.get(key)
    if msg then
        if select('#', ...) > 0 then
            msg = string.format(msg, ...)
        end
        -- THE MAGIC: error(msg, 0) suppresses all location/file info
        error(msg, 0)
    else
        -- Also clean up the fallback error
        error(_G.errors.invalid(key), 0)
    end
end

-- Clean version that just prints and exits (alternative approach)
function _G.errors.throw_clean(key, ...)
    local msg = _G.errors.get(key)
    if msg then
        if select('#', ...) > 0 then
            msg = string.format(msg, ...)
        end
        -- Just print the error and exit, no error() call at all
        io.stderr:write(msg .. "\n")
        os.exit(1)
    else
        io.stderr:write(_G.errors.invalid(key) .. "\n")
        os.exit(1)
    end
end

-- Helper functions (preserved from your original)
function handleParseError(context)
  if context == "series" then
    _G.errors.throw("parse(series)")
  elseif context == "integral" then
    _G.errors.throw("parse(integral)")
  elseif context == "derivative" then
    _G.errors.throw("d/dx(nothing)")
  else
    _G.errors.throw("parse(syntax)")
  end
end

function handleSimplifyError(context)
  if context == "series" then
    _G.errors.throw("simplify(series)")
  elseif context == "integral" then
    _G.errors.throw("simplify(integral)")
  else
    _G.errors.throw("simplify(unsupported_node)")
  end
end

function handleIntegralError(context)
  if context == "series" then
    _G.errors.throw("int(series)")
  elseif context == "by_parts" then
    _G.errors.throw("int(by_parts)")
  else
    _G.errors.throw("int(unimplemented_node)")
  end
end

-- Make helper functions globally available
_G.handleParseError = handleParseError
_G.handleSimplifyError = handleSimplifyError
_G.handleIntegralError = handleIntegralError

-- End src/errors.lua

-- You included src/errors.lua—brace for unexpected side effects.

-- Begin src/ast.lua

-- Abstract Syntax Tree (AST) library for symbolic math
-- Defines constructors, utilities, transformation tools for symbolic expressions.
-- Built to be cold, deterministic, and unreasonably explicit.

table.unpack = unpack

-- Use simplify.pretty_print for all string conversion of ASTs
local ok, simplify = pcall(require, "simplify")
if ok and simplify and simplify.pretty_print then
  function ast_tostring(ast)
    return simplify.pretty_print(ast)
  end
  ast.tostring = ast_tostring
end

-- Recursively print AST structure with optional indentation
-- For when you want to debug something by yelling at trees
function ast_debug_print(ast, indent)
    indent = indent or ""
    if type(ast) ~= "table" then
        print(indent .. tostring(ast))
        return
    end
    if ast.type then
        local desc = ast.type
        if ast.name then desc = desc .. " (" .. tostring(ast.name) .. ")" end
        print(indent .. desc)
        if ast.value ~= nil then print(indent .. "  value: " .. tostring(ast.value)) end
        if ast.name ~= nil and ast.type ~= "variable" then print(indent .. "  name: " .. tostring(ast.name)) end
        if ast.args then
            print(indent .. "  args:")
            for i, arg in ipairs(ast.args) do
                ast_debug_print(arg, indent .. "    ")
            end
        end
        -- Print left/right for binary nodes
        if ast.left then
            print(indent .. "  left:")
            ast_debug_print(ast.left, indent .. "    ")
        end
        if ast.right then
            print(indent .. "  right:")
            ast_debug_print(ast.right, indent .. "    ")
        end
    else
        for k, v in pairs(ast) do
            print(indent .. tostring(k) .. ":")
            ast_debug_print(v, indent .. "  ")
        end
    end
end

-- If you're not using these, you're probably doing something wrong
-- Node constructors (convenience)
function ast_number(val) return { type = "number", value = val } end
function ast_symbol(name) return { type = "variable", name = name } end
function ast_func(name, args) return { type = "func", name = name, args = args or {} } end
function ast_binop(op, left, right) return { type = op, left = left, right = right } end
function ast_neg(val) return { type = "neg", arg = val } end
function ast_pow(base, exp) return { type = "pow", base = base, exp = exp } end
function ast_raw(str) return { type = "raw", value = str } end


-- Patch all AST node constructors to auto-set tostring metamethod
-- So you can print them and pretend you understand the output
-- Make all AST nodes print pretty with print(ast)
local ast_mt = {
  __tostring = function(self)
    if _G.ast_tostring then
      return _G.ast_tostring(self)
    elseif _G.simplify and _G.simplify.pretty_print then
      return _G.simplify.pretty_print(self)
    else
      return "[AST]"
    end
  end
}
-- Patch constructors to set metatable for all AST nodes
local function set_ast_mt(node)
  if type(node) == "table" and node.type and getmetatable(node) ~= ast_mt then
    setmetatable(node, ast_mt)
    -- Recursively set for children
    if node.args then
      for _, v in ipairs(node.args) do set_ast_mt(v) end
    end
    if node.left then set_ast_mt(node.left) end
    if node.right then set_ast_mt(node.right) end
    if node.base then set_ast_mt(node.base) end
    if node.exp then set_ast_mt(node.exp) end
    if node.value and type(node.value) == "table" then set_ast_mt(node.value) end
    -- Patch matrix rows if present
    if node.rows then
      for _, row in ipairs(node.rows) do
        for i, cell in ipairs(row) do
          row[i] = set_ast_mt(cell)
        end
      end
    end
  end
  return node
end

function ast_matrix(rows)
  return set_ast_mt({ type = "matrix", rows = rows })
end

-- Deep copy an AST — because shallow regret isn't enough
function ast_deepcopy(obj)
    if type(obj) ~= "table" then return obj end
    local res = {}
    for k, v in pairs(obj) do
        res[k] = ast_deepcopy(v)
    end
    return res
end

-- Structural equality check for ASTs
-- Tests whether two expressions are indistinguishably boring
function ast_equal(a, b)
    if type(a) ~= type(b) then return false end
    if type(a) ~= "table" then return a == b end
    for k, v in pairs(a) do
        if not ast_equal(v, b[k]) then return false end
    end
    for k, v in pairs(b) do
        if not ast_equal(v, a[k]) then return false end
    end
    return true
end

-- Depth-first traversal of the AST
-- Applies a function to every node, top-down
function ast_traverse(ast, fn)
    fn(ast)
    if type(ast) == "table" then
        if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
            for _, v in ipairs(ast.args) do
                ast_traverse(v, fn)
            end
        else
            for k, v in pairs(ast) do
                if type(v) == "table" then ast_traverse(v, fn) end
            end
        end
    end
end

-- Like traverse, but returns a new AST
-- Good for transformations and bad ideas
function ast_map(ast, fn)
    if type(ast) ~= "table" then return fn(ast) end
    local mapped = {}
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        mapped.type = ast.type
        mapped.args = {}
        if ast.name then mapped.name = ast.name end
        for i, v in ipairs(ast.args) do
            mapped.args[i] = ast_map(v, fn)
        end
    else
        for k, v in pairs(ast) do
            mapped[k] = ast_map(v, fn)
        end
    end
    return fn(mapped)
end

-- Replace all occurrences of a subtree with another
-- Think copy/paste but with slightly more guilt
function ast_substitute(ast, target, replacement)
    if ast_equal(ast, target) then return ast_deepcopy(replacement) end
    if type(ast) ~= "table" then return ast end
    local res = {}
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        res.type = ast.type
        if ast.name then res.name = ast.name end
        res.args = {}
        for i, v in ipairs(ast.args) do
            res.args[i] = ast_substitute(v, target, replacement)
        end
    else
        for k, v in pairs(ast) do
            res[k] = ast_substitute(v, target, replacement)
        end
    end
    return res
end

-- Collect all variable symbols in the AST
-- Returns a set-like table of every symbol that dares to show up
function ast_vars(ast, found)
    found = found or {}
    if type(ast) ~= "table" then return found end
    if ast.type == "variable" then found[ast.name] = true end
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        for _, v in ipairs(ast.args) do
            ast_vars(v, found)
        end
    else
        for k, v in pairs(ast) do
            ast_vars(v, found)
        end
    end
    return found
end

-- Count the total number of nodes in an AST
-- Like measuring code size, but with more branches
function ast_size(ast)
    if type(ast) ~= "table" then return 1 end
    local sum = 1
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        for _, v in ipairs(ast.args) do sum = sum + ast_size(v) end
    else
        for k, v in pairs(ast) do sum = sum + ast_size(v) end
    end
    return sum
end

-- Computes the maximum depth of the AST
-- Deep code is not necessarily smart code
function ast_depth(ast)
    if type(ast) ~= "table" then return 0 end
    local maxd = 0
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        for _, v in ipairs(ast.args) do
            local d = ast_depth(v)
            if d > maxd then maxd = d end
        end
    else
        for k, v in pairs(ast) do
            local d = ast_depth(v)
            if d > maxd then maxd = d end
        end
    end
    return 1 + maxd
end


-- Original AST to string printer (for debugging)
function ast_tostring_raw(ast)
    if type(ast) ~= "table" then return tostring(ast) end
    if ast.type == "number" then return tostring(ast.value) end
    if ast.type == "variable" then return ast.name end
    if ast.type == "func" then
        local args = {}
        for i, v in ipairs(ast.args) do args[i] = ast_tostring_raw(v) end
        return ast.name .. "(" .. table.concat(args, ",") .. ")"
    end
    if ast.type == "neg" then
        return "-(" .. ast_tostring_raw(ast.arg) .. ")"
    end
    if ast.type == "pow" then
        return "(" .. ast_tostring_raw(ast.base) .. ")^(" .. ast_tostring_raw(ast.exp) .. ")"
    end
    if ast.type == "add" then
        local parts = {}
        for i, v in ipairs(ast.args) do
            parts[i] = ast_tostring_raw(v)
        end
        return "(" .. table.concat(parts, " + ") .. ")"
    end
    if ast.type == "sub" then
        return "(" .. ast_tostring_raw(ast.left) .. ") - (" .. ast_tostring_raw(ast.right) .. ")"
    end
    if ast.type == "mul" then
        local parts = {}
        for i, v in ipairs(ast.args) do
            parts[i] = ast_tostring_raw(v)
        end
        -- Nice form: 2x, x2 for two args, otherwise with *
        if #parts == 2 then
            local a, b = ast.args[1], ast.args[2]
            if ast_is_number(a) and ast_is_variable(b) then
                return tostring(a.value) .. parts[2]
            elseif ast_is_variable(a) and ast_is_number(b) then
                return parts[1] .. tostring(b.value)
            end
        end
        return table.concat(parts, "*")
    end
    if ast.type == "div" then
        return "(" .. ast_tostring_raw(ast.left) .. ")/(" .. ast_tostring_raw(ast.right) .. ")"
    end
    if ast.type == "raw" then
        return "[RAW:" .. tostring(ast.value) .. "]"
    end
    -- fallback
    local str = "{" .. (ast.type or "?")
    for k, v in pairs(ast) do
        if k ~= "type" then str = str .. "," .. k .. "=" .. ast_tostring_raw(v) end
    end
    return str .. "}"
end

-- AST node type test helpers
function ast_is_number(node)
    return type(node) == "table" and node.type == "number"
end
function ast_is_variable(node)
    return type(node) == "table" and node.type == "variable"
end
function ast_is_func(node, fname)
    return type(node) == "table" and node.type == "func" and (not fname or node.name == fname)
end
function ast_is_op(node, op)
    return type(node) == "table" and node.type == op
end


-- Evaluate the AST numerically if it's purely numeric
-- Warning: does not handle symbolic stupidity
function ast_eval_numeric(ast, env)
    env = env or {}
    if ast.type == "number" then return ast.value end
    if ast.type == "variable" then
        return env[ast.name] or error("Unbound variable: " .. tostring(ast.name))
    end
    if ast.type == "func" then
        local argv = {}
        for i, v in ipairs(ast.args) do
            argv[i] = ast_eval_numeric(v, env)
        end
        if math[ast.name] then
            return math[ast.name](table.unpack(argv))
        elseif ast.name == "ln" then
            return math.log(argv[1])
        elseif ast.name == "log" then
            return math.log10(argv[1])
        elseif ast.name == "gamma" then
            local n = argv[1]
            if n > 0 and math.floor(n) == n then
                local factorial = 1
                for i = 1, n - 1 do
                    factorial = factorial * i
                end
                return factorial
            elseif n == 0.5 then
                return math.sqrt(math.pi)
            else
                error("Gamma function not implemented for value: " .. tostring(n))
            end
        else
            error("Unknown function: " .. ast.name)
        end
    end
    if ast.type == "add" then
        local sum = 0
        for _, v in ipairs(ast.args) do
            sum = sum + ast_eval_numeric(v, env)
        end
        return sum
    end
    if ast.type == "sub" then
        return ast_eval_numeric(ast.left, env) - ast_eval_numeric(ast.right, env)
    end
    if ast.type == "mul" then
        local prod = 1
        for _, v in ipairs(ast.args) do
            prod = prod * ast_eval_numeric(v, env)
        end
        return prod
    end
    if ast.type == "div" then
        return ast_eval_numeric(ast.left, env) / ast_eval_numeric(ast.right, env)
    end
    if ast.type == "pow" then
        return ast_eval_numeric(ast.base, env) ^ ast_eval_numeric(ast.exp, env)
    end
    if ast.type == "neg" then
        return -ast_eval_numeric(ast.arg, env)
    end
    error("Unsupported node in ast_eval_numeric: " .. tostring(ast.type))
end

-- Pattern match against an AST using a pattern
-- Binds variables, fails if it sees something it doesn’t like
function ast_match(pattern, ast, bindings)
    bindings = bindings or {}
    if type(pattern) ~= "table" then
        if pattern == ast then return bindings else return nil end
    end
    if pattern.var then
        if bindings[pattern.var] then
            return ast_equal(bindings[pattern.var], ast) and bindings or nil
        else
            bindings[pattern.var] = ast
            return bindings
        end
    end
    if type(ast) ~= "table" then return nil end
    if pattern.type and pattern.type ~= ast.type then return nil end
    if (pattern.type == "add" or pattern.type == "mul" or pattern.type == "func") and pattern.args then
        if #pattern.args ~= #ast.args then return nil end
        for i = 1, #pattern.args do
            local sub = ast_match(pattern.args[i], ast.args[i], bindings)
            if not sub then return nil end
            bindings = sub
        end
    else
        for k, v in pairs(pattern) do
            if k ~= "var" and k ~= "args" then
                local sub = ast_match(v, ast[k], bindings)
                if not sub then return nil end
                bindings = sub
            end
        end
    end
    return bindings
end

-- Export all as ast.*
ast = {
    number = ast_number,
    symbol = ast_symbol,
    variable = ast_symbol,
    func = ast_func,
    binop = ast_binop,
    neg = ast_neg,
    pow = ast_pow,
    raw = ast_raw,
    matrix = ast_matrix,

    -- Shorthand binary operation constructors
    add = function(...) return { type = "add", args = {...} } end,
    sub = function(l, r) return ast_binop("sub", l, r) end,
    mul = function(...) return { type = "mul", args = {...} } end,
    div = function(l, r) return ast_binop("div", l, r) end,
    pow = function(l, r) return ast_pow(l, r) end,
    neg = ast_neg,
    eq = function(left, right) return { type = "equation", left = left, right = right } end,

    deepcopy = ast_deepcopy,
    equal = ast_equal,
    traverse = ast_traverse,
    map = ast_map,
    substitute = ast_substitute,
    vars = ast_vars,
    size = ast_size,
    depth = ast_depth,
    tostring = ast_tostring,

    is_number = ast_is_number,
    is_variable = ast_is_variable,
    is_func = ast_is_func,
    is_op = ast_is_op,

    eval_numeric = ast_eval_numeric,
    match = ast_match,
    debug_print = ast_debug_print,
}

-- Flattens nested additive/multiplicative trees
-- Useful for canonicalization, sorting, or general misuse
function ast_flatten_add(node)
    if not ast_is_op(node, "add") then return { node } end
    local parts = {}
    local function collect(n)
        if ast_is_op(n, "add") then
            for _, v in ipairs(n.args) do
                collect(v)
            end
        else
            table.insert(parts, n)
        end
    end
    collect(node)
    table.sort(parts, function(a, b) return ast_tostring(a) < ast_tostring(b) end)
    return parts
end

-- Flattens nested additive/multiplicative trees
-- Useful for canonicalization, sorting, or general misuse
function ast_flatten_mul(node)
    if not ast_is_op(node, "mul") then return { node } end
    local parts = {}
    local function collect(n)
        if ast_is_op(n, "mul") then
            for _, v in ipairs(n.args) do
                collect(v)
            end
        else
            table.insert(parts, n)
        end
    end
    collect(node)
    table.sort(parts, function(a, b) return ast_tostring(a) < ast_tostring(b) end)
    return parts
end

ast.flatten_add = ast_flatten_add
ast.flatten_mul = ast_flatten_mul

-- Generic AST node constructor
function ast_node(typ, opts)
    local node = { type = typ }
    for k, v in pairs(opts or {}) do
        node[k] = v
    end
    return node
end
ast.node = ast_node
_G.ast_node = ast.node
_G.ast = ast






-- Wildcard pattern constructor for integration matching
function ast_wildcard(varname)
    return { var = varname }
end
ast.wildcard = ast_wildcard
_G.wildcard = ast_wildcard

_G.ast_debug_print = ast_debug_print


-- Patch ast.eval_numeric to support physics functions without cyclic load errors
do
  local old_eval_numeric = ast.eval_numeric

  function ast.eval_numeric(node, env)
    env = env or {}
    -- Lazy-load physics module to break cyclic dependency
    local physics = _G.physics or require("physics")

    if node.type == "func" then
      local args_eval = {}
      for i, arg in ipairs(node.args) do
        args_eval[i] = ast.eval_numeric(arg, env)
      end

      if math[node.name] then
        return math[node.name](table.unpack(args_eval))
      end

      if node.name == "ln" then return math.log(args_eval[1]) end
      if node.name == "log" then return math.log10(args_eval[1]) end
      if node.name == "gamma" then
        local n = args_eval[1]
        if n > 0 and math.floor(n) == n then
          local fact = 1
          for i = 1, n - 1 do fact = fact * i end
          return fact
        elseif n == 0.5 then
          return math.sqrt(math.pi)
        else
          error("Gamma function not implemented for value: " .. tostring(n))
        end
      end

      -- Delegate to physics evaluation if available
      local phys_val = physics.eval_physics_func(node.name, node.args)
      if phys_val ~= nil then
        return ast.eval_numeric(phys_val, env)
      end

      error("Unknown function: " .. tostring(node.name))
    else
      return old_eval_numeric(node, env)
    end
  end

  ast.eval_numeric = ast.eval_numeric
end

-- End src/ast.lua

-- Imported src/ast.lua—debuggers rejoice.

-- Begin src/parser.lua
-- parser.lua: Because writing your own parser is the best way to avoid happiness.
--
-- For those who care about "compatibility": yes, the API is still the same.
--   tokenize(expr) => {tokens} -- like anyone remembers the output.
--   buildAST(tokens) => ast    -- because trees are the only way to understand math.
--   parseExpr(tokens, idx) => ast, nextIdx -- because recursion is fun until it isn't.
--
-- Now with more "features" you didn't ask for: error nagging, big numbers, functions, brackets, sneaky multiplication, negative numbers, and, because why not, matrix parsing.
-- Plus: properly weaponized error messages that will make you question your life choices.

local parser = {}
local init = rawget(_G, "init")
local errors = rawget(_G, "errors") or {
  invalid = function(fn, hint)
    return "parse(" .. (fn or "?") .. "): " .. (hint or "unknown error. also: _G.errors was nil.")
  end
}

-- Because seeing your AST in tree form is the only joy you'll get today.
local function print_ast(ast, indent)
  indent = indent or ""
  if type(ast) ~= "table" then
    print(indent .. tostring(ast))
    return
  end
  if ast.type then
    local desc = ast.type
    if ast.name then desc = desc .. " (" .. tostring(ast.name) .. ")" end
    print(indent .. desc)
    if ast.value ~= nil then print(indent .. "  value: " .. tostring(ast.value)) end
    if ast.name ~= nil and ast.type ~= "variable" then print(indent .. "  name: " .. tostring(ast.name)) end
    if ast.args then
      print(indent .. "  args:")
      for i, arg in ipairs(ast.args) do
        print_ast(arg, indent .. "    ")
      end
    end
    if ast.rows then
      print(indent .. "  rows:")
      for i, row in ipairs(ast.rows) do
        print(indent .. "    row " .. i .. ":")
        for j, elem in ipairs(row) do
          print_ast(elem, indent .. "      ")
        end
      end
    end
    if ast.base then
      print(indent .. "  base:")
      print_ast(ast.base, indent .. "    ")
    end
    if ast.type == "lim" then
  print(indent .. "limit:")
  print(indent .. "  expr:")
  print_ast(ast.expr, indent .. "    ")
  print(indent .. "  var: " .. ast.var)
  print(indent .. "  to:")
  print_ast(ast.to, indent .. "    ")
  if ast.direction then
    print(indent .. "  direction: " .. ast.direction)
  end
  return
end
    if ast.exp then
      print(indent .. "  exp:")
      print_ast(ast.exp, indent .. "    ")
    end
    if ast.left then
      print(indent .. "  left:")
      print_ast(ast.left, indent .. "    ")
    end
    if ast.right then
      print(indent .. "  right:")
      print_ast(ast.right, indent .. "    ")
    end
    -- NEW: Add print for integral-specific fields
    if ast.integrand then
        print(indent .. "  integrand:")
        print_ast(ast.integrand, indent .. "    ")
    end
    if ast.respect_to then
        print(indent .. "  respect_to:")
        print_ast(ast.respect_to, indent .. "    ")
    end
    if ast.lower_bound then
        print(indent .. "  lower_bound:")
        print_ast(ast.lower_bound, indent .. "    ")
    end
    if ast.upper_bound then
        print(indent .. "  upper_bound:")
        print_ast(ast.upper_bound, indent .. "    ")
    end
    -- END NEW
  else
    for k, v in pairs(ast) do
      print(indent .. tostring(k) .. ":")
      print_ast(v, indent .. "  ")
    end
  end
end
parser.print_ast = print_ast
_G.print_ast = print_ast

-- Tokenizer: Because parsing math without slicing it into tiny pieces would be too easy.

local function utf8char(str, i)
  local b1 = str:byte(i)
  if not b1 then return nil, 0 end
  if b1 < 0x80 then
    return str:sub(i, i), 1
  elseif b1 < 0xE0 and #str >= i + 1 then
    return str:sub(i, i + 1), 2
  elseif b1 < 0xF0 and #str >= i + 2 then
    return str:sub(i, i + 2), 3
  elseif b1 < 0xF8 and #str >= i + 3 then
    return str:sub(i, i + 3), 4
  else
    -- Invalid start byte or incomplete sequence, treat as one byte to avoid infinite loop
    return str:sub(i, i), 1
  end
end

-- Adjust is_alpha to recognize ascii letters and greek utf8 letters (add more if needed)
local function is_alpha(c)
  -- ASCII letters
  if c:match("^[%a_]$") then return true end
  -- Common Greek letters and others can be added here
  -- For demo, accept anything with byte length > 1 (non-ASCII)
  if #c > 1 then return true end
  return false
end

function parser.tokenize(expr)
  local tokens = {}
  local i = 1
  local len = #expr
  while i <= len do
    local c, clen = utf8char(expr, i)
    if not c or clen == 0 then break end

    if c:match('%s') then
      -- whitespace
      i = i + clen
    -- Improved special handling for (d/dx) derivative pattern
    elseif expr:sub(i, i+4) == "(d/dx" and expr:sub(i+5, i+5) == ")" then
      table.insert(tokens, {type="derivative"})
      i = i + 6 -- skip full "(d/dx)"
    elseif c:match('%d') or (c == '.' and (i+clen <= len) and expr:sub(i+clen,i+clen):match('%d')) then
      -- number, read full numeric token
      local num = c
      i = i + clen
      while i <= len do
        local nc, nclen = utf8char(expr, i)
        if not nc or not (nc:match('%d') or nc == '.') then break end
        num = num .. nc
        i = i + nclen
      end
      table.insert(tokens, {type="number", value=tonumber(num)})
      print(string.format("Token: [number] %s", num))
    elseif c == '∫' then
      table.insert(tokens, {type="integral_symbol", value=c}) -- Changed type name to avoid conflict
      print(string.format("Token: [integral_symbol] %s", c))
      i = i + clen
    elseif is_alpha(c) then
      -- identifier/function
      local ident = c
      i = i + clen
      while i <= len do
        local nc, nclen = utf8char(expr, i)
        if not nc then break end
        if is_alpha(nc) or nc:match('%d') then
          ident = ident .. nc
          i = i + nclen
        else
          break
        end
      end
      table.insert(tokens, {type="ident", value=ident})
      print(string.format("Token: [ident] %s", ident))
    elseif c == '"' or c == "'" then
      -- string literal
      local quote = c
      local j = i + clen
      local str = ''
      while j <= len do
        local cc, cclen = utf8char(expr, j)
        if not cc then break end
        if cc == quote then break end
        str = str .. cc
        j = j + cclen
      end
      if j > len then
        error(_G.errors.get("parse(unmatched_paren)") or errors.invalid('tokenize', 'unterminated string literal'))
      end
      table.insert(tokens, {type='string', value=str})
      print(string.format("Token: [string] %s", str))
      i = j + clen -- skip closing quote
    elseif c == ')' then
      -- Special handling for closing parenthesis after (d/dx
      if #tokens > 0 and tokens[#tokens].type == "derivative_start" then
        tokens[#tokens].type = "derivative"
      else
        table.insert(tokens, {type=c, value=c})
      end
      i = i + clen
    elseif c == ',' or c == '(' or c == '[' or c == ']' or
           c == '+' or c == '-' or c == '*' or c == '/' or c == '^' or
           c == '!' or c == '=' or c == '∫' then
      local ttype
      if c == ',' then ttype = ','
      elseif c == '(' then ttype = c
      elseif c == '[' or c == ']' then ttype = c
      elseif c == '=' then ttype = "equals"
      elseif c == '∫' then ttype = "integral_symbol" -- Consistent type name
      elseif c == '+' or c == '-' or c == '*' or c == '/' or c == '^' or c == '!' then ttype = "op"
      else ttype = "unknown" end
      table.insert(tokens, {type=ttype, value=c})
      print(string.format("Token: [%s] %s", ttype, c))
      i = i + clen
    else
      error(_G.errors.get("parse(invalid_character)") or errors.invalid("tokenize", "unknown character: " .. c))
    end
  end

  -- Insert commas between adjacent tensor brackets like '][' to fix TI calculator formatting
  local j = 2
  while j <= #tokens do
    local t1, t2 = tokens[j-1], tokens[j]
    if t1.type == ']' and t2.type == '[' then
      table.insert(tokens, j, {type=",", value=","})
      j = j + 1
    end
    j = j + 1
  end

  -- Insert implicit multiplication tokens as before
  local j = 2
  while j <= #tokens do
    local t1, t2 = tokens[j-1], tokens[j]
    if (t1.type == 'number' or t1.type == ')' ) and
       (t2.type == 'ident' or t2.type == '(' or t2.type == '[' or t2.type == 'integral_symbol') then -- Added integral_symbol
      table.insert(tokens, j, {type="op", value="*"})
      j = j + 1
    end
    j = j + 1
  end

  print("Final token list:")
  for _, tok in ipairs(tokens) do
    print(string.format("  %s : %s", tok.type, tostring(tok.value)))
  end
  return tokens
end

-- Parser: Because recursion is the only way to feel alive.
--   Now with precedence, unary minus, function calls, and, of course, matrices.


-- Tensor parsing: supports arbitrary rank tensors (nested lists of expressions).
local function parse_tensor(tokens, idx)
  -- Expect '[' to start tensor.
  if not (tokens[idx] and tokens[idx].type == '[') then
    error(_G.errors.get("parse(matrix_syntax)") or errors.invalid("parse_tensor", "expected '[' to start tensor"))
  end

  local function parse_elements(i)
    local elements = {}
    local first = true
    while true do
      if tokens[i] and tokens[i].type == '[' then
        -- Recursively parse a sub-tensor and always wrap as {type="tensor", elements=...}
        local sub_elems, ni = parse_elements(i + 1)
        table.insert(elements, {type = "tensor", elements = sub_elems})
        i = ni
      elseif tokens[i] and tokens[i].type ~= ']' then
        -- Parse a scalar element
        local elem, ni = parser.parseExpr(tokens, i)
        if type(elem) == "number" then
          table.insert(elements, { type = "number", value = elem })
        else
          table.insert(elements, elem)
        end
        i = ni
      end
      if tokens[i] and tokens[i].type == ',' then
        i = i + 1
        first = false
      elseif tokens[i] and tokens[i].type == ']' then
        return elements, i + 1
      else
        break
      end
    end
    error(_G.errors.get("parse(ragged_matrix)") or errors.invalid("parse_tensor", "expected ',' or ']' in tensor definition"))
  end

  local i = idx + 1
  if tokens[i] and tokens[i].type == ']' then
    return {type="tensor", elements={}}, i + 1
  end

  local elements, ni = parse_elements(i)
  return {type="tensor", elements=elements}, ni
end

-- Handles literals, variables, function calls, parentheses, matrices, and unary minus.
-- Also wraps things in factorials if someone thought 'x!' was a good idea. Because, why not.
local function make_var(x) return {type="variable", name=x} end -- Because variables need love too.

-- Integral parsing: parses ∫(expression, variable) or ∫(expression, variable, lower_bound, upper_bound)
local function parse_integral(tokens, idx)
  local tok = tokens[idx]
  if not (tok and tok.type == "integral_symbol") then
    _G.errors.throw("parse(integral)") -- Consistent error throw
  end

  if not (tokens[idx + 1] and tokens[idx + 1].type == "(") then
    _G.errors.throw("parse(function_missing_args)", "integral") -- Consistent error throw
  end

  local integrand_expr, i = parser.parseExpr(tokens, idx + 2)
  if not (tokens[i] and tokens[i].type == ",") then
    _G.errors.throw("parse(integral)", "missing_comma_after_integrand") -- Consistent error throw
  end

  local var_token = tokens[i + 1]
  if not (var_token and var_token.type == "ident") then
    _G.errors.throw("parse(invalid_variable_name)", "integral_variable") -- Consistent error throw
  end

  i = i + 2 -- Move past var_token and comma (now at either ')' or ',')

  local integral_node = {
    type = "integral",
    integrand = integrand_expr,
    respect_to = { type = "variable", name = var_token.value }
  }

  -- Check for definite integral bounds
  if tokens[i] and tokens[i].type == "," then
    local lower_bound, ni1 = parser.parseExpr(tokens, i + 1)
    if not (tokens[ni1] and tokens[ni1].type == ",") then
      _G.errors.throw("parse(integral_limits)", "missing_comma_after_lower_bound") -- Consistent error throw
    end
    local upper_bound, ni2 = parser.parseExpr(tokens, ni1 + 1)
    if not (tokens[ni2] and tokens[ni2].type == ")") then
      _G.errors.throw("parse(unmatched_paren)", "integral_bounds") -- Consistent error throw
    end

    integral_node.lower_bound = lower_bound
    integral_node.upper_bound = upper_bound
    i = ni2 + 1 -- Move past upper_bound and closing parenthesis
  else
    -- For indefinite integral, expect closing parenthesis
    if not (tokens[i] and tokens[i].type == ")") then
      _G.errors.throw("parse(unmatched_paren)", "integral") -- Consistent error throw
    end
    i = i + 1
  end

  return integral_node, i
end


local function parse_primary(tokens, idx)
  local tok = tokens[idx]
  if not tok then return nil, idx end

  local function wrap_factorial(node, i)
    if tokens[i] and tokens[i].type == "op" and tokens[i].value == "!" then
      return {
        type = "func",
        name = "factorial",
        args = { node }
      }, i + 1
    end
    return node, i
  end

  -- Derivative node: (d/dx)(expr) pattern
  if tok.type == "derivative" then
    local expr, ni = parser.parseExpr(tokens, idx + 1)
    return {type="derivative", respect_to="x", expr=expr}, ni
  end

  if tok.type == "integral_symbol" then -- Use the new token type
    return parse_integral(tokens, idx)
  elseif tok.type == "number" then
    return wrap_factorial({type="number", value=tok.value}, idx+1)
  elseif tok.type == "ident" then
    if tokens[idx + 1] and tokens[idx + 1].type == "(" then
      -- Special handling for series(func, var, center, order)
      if tok.value == "series" then
        local i = idx + 2
        local func_expr, ni = parser.parseExpr(tokens, i)
        if not (tokens[ni] and tokens[ni].type == ",") then
          _G.errors.throw("parse(series)", "missing_comma_after_func")
        end
        local var_node, ni2 = parser.parseExpr(tokens, ni + 1)
        if not (tokens[ni2] and tokens[ni2].type == ",") then
          _G.errors.throw("parse(series)", "missing_comma_after_var")
        end
        local center_node, ni3 = parser.parseExpr(tokens, ni2 + 1)
        if not (tokens[ni3] and tokens[ni3].type == ",") then
          _G.errors.throw("parse(series)", "missing_comma_after_center")
        end
        local order_node, ni4 = parser.parseExpr(tokens, ni3 + 1)
        if not (tokens[ni4] and tokens[ni4].type == ")") then
          _G.errors.throw("parse(function_too_many_args)", "series_missing_close_paren")
        end
        return {
          type = "series",
          func = func_expr,
          var = var_node,
          center = center_node,
          order = order_node
        }, ni4 + 1
      end
      
      -- Debug version of the limit parsing logic
      if tok.value == "lim" then
        -- Parse lim(expr, var, to, direction) format
        print("DEBUG: Starting lim parse")
        
        if not (tokens[idx + 1] and tokens[idx + 1].type == "(") then
          _G.errors.throw("parse(limit_syntax)", "expected '(' after lim")
        end
        
        local i = idx + 2
        print("DEBUG: About to parse expression starting at token " .. i)
        if tokens[i] then
          print("DEBUG: Token at " .. i .. " is: " .. tokens[i].type .. " = " .. tostring(tokens[i].value))
        end
        
        -- Parse the expression to take the limit of
        local expr, ni = parser.parseExpr(tokens, i)
        print("DEBUG: Parsed expression, now at token " .. ni)
        if tokens[ni] then
          print("DEBUG: Token at " .. ni .. " is: " .. tokens[ni].type .. " = " .. tostring(tokens[ni].value))
        else
          print("DEBUG: No token at " .. ni .. " (end of tokens?)")
        end
        
        if not (tokens[ni] and tokens[ni].type == ",") then
          _G.errors.throw("parse(limit_syntax)", "expected ',' after limit expression but got " .. 
               (tokens[ni] and tokens[ni].type or "nil"))
        end
        
        -- Parse the variable
        local var_token = tokens[ni + 1]
        print("DEBUG: Variable token: " .. (var_token and var_token.type or "nil") .. " = " .. 
              (var_token and tostring(var_token.value) or "nil"))
        if not (var_token and var_token.type == "ident") then
          _G.errors.throw("parse(function_missing_args)", "limit_expected_variable")
        end
        
        if not (tokens[ni + 2] and tokens[ni + 2].type == ",") then
          _G.errors.throw("parse(limit_syntax)", "expected ',' after variable")
        end
        
        -- Parse the value we're approaching
        local to_val, ni3 = parser.parseExpr(tokens, ni + 3)
        print("DEBUG: Parsed limit value, now at token " .. ni3)
        
        if not (tokens[ni3] and tokens[ni3].type == ")") then
          _G.errors.throw("parse(unmatched_paren)", "limit_missing_close_paren")
        end
        
        -- Actually compute the damn limit like we're supposed to
        local expr_str = ast_to_string(expr)
        local to_str = ast_to_string(to_val)
        
        print("DEBUG: expr_str = '" .. expr_str .. "'")
        print("DEBUG: var = '" .. var_token.value .. "'")
        print("DEBUG: to_str = '" .. to_str .. "'")
        
        -- Call the beautiful limit function
        local ok, result = pcall(_G.lim, expr_str, var_token.value, to_str, direction)
        if not ok then
          print("DEBUG: _G.lim failed with: " .. tostring(result))
          _G.errors.throw("eval(undefined_at_point)", "limit evaluation failed: " .. tostring(result))
        end
        
        print("DEBUG: _G.lim returned: " .. tostring(result))
        return result, ni3 + 1
      end
      
      -- NEW: Handle binomial_expand function call
      if tok.value == "binomial_expand" then
        local i = idx + 2
        local expr_to_expand, ni = parser.parseExpr(tokens, i) -- Parse the expression argument
        if not (tokens[ni] and tokens[ni].type == ")") then
          _G.errors.throw("parse(function_missing_args)", "binomial_expand_missing_close_paren")
        end
        -- Call the actual _G.binomial_expand function from fraction.lua
        -- Note: _G.binomial_expand expects an AST node for base and exp, not a string or the full AST of (base^exp).
        -- This means we need to ensure expr_to_expand is of type 'pow'.
        if expr_to_expand.type ~= "pow" then
            _G.errors.throw("parse(function_too_many_args)", "binomial_expand expects a power expression (e.g., (x+y)^n)")
        end
        -- Call _G.binomial_expand, which requires 'base' and 'exp' nodes
        local expanded_ast = _G.binomial_expand(expr_to_expand.base, expr_to_expand.exp)
        
        -- If expansion results in a new AST, use it. Otherwise, keep the original representation or error.
        if expanded_ast and expanded_ast.type ~= "binomial_expand_failed" then
            return expanded_ast, ni + 1
        else
            -- If binomial_expand failed, you can either return the unexpanded form
            -- or return a specific error node for later processing/display.
            -- For simplicity, we'll return the original power node for now,
            -- allowing further processing if desired (e.g., by _G.simplify.simplify_step).
            return expr_to_expand, ni + 1
        end
      -- NEW: Handle fraction_simplify function call
      elseif tok.value == "fraction_simplify" then
        local i = idx + 2
        local expr_to_simplify, ni = parser.parseExpr(tokens, i) -- Parse the expression argument
        if not (tokens[ni] and tokens[ni].type == ")") then
          _G.errors.throw("parse(function_missing_args)", "fraction_simplify_missing_close_paren")
        end
        -- Call the actual _G.simplify_fraction function from fraction.lua
        -- Note: _G.simplify_fraction expects an AST node, not a string
        local simplified_ast = _G.simplify_fraction(expr_to_simplify)
        return simplified_ast, ni + 1
      end
      
      local args = {}
      local i = idx + 2
      if tokens[i] and tokens[i].type ~= ")" then
        local arg_node
        arg_node, i = parser.parseExpr(tokens, i)
        table.insert(args, arg_node)
        while tokens[i] and tokens[i].type == "," do
          local next_arg
          next_arg, i = parser.parseExpr(tokens, i + 1)
          table.insert(args, next_arg)
        end
      end
      if not (tokens[i] and tokens[i].type == ")") then
        _G.errors.throw("parse(unmatched_paren)", "function_call_missing_close_paren")
      end
      return wrap_factorial({ type="func", name=tok.value, args=args }, i + 1)
    else
      local physics_constants = _G.physics and _G.physics.constants or nil
      if physics_constants and physics_constants[tok.value] then
        -- Use deepcopy to avoid shared state for constant value nodes
        local deepcopy = rawget(_G, "deepcopy") or function(tbl)
          if type(tbl) ~= "table" then return tbl end
          local t2 = {}
          for k, v in pairs(tbl) do
            t2[k] = type(v) == "table" and deepcopy(v) or v
          end
          return t2
        end
        local constant_entry = physics_constants[tok.value]
        local val_node = deepcopy(constant_entry.value)
        local node = {type="constant", name=tok.value, value=val_node}
        return wrap_factorial(node, idx + 1)
      else
        return wrap_factorial({type="variable", name=tok.value}, idx + 1)
      end
    end
  elseif tok.type == '(' then
    -- Detect general derivative notation (d)/(dx)(expr)
    if tokens[idx+1] and tokens[idx+1].type == 'ident' and tokens[idx+1].value == 'd' then
      if tokens[idx+2] and tokens[idx+2].type == ')' and
   tokens[idx+3] and tokens[idx+3].type == 'op' and tokens[idx+3].value == '/' and
   tokens[idx+4] and tokens[idx+4].type == '(' and
   tokens[idx+5] and tokens[idx+5].type == 'ident' and tokens[idx+5].value == 'dx' and
   tokens[idx+6] and tokens[idx+6].type == ')' then
        local expr, ni = parser.parseExpr(tokens, idx + 7)
        return {
            type = "derivative",
            respect_to = "x",
            expr = expr
        }, ni
      end
    end
    local node, ni = parser.parseExpr(tokens, idx+1)
    if not (tokens[ni] and tokens[ni].type == ')') then
      _G.errors.throw("parse(unmatched_paren)", "parenthesized_expression")
    end
    return wrap_factorial(node, ni+1)
  elseif tok.type == '[' then
    local tensor, ni = parse_tensor(tokens, idx)
    return wrap_factorial(tensor, ni)
  elseif tok.type == 'string' then
    return {type='string', value=tok.value}, idx + 1
  elseif tok.type == "op" and tok.value == '-' then
    local expr, ni = parser.parseExpr(tokens, idx+1)
    return wrap_factorial({type="neg", value=expr}, ni)
  else
    _G.errors.throw("parse(what_is_that)", tok.type or '?')
  end
end

-- Parses exponentiation. Right-associative, because math teachers said so.
local function parse_power(tokens, idx)
  local left, i = parse_primary(tokens, idx)
  while tokens[i] and tokens[i].type == "op" and tokens[i].value == '^' do
    local right
    right, i = parse_primary(tokens, i+1)
    left = {type="pow", base=left, exp=right}
  end
  return left, i
end

-- Handles multiplication, division, and reciprocal logic.
-- Because a/b is really just a*1/b, right? (Sure, let's pretend.)
local function parse_term(tokens, idx)
  -- Parse the first factor, because you have to start somewhere.
  local factors = {}
  local i = idx
  local node, ni = parse_power(tokens, i)
  table.insert(factors, node)
  i = ni
  while tokens[i] and tokens[i].type == "op" and (tokens[i].value == '*' or tokens[i].value == '/') do
    local op = tokens[i].value
    local right
    right, i = parse_power(tokens, i+1)
    if op == '*' then
      table.insert(factors, right)
    else
      -- Division: because why not multiply by the reciprocal and confuse everyone.
      table.insert(factors, {type="pow", base=right, exp={type="number", value=-1}})
    end
  end
  if #factors == 1 then
    return factors[1], i
  else
    return {type="mul", args=factors}, i
  end
end

-- The real entry point for expressions. Supports + and -, but mostly supports your suffering.
-- Folds everything into a single add tree so simplify() doesn't go on strike.
function parser.parseExpr(tokens, idx)
  idx = idx or 1
  local terms = {}
  local signs = {}
  local node, i = parse_term(tokens, idx)
  table.insert(terms, node)
  table.insert(signs, 1)
  while tokens[i] and tokens[i].type == "op" and (tokens[i].value == '+' or tokens[i].value == '-') do
    local op = tokens[i].value
    local right
    right, i = parse_term(tokens, i+1)
    if op == '+' then
      table.insert(terms, right)
      table.insert(signs, 1)
    else
      -- Instead of wrapping just numbers in neg, wrap the whole right term
      table.insert(terms, right)
      table.insert(signs, -1)
    end
  end
  -- Flatten into n-ary add, handling subtraction as add of negative (because why not make it harder?)
  if #terms == 1 then
    if tokens[i] and tokens[i].type == "equals" then
      local rhs, next_i = parser.parseExpr(tokens, i + 1)
      return {type = "equation", left = node, right = rhs}, next_i -- Because equations make everything more complicated.
    end
    return node, i
  else
    local args = {}
    for j = 1, #terms do
      if signs[j] == 1 then
        table.insert(args, terms[j])
      else
        table.insert(args, {type="neg", value=terms[j]})
      end
    end
    local add_node = {type="add", args=args}
    if tokens[i] and tokens[i].type == "equals" then
      local rhs, next_i = parser.parseExpr(tokens, i + 1)
      return {type = "equation", left = add_node, right = rhs}, next_i -- Because why stop at arithmetic when you can do algebra?
    end
    return add_node, i
  end
end

-- Wraps parseExpr and checks for leftovers.
-- If you forgot a bracket, this will find it and yell at you.
function parser.buildAST(tokens)
  local ast, idx = parser.parseExpr(tokens, 1)
  if idx <= #tokens then
    _G.errors.throw("parse(unexpected_eof)", tokens[idx].type or '?')
  end
  return ast
end

function parser.parse(expr)
  -- Get physics constants table and category from global
  local constants = _G.physics and _G.physics.constants or nil
  local constants_off = _G.var and _G.var.recall and _G.var.recall("constants_off")
  local current_category = _G.current_constant_category or "fundamental"

  -- Tokenize first, then replace identifier tokens with constants if appropriate
  local tokens = parser.tokenize(expr)

  -- Replace identifiers matching constant symbols after tokenizing
  if constants and not constants_off then
      for _, tok in ipairs(tokens) do
          if tok.type == "ident" and constants[tok.value] then
              if _G.physics.is_constant_enabled(tok.value) and
                 (not current_category or constants[tok.value].category == current_category or constants[tok.value].category == nil) then
                  -- Replace identifier with constant name if symbol matches
                  tok.type = "constant"
                  tok.name = tok.value
                  tok.value = nil
              end
          end
      end
  end

  -- Proceed with building AST etc...
  local ok, ast_or_err = pcall(parser.buildAST, tokens)
  if not ok then
    local err_msg = tostring(ast_or_err)
    if err_msg:find("parse%(series%)") then
      _G.errors.throw("parse(series)")
    elseif err_msg:find("parse%(integral%)") then -- Catches errors from parse_integral
      _G.errors.throw("parse(integral)")
    elseif err_msg:find("d/dx%(nothing%)") then -- Catches errors from derivative parse
      _G.errors.throw("d/dx(nothing)")
    elseif err_msg:find("parse%(matrix_syntax%)") then
      _G.errors.throw("parse(matrix_syntax)")
    elseif err_msg:find("parse%(limit_syntax%)") then
      _G.errors.throw("parse(limit_syntax)")
    elseif err_msg:find("parse%(function_missing_args%)") then
        local func = err_msg:match("function_missing_args%) Error: Function call missing arguments%. Did you forget to feed the function%?%s*(.+)") -- Attempt to extract func name
        _G.errors.throw("parse(function_missing_args)", func or "unknown_func")
    elseif err_msg:find("parse%(function_too_many_args%)") then
        _G.errors.throw("parse(function_too_many_args)")
    elseif err_msg:find("parse%(unmatched_paren%)") then
        _G.errors.throw("parse(unmatched_paren)")
    elseif err_msg:find("parse%(invalid_variable_name%)") then
        local hint = err_msg:match("invalid_variable_name%) Error: Invalid variable name%.%s*(.+)")
        _G.errors.throw("parse(invalid_variable_name)", hint or "generic")
    elseif err_msg:find("parse%(unexpected_token%)") then
        local token_type = err_msg:match("unexpected_token%) Error: Unexpected token%. It's like you're speaking in tongues, I can't parse that garbage%.%s*(.+)")
        _G.errors.throw("parse(unexpected_token)", token_type or "generic")
    elseif err_msg:find("parse%(invalid_character%)") then
        _G.errors.throw("parse(invalid_character)")
    elseif err_msg:find("parse%(malformed_power%)") then
        _G.errors.throw("parse(malformed_power)")
    elseif err_msg:find("parse%(ragged_matrix%)") then
        _G.errors.throw("parse(ragged_matrix)")
    elseif err_msg:find("parse%(what_is_that%)") then
        _G.errors.throw("parse(what_is_that)")
    elseif err_msg:find("parse%(syntax%)") then
      _G.errors.throw("parse(syntax)") -- Generic parse error if specific ones not found
    else
      -- Fallback for completely unmapped pcall errors
      _G.errors.throw("parse(gibberish)", err_msg)
    end
  end
  
  local ast_node = ast_or_err -- If pcall was successful, ast_or_err is the AST
  
  -- Automatically simplify after parsing if possible
  local simplified = rawget(_G, "simplify") and _G.simplify.simplify_step and _G.simplify.simplify_step(ast_node) or ast_node

  -- Evaluate factorial and integral nodes if possible (replace factorial(func(number)) with number node, and int(number, var) with number node)
  local function evaluate_nodes(node)
      if type(node) ~= "table" then return node end

      -- Evaluate factorial for numeric args
      if node.type == "func" and node.name == "factorial" and node.args and #node.args == 1 then
          local arg = evaluate_nodes(node.args[1])
          if arg.type == "number" and _G.evaluateFactorial then
              return { type = "number", value = _G.evaluateFactorial(arg.value) }
          end
          node.args[1] = arg
          return node
      end

      -- Integral nodes are now handled by the integral function directly, not here
      -- This section might need adjustment if you want *numeric* integrals to resolve here.
      -- For symbolic, you want the 'integral' AST node to persist.
      if node.type == "integral" then
          -- If the integral contains only numeric parts and can be evaluated fully to a number,
          -- you might call _G.integrate.eval with bounds here.
          -- Otherwise, let it remain an AST node to be handled by the full integration logic.
          return node
      end

      -- Recurse for common node types with children
      if node.args then
          for i, arg in ipairs(node.args) do
              node.args[i] = evaluate_nodes(arg)
          end
      elseif node.left then
          node.left = evaluate_nodes(node.left)
          if node.right then node.right = evaluate_nodes(node.right) end
      elseif node.base then
          node.base = evaluate_nodes(node.base)
          if node.exp then node.exp = evaluate_nodes(node.exp) end
      elseif node.arg then
          node.arg = evaluate_nodes(node.arg)
      elseif node.value and type(node.value) == "table" then
          node.value = evaluate_nodes(node.value)
      end
      return node
  end

  local evaluated = evaluate_nodes(simplified)
  return evaluated
end

_G.parser = parser
_G.parse = parser.parse

_G.parser = parser

-- Expose a direct solve_equation interface for global use, because everyone wants to solve everything.
if _G.solve_equation then
  _G.solve = function(expr)
    local ast = parser.parse(expr)
    return _G.solve_equation(ast)
  end
end

-- Wraps two arguments in a 'sub' node, because subtraction isn't just minus.
function parser.make_sub(left, right)
  return {type = "sub", left = left, right = right}
end

-- Wraps two arguments in a 'div' node, because division is just misunderstood multiplication.
function parser.make_div(num, denom)
  return {type = "div", left = num, right = denom}
end


-- Greek letter aliases (UTF-8 mapped to standard names)
-- Greek letter aliases for physics constants (assumes Constants table exists)
if _G.Constants then
    -- Basic Greek alphabet
    Constants[utf8(945)] = Constants["alpha"] or Constants[utf8(945)]  -- α (fine structure already exists)
Constants[utf8(946)] = Constants["beta"]                           -- β  
Constants[utf8(947)] = Constants["gamma"]                          -- γ
Constants[utf8(948)] = Constants["delta"]                          -- δ
Constants[utf8(949)] = Constants["epsilon"] or Constants[utf8(949).."0"] -- ε (permittivity already exists)
Constants[utf8(950)] = Constants["zeta"]                           -- ζ
Constants[utf8(951)] = Constants["eta"]                            -- η
Constants[utf8(952)] = Constants["theta"]                          -- θ
Constants[utf8(953)] = Constants["iota"]                           -- ι
Constants[utf8(954)] = Constants["kappa"]                          -- κ
Constants[utf8(955)] = Constants["lambda"]                         -- λ
Constants[utf8(956)] = Constants["mu"] or Constants[utf8(956).."0"] -- μ (permeability already exists)
Constants[utf8(957)] = Constants["nu"]                             -- ν
Constants[utf8(958)] = Constants["xi"]                             -- ξ
Constants[utf8(959)] = Constants["omicron"]                        -- ο
Constants[utf8(960)] = Constants["pi"]                             -- π (already exists)
Constants[utf8(961)] = Constants["rho"]                            -- ρ
Constants[utf8(962)] = Constants["sigma_final"]                    -- ς (final sigma)
Constants[utf8(963)] = Constants["sigma"]                          -- σ
Constants[utf8(964)] = Constants["tau"]                            -- τ
Constants[utf8(965)] = Constants["upsilon"]                        -- υ
Constants[utf8(966)] = Constants["phi"]                            -- φ
Constants[utf8(967)] = Constants["chi"]                            -- χ
Constants[utf8(968)] = Constants["psi"]                            -- ψ
Constants[utf8(969)] = Constants["omega"]                          -- ω

-- Greek letters (uppercase)
Constants[utf8(913)] = Constants["Alpha"]                          -- Α
Constants[utf8(914)] = Constants["Beta"]                           -- Β
Constants[utf8(915)] = Constants["Gamma"]                          -- Γ
Constants[utf8(916)] = Constants["Delta"]                          -- Δ
Constants[utf8(917)] = Constants["Epsilon"]                        -- Ε
Constants[utf8(918)] = Constants["Zeta"]                           -- Ζ
Constants[utf8(919)] = Constants["Eta"]                            -- Η
Constants[utf8(920)] = Constants["Theta"]                          -- Θ
Constants[utf8(921)] = Constants["Iota"]                           -- Ι
Constants[utf8(922)] = Constants["Kappa"]                          -- Κ
Constants[utf8(923)] = Constants["Lambda"]                         -- Λ
Constants[utf8(924)] = Constants["Mu"]                             -- Μ
Constants[utf8(925)] = Constants["Nu"]                             -- Ν
Constants[utf8(926)] = Constants["Xi"]                             -- Ξ
Constants[utf8(927)] = Constants["Omicron"]                        -- Ο
Constants[utf8(928)] = Constants["Pi"]                             -- Π
Constants[utf8(929)] = Constants["Rho"]                            -- Ρ
Constants[utf8(931)] = Constants["Sigma"]                          -- Σ
Constants[utf8(932)] = Constants["Tau"]                            -- Τ
Constants[utf8(933)] = Constants["Upsilon"]                        -- Υ
Constants[utf8(934)] = Constants["Phi"]                            -- Φ
Constants[utf8(935)] = Constants["Chi"]                            -- Χ
Constants[utf8(936)] = Constants["Psi"]                            -- Ψ
Constants[utf8(937)] = Constants["Omega"]                          -- Ω

-- PHYSICS-SPECIFIC CONSTANTS AND ALIASES

-- Common physics symbols
Constants[utf8(8463)] = Constants["h"] or Constants["planck"]      -- ℏ (reduced Planck)
Constants["hbar"] = Constants[utf8(8463)]

-- Mass-energy relations
Constants[utf8(956).."e"] = Constants["me"]                        -- μe (electron mass)
Constants[utf8(956).."p"] = Constants["mp"]                        -- μp (proton mass) 
Constants[utf8(956).."n"] = Constants["mn"]                        -- μn (neutron mass)

-- Coupling constants
Constants[utf8(945).."s"] = Constants["strong_coupling"]           -- αs (strong coupling)
Constants[utf8(945).."em"] = Constants[utf8(945)]                  -- αem (electromagnetic, same as fine structure)

-- Particle physics masses (if you add them)
Constants[utf8(956).."_e"] = Constants["electron_mass"]            -- μ_e
Constants[utf8(956).."_"..utf8(956)] = Constants["muon_mass"]      -- μ_μ (muon)
Constants[utf8(956).."_"..utf8(964)] = Constants["tau_mass"]       -- μ_τ (tau)
Constants["m_W"] = Constants["w_boson_mass"]                       -- W boson
Constants["m_Z"] = Constants["z_boson_mass"]                       -- Z boson
Constants["m_H"] = Constants["higgs_mass"]                         -- Higgs
Constants["m_t"] = Constants["top_mass"]                          -- top quark
Constants["m_b"] = Constants["bottom_mass"]                       -- bottom quark
Constants["m_c"] = Constants["charm_mass"]                        -- charm quark
Constants["m_s"] = Constants["strange_mass"]                      -- strange quark
Constants["m_u"] = Constants["up_mass"]                           -- up quark
Constants["m_d"] = Constants["down_mass"]                         -- down quark

-- QCD scale
Constants[utf8(923).."_QCD"] = Constants["lambda_qcd"]            -- Λ_QCD
Constants[utf8(952).."_QCD"] = Constants["theta_qcd"]             -- θ_QCD

-- Weinberg angle
Constants[utf8(952).."_W"] = Constants["weinberg_angle"]          -- θ_W
Constants["sin2"..utf8(952).."_W"] = Constants["sin2_theta_w"]    -- sin²θ_W

-- Cosmological constants
Constants[utf8(923)] = Constants["cosmological_constant"]         -- Λ
Constants[utf8(937).."_m"] = Constants["matter_density"]          -- Ω_m
Constants[utf8(937).."_"..utf8(923)] = Constants["dark_energy"]  -- Ω_Λ
Constants[utf8(937).."_b"] = Constants["baryon_density"]          -- Ω_b
Constants["H_0"] = Constants["hubble_constant"]                   -- H₀

-- Thermodynamic
Constants[utf8(946)] = Constants["inverse_temperature"]           -- β = 1/(kT)
Constants[utf8(963).."_SB"] = Constants["stefan_boltzmann"]       -- σ_SB

-- CKM matrix elements (quark mixing)
Constants["V_ud"] = Constants["ckm_ud"]
Constants["V_us"] = Constants["ckm_us"] 
Constants["V_ub"] = Constants["ckm_ub"]
Constants["V_cd"] = Constants["ckm_cd"]
Constants["V_cs"] = Constants["ckm_cs"]
Constants["V_cb"] = Constants["ckm_cb"]
Constants["V_td"] = Constants["ckm_td"]
Constants["V_ts"] = Constants["ckm_ts"]
Constants["V_tb"] = Constants["ckm_tb"]

-- PMNS matrix elements (neutrino mixing)
Constants[utf8(952).."_12"] = Constants["solar_angle"]           -- θ₁₂
Constants[utf8(952).."_23"] = Constants["atmospheric_angle"]     -- θ₂₃  
Constants[utf8(952).."_13"] = Constants["reactor_angle"]         -- θ₁₃
Constants[utf8(948).."_CP"] = Constants["cp_phase"]              -- δ_CP

-- Neutrino mass differences
Constants[utf8(916).."m2_21"] = Constants["delta_m21_squared"]   -- Δm²₂₁
Constants[utf8(916).."m2_31"] = Constants["delta_m31_squared"]   -- Δm²₃₁

-- Running couplings (scale dependent)
Constants[utf8(945).."("..utf8(956)..")"] = Constants["running_alpha"]     -- α(μ)
Constants[utf8(945).."s("..utf8(956)..")"] = Constants["running_alphas"]   -- αs(μ)

-- Renormalization scales  
Constants[utf8(956).."_R"] = Constants["renormalization_scale"]  -- μ_R
Constants[utf8(956).."_F"] = Constants["factorization_scale"]    -- μ_F

-- Effective field theory cutoffs
Constants[utf8(923).."_UV"] = Constants["uv_cutoff"]             -- Λ_UV
Constants[utf8(923).."_IR"] = Constants["ir_cutoff"]             -- Λ_IR

-- Supersymmetry parameters
Constants["M_SUSY"] = Constants["susy_scale"]
Constants["tan"..utf8(946)] = Constants["tan_beta"]              -- tan β
Constants[utf8(956).."_SUSY"] = Constants["susy_mu"]             -- μ_SUSY

-- Axion physics
Constants["f_a"] = Constants["axion_decay_constant"]             -- f_a
Constants[utf8(952).."_strong"] = Constants["strong_cp_angle"]   -- θ_strong

-- Dark matter
Constants[utf8(963).."_SI"] = Constants["dm_si_cross_section"]   -- σ_SI
Constants[utf8(963).."_SD"] = Constants["dm_sd_cross_section"]   -- σ_SD
Constants["<"..utf8(963).."v>"] = Constants["dm_annihilation"]   -- ⟨σv⟩

-- Extra dimensions
Constants["M_D"] = Constants["extra_dim_scale"]
Constants["R_extra"] = Constants["extra_dim_radius"]

-- String theory scale
Constants["M_string"] = Constants["string_scale"]
Constants["M_Pl"] = Constants["planck_mass"]

-- AdS/CFT
Constants["L_AdS"] = Constants["ads_radius"]
Constants["c_central"] = Constants["central_charge"]

-- Instantons and topology
Constants[utf8(952)] = Constants["theta_angle"]                  -- θ
Constants["w"] = Constants["winding_number"]
end

-- End src/parser.lua

-- src/parser.lua makes your code richer. Or at least gout-ridden.

-- Begin src/factorial.lua
-- factorial.lua
-- Converts symbolic factorial calls to Gamma-based equivalents
-- Works even when you feed it algebra instead of numbers, which is both useful and terrifying

-- Numerical fallback (not actually used in AST transforms)
-- Just here for completeness, or when someone evaluates factorial(5) directly
-- Lanczos approximation for Gamma function, accurate for most real numbers
local lanczos_coef = {
  676.5203681218851, -1259.1392167224028, 771.32342877765313,
  -176.61502916214059, 12.507343278686905, -0.13857109526572012,
  9.9843695780195716e-6, 1.5056327351493116e-7
}

local function gamma(z)
  if z < 0.5 then
    -- Reflection formula for negative arguments
    return math.pi / (math.sin(math.pi * z) * gamma(1 - z))
  else
    z = z - 1
    local x = 0.99999999999980993
    for i = 1, #lanczos_coef do
      x = x + lanczos_coef[i] / (z + i)
    end
    local t = z + #lanczos_coef - 0.5
    return math.sqrt(2 * math.pi) * t^(z + 0.5) * math.exp(-t) * x
  end
end

-- General factorial using Gamma, valid for real/complex domain
local function factorial(n)
  return gamma(n + 1)
end

-- Matches factorial(x) and returns gamma(x + 1)
-- Strictly cosmetic — lets us pretend we know how to differentiate factorials
local function matchFactorial(ast)
  if ast.type == "func" and ast.name == "factorial" and ast.args and #ast.args == 1 then
    local arg = ast.args[1]
    -- Convert factorial(n) to gamma(n+1)
    return {
      type = "func",
      name = "gamma",
      args = {
        {
          type = "add",
          args = { arg, { type = "number", value = 1 } }  -- ← Fixed: Use args array
        }
      }
    }
  end
  return ast
end

-- Walks the AST and replaces every factorial(...) with gamma(... + 1)
-- Recursively rewrites child nodes as well, whether they like it or not
function transformFactorial(ast)
  if type(ast) ~= "table" then return ast end
  
  -- Transform factorial(n) → gamma(n+1)
  if ast.type == "func" and ast.name == "factorial" and ast.args and #ast.args == 1 then
    local arg = transformFactorial(ast.args[1])
    return {
      type = "func",
      name = "gamma",
      args = {
        {
          type = "add",
          args = { arg, { type = "number", value = 1 } }  -- ← Fixed: Use args array
        }
      }
    }
  end
  
  local out = {}
  for k, v in pairs(ast) do
    if type(v) == "table" then
      if #v > 0 then
        out[k] = {}
        for i = 1, #v do
          out[k][i] = transformFactorial(v[i])
        end
      else
        out[k] = transformFactorial(v)
      end
    else
      out[k] = v
    end
  end
  return out
end

-- Evaluate the Gamma function numerically using the Lanczos approximation
local function evaluateGamma(z)
  return gamma(z)
end

-- Evaluate the factorial numerically using the Gamma function
local function evaluateFactorial(n)
  return factorial(n)
end

_G.transformFactorial = transformFactorial
_G.evaluateGamma = evaluateGamma  -- Expose evaluateGamma globally
_G.evaluateFactorial = evaluateFactorial  -- Expose evaluateFactorial globally

-- End src/factorial.lua

-- Merged src/factorial.lua: pray those ASTs behave.

-- Begin src/simplify.lua
local simplify = {}



-- Helper: get precision from flag or default
local function get_precision()
    
    -- local prec = var and var.recall and var.recall("nLuaCAS_precision_pref")
    -- if type(prec) == "number" and prec >= 0 then return prec end
    return nil 
end

-- Helper: round to precision
local function round_to_precision(val, precision)
    local mult = 10 ^ (precision or 4)
    return math.floor(val * mult + 0.5) / mult
end
local ast = rawget(_G, "ast") or require("ast")
local parser = rawget(_G, "parser") or require("parser")

-- ===== UTILITY FUNCTIONS (The Boring But Essential Shit) =====

local function num(n) return {type="number", value=n} end
local function var(name) return {type="variable", name=name} end

local function is_num(e) return e and e.type == "number" end
local function is_var(e) return e and e.type == "variable" end
local function is_pow(e) return e and e.type == "pow" end
local function is_add(e) return e and e.type == "add" end
local function is_mul(e) return e and e.type == "mul" end
local function is_sin(e) return e and e.type == "sin" end
local function is_cos(e) return e and e.type == "cos" end
local function is_ln(e) return e and e.type == "ln" end
local function is_exp(e) return e and e.type == "exp" end

local function deepcopy(t)
    if type(t) ~= "table" then return t end
    local c = {}
    for k,v in pairs(t) do c[k] = deepcopy(v) end
    return c
end

-- ===== TENSOR MULTIPLICATION HELPER =====
local function tensor_multiply(t1, t2)
    if not (t1 and t1.type == "tensor" and t2 and t2.type == "tensor") then
        return nil
    end

    local function is_vector(t)
        for _, e in ipairs(t.elements) do
            if e.type == "tensor" then return false end
        end
        return true
    end

    local function is_matrix(t)
        for _, row in ipairs(t.elements) do
            if row.type ~= "tensor" then return false end
        end
        return true
    end

    if is_vector(t1) and is_vector(t2) then
        -- Dot product
        local sum = 0
        for i=1, math.min(#t1.elements, #t2.elements) do
            local e1, e2 = t1.elements[i], t2.elements[i]
            if e1.type == "number" and e2.type == "number" then
                sum = sum + e1.value * e2.value
            else
                return nil -- Non-numeric elements, bail
            end
        end
        return { type = "number", value = sum }
    elseif is_matrix(t1) and is_matrix(t2) then
        -- Matrix multiplication: (m x n) * (n x p)
        local m = #t1.elements
        local n = #t1.elements[1].elements
        local n2 = #t2.elements
        local p = #t2.elements[1].elements
        if n ~= n2 then return nil end

        local result = {}
        for i=1,m do
            local row = {}
            for j=1,p do
                local sum = 0
                for k=1,n do
                    local a = t1.elements[i].elements[k]
                    local b = t2.elements[k].elements[j]
                    if a.type == "number" and b.type == "number" then
                        sum = sum + a.value * b.value
                    else
                        return nil
                    end
                end
                table.insert(row, { type = "number", value = sum })
            end
            table.insert(result, { type = "tensor", elements = row })
        end
        return { type = "tensor", elements = result }
    elseif is_matrix(t1) and is_vector(t2) then
        -- Matrix * vector
        local m = #t1.elements
        local n = #t1.elements[1].elements
        local len = #t2.elements
        if n ~= len then return nil end

        local result = {}
        for i=1,m do
            local sum = 0
            for j=1,n do
                local a = t1.elements[i].elements[j]
                local b = t2.elements[j]
                if a.type == "number" and b.type == "number" then
                    sum = sum + a.value * b.value
                else
                    return nil
                end
            end
            table.insert(result, { type = "number", value = sum })
        end
        return { type = "tensor", elements = result }
    else
        return nil -- Unsupported tensor shapes
    end
end

-- Helper: pretty print AST nodes for debugging (recursive)
local function ast_to_string(node, visited, depth)
    visited = visited or {}
    depth = depth or 0
    local indent = string.rep("  ", depth)
    if type(node) ~= "table" then
        return tostring(node)
    end
    if visited[node] then
        return indent .. "<cycle>"
    end
    visited[node] = true
    local parts = {}
    table.insert(parts, indent .. "{")
    for k, v in pairs(node) do
        local keystr = tostring(k)
        if type(v) == "table" then
            table.insert(parts, indent .. "  " .. keystr .. " = " .. ast_to_string(v, visited, depth + 1))
        else
            table.insert(parts, indent .. "  " .. keystr .. " = " .. tostring(v))
        end
    end
    table.insert(parts, indent .. "}")
    return table.concat(parts, "\n")
end

-- Simple hash for expression comparison
local function expr_hash(expr)
    if type(expr) ~= "table" then return tostring(expr) end
    
    local parts = {expr.type}
    if expr.type == "number" then
        table.insert(parts, tostring(expr.value))
    elseif expr.type == "variable" then
        table.insert(parts, expr.name)
    elseif expr.type == "pow" then
        table.insert(parts, expr_hash(expr.base))
        table.insert(parts, expr_hash(expr.exp))
    elseif expr.type == "sin" or expr.type == "cos" or expr.type == "ln" or expr.type == "exp" then
        table.insert(parts, expr_hash(expr.arg))
    elseif (expr.type == "add" or expr.type == "mul") and expr.args then
        local arg_hashes = {}
        for _, arg in ipairs(expr.args) do
            table.insert(arg_hashes, expr_hash(arg))
        end
        table.sort(arg_hashes) -- Commutative operations
        for _, hash in ipairs(arg_hashes) do
            table.insert(parts, hash)
        end
    end
    
    return table.concat(parts, "|")
end

local function expr_equal(a, b)
    return expr_hash(a) == expr_hash(b)
end

-- ===== STEP 1: FLATTEN ASSOCIATIVE OPERATIONS =====
-- Because nested additions/multiplications are the devil

local function flatten(expr)
    if not (is_add(expr) or is_mul(expr)) or not expr.args then return expr end
    
    local flattened = {}
    local op_type = expr.type
    
    local function collect_args(e)
        if e.type == op_type and e.args then
            for _, arg in ipairs(e.args) do
                collect_args(arg)
            end
        else
            table.insert(flattened, e)
        end
    end
    
    for _, arg in ipairs(expr.args) do
        collect_args(arg)
    end
    
    return {type = op_type, args = flattened}
end

-- ===== STEP 2: SORT ARGUMENTS FOR COMMUTATIVITY =====
-- Because order matters for consistency, not math

local function get_power_of_var(expr, var_name)
    -- Return exponent if expr is base^exp where base is var_name
    if expr.type == "pow" and expr.base.type == "variable" and expr.base.name == var_name then
        if expr.exp.type == "number" then
            return expr.exp.value
        end
    elseif expr.type == "variable" and expr.name == var_name then
        return 1
    elseif expr.type == "number" then
        return 0
    end
    return nil -- Cannot determine power
end

local function sort_args(expr)
    if not ((expr.type == "add" or expr.type == "mul") and expr.args) then return expr end
    
    local sorted_args = deepcopy(expr.args)
    -- If addition, try to sort by power of x ascending
    if expr.type == "add" then
        table.sort(sorted_args, function(a, b)
            local a_pow = get_power_of_var(a, "x")
            local b_pow = get_power_of_var(b, "x")
            if a_pow and b_pow then
                return a_pow < b_pow
            elseif a_pow then
                return true
            elseif b_pow then
                return false
            else
                return expr_hash(a) < expr_hash(b)
            end
        end)
    else
        -- For multiplication, keep original expr_hash sorting
        table.sort(sorted_args, function(a, b)
            return expr_hash(a) < expr_hash(b)
        end)
    end
    
    return {type = expr.type, args = sorted_args}
end

-- ===== STEP 3: CONSTANT FOLDING (The Easy Wins) =====

-- fold_constants: The Elegant Edition


local function fold_constants(expr)
    if not expr or type(expr) ~= "table" then return expr end
    if expr.type == "<unknown>" then return expr end

    -- Helper: create a number node (because apparently this needs to be a function)
    local function make_num(val)
        return { type = "number", value = val }
    end

    -- Helper: round number to current precision if needed
    local function round_number_if_needed(expr)
        if expr and expr.type == "number" then
            local p = get_precision()
            if p and p >= 0 then
                return { type = "number", value = round_to_precision(expr.value, p) }
            end
        end
        return expr
    end

    -- Helper: extract numeric value from node, handling negation gracefully
    local function extract_numeric_value(node)
        if node.type == "number" then
            return node.value, true
        elseif node.type == "neg" then
            local inner = node.arg or node.value
            if inner and inner.type == "number" then
                return -inner.value, true
            end
        end
        return nil, false
    end

    -- Handle addition: collect numbers, preserve everything else
    if expr.type == "add" and expr.args then
        local numeric_sum = 0
        local non_numeric_terms = {}
        local found_numbers = false

        for _, term in ipairs(expr.args) do
            local folded_term = fold_constants(term)
            local numeric_val, is_numeric = extract_numeric_value(folded_term)
            
            if is_numeric then
                numeric_sum = numeric_sum + numeric_val
                found_numbers = true
            else
                table.insert(non_numeric_terms, folded_term)
            end
        end

        -- Assemble the result with mathematical dignity
        local result_terms = {}
        if found_numbers and numeric_sum ~= 0 then
            table.insert(result_terms, make_num(numeric_sum))
        end
        for _, term in ipairs(non_numeric_terms) do
            table.insert(result_terms, term)
        end

        -- Return the most elegant representation
        if #result_terms == 0 then return round_number_if_needed(make_num(0)) end
        if #result_terms == 1 then return round_number_if_needed(result_terms[1]) end
        return { type = "add", args = result_terms }
    end

    -- Handle multiplication: the source of discriminant trauma
    if expr.type == "mul" and expr.args then
        local numeric_product = 1
        local non_numeric_factors = {}
        local found_numbers = false

        for _, factor in ipairs(expr.args) do
            local folded_factor = fold_constants(factor)
            local numeric_val, is_numeric = extract_numeric_value(folded_factor)
            
            if is_numeric then
                numeric_product = numeric_product * numeric_val
                found_numbers = true
            else
                table.insert(non_numeric_factors, folded_factor)
            end
        end

        -- PATCH: Distribute numeric factors over negations
        local patched_factors = {}
        for _, factor in ipairs(non_numeric_factors) do
            if factor.type == "neg" and factor.arg then
                -- Distribute all previous numeric_product into the negation
                table.insert(patched_factors, {type = "mul", args = {{type="number", value = -1 * numeric_product}, fold_constants(factor.arg)}})
                numeric_product = 1
                found_numbers = false
            else
                table.insert(patched_factors, factor)
            end
        end
        non_numeric_factors = patched_factors

        -- Handle the mathematical realities
        if numeric_product == 0 then return round_number_if_needed(make_num(0)) end

        -- Assemble result with appropriate elegance
        local result_factors = {}
        if found_numbers and (numeric_product ~= 1 or #non_numeric_factors == 0) then
            table.insert(result_factors, make_num(numeric_product))
        end
        for _, factor in ipairs(non_numeric_factors) do
            table.insert(result_factors, factor)
        end

        if #result_factors == 0 then return round_number_if_needed(make_num(1)) end
        if #result_factors == 1 then return round_number_if_needed(result_factors[1]) end
        return { type = "mul", args = result_factors }
    end

    -- Handle subtraction: where quadratic dreams go to die
    if expr.type == "sub" and expr.left and expr.right then
        local left = fold_constants(expr.left)
        local right = fold_constants(expr.right)

        -- Extract numeric values for direct computation
        local left_val, left_is_num = extract_numeric_value(left)
        local right_val, right_is_num = extract_numeric_value(right)

        -- Handle pure numeric subtraction
        if left_is_num and right_is_num then
            return round_number_if_needed(make_num(left_val - right_val))
        end

        -- Handle subtraction of negative: a - (-b) = a + b
        if right.type == "neg" then
            local right_inner = right.arg or right.value
            return fold_constants({ type = "add", args = { left, right_inner } })
        end

        -- Handle special case: 0 - x = -x
        if left_is_num and left_val == 0 then
            return fold_constants({ type = "neg", arg = right })
        end

        -- Handle special case: x - 0 = x
        if right_is_num and right_val == 0 then
            return round_number_if_needed(left)
        end

        return { type = "sub", left = left, right = right }
    end

    -- Handle division: because completeness matters
    if expr.type == "div" and expr.left and expr.right then
        local left = fold_constants(expr.left)
        local right = fold_constants(expr.right)

        local left_val, left_is_num = extract_numeric_value(left)
        local right_val, right_is_num = extract_numeric_value(right)

        if left_is_num and right_is_num and right_val ~= 0 then
            return round_number_if_needed(make_num(left_val / right_val))
        end

        -- x / 1 = x
        if right_is_num and right_val == 1 then
            return round_number_if_needed(left)
        end

        -- 0 / x = 0 (assuming x ≠ 0)
        if left_is_num and left_val == 0 then
            return round_number_if_needed(make_num(0))
        end

        return { type = "div", left = left, right = right }
    end

    -- Handle powers: because the quadratic formula demands it
    if expr.type == "pow" then
        local base = fold_constants(expr.base or expr.left)
        local exp = fold_constants(expr.exp or expr.right)

        local base_val, base_is_num = extract_numeric_value(base)
        local exp_val, exp_is_num = extract_numeric_value(exp)

        -- Simplify i^2 = -1
        if base.type == "symbol" and base.name == "i" and exp_is_num and exp_val == 2 then
            return round_number_if_needed(make_num(-1))
        end

        -- Handle numeric powers
        if base_is_num and exp_is_num and not _G.showComplex then
            -- Special cases to avoid numerical disasters
            if base_val == 0 and exp_val > 0 then return round_number_if_needed(make_num(0)) end
            if base_val == 0 and exp_val == 0 then return round_number_if_needed(make_num(1)) end
            if exp_val == 0 then return round_number_if_needed(make_num(1)) end
            if exp_val == 1 then return round_number_if_needed(base) end
            return round_number_if_needed(make_num(base_val ^ exp_val))
        end

        -- x^0 = 1
        if exp_is_num and exp_val == 0 then
            return round_number_if_needed(make_num(1))
        end

        -- x^1 = x
        if exp_is_num and exp_val == 1 then
            return round_number_if_needed(base)
        end

        -- 0^x = 0 (for positive x)
        if base_is_num and base_val == 0 then
            return round_number_if_needed(make_num(0))
        end

        -- 1^x = 1
        if base_is_num and base_val == 1 then
            return round_number_if_needed(make_num(1))
        end

        return { type = "pow", base = base, exp = exp }
    end

    -- Handle negation: with proper respect for double negatives
    if expr.type == "neg" then
        local inner = fold_constants(expr.arg or expr.value)
        local inner_val, inner_is_num = extract_numeric_value(inner)

        if inner_is_num then
            return round_number_if_needed(make_num(-inner_val))
        end

        -- Handle double negation: -(-x) = x
        if inner.type == "neg" then
            return fold_constants(inner.arg or inner.value)
        end

        return { type = "neg", arg = inner }
    end

    -- Handle functions: sqrt, sin, cos, etc.
    if expr.type == "func" and expr.args then
        local folded_args = {}
        local all_numeric = true
        
        for i, arg in ipairs(expr.args) do
            folded_args[i] = fold_constants(arg)
            if not extract_numeric_value(folded_args[i]) then
                all_numeric = false
            end
        end

        -- Handle sqrt of numeric values, including sqrt(-1) = i
        if expr.name == "sqrt" and #folded_args == 1 then
            local val, is_num = extract_numeric_value(folded_args[1])
            if is_num then
                if val >= 0 and not _G.showComplex then
                    return round_number_if_needed(make_num(math.sqrt(val)))
                elseif val == -1 then
                    return { type = "symbol", name = "i" }
                end
            end
        end

        -- Handle root(n, x) = x^(1/n)
        if expr.name == "root" and #folded_args == 2 then
            return {
                type = "pow",
                base = folded_args[2],
                exp = { type = "div", left = make_num(1), right = folded_args[1] }
            }
        end

        return { type = "func", name = expr.name, args = folded_args }
    end

    -- For everything else, recursively fold children
    local result = {}
    for k, v in pairs(expr) do
        if type(v) == "table" and k ~= "args" then
            result[k] = fold_constants(v)
        else
            result[k] = v
        end
    end

    -- At the end, round number if needed
    if result and result.type == "number" then
        result = round_number_if_needed(result)
    end
    return result
end

-- Helper: recursively simplify children before folding constants
local function fold_constants_recursive(expr)
    if type(expr) ~= "table" then return expr end
    -- Recursively process children
    local new_expr = deepcopy(expr)
    if is_num(new_expr) and new_expr.value == 0 then
        new_expr.value = 0  -- Normalize any -0 to 0
    end
    if new_expr.type == "pow" then
        new_expr.base = fold_constants_recursive(new_expr.base)
        new_expr.exp = fold_constants_recursive(new_expr.exp)
    elseif new_expr.type == "sin" or new_expr.type == "cos" or new_expr.type == "ln" or new_expr.type == "exp" then
        new_expr.arg = fold_constants_recursive(new_expr.arg)
    elseif (new_expr.type == "add" or new_expr.type == "mul") and new_expr.args then
        for i = 1, #new_expr.args do
            new_expr.args[i] = fold_constants_recursive(new_expr.args[i])
        end
    elseif new_expr.type == "func" and new_expr.args then
        for i = 1, #new_expr.args do
            new_expr.args[i] = fold_constants_recursive(new_expr.args[i])
        end
    elseif new_expr.type == "neg" and new_expr.arg then
        new_expr.arg = fold_constants_recursive(new_expr.arg)
    elseif new_expr.type == "sub" and new_expr.left and new_expr.right then
        new_expr.left = fold_constants_recursive(new_expr.left)
        new_expr.right = fold_constants_recursive(new_expr.right)
    end
    return fold_constants(new_expr)
end

-- ===== STEP 4: COLLECT LIKE TERMS (The Real Work) =====

local function extract_coefficient_and_base(expr)
    if is_num(expr) then
        return expr.value, num(1)
    end
    
    if is_mul(expr) and expr.args then
        local coeff = 1
        local base_parts = {}
        
        for _, arg in ipairs(expr.args) do
            if is_num(arg) then
                coeff = coeff * arg.value
            else
                table.insert(base_parts, arg)
            end
        end
        
        local base
        if #base_parts == 0 then
            base = num(1)
        elseif #base_parts == 1 then
            base = base_parts[1]
        else
            base = {type = "mul", args = base_parts}
        end
        
        return coeff, base
    end
    
    return 1, expr
end

local function collect_like_terms(expr)
    if not (is_add(expr) and expr.args) then return expr end

    local groups = {}

    for _, term in ipairs(expr.args) do
        local t = term
        local sign = 1
        if t.type == "neg" then
            t = t.arg or t.value
            sign = -1
        end
        local coeff, base = extract_coefficient_and_base(t)
        coeff = coeff * sign
        local base_key = expr_hash(base)

        if groups[base_key] then
            groups[base_key].coeff = groups[base_key].coeff + coeff
        else
            groups[base_key] = {coeff = coeff, base = base}
        end
    end

    local result_terms = {}
    for _, group in pairs(groups) do
        if math.abs(group.coeff) > 1e-10 then -- Handle floating point errors
            if math.abs(group.coeff - 1) < 1e-10 and not expr_equal(group.base, num(1)) then
                -- Coefficient is 1, just use base
                table.insert(result_terms, group.base)
            elseif expr_equal(group.base, num(1)) then
                -- Base is 1, just use coefficient
                table.insert(result_terms, num(group.coeff))
            else
                -- Both matter
                table.insert(result_terms, {type = "mul", args = {num(group.coeff), group.base}})
            end
        end
    end

    if #result_terms == 0 then return num(0) end
    if #result_terms == 1 then return result_terms[1] end
    return {type = "add", args = result_terms}
end

-- ===== STEP 5: POWER SIMPLIFICATION =====

local function simplify_powers(expr)
    -- x^0 = 1
    if is_pow(expr) and is_num(expr.exp) and expr.exp.value == 0 then
        return num(1)
    end
    
    -- x^1 = x
    if is_pow(expr) and is_num(expr.exp) and expr.exp.value == 1 then
        return expr.base
    end
    
    -- (x^a)^b = x^(a*b)
    if is_pow(expr) and is_pow(expr.base) then
        local new_exp = {type = "mul", args = {expr.base.exp, expr.exp}}
        return {type = "pow", base = expr.base.base, exp = new_exp}
    end
    
    return expr
end

-- ===== STEP 6: COMBINE LIKE POWERS IN MULTIPLICATION =====

local function combine_powers(expr)
    if not (is_mul(expr) and expr.args) then return expr end

    local base_groups = {}
    local other_factors = {}

    for _, factor in ipairs(expr.args) do
        local base, exp
        if is_pow(factor) then
            base, exp = factor.base, factor.exp
        else
            base, exp = factor, num(1)
        end

        -- Guard: Skip exponent combination for tensors
        if base.type == "tensor" then
            table.insert(other_factors, factor)
        else
            local base_key = expr_hash(base)
            if base_groups[base_key] then
                -- Combine exponents: x^a * x^b = x^(a+b)
                base_groups[base_key].exponents = base_groups[base_key].exponents or {}
                table.insert(base_groups[base_key].exponents, exp)
            else
                base_groups[base_key] = {base = base, exponents = {exp}}
            end
        end
    end

    local result_factors = {}

    for _, group in pairs(base_groups) do
        if #group.exponents == 1 then
            if expr_equal(group.exponents[1], num(1)) then
                table.insert(result_factors, group.base)
            else
                table.insert(result_factors, {type = "pow", base = group.base, exp = group.exponents[1]})
            end
        else
            local combined_exp = {type = "add", args = group.exponents}
            table.insert(result_factors, {type = "pow", base = group.base, exp = combined_exp})
        end
    end

    -- Append the other factors (e.g., tensors) that were skipped for exponent combination
    for _, f in ipairs(other_factors) do
        table.insert(result_factors, f)
    end

    if #result_factors == 0 then return num(1) end
    if #result_factors == 1 then return result_factors[1] end
    return {type = "mul", args = result_factors}
end

-- ===== STEP 7: BASIC DISTRIBUTION =====

local function distribute_simple(expr)
    if not (is_mul(expr) and expr.args) then return expr end
    
    -- Look for a(b + c) pattern
    local additions = {}
    local other_factors = {}
    
    for _, factor in ipairs(expr.args) do
        if is_add(factor) and factor.args then
            table.insert(additions, factor)
        else
            table.insert(other_factors, factor)
        end
    end
    
    if #additions == 0 then return expr end
    
    -- Take first addition and distribute other factors into it
    local first_add = additions[1]
    local remaining_adds = {}
    for i = 2, #additions do
        table.insert(remaining_adds, additions[i])
    end
    
    local all_other_factors = {}
    for _, f in ipairs(other_factors) do
        table.insert(all_other_factors, f)
    end
    for _, f in ipairs(remaining_adds) do
        table.insert(all_other_factors, f)
    end
    
    local distributed_terms = {}
    for _, addend in ipairs(first_add.args) do
        local new_factors = {addend}
        for _, factor in ipairs(all_other_factors) do
            table.insert(new_factors, factor)
        end
        
        if #new_factors == 1 then
            table.insert(distributed_terms, new_factors[1])
        else
            table.insert(distributed_terms, {type = "mul", args = new_factors})
        end
    end
    
    return {type = "add", args = distributed_terms}
end

-- ===== STEP 8: SPECIAL EXPANSIONS =====

local function expand_special_cases(expr)
    -- (a + b)^2 = a^2 + 2ab + b^2
    if is_pow(expr) and is_num(expr.exp) and expr.exp.value == 2 then
        if is_add(expr.base) and expr.base.args and #expr.base.args == 2 then
            local a, b = expr.base.args[1], expr.base.args[2]
            return {
                type = "add",
                args = {
                    {type = "pow", base = a, exp = num(2)},
                    {type = "mul", args = {num(2), a, b}},
                    {type = "pow", base = b, exp = num(2)}
                }
            }
        end
    end
    
    return expr
end

-- ===== STEP 9: TRIGONOMETRIC IDENTITIES =====

local function apply_trig_identities(expr)
    -- sin^2(x) + cos^2(x) = 1
    if is_add(expr) and expr.args and #expr.args == 2 then
        local term1, term2 = expr.args[1], expr.args[2]
        
        -- Check if we have sin^2(x) and cos^2(x)
        if is_pow(term1) and is_pow(term2) and 
           is_num(term1.exp) and is_num(term2.exp) and
           term1.exp.value == 2 and term2.exp.value == 2 then
            
            if is_sin(term1.base) and is_cos(term2.base) and
               expr_equal(term1.base.arg, term2.base.arg) then
                return num(1)
            elseif is_cos(term1.base) and is_sin(term2.base) and
                   expr_equal(term1.base.arg, term2.base.arg) then
                return num(1)
            end
        end
    end
    
    return expr
end

-- ===== STEP 10: LOGARITHM IDENTITIES =====

local function apply_log_identities(expr)
    -- ln(e^x) = x
    if is_ln(expr) and is_exp(expr.arg) then
        return expr.arg.arg
    end
    
    -- e^(ln(x)) = x
    if is_exp(expr) and is_ln(expr.arg) then
        return expr.arg.arg
    end
    
    return expr
end

-- ===== MAIN SIMPLIFICATION ENGINE =====

-- Helper function to serialize AST nodes for debugging
local function ast_to_string(node, visited, depth)
    visited = visited or {}
    depth = depth or 0
    local indent = string.rep("  ", depth)
    if type(node) ~= "table" then
        return tostring(node)
    end
    if visited[node] then
        return indent .. "<cycle>"
    end
    visited[node] = true
    local parts = {}
    table.insert(parts, indent .. "{")
    for k, v in pairs(node) do
        local keystr = tostring(k)
        if type(v) == "table" then
            table.insert(parts, indent .. "  " .. keystr .. " = " .. ast_to_string(v, visited, depth + 1))
        else
            table.insert(parts, indent .. "  " .. keystr .. " = " .. tostring(v))
        end
    end
    table.insert(parts, indent .. "}")
    return table.concat(parts, "\n")
end


-- Save original simplify_step
local old_simplify_step = simplify.simplify_step or function(expr) return expr end

-- Override simplify_step to add tensor mul support
function simplify.simplify_step(expr)
    -- Tensor multiplication (dot/matrix product)
    if type(expr) == "table" and expr.type == "mul" and expr.args and #expr.args == 2 then
        local a, b = expr.args[1], expr.args[2]
        if a.type == "tensor" and b.type == "tensor" then
            local prod = tensor_multiply(a, b)
            if prod then
                if prod.type == "number" then
                    return prod
                end
                -- Recursively simplify the product result
                return simplify.simplify_step(prod)
            end
        end
    end

    -- Scalar-Tensor element-wise multiplication
    if type(expr) == "table" and expr.type == "mul" and expr.args and #expr.args == 2 then
        local a, b = expr.args[1], expr.args[2]
        if is_num(a) and b.type == "tensor" then
            local scaled = {}
            for i, e in ipairs(b.elements) do
                if e.type == "number" then
                    scaled[i] = { type = "number", value = a.value * e.value }
                else
                    return expr
                end
            end
            return { type = "tensor", elements = scaled }
        elseif a.type == "tensor" and is_num(b) then
            local scaled = {}
            for i, e in ipairs(a.elements) do
                if e.type == "number" then
                    scaled[i] = { type = "number", value = e.value * b.value }
                else
                    return expr
                end
            end
            return { type = "tensor", elements = scaled }
        end
    end

    -- Tensor addition or subtraction (element-wise for exactly two tensors)
    if type(expr) == "table" and expr.type == "add" and expr.args then
        local tensors = {}
        for _, arg in ipairs(expr.args) do
            if arg.type == "tensor" then
                table.insert(tensors, arg)
            else
                return expr -- Non-tensor terms present, skip
            end
        end
        if #tensors == 2 then
            local a, b = tensors[1], tensors[2]
            if #a.elements ~= #b.elements then return expr end
            local sum_elements = {}
            for i = 1, #a.elements do
                if a.elements[i].type == "number" and b.elements[i].type == "number" then
                    sum_elements[i] = { type = "number", value = a.elements[i].value + b.elements[i].value }
                else
                    return expr
                end
            end
            return { type = "tensor", elements = sum_elements }
        elseif #tensors > 2 then
            return expr -- Skip multi-term tensor sums for now
        end
    end

    -- Tensor subtraction with recursive simplification
    if type(expr) == "table" and expr.type == "sub" and expr.left and expr.right then
        local a = simplify.simplify_step(expr.left)
        local b = simplify.simplify_step(expr.right)
        if a.type == "tensor" and b.type == "tensor" then
            if #a.elements ~= #b.elements then return expr end
            local diff_elements = {}
            for i = 1, #a.elements do
                if a.elements[i].type == "number" and b.elements[i].type == "number" then
                    diff_elements[i] = { type = "number", value = a.elements[i].value - b.elements[i].value }
                else
                    return expr
                end
            end
            return { type = "tensor", elements = diff_elements }
        end
    end

    -- Tensor division: tensor / tensor reduces to scalar 1 if dot product nonzero
    if type(expr) == "table" and expr.type == "mul" and expr.args and #expr.args == 2 then
        local a, b = expr.args[1], expr.args[2]
        if is_pow(a) and a.base.type == "tensor" and is_num(a.exp) and a.exp.value == -1 and b.type == "tensor" then
            local prod = tensor_multiply(a.base, b)
            if prod and prod.type == "number" then
                if prod.value ~= 0 then
                    return { type = "number", value = 1 }
                else
                    return { type = "number", value = 0 }
                end
            end
        end
    end

    -- Tensor exponentiation: restrict to scalar exponents, handle positive integers
    if type(expr) == "table" and expr.type == "pow" and expr.base and expr.exp then
        if expr.base.type == "tensor" and is_num(expr.exp) then
            local k = expr.exp.value
            if k == -1 then
                return { type = "pow", base = expr.base, exp = { type = "number", value = -1 } }
            elseif k >= 1 and math.floor(k) == k then
                local result = expr.base
                for _ = 2, k do
                    result = tensor_multiply(result, expr.base) or expr
                end
                return result
            end
        end
    end

    ----------------------------------------------------------------------
    -- Automatic evaluation for numeric factorial
    if type(expr) == "table" and expr.type == "func" and expr.name == "factorial" and expr.args and #expr.args == 1 then
        local arg = simplify.simplify_step(expr.args[1])
        if arg.type == "number" and _G.evaluateFactorial then
            return { type = "number", value = _G.evaluateFactorial(arg.value) }
        end
        expr.args[1] = arg
        return expr
    end

    -- Automatic evaluation for integral (debug-enhanced version)
    if type(expr) == "table" and expr.type == "func" and expr.name == "int" and expr.args and #expr.args == 2 then
        print("Simplifying integral: ", simplify.pretty_print(expr))

        local inner = simplify.simplify_step(expr.args[1])
        local respect_to = simplify.simplify_step(expr.args[2])

        print("Inner after simplify: ", simplify.pretty_print(inner))
        print("Respect to after simplify: ", simplify.pretty_print(respect_to))

        if respect_to.type == "variable" and _G.integrate and _G.integrate.integrateAST then
            print("Calling _G.integrate.integrateAST with:")
            print("Inner: ", simplify.pretty_print(inner))
            print("Respect to: ", respect_to.name)
            local status, val = pcall(_G.integrate.integrateAST, inner, respect_to.name)
            print("Integration status: ", status)
            if status and type(val) == "table" then
                print("Integration result: ", simplify.pretty_print(val))
                return simplify.simplify_step(val)
            else
                print("Integration failed or returned non-table, val = ", val)
            end
        else
            print("Skipping integral: invalid respect_to or integrateAST missing")
        end

        expr.args[1] = inner
        expr.args[2] = respect_to
        return expr
    end
    ----------------------------------------------------------------------

    -- Fall back to original simplify_step
    return old_simplify_step(expr)
end

-- Original recursive simplify_step for internal use
local function simplify_step(expr)
    if type(expr) ~= "table" then return expr end
    if expr.type == "<unknown>" then
        print("Warning: encountered unknown AST node during simplification")
        return expr
    end
    -- Handle tensor AST node type (recursive for arbitrary depth)
    if expr.type == "tensor" and expr.elements then
        local function simplify_tensor_elements(elems)
            local simplified = {}
            for i, elem in ipairs(elems) do
                if type(elem) == "table" and elem.type == "tensor" and elem.elements then
                    simplified[i] = { type = "tensor", elements = simplify_tensor_elements(elem.elements) }
                else
                    simplified[i] = simplify_step(elem)
                end
            end
            return simplified
        end
        return { type = "tensor", elements = simplify_tensor_elements(expr.elements) }
    end

    -- Handle equation normalization: move right to left (left - right = 0)
    if expr.type == "equation" and expr.left and expr.right then
        local sub_expr = { type = "sub", left = expr.left, right = expr.right, _from_equation = true }
        return simplify_step(sub_expr)
    end

    -- Recursively simplify children first
    local new_expr = deepcopy(expr)

    -- Preserve subtraction by zero if part of an equation during solve
    if new_expr.type == "sub" and is_num(new_expr.right) and new_expr.right.value == 0 then
        if new_expr._from_equation then
            return new_expr
        else
            return simplify_step(new_expr.left)
        end
    end

    -- Only simplify known types; preserve unknown types
    local known_types = {
        number = true, variable = true, constant = true, pow = true, add = true, mul = true,
        sin = true, cos = true, ln = true, exp = true, integral = true, func = true, neg = true,
        series = true, sub = true, div = true
    }
    if not known_types[new_expr.type] then
        return new_expr
    end

    if new_expr.type == "pow" then
        new_expr.base = simplify_step(new_expr.base)
        new_expr.exp = simplify_step(new_expr.exp)
    elseif new_expr.type == "sin" or new_expr.type == "cos" or new_expr.type == "ln" or new_expr.type == "exp" then
        new_expr.arg = simplify_step(new_expr.arg)
    elseif (new_expr.type == "add" or new_expr.type == "mul") and new_expr.args then
        for i = 1, #new_expr.args do
            new_expr.args[i] = simplify_step(new_expr.args[i])
        end
    elseif new_expr.type == "neg" then
        local val_field = new_expr.arg or new_expr.value
        val_field = simplify_step(val_field)
        if val_field.type == "neg" then
            return simplify_step(val_field.arg or val_field.value)
        end
        new_expr.arg = val_field
        new_expr.value = nil
    elseif new_expr.type == "constant" then
        new_expr.value = simplify_step(new_expr.value)
        return new_expr.value
    end

    new_expr = flatten(new_expr)
    new_expr = sort_args(new_expr)
    new_expr = fold_constants_recursive(new_expr)
    new_expr = collect_like_terms(new_expr)
    new_expr = simplify_powers(new_expr)
    new_expr = combine_powers(new_expr)
    new_expr = distribute_simple(new_expr)
    new_expr = expand_special_cases(new_expr)
    new_expr = apply_trig_identities(new_expr)
    new_expr = apply_log_identities(new_expr)

    return new_expr
end

local function simplify_until_stable(expr, max_iterations)
    max_iterations = max_iterations or 20
    local iteration = 0
    local prev_hash = nil
    
    while iteration < max_iterations do
        expr = simplify_step(expr)
        local current_hash = expr_hash(expr)
        
        if current_hash == prev_hash then
            break -- Converged
        end
        
        prev_hash = current_hash
        iteration = iteration + 1
    end
    
    return expr
end

-- ===== PRETTY PRINTER =====

-- Improved precedence-aware parentheses logic
local function needs_parens(expr, parent_op, position)
    -- Precedence: higher number = binds tighter
    local precedence = {
        add = 1,
        sub = 1,
        mul = 2,
        div = 2,
        pow = 3,
        neg = 4,
        func = 5,
        sin = 5,
        cos = 5,
        ln = 5,
        exp = 5,
        sqrt = 5,
    }
    local expr_prec = precedence[expr.type] or 6
    local parent_prec = precedence[parent_op] or 0
    if not parent_op then return false end
    if expr_prec > parent_prec then return false end
    if expr_prec < parent_prec then return true end
    -- When precedence is equal, only pow is right-associative
    if parent_op == "pow" and position == "right" then return true end
    -- For subtraction and division, left and right children may need parens for clarity
    if (parent_op == "sub" or parent_op == "div") and position == "right" then return true end
    return false
end

-- Helper: should multiplication be shown as explicit * ?
local function should_show_multiplication(left, right)
    -- Omit * when: number followed by variable/power, variable by variable/power, power by variable/power, sqrt by variable/number/etc.
    local function is_sqrt(e)
        return e and (e.type == "sqrt" or (is_pow(e) and is_num(e.exp) and e.exp.value == 0.5))
    end
    if is_num(left) and (is_var(right) or is_pow(right) or is_sqrt(right)) then return false end
    if is_var(left) and (is_var(right) or is_pow(right) or is_sqrt(right)) then return false end
    if is_pow(left) and (is_var(right) or is_pow(right) or is_sqrt(right)) then return false end
    if is_sqrt(left) and (is_var(right) or is_num(right) or is_pow(right) or is_sqrt(right)) then return false end
    -- Omit * between closing paren and variable/number
    if left.type == "constant" and (is_var(right) or is_num(right)) then return false end
    return true
end

-- Helper: is a simple factor (number, variable, constant, or function call)
local function is_simple_factor(expr)
    return is_num(expr) or is_var(expr) or expr.type == "constant"
        or expr.type == "sin" or expr.type == "cos" or expr.type == "ln" or expr.type == "exp"
        or expr.type == "sqrt"
        or (expr.type == "func" and expr.name and expr.args)
end

local function pretty_print_internal(expr, parent_op, position)
    if not expr then return "<nil>" end

    if expr.type == "solutions" and expr.solutions then
        local parts = {}
        for i, sol in ipairs(expr.solutions) do
            local sol_str = pretty_print_internal(sol, nil, nil)
            table.insert(parts, "Solution " .. i .. ": " .. sol_str)
        end
        return table.concat(parts, "\n")
    end
    -- Numbers
    if is_num(expr) then
        if expr.value >= 0 then
            return tostring(expr.value)
        else
            return "(" .. tostring(expr.value) .. ")"
        end
    end
    -- Variable
    if is_var(expr) then
        return expr.name
    end
    -- Constants
    if expr.type == "constant" then
        return expr.name
    end
    -- Negation
    if expr.type == "neg" and expr.value then
        local inner = pretty_print_internal(expr.value, "neg", "right")
        if not is_simple_factor(expr.value) then
            inner = "(" .. inner .. ")"
        end
        return "-" .. inner
    end
    -- Power: x^y, also handle sqrt
    if is_pow(expr) then
        -- Square root pretty print
        if is_num(expr.exp) and expr.exp.value == 0.5 then
            local arg_str = pretty_print_internal(expr.base, "sqrt", "arg")
            -- Avoid excessive parentheses around simple factors or powers (like x^2)
            if not (is_simple_factor(expr.base) or is_pow(expr.base)) then
                arg_str = "(" .. arg_str .. ")"
            end
            return "√" .. arg_str
        end
        local base_str = pretty_print_internal(expr.base, "pow", "left")
        local exp_str = pretty_print_internal(expr.exp, "pow", "right")
        if needs_parens(expr.base, "pow", "left") then
            base_str = "(" .. base_str .. ")"
        end
        if needs_parens(expr.exp, "pow", "right") then
            exp_str = "(" .. exp_str .. ")"
        end
        return base_str .. "^" .. exp_str
    end
    -- Functions: sin, cos, ln, exp, sqrt, and custom
    if expr.type == "sin" or expr.type == "cos" or expr.type == "ln" or expr.type == "exp" then
        local fname = expr.type
        return fname .. "(" .. pretty_print_internal(expr.arg, nil, nil) .. ")"
    end
    if expr.type == "sqrt" then
        local arg_str = pretty_print_internal(expr.arg, "sqrt", "arg")
        -- Avoid excessive parentheses around simple factors or powers (like x^2)
        if not (is_simple_factor(expr.arg) or is_pow(expr.arg)) then
            arg_str = "(" .. arg_str .. ")"
        end
        return "√" .. arg_str
    end
    -- Pretty print for func("int", ...): display as integral
    if expr.type == "func" and expr.name == "int" and expr.args then
        local arg_str = pretty_print_internal(expr.args[1], nil, nil)
        local respect_to = "x"
        if expr.args[2] and expr.args[2].type == "variable" then
            respect_to = expr.args[2].name
        end
        return "∫" .. arg_str .. " d" .. respect_to
    end
    -- Pretty print for inverse trig: arcsin, arccos, arctan, etc.
    if expr.type == "func" and expr.name and expr.args and (
        expr.name == "arcsin" or expr.name == "arccos" or expr.name == "arctan" or expr.name == "arccot"
        or expr.name == "arccsc" or expr.name == "arcsec"
    ) then
        local arg_strs = {}
        for i, arg in ipairs(expr.args) do
            table.insert(arg_strs, pretty_print_internal(arg, nil, nil))
        end
        return expr.name .. "(" .. table.concat(arg_strs, ", ") .. ")"
    end
    -- Handle generic function nodes: func(name, args)
    if expr.type == "func" and expr.name and expr.args then
        local arg_strs = {}
        for i, arg in ipairs(expr.args) do
            table.insert(arg_strs, pretty_print_internal(arg, nil, nil))
        end
        return expr.name .. "(" .. table.concat(arg_strs, ", ") .. ")"
    end
    -- Addition with forced + C at the end
    if is_add(expr) and expr.args then
        local regular_terms = {}
        local constant_c = nil

        for _, arg in ipairs(expr.args) do
            if arg.type == "variable" and arg.name == "C" then
                constant_c = pretty_print_internal(arg, "add", "inner")
            else
                local s = pretty_print_internal(arg, "add", "inner")
                -- Parenthesize negative terms for clarity
                if is_num(arg) and arg.value < 0 then
                    s = "(" .. s .. ")"
                elseif arg.type == "neg" then
                    s = "(" .. s .. ")"
                end
                table.insert(regular_terms, s)
            end
        end

        local result = table.concat(regular_terms, " + ")
        if constant_c then
            if #regular_terms > 0 then
                result = result .. " + " .. constant_c
            else
                result = constant_c
            end
        end

        if needs_parens(expr, parent_op, position) then
            return "(" .. result .. ")"
        end
        return result
    end
    -- Multiplication (improved implicit multiplication logic, always print 2x not x*2)
    if is_mul(expr) and expr.args then
        local parts = {}
        local function is_simple_func(e)
            return e and (e.type == "sin" or e.type == "cos" or e.type == "ln" or e.type == "exp" or (e.type == "func"))
        end
        -- Sort: numbers first, then variables, then powers, then functions, then others
        local sorted_args = {}
        for i, arg in ipairs(expr.args) do sorted_args[i] = arg end
        table.sort(sorted_args, function(a, b)
            local function sort_key(e)
                if is_num(e) then return 1
                elseif is_var(e) then return 2
                elseif is_pow(e) then return 3
                elseif is_simple_func(e) then return 4
                else return 5 end
            end
            local ka, kb = sort_key(a), sort_key(b)
            if ka ~= kb then return ka < kb end
            -- If same type, keep original order for stability
            return false
        end)
        -- Suppress leading 1 * expr, unless it's the only argument
        if is_num(sorted_args[1]) and sorted_args[1].value == 1 and #sorted_args > 1 then
            table.remove(sorted_args, 1)
        end
        -- Now build pretty print from sorted_args
        for i, arg in ipairs(sorted_args) do
            local s = pretty_print_internal(arg, "mul", "inner")
            if i == 1 then
                table.insert(parts, s)
            else
                local prev = sorted_args[i-1]
                local prev_is_num = is_num(prev)
                local prev_is_var = is_var(prev)
                local prev_is_pow = is_pow(prev)
                local prev_is_func = is_simple_func(prev)
                local curr_is_num = is_num(arg)
                local curr_is_var = is_var(arg)
                local curr_is_pow = is_pow(arg)
                local curr_is_func = is_simple_func(arg)

                -- Implicit multiplication rules:
                -- 2x, 3sin(x), xy, x^2y, x^2sin(x), sin(x)y, etc.
                -- But: x*6, sin(x)*5, etc. should be explicit
                local implicit = false
                -- Number before variable/power/function: 2x, 3sin(x), 4x^2
                if prev_is_num and (curr_is_var or curr_is_pow or curr_is_func) then
                    implicit = true
                    table.insert(parts, s)
                -- Variable before variable/power/function: xy, xsin(x), x^2y, x^2sin(x)
                elseif prev_is_var and (curr_is_var or curr_is_pow or curr_is_func) then
                    -- Special: if variable before inverse trig function, add space
                    if curr_is_func and arg.type == "func"
                        and (arg.name == "arcsin" or arg.name == "arccos" or arg.name == "arctan"
                             or arg.name == "arccot" or arg.name == "arccsc" or arg.name == "arcsec")
                    then
                        implicit = true
                        table.insert(parts, " " .. s)
                    else
                        implicit = true
                        table.insert(parts, s)
                    end
                -- Power before variable/power/function: x^2y, x^2sin(x), (x^2)(y^3)
                elseif prev_is_pow and (curr_is_var or curr_is_pow or curr_is_func) then
                    implicit = true
                    table.insert(parts, s)
                -- Function before variable/power/function: sin(x)y, sin(x)x^2
                elseif prev_is_func and (curr_is_var or curr_is_pow) then
                    implicit = true
                    table.insert(parts, s)
                else
                    table.insert(parts, " * " .. s)
                end
            end
        end
        local result = table.concat(parts)
        if needs_parens(expr, parent_op, position) then
            return "(" .. result .. ")"
        end
        return result
    end
    -- Division
    if expr.type == "div" and expr.left and expr.right then
        -- If denominator is 1, just return numerator
        if is_num(expr.right) and expr.right.value == 1 then
            return pretty_print_internal(expr.left, parent_op, position)
        end
        local left_str = pretty_print_internal(expr.left, "div", "left")
        local right_str = pretty_print_internal(expr.right, "div", "right")
        if not is_simple_factor(expr.left) then
            left_str = "(" .. left_str .. ")"
        end
        if not is_simple_factor(expr.right) then
            right_str = "(" .. right_str .. ")"
        end
        return left_str .. "/" .. right_str
    end
    -- Subtraction
    if expr.type == "sub" and expr.left and expr.right then
        local left_str = pretty_print_internal(expr.left, "sub", "left")
        local right_str = pretty_print_internal(expr.right, "sub", "right")
        if not is_simple_factor(expr.left) then
            left_str = "(" .. left_str .. ")"
        end
        if not is_simple_factor(expr.right) then
            right_str = "(" .. right_str .. ")"
        end
        return left_str .. " - " .. right_str
    end
    -- Pretty print for integral nodes
    if expr.type == "integral" and expr.integrand and expr.respect_to then
        return "∫" .. pretty_print_internal(expr.integrand, nil, nil) .. " d" .. expr.respect_to
    end

    -- Pretty print for limit nodes
    if expr.type == "lim" and expr.expr and expr.var and expr.to then
        local expr_str = pretty_print_internal(expr.expr, nil, nil)
        local to_str = pretty_print_internal(expr.to, nil, nil)
        return "lim_(" .. expr.var .. "→" .. to_str .. ") " .. expr_str
    end
    -- Pretty print for series node
    if expr.type == "series" and expr.func and expr.var and expr.center and expr.order then
        local func_str = pretty_print_internal(expr.func, nil, nil)
        local varName_str = pretty_print_internal(expr.var, nil, nil)
        local center_str = pretty_print_internal(expr.center, nil, nil)
        local order_str = pretty_print_internal(expr.order, nil, nil)
        return "series(" .. func_str .. ", " .. varName_str .. ", " .. center_str .. ", " .. order_str .. ")"
    end

    -- Pretty print for plus-minus node ("pm")
    if expr.type == "pm" and expr.left and expr.right then
        local left_str = pretty_print_internal(expr.left, nil, nil)
        local right_str = pretty_print_internal(expr.right, nil, nil)
        return "(" .. left_str .. " ± " .. right_str .. ")"
    end

    -- Pretty print for tensor node (recursive for arbitrary depth)
    if expr.type == "tensor" and expr.elements then
        local function pretty_print_tensor_elements(elems)
            local strs = {}
            for i, elem in ipairs(elems) do
                if type(elem) == "table" and elem.type == "tensor" and elem.elements then
                    strs[i] = "[" .. table.concat(pretty_print_tensor_elements(elem.elements), ", ") .. "]"
                else
                    strs[i] = pretty_print_internal(elem, nil, nil)
                end
            end
            return strs
        end
        return "[" .. table.concat(pretty_print_tensor_elements(expr.elements), ", ") .. "]"
    end

    return "<unknown>"
end
-- Debug print full AST for any expression
function simplify.debug_print_ast(expr)
    print("DEBUG AST dump:\n" .. ast_to_string(expr))
end
-- Recursively round all number nodes (including those inside expressions like mul, add, etc.)
local function recursively_round_numbers(expr)
    if type(expr) ~= "table" then return expr end
    if expr.type == "number" and type(expr.value) == "number" then
        local p = get_precision()
        expr.value = round_to_precision(expr.value, p)
        return expr
    end
    local out = {}
    for k, v in pairs(expr) do
        if type(v) == "table" then
            out[k] = recursively_round_numbers(v)
        else
            out[k] = v
        end
    end
    setmetatable(out, getmetatable(expr))
    return out
end
-- ===== PUBLIC API =====

function simplify.simplify(expr)
    return simplify_until_stable(expr)
end

function simplify.pretty_print(expr)
    local display_expr = recursively_round_numbers(deepcopy(expr))
    return pretty_print_internal(display_expr, nil, nil)
end

function simplify.canonicalize(expr)
    -- Just normalize structure without aggressive simplification
    local normalized = deepcopy(expr)
    if (is_add(normalized) or is_mul(normalized)) and normalized.args then
        normalized = flatten(normalized)
        normalized = sort_args(normalized)
    end
    return normalized
end

function simplify.simplify_with_stats(expr)
    local max_iterations = 20
    local iteration = 0
    local prev_hash = nil
    
    while iteration < max_iterations do
        expr = simplify_step(expr)
        local current_hash = expr_hash(expr)
        
        if current_hash == prev_hash then
            break -- Converged
        end
        
        prev_hash = current_hash
        iteration = iteration + 1
    end
    
    return expr, {
        passes = iteration,
        converged = iteration < max_iterations
    }
end



-- Export to global if needed (keeping compatibility)
_G.simplify = simplify

-- End src/simplify.lua

-- Integrated src/simplify.lua: let’s hope it compiles this time.

-- Begin src/tensor.lua
local ast = _G.ast or error("AST module required")

local Tensor = {}
Tensor.__index = Tensor


-- Get shape of nested table recursively
local function get_shape(data)
  local shape = {}
  local cur = data
  while type(cur) == "table" do
    table.insert(shape, #cur)
    cur = cur[1]
  end
  return shape
end

-- Validate shape uniformity recursively
local function validate_shape(data, shape, level)
  level = level or 1
  if level > #shape then return true end
  if type(data) ~= "table" or #data ~= shape[level] then
    error("Shape mismatch at level "..level)
  end
  for _, v in ipairs(data) do
    validate_shape(v, shape, level + 1)
  end
end

-- Deep copy nested table
local function deep_copy(data)
  if type(data) ~= "table" then return data end
  local copy = {}
  for k,v in pairs(data) do
    copy[k] = deep_copy(v)
  end
  return copy
end

-- Recursive map over two tensors elementwise
local function map_recursive(t1_data, t2_data, fn, level, shape)
  if level > #shape then
    return fn(t1_data, t2_data)
  end
  local res = {}
  for i = 1, shape[level] do
    res[i] = map_recursive(t1_data[i], t2_data[i], fn, level + 1, shape)
  end
  return res
end

-- Recursive eval_numeric on nested data
local function eval_recursive(data, env)
  if type(data) ~= "table" then
    return ast.eval_numeric(data, env)
  end
  local res = {}
  for i, v in ipairs(data) do
    res[i] = eval_recursive(v, env)
  end
  return res
end

-- Recursive function to permute axes of nested tensor data
local function transpose_recursive(data, perm, level, old_shape)
  level = level or 1
  if level > #perm then
    return data
  end

  local new_dim_size = old_shape[perm[level]]
  local res = {}
  for i = 1, new_dim_size do
    -- Gather slice along axis perm[level]
    local function get_sliced(data, indices, cur_level)
      if cur_level > #perm then
        return data
      end
      local idx = indices[cur_level]
      return get_sliced(data[idx], indices, cur_level + 1)
    end

    -- Build indices array for recursive calls
    local function build_indices(level, fixed_index)
      if level > #perm then return {} end
      if level == level then
        local rest = build_indices(level + 1, fixed_index)
        table.insert(rest, 1, fixed_index)
        return rest
      else
        -- Return range over dimension (hacky, but for full transpose you need full iterator)
        local arr = {}
        for j=1, old_shape[perm[level]] do
          arr[j] = j
        end
        return arr
      end
    end

    -- Because full implementation is complicated, do a simpler approach:
    -- We'll transpose by swapping axes by recursively re-indexing
    -- For now, we'll leave this stubbed, returning data as-is (TODO)

    res[i] = data -- TODO: Implement full permutation
  end
  return res
end

-- Function to get value from nested tensor data by index array
local function get_element(data, indices)
  local cur = data
  for _, idx in ipairs(indices) do
    cur = cur[idx]
  end
  return cur
end

-- Function to set value in nested tensor data by index array
local function set_element(data, indices, value)
  local cur = data
  for i = 1, #indices - 1 do
    cur = cur[indices[i]]
  end
  cur[indices[#indices]] = value
end

-- Utility to generate all index tuples for given shape
local function index_iterator(shape)
  local indices = {}
  for i=1,#shape do indices[i] = 1 end

  return function()
    if not indices then return nil end
    local result = {table.unpack(indices)}
    -- increment indices
    for i = #indices, 1, -1 do
      indices[i] = indices[i] + 1
      if indices[i] > shape[i] then
        if i == 1 then
          indices = nil
          break
        else
          indices[i] = 1
        end
      else
        break
      end
    end
    return result
  end
end

-- Tensor constructor
function Tensor.new(data)
  assert(type(data) == "table", "Tensor must be constructed from nested table")
  local shape = get_shape(data)
  validate_shape(data, shape)
  local function wrap_numbers(d)
    if type(d) ~= "table" then
      if type(d) == "number" then
        return { type = "number", value = d }
      else
        return d
      end
    end
    local res = {}
    for k, v in pairs(d) do
      res[k] = wrap_numbers(v)
    end
    return res
  end

  local wrapped_data = wrap_numbers(data)
  return setmetatable({ type = "tensor", data = wrapped_data, shape = shape }, Tensor)
end

function Tensor:eval_numeric(env)
  return eval_recursive(self.data, env)
end

function Tensor:add(other)
  assert(#self.shape == #other.shape, "Shape rank mismatch for addition")
  for i=1,#self.shape do
    assert(self.shape[i] == other.shape[i], "Shape dimension mismatch for addition")
  end
  local res_data = map_recursive(self.data, other.data, ast.add, 1, self.shape)
  return Tensor.new(res_data)
end

function Tensor:mul(other)
  assert(#self.shape == #other.shape, "Shape rank mismatch for multiplication")
  for i=1,#self.shape do
    assert(self.shape[i] == other.shape[i], "Shape dimension mismatch for multiplication")
  end
  local res_data = map_recursive(self.data, other.data, ast.mul, 1, self.shape)
  local res_tensor = Tensor.new(res_data)
  return Tensor.new(res_tensor:eval_numeric({}))
end

-- Generalized transpose (permute axes)
function Tensor:transpose(perm)
  perm = perm or {}
  local rank = #self.shape
  if #perm == 0 then
    -- default reverse axes
    for i=rank,1,-1 do table.insert(perm, i) end
  end
  assert(#perm == rank, "Permutation length must equal tensor rank")
  local new_shape = {}
  for i=1, rank do
    new_shape[i] = self.shape[perm[i]]
  end

  -- TODO: full transpose requires complex recursive reindexing
  -- for now, stub to just return self, but shape updated
  -- WARNING: This won't actually rearrange data correctly
  return Tensor.new(deep_copy(self.data)) -- TODO: fix data permuting
end

-- Tensor contraction over specified axes
-- axes1 and axes2 are arrays of axis indices in self and other respectively to contract over
function Tensor:contract(other, axes1, axes2)
  assert(#axes1 == #axes2, "Must contract same number of axes")

  local rank1 = #self.shape
  local rank2 = #other.shape

  -- Validate axes
  for i=1,#axes1 do
    assert(axes1[i] >=1 and axes1[i] <= rank1, "axes1 out of range")
    assert(axes2[i] >=1 and axes2[i] <= rank2, "axes2 out of range")
    assert(self.shape[axes1[i]] == other.shape[axes2[i]], "Dimension mismatch for contraction axes")
  end

  -- Result shape is all axes of self not in axes1 + all axes of other not in axes2
  local result_shape = {}
  local used_axes1 = {}
  for _, a in ipairs(axes1) do used_axes1[a] = true end
  for i=1, rank1 do
    if not used_axes1[i] then table.insert(result_shape, self.shape[i]) end
  end
  local used_axes2 = {}
  for _, a in ipairs(axes2) do used_axes2[a] = true end
  for i=1, rank2 do
    if not used_axes2[i] then table.insert(result_shape, other.shape[i]) end
  end

  -- Helper to get index mapping
  local function build_indices(base_indices, shape, exclude_axes)
    local indices = {}
    local skip = {}
    for _, e in ipairs(exclude_axes) do skip[e] = true end
    local idx = 1
    for i=1,#shape do
      if not skip[i] then
        indices[idx] = base_indices[i]
        idx = idx + 1
      end
    end
    return indices
  end

  -- All indices iterator for given shape
  local function iter_indices(shape)
    local idxs = {}
    for i=1,#shape do idxs[i] = 1 end
    return function()
      if not idxs then return nil end
      local ret = {table.unpack(idxs)}
      for i=#idxs,1,-1 do
        idxs[i] = idxs[i] + 1
        if idxs[i] > shape[i] then
          if i == 1 then idxs = nil break end
          idxs[i] = 1
        else
          break
        end
      end
      return ret
    end
  end

  -- Indices for contracted axes shape
  local contract_shape = {}
  for i=1,#axes1 do
    table.insert(contract_shape, self.shape[axes1[i]])
  end

  -- Indices for non-contracted axes in self
  local non_contract_shape1 = {}
  local non_contract_axes1 = {}
  for i=1, rank1 do
    if not used_axes1[i] then
      table.insert(non_contract_shape1, self.shape[i])
      table.insert(non_contract_axes1, i)
    end
  end

  -- Indices for non-contracted axes in other
  local non_contract_shape2 = {}
  local non_contract_axes2 = {}
  for i=1, rank2 do
    if not used_axes2[i] then
      table.insert(non_contract_shape2, other.shape[i])
      table.insert(non_contract_axes2, i)
    end
  end

  local contract_iter = iter_indices(contract_shape)
  local non_contract_iter1 = iter_indices(non_contract_shape1)
  local non_contract_iter2 = iter_indices(non_contract_shape2)

  -- Create zero-initialized nested table for result
  local function create_nested_table(shape, level)
    if level > #shape then return ast.number(0) end
    local t = {}
    for i=1, shape[level] do
      t[i] = create_nested_table(shape, level + 1)
    end
    return t
  end

  local result_data = create_nested_table(result_shape, 1)

  -- Main contraction loop
  -- Iterate over all non contracted indices of self and other, then sum over contracted axes
  local idx1 = non_contract_iter1()
  while idx1 do
    local idx2 = non_contract_iter2()
    while idx2 do
      local sum = nil
      local contract_idx = iter_indices(contract_shape)()
      while contract_idx do
        -- Build full indices for self and other
        local full_idx_self = {}
        for i=1, rank1 do
          if used_axes1[i] then
            -- contracted axis, find position in axes1 to get index
            for pos, ax in ipairs(axes1) do
              if ax == i then full_idx_self[i] = contract_idx[pos] break end
            end
          else
            -- find position in non_contract_axes1
            for pos2, ax2 in ipairs(non_contract_axes1) do
              if ax2 == i then
                full_idx_self[i] = idx1[pos2]
                break
              end
            end
          end
        end
        local full_idx_other = {}
        for i=1, rank2 do
          if used_axes2[i] then
            for pos, ax in ipairs(axes2) do
              if ax == i then full_idx_other[i] = contract_idx[pos] break end
            end
          else
            for pos2, ax2 in ipairs(non_contract_axes2) do
              if ax2 == i then
                full_idx_other[i] = idx2[pos2]
                break
              end
            end
          end
        end
        -- Fetch elements
        local val1 = get_element(self.data, full_idx_self)
        local val2 = get_element(other.data, full_idx_other)
        local mul_val = ast.mul(val1, val2)
        if sum == nil then sum = mul_val else sum = ast.add(sum, mul_val) end
        contract_idx = iter_indices(contract_shape)()
      end
      -- Set result element
      local res_idx = {}
      for _, v in ipairs(idx1) do table.insert(res_idx, v) end
      for _, v in ipairs(idx2) do table.insert(res_idx, v) end
      set_element(result_data, res_idx, sum)
      idx2 = non_contract_iter2()
    end
    idx1 = non_contract_iter1()
  end

  return Tensor.new(result_data)
end

-- Default tensor multiplication: contract last axis of self with first axis of other
function Tensor:tensor_multiply(other)
  -- Default tensor multiplication contracts last axis of self with first axis of other
  local axes1 = { #self.shape }
  local axes2 = { 1 }
  return self:contract(other, axes1, axes2)
end

_G.Tensor = Tensor

-- Hook for AST simplifier to use for tensor multiplication
-- (This is not strictly needed here, but for clarity in patch context)

-- End src/tensor.lua

-- src/tensor.lua has arrived. Prepare to blame someone.

-- Begin src/trig.lua
-- trig.lua
-- Trig evaluation and symbolic helpers for nLuaCAS
-- Mostly here to pretend we remember SOHCAHTOA and the chain rule

local errors = _G.errors

-- Handles numeric evaluation of trig functions
-- Assumes degrees because radians scare most calculator users
-- Falls back to symbolic if it smells like algebra
-- Numeric trig evaluation (angle in degrees if constant input)
local function eval_trig_func(fname, arg)
  if type(arg) == "table" and arg.type == "number" then
    local val = arg.value
    -- Assume degrees for simple numbers (can adapt for radians)
    local rad = math.rad(val)
    if fname == "sin" then return ast.number(math.sin(rad)) end
    if fname == "cos" then return ast.number(math.cos(rad)) end
    if fname == "tan" then return ast.number(math.tan(rad)) end
    if fname == "cot" then return ast.number(1 / math.tan(rad)) end
    if fname == "sec" then return ast.number(1 / math.cos(rad)) end
    if fname == "csc" then return ast.number(1 / math.sin(rad)) end
  end
  -- Not a numeric constant: return nil, fall back to symbolic
  return nil -- fallback to symbolic; not a number
end

-- Applies the chain rule without asking for permission
-- Sins become cosines, cosines become negative sins, and so on
-- Symbolic differentiation of all trig functions (chain rule applied)
local function diff_trig_func(fname, arg, darg)
  if fname == "sin" then
    return ast.mul(ast.func("cos", {arg}), darg)
  elseif fname == "cos" then
    return ast.mul(ast.neg(ast.func("sin", {arg})), darg)
  elseif fname == "tan" then
    return ast.mul(ast.add(ast.number(1), ast.pow(ast.func("tan", {arg}), ast.number(2))), darg)
  elseif fname == "cot" then
    return ast.mul(ast.neg(ast.add(ast.number(1), ast.pow(ast.func("cot", {arg}), ast.number(2)))), darg)
  elseif fname == "sec" then
    return ast.mul(ast.mul(ast.func("sec", {arg}), ast.func("tan", {arg})), darg)
  elseif fname == "csc" then
    return ast.mul(ast.neg(ast.mul(ast.func("csc", {arg}), ast.func("cot", {arg}))), darg)
  end
  return error(errors.invalid("diff", "unknown trig function: " .. tostring(fname)))
end

-- Symbolic integration of trig functions
local function integrate_trig_func(fname, arg)
  if fname == "sin" then
    return ast.neg(ast.func("cos", {arg}))
  elseif fname == "cos" then
    return ast.func("sin", {arg})
  elseif fname == "tan" then
    return ast.neg(ast.func("ln", {ast.func("cos", {arg})}))
  elseif fname == "cot" then
    return ast.func("ln", {ast.func("sin", {arg})})
  elseif fname == "sec" then
    return ast.func("ln", {ast.add(ast.func("sec", {arg}), ast.func("tan", {arg}))})
  elseif fname == "csc" then
    return ast.neg(ast.func("ln", {ast.add(ast.func("csc", {arg}), ast.func("cot", {arg}))}))
  end
  return nil -- unknown trig function, fallback to unhandled
end

-- Bundle it up for the global namespace
-- Hopefully avoids circular dependency chaos
_G.trig = {
  eval_trig_func = eval_trig_func,
  diff_trig_func = diff_trig_func,
  integrate_trig_func = integrate_trig_func,
}

-- End src/trig.lua

-- Tossed src/trig.lua in here—go ahead, run your tests.

-- Begin src/derivative.lua
-- Derivative Engine with Mathematical Solution Steps
-- Now shows actual mathematical work instead of rule explanations

local ast = rawget(_G, "ast") or require("ast")
local trig = rawget(_G, "trig")
local simplify = rawget(_G, "simplify")

-- Utility: DEEP copy of a table
local function deep_copy(obj)
  if type(obj) ~= "table" then return obj end
  
  if obj.__copy_visited then return obj end 
  obj.__copy_visited = true

  local new_table = {}
  for key, value in pairs(obj) do
      new_table[key] = deep_copy(value)
  end
  
  obj.__copy_visited = nil

  local mt = getmetatable(obj)
  if mt then
      setmetatable(new_table, mt)
  end
  return new_table
end

-- Utility functions
local function is_const(ast_node)
  return ast_node and ast_node.type == "number"
end

local function is_var(ast_node)
  return ast_node and ast_node.type == "variable"
end

local function is_symbol(ast_node, name)
  return ast_node and ast_node.type == "variable" and ast_node.name == name
end

local function lim(expr, var, to)
  return { type = 'lim', expr = expr, var = var, to = to }
end

-- Helper to format expressions nicely for steps
local function format_expr(ast_node)
  return (simplify and simplify.pretty_print(ast_node)) or ast.tostring(ast_node)
end

-- Symbolic differentiation core with mathematical solution steps
local function diffAST(ast_node, var)
  local steps = {}
  local result = nil

  -- Input validation
  if not ast_node then
    error(_G.errors.get("diff(unimplemented_node)") or "Input AST node is nil.")
  end
  if type(ast_node) ~= "table" then
    error(_G.errors.get("diff(just_no)") or "Input is not an AST table.")
  end
  if not ast_node.type then
    error(_G.errors.get("diff(no_type)") or "Input AST table missing 'type' field.")
  end

  var = var or "x"
  
  -- Helper to add a mathematical step
  local function add_step(description)
      table.insert(steps, { description = description })
  end

  -- Check if this is a trivial derivative that doesn't need showing steps
  local function is_trivial(node)
    return (node.type == "number") or 
           (node.type == "variable" and node.name == var) or
           (node.type == "variable" and node.name ~= var)
  end

  -- Numbers: derivative is 0 (only show step if it's the main expression)
  if ast_node.type == "number" then
    result = ast.number(0)
    assert(result and result.type == "number", "Constant Rule failed.")
    -- Only add step if this is likely the main expression being differentiated
    if format_expr(ast_node) ~= "1" and format_expr(ast_node) ~= "0" then
      add_step("d/d" .. var .. "(" .. format_expr(ast_node) .. ") = 0")
    end
  
  -- Variables (only show step for non-trivial cases)
  elseif ast_node.type == "variable" then
    if ast_node.name == var then
      result = ast.number(1)
      assert(result and result.type == "number", "Variable Rule (self) failed.")
      -- Don't show d/dx(x) = 1 unless it's the main expression
    else
      result = ast.number(0)
      assert(result and result.type == "number", "Variable Rule (other) failed.")
      -- Don't show d/dx(constant) = 0 unless it's the main expression
    end
  
  -- Negation: -f(x) → -f'(x)
  elseif ast_node.type == "neg" then
    local inner_arg = ast_node.arg or ast_node.value
    assert(inner_arg, "Negation node has no valid argument.")
    
    add_step("d/d" .. var .. "(-" .. format_expr(inner_arg) .. ") = -d/d" .. var .. "(" .. format_expr(inner_arg) .. ")")
    
    local inner_deriv, inner_steps = diffAST(inner_arg, var)
    assert(inner_deriv and inner_deriv.type, "diffAST failed for negation argument.")
    for _, s in ipairs(inner_steps) do table.insert(steps, s) end

    result = ast.neg(inner_deriv)
    assert(result and result.type == "neg", "Negation Rule failed.")
    add_step("= -(" .. format_expr(inner_deriv) .. ")")
  
  -- Addition: sum rule
  elseif ast_node.type == "add" then
    local expr_str = format_expr(ast_node)
    add_step("d/d" .. var .. "(" .. expr_str .. ") = " .. 
             table.concat(
               (function()
                 local parts = {}
                 for i, term in ipairs(ast_node.args) do
                   table.insert(parts, "d/d" .. var .. "(" .. format_expr(term) .. ")")
                 end
                 return parts
               end)(), " + "))
    
    local deriv_args = {}
    for i, term in ipairs(ast_node.args) do
      local d_term, d_term_steps = diffAST(term, var)
      assert(d_term and d_term.type, "diffAST failed for addition term.")
      for _, s in ipairs(d_term_steps) do table.insert(steps, s) end
      table.insert(deriv_args, d_term)
    end
    assert(#deriv_args > 0, "Sum rule resulted in no terms.")
    result = ast.add(table.unpack(deriv_args))
    assert(result and result.type == "add", "Sum Rule failed.")
    
    add_step("= " .. format_expr(result))
  
  -- Subtraction
  elseif ast_node.type == "sub" then
    add_step("d/d" .. var .. "(" .. format_expr(ast_node) .. ") = d/d" .. var .. "(" .. 
             format_expr(ast_node.left) .. ") - d/d" .. var .. "(" .. format_expr(ast_node.right) .. ")")
    
    local left_deriv, left_steps = diffAST(ast_node.left, var)
    assert(left_deriv and left_deriv.type, "diffAST failed for subtraction left.")
    for _, s in ipairs(left_steps) do table.insert(steps, s) end

    local right_deriv, right_steps = diffAST(ast_node.right, var)
    assert(right_deriv and right_deriv.type, "diffAST failed for subtraction right.")
    for _, s in ipairs(right_steps) do table.insert(steps, s) end

    result = ast.sub(left_deriv, right_deriv)
    assert(result and result.type == "sub", "Difference Rule failed.")
    add_step("= " .. format_expr(left_deriv) .. " - " .. format_expr(right_deriv))
    add_step("= " .. format_expr(result))
  
  -- Multiplication: product rule
  elseif ast_node.type == "mul" then
    local n_factors = #ast_node.args
    
    if n_factors == 2 then
        local u, v = ast_node.args[1], ast_node.args[2]
        add_step("d/d" .. var .. "(" .. format_expr(u) .. " · " .. format_expr(v) .. 
                ") = d/d" .. var .. "(" .. format_expr(u) .. ") · " .. format_expr(v) .. 
                " + " .. format_expr(u) .. " · d/d" .. var .. "(" .. format_expr(v) .. ")")
        
        local du, du_steps = diffAST(u, var)
        assert(du and du.type, "diffAST failed for product u.")
        for _, s in ipairs(du_steps) do table.insert(steps, s) end

        local dv, dv_steps = diffAST(v, var)
        assert(dv and dv.type, "diffAST failed for product v.")
        for _, s in ipairs(dv_steps) do table.insert(steps, s) end
        
        local term1 = ast.mul(du, deep_copy(v))
        assert(term1 and term1.type == "mul", "Product Rule term1 failed.")
        local term2 = ast.mul(deep_copy(u), dv)
        assert(term2 and term2.type == "mul", "Product Rule term2 failed.")
        
        add_step("= " .. format_expr(du) .. " · " .. format_expr(v) .. 
                " + " .. format_expr(u) .. " · " .. format_expr(dv))
        
        result = ast.add(term1, term2)
        assert(result and result.type == "add", "Product Rule failed.")
        add_step("= " .. format_expr(result))
    else
        -- General product rule
        add_step("Using product rule for " .. n_factors .. " factors:")
        local terms = {}
        for k = 1, n_factors do
            local prod_args = {}
            local d_arg_k, d_arg_k_steps = diffAST(ast_node.args[k], var)
            assert(d_arg_k and d_arg_k.type, "diffAST failed for general product factor.")
            for _, s in ipairs(d_arg_k_steps) do table.insert(steps, s) end

            for i = 1, n_factors do
                if i == k then
                    prod_args[i] = d_arg_k
                else
                    prod_args[i] = deep_copy(ast_node.args[i])
                end
            end
            local term_k = ast.mul(table.unpack(prod_args))
            assert(term_k and term_k.type == "mul", "General Product Rule term failed.")
            table.insert(terms, term_k)
        end
        assert(#terms > 0, "General Product Rule resulted in no terms.")
        result = ast.add(table.unpack(terms))
        assert(result and result.type == "add", "General Product Rule failed.")
        add_step("= " .. format_expr(result))
    end
  
  -- Division: quotient rule
  elseif ast_node.type == "div" then
    local u = ast_node.left
    local v = ast_node.right
    
    add_step("d/d" .. var .. "(" .. format_expr(u) .. "/" .. format_expr(v) .. 
            ") = [" .. format_expr(v) .. " · d/d" .. var .. "(" .. format_expr(u) .. 
            ") - " .. format_expr(u) .. " · d/d" .. var .. "(" .. format_expr(v) .. 
            ")] / (" .. format_expr(v) .. ")²")
    
    local du, du_steps = diffAST(u, var)
    assert(du and du.type, "diffAST failed for quotient numerator.")
    for _, s in ipairs(du_steps) do table.insert(steps, s) end

    local dv, dv_steps = diffAST(v, var)
    assert(dv and dv.type, "diffAST failed for quotient denominator.")
    for _, s in ipairs(dv_steps) do table.insert(steps, s) end

    add_step("= [" .. format_expr(v) .. " · " .. format_expr(du) .. 
            " - " .. format_expr(u) .. " · " .. format_expr(dv) .. 
            "] / (" .. format_expr(v) .. ")²")

    local numerator = ast.sub(
      ast.mul(du, deep_copy(v)),
      ast.mul(deep_copy(u), dv)
    )
    assert(numerator and numerator.type == "sub", "Quotient Rule numerator failed.")

    local denominator = ast.pow(deep_copy(v), ast.number(2))
    assert(denominator and denominator.type == "pow", "Quotient Rule denominator failed.")

    result = ast.div(numerator, denominator)
    assert(result and result.type == "div", "Quotient Rule failed.")
    add_step("= " .. format_expr(result))
  
  -- Powers
  elseif ast_node.type == "pow" then
    local u, n = ast_node.base, ast_node.exp
    
    if is_const(n) then
      -- Power rule: more concise for simple cases
      local du, du_steps = diffAST(u, var)
      assert(du and du.type, "diffAST failed for power base.")
      
      local n_val = n.value
      local n_minus_1 = ast.number(n_val - 1)
      assert(n_minus_1 and n_minus_1.type == "number", "Power Rule n-1 failed.")
      
      -- For simple x^n, just show: d/dx(x^n) = nx^(n-1)
      if is_var(u) and u.name == var and is_trivial(du) then
        add_step("d/d" .. var .. "(" .. format_expr(u) .. "^" .. format_expr(n) .. 
                ") = " .. format_expr(n) .. format_expr(u) .. "^(" .. 
                format_expr(n) .. "-1) = " .. format_expr(n) .. format_expr(u) .. "^" .. 
                format_expr(n_minus_1))
      else
        -- For more complex cases, show chain rule
        add_step("d/d" .. var .. "(" .. format_expr(u) .. "^" .. format_expr(n) .. 
                ") = " .. format_expr(n) .. "(" .. format_expr(u) .. ")^(" .. 
                format_expr(n) .. "-1) · d/d" .. var .. "(" .. format_expr(u) .. ")")
        
        -- Add inner derivative steps if non-trivial
        if not is_trivial(u) then
          for _, s in ipairs(du_steps) do table.insert(steps, s) end
        end
        
        add_step("= " .. format_expr(n) .. "(" .. format_expr(u) .. ")^" .. 
                format_expr(n_minus_1) .. " · " .. format_expr(du))
      end
      
      local term1 = ast.mul(deep_copy(n), ast.pow(deep_copy(u), n_minus_1))
      assert(term1 and term1.type == "mul", "Power Rule term1 failed.")
      result = ast.mul(term1, du)
      assert(result and result.type == "mul", "Power Rule failed.")
      
      add_step("= " .. format_expr(result))
      
    elseif is_const(u) then
      -- Exponential rule: d/dx(a^u) = ln(a)·a^u·u'
      add_step("d/d" .. var .. "(" .. format_expr(u) .. "^" .. format_expr(n) .. 
              ") = ln(" .. format_expr(u) .. ") · " .. format_expr(u) .. "^" .. 
              format_expr(n) .. " · d/d" .. var .. "(" .. format_expr(n) .. ")")
      
      local dv, dv_steps = diffAST(n, var)
      assert(dv and dv.type, "diffAST failed for exponential exponent.")
      for _, s in ipairs(dv_steps) do table.insert(steps, s) end
      
      local ln_u = ast.func("ln", { deep_copy(u) })
      assert(ln_u and ln_u.type == "func", "Exponential Rule ln(u) failed.")
      local u_pow_n = ast.pow(deep_copy(u), deep_copy(n))
      assert(u_pow_n and u_pow_n.type == "pow", "Exponential Rule a^u failed.")

      local term1 = ast.mul(ln_u, u_pow_n)
      assert(term1 and term1.type == "mul", "Exponential Rule term1 failed.")
      result = ast.mul(term1, dv)
      assert(result and result.type == "mul", "Exponential Rule failed.")
      
      add_step("= " .. format_expr(ln_u) .. " · " .. format_expr(u_pow_n) .. " · " .. format_expr(dv))
      add_step("= " .. format_expr(result))
    else
      -- General case: u^v using logarithmic differentiation
      add_step("d/d" .. var .. "(" .. format_expr(u) .. "^" .. format_expr(n) .. 
              ") = " .. format_expr(u) .. "^" .. format_expr(n) .. 
              " · [d/d" .. var .. "(" .. format_expr(n) .. ") · ln(" .. format_expr(u) .. 
              ") + " .. format_expr(n) .. " · d/d" .. var .. "(" .. format_expr(u) .. 
              ")/" .. format_expr(u) .. "]")
      
      local du, du_steps = diffAST(u, var)
      assert(du and du.type, "diffAST failed for general power base.")
      for _, s in ipairs(du_steps) do table.insert(steps, s) end
      local dv, dv_steps = diffAST(n, var)
      assert(dv and dv.type, "diffAST failed for general power exponent.")
      for _, s in ipairs(dv_steps) do table.insert(steps, s) end
      
      local copied_u_pow_n = ast.pow(deep_copy(u), deep_copy(n))
      assert(copied_u_pow_n and copied_u_pow_n.type == "pow", "General power u^v failed.")
      
      local ln_u = ast.func("ln", { deep_copy(u) })
      assert(ln_u and ln_u.type == "func", "General power ln(u) failed.")
      
      local div_u_prime_u = ast.div(du, deep_copy(u))
      assert(div_u_prime_u and div_u_prime_u.type == "div", "General power u'/u failed.")

      local term1_add = ast.mul(dv, ln_u)
      assert(term1_add and term1_add.type == "mul", "General power term1 failed.")
      
      local term2_add = ast.mul(deep_copy(n), div_u_prime_u)
      assert(term2_add and term2_add.type == "mul", "General power term2 failed.")

      local sum_terms = ast.add(term1_add, term2_add)
      assert(sum_terms and sum_terms.type == "add", "General power sum failed.")

      result = ast.mul(copied_u_pow_n, sum_terms)
      assert(result and result.type == "mul", "General power final failed.")
      
      add_step("= " .. format_expr(copied_u_pow_n) .. " · [" .. format_expr(dv) .. 
              " · " .. format_expr(ln_u) .. " + " .. format_expr(n) .. " · " .. 
              format_expr(div_u_prime_u) .. "]")
      add_step("= " .. format_expr(result))
    end
  
  -- Function differentiation with chain rule
  elseif ast_node.type == "func" then
    local fname = ast_node.name
    local u = ast_node.arg or (ast_node.args and ast_node.args[1])
    assert(u, "Function argument is nil for '" .. fname .. "'.")
    
    local du, du_steps = diffAST(u, var)
    assert(du and du.type, "diffAST failed for function argument.")
    
    -- Handle specific functions
    if fname == "sin" then
        local cos_u = ast.func("cos", { deep_copy(u) })
        result = ast.mul(cos_u, du)
        
        if is_var(u) and u.name == var then
          -- Simple case: d/dx(sin(x)) = cos(x)
          add_step("d/d" .. var .. "(sin(" .. format_expr(u) .. ")) = cos(" .. format_expr(u) .. ")")
        else
          -- Chain rule case
          add_step("d/d" .. var .. "(sin(" .. format_expr(u) .. ")) = cos(" .. format_expr(u) .. ") · d/d" .. var .. "(" .. format_expr(u) .. ")")
          if not is_trivial(u) then
            for _, s in ipairs(du_steps) do table.insert(steps, s) end
          end
          add_step("= cos(" .. format_expr(u) .. ") · " .. format_expr(du))
          add_step("= " .. format_expr(result))
        end
        
    elseif fname == "cos" then
        local sin_u = ast.func("sin", { deep_copy(u) })
        local neg_sin_u = ast.neg(sin_u)
        result = ast.mul(neg_sin_u, du)
        
        if is_var(u) and u.name == var then
          add_step("d/d" .. var .. "(cos(" .. format_expr(u) .. ")) = -sin(" .. format_expr(u) .. ")")
        else
          add_step("d/d" .. var .. "(cos(" .. format_expr(u) .. ")) = -sin(" .. format_expr(u) .. ") · d/d" .. var .. "(" .. format_expr(u) .. ")")
          if not is_trivial(u) then
            for _, s in ipairs(du_steps) do table.insert(steps, s) end
          end
          add_step("= -sin(" .. format_expr(u) .. ") · " .. format_expr(du))
          add_step("= " .. format_expr(result))
        end
        
    elseif fname == "tan" then
        local sec_u_sq = ast.pow(ast.func("sec", { deep_copy(u) }), ast.number(2))
        result = ast.mul(sec_u_sq, du)
        
        if is_var(u) and u.name == var then
          add_step("d/d" .. var .. "(tan(" .. format_expr(u) .. ")) = sec²(" .. format_expr(u) .. ")")
        else
          add_step("d/d" .. var .. "(tan(" .. format_expr(u) .. ")) = sec²(" .. format_expr(u) .. ") · d/d" .. var .. "(" .. format_expr(u) .. ")")
          if not is_trivial(u) then
            for _, s in ipairs(du_steps) do table.insert(steps, s) end
          end
          add_step("= sec²(" .. format_expr(u) .. ") · " .. format_expr(du))
          add_step("= " .. format_expr(result))
        end
        
    elseif fname == "exp" then
        local exp_u = ast.func("exp", { deep_copy(u) })
        result = ast.mul(exp_u, du)
        
        if is_var(u) and u.name == var then
          add_step("d/d" .. var .. "(e^" .. format_expr(u) .. ") = e^" .. format_expr(u))
        else
          add_step("d/d" .. var .. "(e^" .. format_expr(u) .. ") = e^" .. format_expr(u) .. " · d/d" .. var .. "(" .. format_expr(u) .. ")")
          if not is_trivial(u) then
            for _, s in ipairs(du_steps) do table.insert(steps, s) end
          end
          add_step("= e^" .. format_expr(u) .. " · " .. format_expr(du))
          add_step("= " .. format_expr(result))
        end
        
    elseif fname == "ln" then
        local one_div_u = ast.div(ast.number(1), deep_copy(u))
        result = ast.mul(one_div_u, du)
        
        if is_var(u) and u.name == var then
          add_step("d/d" .. var .. "(ln(" .. format_expr(u) .. ")) = 1/" .. format_expr(u))
        else
          add_step("d/d" .. var .. "(ln(" .. format_expr(u) .. ")) = (1/" .. format_expr(u) .. ") · d/d" .. var .. "(" .. format_expr(u) .. ")")
          if not is_trivial(u) then
            for _, s in ipairs(du_steps) do table.insert(steps, s) end
          end
          add_step("= (1/" .. format_expr(u) .. ") · " .. format_expr(du))
          add_step("= " .. format_expr(result))
        end
        
    elseif fname == "sqrt" then
        local two_sqrt_u = ast.mul(ast.number(2), ast.func("sqrt", { deep_copy(u) }))
        local one_div_two_sqrt_u = ast.div(ast.number(1), two_sqrt_u)
        result = ast.mul(one_div_two_sqrt_u, du)
        
        if is_var(u) and u.name == var then
          add_step("d/d" .. var .. "(√" .. format_expr(u) .. ") = 1/(2√" .. format_expr(u) .. ")")
        else
          add_step("d/d" .. var .. "(√" .. format_expr(u) .. ") = (1/(2√" .. format_expr(u) .. ")) · d/d" .. var .. "(" .. format_expr(u) .. ")")
          if not is_trivial(u) then
            for _, s in ipairs(du_steps) do table.insert(steps, s) end
          end
          add_step("= (1/(2√" .. format_expr(u) .. ")) · " .. format_expr(du))
          add_step("= " .. format_expr(result))
        end
        
    else
        -- For other functions, show generic derivative notation
        local generic_deriv = ast.func(fname .. "'", { deep_copy(u) })
        result = ast.mul(generic_deriv, du)
        
        if is_var(u) and u.name == var then
          add_step("d/d" .. var .. "(" .. fname .. "(" .. format_expr(u) .. ")) = " .. fname .. "'(" .. format_expr(u) .. ")")
        else
          add_step("d/d" .. var .. "(" .. fname .. "(" .. format_expr(u) .. ")) = " .. fname .. "'(" .. format_expr(u) .. ") · d/d" .. var .. "(" .. format_expr(u) .. ")")
          if not is_trivial(u) then
            for _, s in ipairs(du_steps) do table.insert(steps, s) end
          end
          add_step("= " .. fname .. "'(" .. format_expr(u) .. ") · " .. format_expr(du))
          add_step("= " .. format_expr(result))
        end
    end
    
    assert(result and result.type, "Function differentiation failed.")
  
  else
    error(_G.errors.get("diff(unimplemented_node)") or "Unhandled node type '" .. tostring(ast_node.type) .. "'.")
  end
  
  -- Simplify final result
  assert(result and result.type, "Differentiation produced invalid result.")
  local simplified_result = (simplify and simplify.simplify(deep_copy(result))) or deep_copy(result)
  
  -- Show simplification step if it actually simplified
  if simplify and not ast.equal(simplified_result, result) then
      add_step("Simplified: " .. format_expr(simplified_result))
  end
  
  return simplified_result, steps
end

-- Public interface
local function derivative(expr, var)
  local parser = rawget(_G, "parser") or require("parser")
  
  if type(expr) ~= "string" then
    error(_G.errors.get("diff(where_is_the_var)") or "Input must be a string expression.")
  end
  
  local tree = parser.parse(expr)
  if not tree then
    error(_G.errors.get("parse(syntax)") or "Failed to parse expression.")
  end
  if type(tree) ~= "table" or not tree.type then
    error(_G.errors.get("parse(invalid_ast)") or "Invalid AST from parser.")
  end
  
  local result_ast, steps_list = diffAST(tree, var)
  
  if not result_ast or type(result_ast) ~= "table" or not result_ast.type then
    error(_G.errors.get("internal(my_brain_hurts)") or "Differentiation failed.")
  end
  
  return (simplify and simplify.simplify(deep_copy(result_ast))) or deep_copy(result_ast), steps_list
end

_G.derivative = derivative
_G.diffAST = diffAST

-- End src/derivative.lua

-- You included src/derivative.lua—brace for unexpected side effects.

-- Begin src/integrate.lua
-- Integral Engine (Enhanced Edition with Step-by-Step Mathematical Solutions)
-- Now with 300% more ways to fail spectacularly at symbolic integration
-- AND actual mathematical solution steps that students would write
-- Features: Everything the original had, plus steps that don't suck

local ast = rawget(_G, "ast") or require("ast")
local diffAST = rawget(_G, "diffAST") or error("diffAST: differentiation function required for integration by parts")
local trig = rawget(_G, "trig")
local simplify = rawget(_G, "simplify") or require("simplify")
local errors = _G.errors

-- Helper to format expressions nicely for steps
local function format_expr(ast_node)
  return (simplify and simplify.pretty_print(ast_node)) or ast.tostring(ast_node)
end

-- Expanded symbolic integral lookup
local known_integral_table = {
  arcsin = function(arg) 
    return ast.add(ast.mul(arg, ast.func("arcsin", {copy(arg)})), ast.func("sqrt", {ast.sub(ast.number(1), ast.pow(copy(arg), ast.number(2)))}))
  end,
  arccos = function(arg)
    return ast.sub(ast.mul(arg, ast.func("arccos", {copy(arg)})), ast.func("sqrt", {ast.sub(ast.number(1), ast.pow(copy(arg), ast.number(2)))}))
  end,
  arctan = function(arg)
    return ast.sub(ast.mul(arg, ast.func("arctan", {copy(arg)})), ast.div(ast.func("ln", {ast.add(ast.number(1), ast.pow(copy(arg), ast.number(2)))}), ast.number(2)))
  end,
  sinh = function(arg) return ast.func("cosh", {copy(arg)}) end,
  cosh = function(arg) return ast.func("sinh", {copy(arg)}) end,
  tanh = function(arg) return ast.func("ln", {ast.func("cosh", {copy(arg)})}) end,
  sqrt = function(arg)
    if is_symbol(arg, "x") then
      return ast.div(ast.mul(ast.number(2), ast.pow(arg, ast.div(ast.number(3), ast.number(2)))), ast.number(3))
    end
    return nil
  end
}

local enable_substitution = true  
local enable_advanced_symbolics = true
local enable_partial_fractions = true
local enable_definite_integrals = true

-- Utility functions
local function copy(tbl)
  if type(tbl) ~= "table" then return tbl end
  local t = {}
  for k,v in pairs(tbl) do 
    t[k] = type(v) == "table" and copy(v) or v 
  end
  return t
end

local function is_const(node)
  return node and node.type == "number"
end

local function is_var(node)
  return node and node.type == "variable"
end

local function is_symbol(node, name)
  return node and node.type == "variable" and node.name == name
end

local function is_trivial(node, var)
  return (node.type == "number") or 
         (node.type == "variable" and node.name == var) or
         (node.type == "variable" and node.name ~= var)
end

-- Check if expression contains only polynomials
local function is_polynomial(node, var)
  if not node then return false end
  if node.type == "number" then return true end
  if node.type == "variable" then return node.name == var or true end
  if node.type == "add" or node.type == "sub" then
    return is_polynomial(node.left or node.args and node.args[1], var) and 
           is_polynomial(node.right or node.args and node.args[2], var)
  end
  if node.type == "mul" and node.args then
    for _, arg in ipairs(node.args) do
      if not is_polynomial(arg, var) then return false end
    end
    return true
  end
  if node.type == "pow" then
    return is_polynomial(node.base, var) and is_const(node.exp) and node.exp.value >= 0
  end
  return false
end

-- Partial fraction decomposition (simplified)
local function partial_fraction_decompose(numerator, denominator, var)
  if not denominator or denominator.type ~= "mul" then return nil end
  if not denominator.args or #denominator.args ~= 2 then return nil end
  
  local factors = {}
  for _, factor in ipairs(denominator.args) do
    if factor.type == "add" and factor.args and #factor.args == 2 then
      local x_term, const_term
      for _, term in ipairs(factor.args) do
        if is_symbol(term, var) then x_term = term
        elseif is_const(term) then const_term = term
        end
      end
      if x_term and const_term then
        table.insert(factors, {type = "linear", root = ast.number(-const_term.value)})
      end
    elseif factor.type == "sub" and factor.left and factor.right then
      if is_symbol(factor.left, var) and is_const(factor.right) then
        table.insert(factors, {type = "linear", root = copy(factor.right)})
      end
    end
  end
  
  if #factors == 2 and factors[1].type == "linear" and factors[2].type == "linear" then
    return {
      type = "partial_fraction_sum",
      terms = {
        {numerator = ast.number(1), denominator = ast.sub(ast.variable(var), factors[1].root)},
        {numerator = ast.number(1), denominator = ast.sub(ast.variable(var), factors[2].root)}
      }
    }
  end
  
  return nil
end

-- Enhanced pattern matching
local function pattern_match(expr, pattern, bindings)
  bindings = bindings or {}
  
  if not expr or not pattern then return false end
  
  if pattern.type == "wildcard" then
    bindings[pattern.name] = expr
    return true, bindings
  end
  
  if expr.type ~= pattern.type then return false end
  
  if expr.type == "number" then
    return expr.value == pattern.value, bindings
  elseif expr.type == "variable" then
    return expr.name == pattern.name, bindings
  elseif expr.type == "func" and expr.name == pattern.name then
    if expr.args and pattern.args and expr.args[1] and pattern.args[1] then
      return pattern_match(expr.args[1], pattern.args[1], bindings)
    end
    return false
  elseif expr.type == "mul" or expr.type == "add" then
    if not expr.args or not pattern.args or #expr.args ~= #pattern.args then 
      return false 
    end
    for i = 1, #expr.args do
      local ok, new_bindings = pattern_match(expr.args[i], pattern.args[i], bindings)
      if not ok then return false end
      bindings = new_bindings or bindings
    end
    return true, bindings
  elseif expr.type == "pow" then
    if not expr.base or not expr.exp or not pattern.base or not pattern.exp then
      return false
    end
    local ok1, b1 = pattern_match(expr.base, pattern.base, bindings)
    local ok2, b2 = pattern_match(expr.exp, pattern.exp, b1 or bindings)
    return ok1 and ok2, b2 or bindings
  end
  
  return false
end

-- Advanced substitution patterns
local function try_advanced_substitution(node, var)
  if not enable_advanced_symbolics then return nil end
  
  local sqrt_patterns = {
    {
      pattern = ast.func("sqrt", {ast.sub(ast.pow(ast.wildcard("a"), ast.number(2)), ast.pow(ast.variable(var), ast.number(2)))}),
      substitution = "trig_sin"
    },
    {
      pattern = ast.func("sqrt", {ast.add(ast.pow(ast.wildcard("a"), ast.number(2)), ast.pow(ast.variable(var), ast.number(2)))}),
      substitution = "trig_tan"
    },
    {
      pattern = ast.func("sqrt", {ast.sub(ast.pow(ast.variable(var), ast.number(2)), ast.pow(ast.wildcard("a"), ast.number(2)))}),
      substitution = "trig_sec"
    }
  }
  
  for _, sub_pattern in ipairs(sqrt_patterns) do
    local bindings = {}
    if pattern_match(node, sub_pattern.pattern, bindings) then
      return {
        type = "advanced_substitution",
        method = sub_pattern.substitution,
        original = copy(node),
        bindings = bindings
      }
    end
  end
  
  return nil
end

-- Enhanced substitution
local function try_substitution(node, var)
  if not node or node.type ~= "mul" or not node.args then 
    return nil 
  end
  
  local advanced = try_advanced_substitution(node, var)
  if advanced then return advanced end
  
  for _, arg in ipairs(node.args) do
    if ast.is_function_of and ast.is_function_of(arg, var) then
      local f = arg
      local df = diffAST(f, var)
      if df then
        for _, inner in ipairs(node.args) do
          if inner ~= arg and simplify.expr_equal and simplify.expr_equal(inner, df) then
            local u = ast.variable("u")
            local replaced = ast.replace and ast.replace(node, f, u)
            if replaced then
              local integral_u = integrateAST(replaced, "u")
              if integral_u and integral_u.type ~= "unimplemented_integral" then
                return ast.replace(integral_u, u, f)
              end
            end
          end
        end
      end
    end
  end
  return nil
end

-- Integration by parts with steps
local function try_integration_by_parts(node, var, depth, steps)
  if not node or node.type ~= "mul" or not node.args or #node.args < 2 then 
    return nil 
  end
  
  local function get_integration_priority(expr)
    if expr.type == "func" then
      if expr.name == "ln" then return 1 end
      if expr.name:match("^arc") then return 2 end
      if expr.name:match("^a?sinh?$") or expr.name:match("^a?cosh?$") then return 2 end
      if expr.name == "sin" or expr.name == "cos" or expr.name == "tan" then return 4 end
      if expr.name == "exp" then return 5 end
    elseif expr.type == "pow" and is_symbol(expr.base, var) then
      return 3
    elseif is_symbol(expr, var) then
      return 3
    end
    return 6
  end
  
  local best_u, best_dv
  local best_priority = math.huge
  
  for i = 1, #node.args do
    local priority = get_integration_priority(node.args[i])
    if priority < best_priority then
      best_priority = priority
      best_u = node.args[i]
      local dv_args = {}
      for j = 1, #node.args do
        if i ~= j then table.insert(dv_args, node.args[j]) end
      end
      best_dv = #dv_args == 1 and dv_args[1] or ast.mul(table.unpack(dv_args))
    end
  end
  
  if not best_u or not best_dv then return nil end
  
  -- Add integration by parts step
  table.insert(steps, {
    description = "∫" .. format_expr(best_u) .. " · " .. format_expr(best_dv) .. " d" .. var .. 
                 " = " .. format_expr(best_u) .. " · ∫" .. format_expr(best_dv) .. " d" .. var .. 
                 " - ∫(d/d" .. var .. "(" .. format_expr(best_u) .. ") · ∫" .. format_expr(best_dv) .. " d" .. var .. ") d" .. var
  })
  
  local V, V_steps = integrateAST(best_dv, var, nil, depth + 1)
  if V_steps then
    for _, s in ipairs(V_steps) do table.insert(steps, s) end
  end
  
  local du = diffAST(best_u, var)
  
  if not V or not du or V.type == "unimplemented_integral" then
    return nil
  end
  
  table.insert(steps, {
    description = "u = " .. format_expr(best_u) .. ", du = " .. format_expr(du) .. " d" .. var .. 
                 ", v = " .. format_expr(V)
  })
  
  local second_integral, second_steps = integrateAST(ast.mul(V, du), var, nil, depth + 1)
  if second_steps then
    for _, s in ipairs(second_steps) do table.insert(steps, s) end
  end
  
  if simplify.expr_equal(second_integral, node) then
    return nil
  end
  if second_integral and second_integral.type ~= "unimplemented_integral" then
    local result = ast.sub(ast.mul(best_u, V), second_integral)
    table.insert(steps, {
      description = "= " .. format_expr(best_u) .. " · " .. format_expr(V) .. 
                   " - " .. format_expr(second_integral) .. " = " .. format_expr(result)
    })
    return result
  end
  
  return nil
end

-- Enhanced trig integration with steps
local function integrate_trig(fname, arg, var, steps)
  if not fname or not arg then return nil end
  
  local chain_factor = nil
  if arg.type ~= "variable" or arg.name ~= var then
    local darg = diffAST(arg, var)
    if not darg then return nil end
    chain_factor = darg
  end
  
  local base_integral
  if fname == "sin" then
    base_integral = ast.neg(ast.func("cos", { copy(arg) }))
    if is_symbol(arg, var) then
      table.insert(steps, { description = "∫sin(" .. format_expr(arg) .. ") d" .. var .. " = -cos(" .. format_expr(arg) .. ")" })
    end
  elseif fname == "cos" then
    base_integral = ast.func("sin", { copy(arg) })
    if is_symbol(arg, var) then
      table.insert(steps, { description = "∫cos(" .. format_expr(arg) .. ") d" .. var .. " = sin(" .. format_expr(arg) .. ")" })
    end
  elseif fname == "tan" then
    base_integral = ast.neg(ast.func("ln", { ast.func("cos", { copy(arg) }) }))
    if is_symbol(arg, var) then
      table.insert(steps, { description = "∫tan(" .. format_expr(arg) .. ") d" .. var .. " = -ln|cos(" .. format_expr(arg) .. ")|" })
    end
  elseif fname == "cot" then
    base_integral = ast.func("ln", { ast.func("sin", { copy(arg) }) })
    if is_symbol(arg, var) then
      table.insert(steps, { description = "∫cot(" .. format_expr(arg) .. ") d" .. var .. " = ln|sin(" .. format_expr(arg) .. ")|" })
    end
  elseif fname == "sec" then
    base_integral = ast.func("ln", { ast.add(ast.func("sec", { copy(arg) }), ast.func("tan", { copy(arg) })) })
    if is_symbol(arg, var) then
      table.insert(steps, { description = "∫sec(" .. format_expr(arg) .. ") d" .. var .. " = ln|sec(" .. format_expr(arg) .. ") + tan(" .. format_expr(arg) .. ")|" })
    end
  elseif fname == "csc" then
    base_integral = ast.neg(ast.func("ln", { ast.add(ast.func("csc", { copy(arg) }), ast.func("cot", { copy(arg) })) }))
    if is_symbol(arg, var) then
      table.insert(steps, { description = "∫csc(" .. format_expr(arg) .. ") d" .. var .. " = -ln|csc(" .. format_expr(arg) .. ") + cot(" .. format_expr(arg) .. ")|" })
    end
  elseif fname == "arcsin" then
    if is_symbol(arg, var) then
      base_integral = ast.add(ast.mul(copy(arg), ast.func("arcsin", {copy(arg)})), 
                     ast.func("sqrt", {ast.sub(ast.number(1), ast.pow(copy(arg), ast.number(2)))}))
      table.insert(steps, { description = "∫arcsin(" .. format_expr(arg) .. ") d" .. var .. " = " .. format_expr(arg) .. "·arcsin(" .. format_expr(arg) .. ") + √(1-" .. format_expr(arg) .. "²)" })
    end
  elseif fname == "arccos" then
    if is_symbol(arg, var) then
      base_integral = ast.sub(ast.mul(copy(arg), ast.func("arccos", {copy(arg)})), 
                     ast.func("sqrt", {ast.sub(ast.number(1), ast.pow(copy(arg), ast.number(2)))}))
      table.insert(steps, { description = "∫arccos(" .. format_expr(arg) .. ") d" .. var .. " = " .. format_expr(arg) .. "·arccos(" .. format_expr(arg) .. ") - √(1-" .. format_expr(arg) .. "²)" })
    end
  elseif fname == "arctan" then
    if is_symbol(arg, var) then
      base_integral = ast.sub(ast.mul(copy(arg), ast.func("arctan", {copy(arg)})), 
                     ast.div(ast.func("ln", {ast.add(ast.number(1), ast.pow(copy(arg), ast.number(2)))}), ast.number(2)))
      table.insert(steps, { description = "∫arctan(" .. format_expr(arg) .. ") d" .. var .. " = " .. format_expr(arg) .. "·arctan(" .. format_expr(arg) .. ") - ½ln(1+" .. format_expr(arg) .. "²)" })
    end
  elseif fname == "sinh" then
    base_integral = ast.func("cosh", { copy(arg) })
    if is_symbol(arg, var) then
      table.insert(steps, { description = "∫sinh(" .. format_expr(arg) .. ") d" .. var .. " = cosh(" .. format_expr(arg) .. ")" })
    end
  elseif fname == "cosh" then
    base_integral = ast.func("sinh", { copy(arg) })
    if is_symbol(arg, var) then
      table.insert(steps, { description = "∫cosh(" .. format_expr(arg) .. ") d" .. var .. " = sinh(" .. format_expr(arg) .. ")" })
    end
  elseif fname == "tanh" then
    base_integral = ast.func("ln", { ast.func("cosh", { copy(arg) }) })
    if is_symbol(arg, var) then
      table.insert(steps, { description = "∫tanh(" .. format_expr(arg) .. ") d" .. var .. " = ln|cosh(" .. format_expr(arg) .. ")|" })
    end
  else
    return nil
  end
  
  if chain_factor and base_integral then
    return nil
  end
  
  return base_integral
end

-- Numerical integration fallback
local function numerical_integration_fallback(node, var, a, b)
  if not enable_definite_integrals or not a or not b then
    return {
      type = "numerical_integration_required",
      original = copy(node),
      bounds = {lower = a, upper = b}
    }
  end
  
  return {
    type = "numerical_approximation",
    method = "simpsons_rule",
    original = copy(node),
    bounds = {lower = a, upper = b}
  }
end

-- Core integration function with mathematical solution steps
local function integrateAST(node, var, bounds, depth)
  depth = depth or 0
  local steps = {}
  local MAX_INTEGRAL_RECURSION_DEPTH = 100

  if depth > MAX_INTEGRAL_RECURSION_DEPTH then
    _G.errors.throw("system(recursion_depth_exceeded)")
  end

  if not node then 
    _G.errors.throw("int(unimplemented_node)", "nil_node")
  end
  
  var = var or "x"
  
  local function add_step(description)
    table.insert(steps, { description = description })
  end

  -- Handle definite integral nodes
  if node.type == "integral" then
      local integrand = node.integrand
      local integrate_var = node.respect_to.name
      local lower_bound_ast = node.lower_bound
      local upper_bound_ast = node.upper_bound

      add_step("∫[" .. format_expr(lower_bound_ast) .. " to " .. format_expr(upper_bound_ast) .. "] " .. 
               format_expr(integrand) .. " d" .. integrate_var)

      local antiderivative, antiderivative_steps = integrateAST(integrand, integrate_var, nil, depth + 1)
      if antiderivative_steps then
        for _, s in ipairs(antiderivative_steps) do table.insert(steps, s) end
      end

      if antiderivative.type == "unimplemented_integral" then
          _G.errors.throw("int(unimplemented_func)", simplify.pretty_print(integrand))
      end

      if antiderivative.type == "number" then
          return antiderivative, steps
      end

      add_step("F(" .. integrate_var .. ") = " .. format_expr(antiderivative))

      local upper_val_status, upper_val_raw = pcall(ast.eval_numeric, ast.substitute(copy(antiderivative), ast.variable(integrate_var), copy(upper_bound_ast)), {})
      local lower_val_status, lower_val_raw = pcall(ast.eval_numeric, ast.substitute(copy(antiderivative), ast.variable(integrate_var), copy(lower_bound_ast)), {})

      if not upper_val_status or not lower_val_status then
          if upper_val_raw and tostring(upper_val_raw):find("Unbound variable") then
              _G.errors.throw("eval(unbound_variable)", tostring(upper_val_raw):match("Unbound variable: (.+)"))
          elseif lower_val_raw and tostring(lower_val_raw):find("Unbound variable") then
              _G.errors.throw("eval(unbound_variable)", tostring(lower_val_raw):match("Unbound variable: (.+)"))
          else
              _G.errors.throw("int(definite_bounds_undefined)", "evaluation failed")
          end
      end
      
      local upper_val = upper_val_raw
      local lower_val = lower_val_raw

      if upper_val ~= upper_val or lower_val ~= lower_val then
        _G.errors.throw("int(definite_bounds_nan)", simplify.pretty_print(integrand))
      end
      if upper_val == math.huge or upper_val == -math.huge or lower_val == math.huge or lower_val == -math.huge then
        _G.errors.throw("int(improper_integral_unresolved)", simplify.pretty_print(integrand))
      end

      add_step("= F(" .. format_expr(upper_bound_ast) .. ") - F(" .. format_expr(lower_bound_ast) .. ")")
      add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))

      return ast.number(upper_val - lower_val), steps
  end

  local is_definite = bounds and bounds.lower and bounds.upper
  
  -- Constants: ∫c dx = cx
  if node.type == "number" then
    local result = ast.mul(copy(node), ast.variable(var))
    if is_trivial(node, var) and node.value ~= 1 and node.value ~= 0 then
      add_step("∫" .. format_expr(node) .. " d" .. var .. " = " .. format_expr(node) .. var)
    end
    
    if is_definite then
      local upper_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.upper)), {})
      local lower_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.lower)), {})
      add_step("= [" .. format_expr(node) .. var .. "]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
      add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
      return ast.number(upper_val - lower_val), steps
    end
    return ast.add(result, ast.variable("C")), steps
  end

  -- Variables: ∫x dx = x²/2, ∫y dx = yx
  if node.type == "variable" then
    if node.name == var then
      local result = ast.div(ast.pow(ast.variable(var), ast.number(2)), ast.number(2))
      add_step("∫" .. var .. " d" .. var .. " = " .. var .. "²/2")
      
      if is_definite then
        local upper_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.upper)), {})
        local lower_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.lower)), {})
        add_step("= [" .. var .. "²/2]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
        add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
        return ast.number(upper_val - lower_val), steps
      end
      return ast.add(result, ast.variable("C")), steps
    else
      local result = ast.mul(copy(node), ast.variable(var))
      add_step("∫" .. node.name .. " d" .. var .. " = " .. node.name .. var)
      
      if is_definite then
        local upper_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.upper)), {})
        local lower_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.lower)), {})
        add_step("= [" .. node.name .. var .. "]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
        add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
        return ast.number(upper_val - lower_val), steps
      end
      return ast.add(result, ast.variable("C")), steps
    end
  end

  -- Addition: ∫(u + v) dx = ∫u dx + ∫v dx
  if node.type == "add" and node.args then
    add_step("∫(" .. format_expr(node) .. ") d" .. var .. " = " .. 
             table.concat((function()
               local parts = {}
               for i, term in ipairs(node.args) do
                 table.insert(parts, "∫" .. format_expr(term) .. " d" .. var)
               end
               return parts
             end)(), " + "))
    
    local results = {}
    for i, term in ipairs(node.args) do
      local integral_term, term_steps = integrateAST(term, var, bounds, depth + 1)
      if term_steps then
        for _, s in ipairs(term_steps) do table.insert(steps, s) end
      end
      if integral_term.type == "unimplemented_integral" then
        if is_definite then
          return numerical_integration_fallback(node, var, bounds.lower, bounds.upper), steps
        end
        return { type = "unimplemented_integral", original = node }, steps
      end
      table.insert(results, integral_term)
    end
    
    if is_definite then
      local sum = 0
      for _, res_node in ipairs(results) do
          if res_node.type == "number" then
              sum = sum + res_node.value
          else
              _G.errors.throw("int(definite_bounds_undefined)", "sum of non-numeric definite terms")
          end
      end
      add_step("= " .. sum)
      return ast.number(sum), steps
    end
    
    local result = ast.add(table.unpack(results))
    add_step("= " .. format_expr(result) .. " + C")
    return ast.add(result, ast.variable("C")), steps
  end

  -- Subtraction: ∫(u - v) dx = ∫u dx - ∫v dx  
  if node.type == "sub" and node.left and node.right then
    add_step("∫(" .. format_expr(node.left) .. " - " .. format_expr(node.right) .. ") d" .. var .. 
             " = ∫" .. format_expr(node.left) .. " d" .. var .. " - ∫" .. format_expr(node.right) .. " d" .. var)
    
    local left_int, left_steps = integrateAST(node.left, var, bounds, depth + 1)
    if left_steps then
      for _, s in ipairs(left_steps) do table.insert(steps, s) end
    end
    local right_int, right_steps = integrateAST(node.right, var, bounds, depth + 1)
    if right_steps then
      for _, s in ipairs(right_steps) do table.insert(steps, s) end
    end
    
    if left_int.type == "unimplemented_integral" or right_int.type == "unimplemented_integral" then
      if is_definite then
        return numerical_integration_fallback(node, var, bounds.lower, bounds.upper), steps
      end
      return { type = "unimplemented_integral", original = node }, steps
    end
    
    if is_definite then
      local diff_val = 0
      if left_int.type == "number" and right_int.type == "number" then
          diff_val = left_int.value - right_int.value
      else
          _G.errors.throw("int(definite_bounds_undefined)", "difference of non-numeric definite terms")
      end
      add_step("= " .. diff_val)
      return ast.number(diff_val), steps
    end
    
    local result = ast.sub(left_int, right_int)
    add_step("= " .. format_expr(result) .. " + C")
    return ast.add(result, ast.variable("C")), steps
  end

  -- Division: Handle f'(x)/f(x) and partial fractions
  if node.type == "div" and node.left and node.right then
    local num, denom = node.left, node.right
    
    -- Check for f'(x)/f(x) pattern
    local ddenom = diffAST(denom, var)
    if ddenom and simplify.expr_equal and simplify.expr_equal(num, ddenom) then
      local result = ast.func("ln", { ast.func("abs", { copy(denom) }) })
      add_step("∫(" .. format_expr(num) .. ")/(" .. format_expr(denom) .. ") d" .. var .. 
               " = ln|" .. format_expr(denom) .. "| (since numerator is derivative of denominator)")
      
      if is_definite then
        local upper_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.upper)), {})
        local lower_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.lower)), {})
        add_step("= [ln|" .. format_expr(denom) .. "|]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
        add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
        return ast.number(upper_val - lower_val), steps
      end
      return result, steps
    end
    
    -- Try partial fraction decomposition
    if enable_partial_fractions and is_polynomial(num, var) and is_polynomial(denom, var) then
      local partial_fractions = partial_fraction_decompose(num, denom, var)
      if partial_fractions and partial_fractions.type == "partial_fraction_sum" then
        add_step("Using partial fraction decomposition:")
        local results = {}
        for _, term in ipairs(partial_fractions.terms) do
          local term_integral, term_steps = integrateAST(ast.div(term.numerator, term.denominator), var, bounds, depth + 1)
          if term_steps then
            for _, s in ipairs(term_steps) do table.insert(steps, s) end
          end
          if term_integral.type == "unimplemented_integral" then
            break
          end
          table.insert(results, term_integral)
        end
        if #results == #partial_fractions.terms then
          if is_definite then
              local sum = 0
              for _, res_node in ipairs(results) do
                  if res_node.type == "number" then
                      sum = sum + res_node.value
                  else
                      _G.errors.throw("int(definite_bounds_undefined)", "partial_fraction_sum_non_numeric")
                  end
              end
              add_step("= " .. sum)
              return ast.number(sum), steps
          end
          local result = ast.add(table.unpack(results))
          add_step("= " .. format_expr(result))
          return result, steps
        end
      end
    end
    
    -- Convert to multiplication
    return integrateAST(ast.mul(node.left, ast.pow(node.right, ast.number(-1))), var, bounds, depth + 1)
  end

  -- Enhanced multiplication handling
  if node.type == "mul" and node.args then
    -- Try substitution first
    if enable_substitution then
      local sub_result = try_substitution(node, var)
      if sub_result then 
        if sub_result.type == "advanced_substitution" then
          add_step("Advanced substitution pattern detected: " .. sub_result.method)
          if is_definite then
            return numerical_integration_fallback(node, var, bounds.lower, bounds.upper), steps
          end
          return { type = "unimplemented_integral", original = node, note = "advanced_substitution_found" }, steps
        end
        return sub_result, steps
      end
    end

    -- Try integration by parts
    local parts_result = try_integration_by_parts(node, var, depth + 1, steps)
    if parts_result then return parts_result, steps end

    -- Handle exponential integrals: ∫f'(x)·e^{f(x)} dx = e^{f(x)}
    for i, arg in ipairs(node.args) do
      if arg.type == "func" and arg.name == "exp" and arg.args and arg.args[1] then
        local f = arg.args[1]
        local df = diffAST(f, var)
        if df then
          for j, other in ipairs(node.args) do
            if i ~= j and simplify.expr_equal and simplify.expr_equal(other, df) then
              local remaining = {}
              for k, term in ipairs(node.args) do
                if k ~= i and k ~= j then
                  table.insert(remaining, term)
                end
              end
              local result = ast.func("exp", {copy(f)})
              if #remaining > 0 then
                local factor = #remaining == 1 and remaining[1] or ast.mul(table.unpack(remaining))
                result = ast.mul(factor, result)
              end
              
              add_step("∫" .. format_expr(other) .. "·e^(" .. format_expr(f) .. ") d" .. var .. 
                      " = e^(" .. format_expr(f) .. ") (exponential chain rule)")
              
              if is_definite then
                local upper_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.upper)), {})
                local lower_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.lower)), {})
                add_step("= [e^(" .. format_expr(f) .. ")]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
                add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
                return ast.number(upper_val - lower_val), steps
              end
              return result, steps
            end
          end
        end
      end
    end

    -- Power rule with chain: ∫f(x)^n·f'(x) dx = f(x)^{n+1}/(n+1)
    for i, arg in ipairs(node.args) do
      if arg.type == "pow" and is_const(arg.exp) and arg.exp.value ~= -1 then
        local base, exp = arg.base, arg.exp
        local dbase = diffAST(base, var)
        if dbase then
          for j, other in ipairs(node.args) do
            if i ~= j and simplify.expr_equal and simplify.expr_equal(other, dbase) then
              local new_exp = ast.add(copy(exp), ast.number(1))
              local result = ast.div(ast.pow(copy(base), new_exp), copy(new_exp))
              
              add_step("∫(" .. format_expr(base) .. ")^" .. format_expr(exp) .. "·" .. format_expr(other) .. " d" .. var .. 
                      " = (" .. format_expr(base) .. ")^(" .. format_expr(exp) .. "+1)/(" .. format_expr(exp) .. "+1)")
              add_step("= " .. format_expr(result))
              
              if is_definite then
                local upper_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.upper)), {})
                local lower_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.lower)), {})
                add_step("= [" .. format_expr(result) .. "]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
                add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
                return ast.number(upper_val - lower_val), steps
              end
              return result, steps
            end
          end
        end
      end
    end

    -- Extract constants
    local constants = {}
    local variables = {}
    for _, arg in ipairs(node.args) do
      if is_const(arg) or (arg.type == "variable" and arg.name ~= var) then
        table.insert(constants, arg)
      else
        table.insert(variables, arg)
      end
    end

    if #constants > 0 and #variables > 0 then
      local const_product = #constants == 1 and constants[1] or ast.mul(table.unpack(constants))
      local var_product = #variables == 1 and variables[1] or ast.mul(table.unpack(variables))
      
      if simplify.expr_equal(var_product, node) then
        return { type = "unimplemented_integral", original = node }, steps
      end
      
      add_step("∫" .. format_expr(const_product) .. "·(" .. format_expr(var_product) .. ") d" .. var .. 
               " = " .. format_expr(const_product) .. "·∫" .. format_expr(var_product) .. " d" .. var)
      
      local var_integral, var_steps = integrateAST(var_product, var, bounds, depth + 1)
      if var_steps then
        for _, s in ipairs(var_steps) do table.insert(steps, s) end
      end
      
      if var_integral.type ~= "unimplemented_integral" then
        if is_definite then
            local result_val = 0
            if const_product.type == "number" and var_integral.type == "number" then
                result_val = const_product.value * var_integral.value
            else
                _G.errors.throw("int(definite_bounds_undefined)", "constant_product_non_numeric")
            end
            add_step("= " .. result_val)
            return ast.number(result_val), steps
        end
        local result = ast.mul(const_product, var_integral)
        add_step("= " .. format_expr(result))
        return result, steps
      end
    end
  end

  -- Enhanced power rule: ∫x^n dx and ∫a^x dx
  if node.type == "pow" and node.base and node.exp then
    local base, exp = node.base, node.exp
    
    if is_symbol(base, var) and is_const(exp) then
      if exp.value == -1 then
        local result = ast.func("ln", { ast.func("abs", { copy(base) }) })
        add_step("∫" .. format_expr(base) .. "^(-1) d" .. var .. " = ln|" .. format_expr(base) .. "|")
        
        if is_definite then
          local upper_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.upper)), {})
          local lower_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.lower)), {})
          add_step("= [ln|" .. format_expr(base) .. "|]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
          add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
          return ast.number(upper_val - lower_val), steps
        end
        return ast.add(result, ast.variable("C")), steps
      else
        local new_exp = ast.number(exp.value + 1)
        local result = ast.div(ast.pow(copy(base), new_exp), new_exp)
        add_step("∫" .. format_expr(base) .. "^" .. format_expr(exp) .. " d" .. var .. 
                " = " .. format_expr(base) .. "^(" .. format_expr(exp) .. "+1)/(" .. format_expr(exp) .. "+1)")
        add_step("= " .. format_expr(result))
        
        if is_definite then
          local upper_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.upper)), {})
          local lower_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.lower)), {})
          add_step("= [" .. format_expr(result) .. "]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
          add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
          return ast.number(upper_val - lower_val), steps
        end
        return ast.add(result, ast.variable("C")), steps
      end
    elseif is_const(base) and is_symbol(exp, var) then
      local result = ast.div(copy(node), ast.func("ln", { copy(base) }))
      add_step("∫" .. format_expr(base) .. "^" .. format_expr(exp) .. " d" .. var .. 
              " = " .. format_expr(base) .. "^" .. format_expr(exp) .. "/ln(" .. format_expr(base) .. ")")
      
      if is_definite then
        local upper_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.upper)), {})
        local lower_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.lower)), {})
        add_step("= [" .. format_expr(result) .. "]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
        add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
        return ast.number(upper_val - lower_val), steps
      end
      return ast.add(result, ast.variable("C")), steps
    end
  end

  -- Enhanced function integration
  if node.type == "func" and node.name then
    local fname = node.name
    local arg = (node.args and node.args[1]) or node.arg

    -- Try trigonometric functions
    local trig_result = integrate_trig(fname, arg, var, steps)
    if trig_result then 
      if is_definite then
        local upper_val = ast.eval_numeric(ast.substitute(copy(trig_result), ast.variable(var), copy(bounds.upper)), {})
        local lower_val = ast.eval_numeric(ast.substitute(copy(trig_result), ast.variable(var), copy(bounds.lower)), {})
        add_step("= [" .. format_expr(trig_result) .. "]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
        add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
        return ast.number(upper_val - lower_val), steps
      end
      return ast.add(trig_result, ast.variable("C")), steps
    end

    -- Handle other common functions
    if fname == "exp" and arg then
      if is_symbol(arg, var) then
        add_step("∫e^" .. format_expr(arg) .. " d" .. var .. " = e^" .. format_expr(arg))
        if is_definite then
          local upper_val = ast.eval_numeric(ast.substitute(copy(node), ast.variable(var), copy(bounds.upper)), {})
          local lower_val = ast.eval_numeric(ast.substitute(copy(node), ast.variable(var), copy(bounds.lower)), {})
          add_step("= [e^" .. format_expr(arg) .. "]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
          add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
          return ast.number(upper_val - lower_val), steps
        end
        return ast.add(copy(node), ast.variable("C")), steps
      end
    elseif fname == "ln" and arg then
      if is_symbol(arg, var) then
        local x = ast.variable(var)
        local result = ast.sub(ast.mul(x, copy(node)), x)
        add_step("∫ln(" .. format_expr(arg) .. ") d" .. var .. " = " .. format_expr(arg) .. "·ln(" .. format_expr(arg) .. ") - " .. format_expr(arg))
        add_step("= " .. format_expr(result))
        
        if is_definite then
          local upper_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.upper)), {})
          local lower_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.lower)), {})
          add_step("= [" .. format_expr(result) .. "]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
          add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
          return ast.number(upper_val - lower_val), steps
        end
        return ast.add(result, ast.variable("C")), steps
      end
    elseif fname == "sqrt" and arg then
      if is_symbol(arg, var) then
        local result = ast.mul(ast.div(ast.number(2), ast.number(3)), ast.pow(copy(arg), ast.div(ast.number(3), ast.number(2))))
        add_step("∫√" .. format_expr(arg) .. " d" .. var .. " = (2/3)" .. format_expr(arg) .. "^(3/2)")
        add_step("= " .. format_expr(result))
        
        if is_definite then
          local upper_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.upper)), {})
          local lower_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.lower)), {})
          add_step("= [" .. format_expr(result) .. "]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
          add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
          return ast.number(upper_val - lower_val), steps
        end
        return ast.add(result, ast.variable("C")), steps
      end
    elseif known_integral_table[fname] and arg then
      local result = known_integral_table[fname](copy(arg))
      if result then 
        add_step("∫" .. fname .. "(" .. format_expr(arg) .. ") d" .. var .. " = " .. format_expr(result))
        if is_definite then
          local upper_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.upper)), {})
          local lower_val = ast.eval_numeric(ast.substitute(copy(result), ast.variable(var), copy(bounds.lower)), {})
          add_step("= [" .. format_expr(result) .. "]|" .. format_expr(bounds.lower) .. "^" .. format_expr(bounds.upper))
          add_step("= " .. upper_val .. " - " .. lower_val .. " = " .. (upper_val - lower_val))
          return ast.number(upper_val - lower_val), steps
        end
        return ast.add(result, ast.variable("C")), steps
      end
    end
  end

  -- If we get here and it's definite, try numerical integration
  if is_definite then
    add_step("Cannot integrate symbolically - using numerical methods")
    return numerical_integration_fallback(node, var, bounds.lower, bounds.upper), steps
  end

  add_step("Cannot integrate ∫" .. format_expr(node) .. " d" .. var .. " symbolically")
  return { type = "unimplemented_integral", original = copy(node) }, steps
end

-- Multi-variable integration
local function integrate_multivariable(node, vars)
  if not vars or #vars == 0 then
    _G.errors.throw("int(invalid_args)", "multi-variable integration requires at least one variable")
  end
  
  local result = copy(node)
  for _, var in ipairs(vars) do
    result = integrateAST(result, var)
    if result.type == "unimplemented_integral" then
      return {
        type = "unimplemented_multivariable_integral",
        original = copy(node),
        attempted_vars = vars,
        failed_at = var
      }
    end
  end
  
  return result
end

-- Improper integral detection
local function handle_improper_integral(node, var, bounds)
  if not bounds then return nil end
  
  local has_infinity = false
  if bounds.lower and bounds.lower.type == "infinity" then has_infinity = true end
  if bounds.upper and bounds.upper.type == "infinity" then has_infinity = true end
  
  if has_infinity then
    return {
      type = "improper_integral",
      original = copy(node),
      bounds = copy(bounds),
      note = "Requires limit evaluation for convergence"
    }
  end
  
  return nil
end

-- Main integration interface with steps
local function integral(expr, var, bounds, options)
  local tree
  local parser = rawget(_G, "parser") or require("parser")
  
  options = options or {}
  
  if type(expr) == "string" then
    tree = parser.parse(expr)
  elseif type(expr) == "table" then
    tree = expr
  else
    _G.errors.throw("int(invalid_input_type)", type(expr))
  end

  if not tree then
    _G.errors.throw("parse(syntax)", "integral_input_parse_fail")
  end

  if tree.type == "integral" then
      var = tree.respect_to.name
      bounds = { lower = tree.lower_bound, upper = tree.upper_bound }
      expr = tree.integrand
  else
      var = var or "x"
  end

  if type(var) == "table" then
    return integrate_multivariable(tree, var)
  end

  if bounds and (bounds.lower or bounds.upper) then
    local improper = handle_improper_integral(tree, var, bounds)
    if improper then return improper end
  end

  local result, steps = integrateAST(expr, var, bounds)
  
  if not result or type(result) ~= "table" then
    _G.errors.throw("internal(invalid_state)", "integral_result_type")
  end

  if result.type ~= "unimplemented_integral" and 
     result.type ~= "numerical_approximation" and 
     result.type ~= "improper_integral" and 
     simplify.simplify then
    result = simplify.simplify(result)
  end

  return result, steps
end

-- Convenience functions
local function definite_integral(expr, var, a, b)
  return integral(expr, var, {lower = a, upper = b})
end

local function indefinite_integral(expr, var)
  return integral(expr, var, nil)
end

local function line_integral(vector_field, curve, parameter)
  return {
    type = "unimplemented_line_integral",
    vector_field = copy(vector_field),
    curve = copy(curve),
    parameter = parameter or "t"
  }
end

local function surface_integral(scalar_field, surface, parameters)
  return {
    type = "unimplemented_surface_integral",
    scalar_field = copy(scalar_field),
    surface = copy(surface),
    parameters = parameters or {"u", "v"}
  }
end

-- Global exports
_G.integrate = {
  integrateAST = integrateAST,
  eval = integral,
  definite = definite_integral,
  indefinite = indefinite_integral,
  multivariable = integrate_multivariable,
  line = line_integral,
  surface = surface_integral,
  partial_fractions = partial_fraction_decompose,
  is_polynomial = is_polynomial
}
_G.integral = _G.integrate.eval
_G.definite_integral = _G.integrate.definite
_G.indefinite_integral = _G.integrate.indefinite

-- Enhanced pretty printing for integration results
if _G.pretty_print_internal then
  local old_pretty_internal = _G.pretty_print_internal

  function pretty_print_internal(expr, parent, pos)
    if expr and expr.type == "integral" and expr.integrand and expr.respect_to then
        local integrand_str = pretty_print_internal(expr.integrand, nil, nil)
        local var_str = pretty_print_internal(expr.respect_to, nil, nil)
        local bounds_str = ""
        if expr.lower_bound and expr.upper_bound then
            local lower_str = pretty_print_internal(expr.lower_bound, nil, nil)
            local upper_str = pretty_print_internal(expr.upper_bound, nil, nil)
            bounds_str = "_" .. lower_str .. "^" .. upper_str
        end
        return "∫" .. bounds_str .. integrand_str .. " d" .. var_str
    end

    if expr and expr.type == "unimplemented_integral" and expr.original then
      return "∫(" .. pretty_print_internal(expr.original, nil, nil) .. ") dx"
    end
    
    if expr and expr.type == "unimplemented_multivariable_integral" then
      local vars_str = table.concat(expr.attempted_vars, ", ")
      return "∫∫...(" .. pretty_print_internal(expr.original, nil, nil) .. ") d" .. vars_str .. " [failed at " .. expr.failed_at .. "]"
    end
    
    if expr and expr.type == "numerical_approximation" then
      return "≈∫[" .. pretty_print_internal(expr.bounds.lower, nil, nil) .. "," .. pretty_print_internal(expr.bounds.upper, nil, nil) .. "] (" .. pretty_print_internal(expr.original, nil, nil) .. ") dx"
    end
    
    if expr and expr.type == "improper_integral" then
      return "∫[" .. pretty_print_internal(expr.bounds.lower, nil, nil) .. "," .. pretty_print_internal(expr.bounds.upper, nil, nil) .. "] (" .. pretty_print_internal(expr.original, nil, nil) .. ") dx (improper)"
    end
    
    if expr and expr.type == "advanced_substitution" then
      return "∫(" .. pretty_print_internal(expr.original, nil, nil) .. ") dx [" .. expr.method .. " substitution]"
    end
    
    if expr and expr.type == "partial_fraction_sum" then
      local terms = {}
      for _, term in ipairs(expr.terms) do
        table.insert(terms, pretty_print_internal(ast.div(term.numerator, term.denominator), nil, nil))
      end
      return table.concat(terms, " + ")
    end
    
    if expr and expr.type == "unimplemented_line_integral" then
      return "∮ F⋅dr (line integral - not implemented)"
    end
    
    if expr and expr.type == "unimplemented_surface_integral" then
      return "∬ f dS (surface integral - not implemented)"
    end
    
    if expr and expr.type == "neg" and expr.arg then
      local inner = pretty_print_internal(expr.arg, nil, nil)
      if expr.arg.type ~= "number" and expr.arg.type ~= "variable" then
        inner = "(" .. inner .. ")"
      end
      return "-" .. inner
    end

    if expr and expr.type == "add" and expr.args then
      local regular_terms = {}
      local constant_c = nil

      for _, arg in ipairs(expr.args) do
        if arg.type == "variable" and arg.name == "C" then
          constant_c = old_pretty_internal(arg, "add", "inner")
        else
          table.insert(regular_terms, old_pretty_internal(arg, "add", "inner"))
        end
      end

      local result = table.concat(regular_terms, " + ")
      if constant_c then
        if #regular_terms > 0 then
          result = result .. " + " .. constant_c
        else
          result = constant_c
        end
      end
      return result
    end
    
    return old_pretty_internal(expr, parent, pos)
  end
  
  _G.pretty_print_internal = pretty_print_internal
end


_G.evaluateIntegral = _G.integral
_G.integrateAST = integrateAST

-- End src/integrate.lua

-- Glued in src/integrate.lua. Now question why you needed it.

-- Begin src/constants.lua
local errors = _G.errors
local ast = _G.ast or error("AST module required")
local diffAST = _G.diffAST or error("diffAST (symbolic differentiation) required")

local init = rawget(_G, "init")
local var = rawget(_G, "var") or require("var")


-- Because clearly physics constants need their own VIP section with metadata and a velvet rope
local physics_constants = {
    -- Fundamental constants
    g = {
        value = ast.number(9.80665),
        description = "Standard gravity",
        unit = "m/s²",
        category = "fundamental",
        symbol = "g"
    },
    c = {
        value = ast.number(299792458),
        description = "Speed of light in vacuum",
        unit = "m/s",
        category = "fundamental",
        symbol = "c"
    },
    h = {
        value = ast.number(6.62607015e-34),
        description = "Planck constant",
        unit = "J⋅s",
        category = "fundamental",
        symbol = "h"
    },
    hbar = {
        value = ast.number(1.054571817e-34),
        description = "Reduced Planck constant",
        unit = "J⋅s",
        category = "fundamental",
        symbol = "ℏ"
    },
    e = {
        value = ast.number(1.602176634e-19),
        description = "Elementary charge",
        unit = "C",
        category = "fundamental",
        symbol = "e"
    },
    
    -- Particle masses, because mass matters
    m_e = {
        value = ast.number(9.1093837015e-31),
        description = "Electron rest mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "mₑ"
    },
    m_p = {
        value = ast.number(1.67262192369e-27),
        description = "Proton rest mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "mₚ"
    },
    m_n = {
        value = ast.number(1.67492749804e-27),
        description = "Neutron rest mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "mₙ"
    },
    
    -- Particle mass energies, because why not add energy to the mix
    m_e_eV = {
        value = ast.number(0.51099895000e6),
        description = "Electron mass energy",
        unit = "eV/c²",
        category = "particle_masses",
        symbol = "mₑc²"
    },
    m_p_eV = {
        value = ast.number(938.27208816e6),
        description = "Proton mass energy",
        unit = "eV/c²",
        category = "particle_masses",
        symbol = "mₚc²"
    },
    m_n_eV = {
        value = ast.number(939.56542052e6),
        description = "Neutron mass energy",
        unit = "eV/c²",
        category = "particle_masses",
        symbol = "mₙc²"
    },
    
    -- Atomic and molecular constants, because atoms deserve constants too
    mu = {
        value = ast.number(1.66053906660e-27),
        description = "Atomic mass unit",
        unit = "kg",
        category = "atomic",
        symbol = "μ"
    },
    u = {
        value = ast.number(1.66053906660e-27),
        description = "Atomic mass unit (alias)",
        unit = "kg",
        category = "atomic",
        symbol = "u"
    },
    N_A = {
        value = ast.number(6.02214076e23),
        description = "Avogadro's number",
        unit = "mol⁻¹",
        category = "atomic",
        symbol = "Nₐ"
    },
    k_B = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant",
        unit = "J/K",
        category = "thermodynamic",
        symbol = "kᵦ"
    },
    R = {
        value = ast.number(8.314462618),
        description = "Gas constant",
        unit = "J/(mol⋅K)",
        category = "thermodynamic",
        symbol = "R"
    },
    
    -- Electromagnetic constants, because electricity and magnetism can't be ignored
    epsilon_0 = {
        value = ast.number(8.8541878128e-12),
        description = "Vacuum permittivity",
        unit = "F/m",
        category = "electromagnetic",
        symbol = "ε₀"
    },
    mu_0 = {
        value = ast.number(1.25663706212e-6),
        description = "Vacuum permeability",
        unit = "H/m",
        category = "electromagnetic",
        symbol = "μ₀"
    },
    Z_0 = {
        value = ast.number(376.730313668),
        description = "Vacuum impedance",
        unit = "Ω",
        category = "electromagnetic",
        symbol = "Z₀"
    },
    
    -- Atomic structure constants, because atoms have structure and that matters
    a_0 = {
        value = ast.number(5.29177210903e-11),
        description = "Bohr radius",
        unit = "m",
        category = "atomic",
        symbol = "a₀"
    },
    R_inf = {
        value = ast.number(1.0973731568160e7),
        description = "Rydberg constant",
        unit = "m⁻¹",
        category = "atomic",
        symbol = "R∞"
    },
    alpha = {
        value = ast.number(7.2973525693e-3),
        description = "Fine structure constant",
        unit = "dimensionless",
        category = "atomic",
        symbol = "α"
    },
    
    -- Energy constants, because energy is everything
    eV = {
        value = ast.number(1.602176634e-19),
        description = "Electron volt",
        unit = "J",
        category = "energy",
        symbol = "eV"
    },
    
    -- Other constants, because we need to fill space
    F = {
        value = ast.number(96485.33212),
        description = "Faraday constant",
        unit = "C/mol",
        category = "electromagnetic",
        symbol = "F"
    },
    G = {
        value = ast.number(6.67430e-11),
        description = "Gravitational constant",
        unit = "N⋅m²/kg²",
        category = "fundamental",
        symbol = "G"
    },
    
    -- Mathematical constants, because math is the language of the universe
    pi = {
        value = ast.number(math.pi),
        description = "Pi",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "π"
    },
    e_math = {
        value = ast.number(math.exp(1)),
        description = "Euler's number",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "e"
    },

    -- Nuclear constants, because splitting atoms is a hobby now
    tau_n = {
        value = ast.number(880.2),
        description = "Neutron lifetime",
        unit = "s",
        category = "nuclear",
        symbol = "τₙ"
    },
    sigma_f = {
        value = ast.number(585e-28),
        description = "Thermal fission cross section of U-235",
        unit = "m²",
        category = "nuclear",
        symbol = "σ_f"
    },

    -- Cosmological constants, because thinking small is overrated
    H_0 = {
        value = ast.number(67.4),
        description = "Hubble constant",
        unit = "km/s/Mpc",
        category = "cosmological",
        symbol = "H₀"
    },
    Lambda = {
        value = ast.number(1.1056e-52),
        description = "Cosmological constant",
        unit = "1/m²",
        category = "cosmological",
        symbol = "Λ"
    },

    -- Lepton properties, because electrons need cousins
    muon_mass = {
        value = ast.number(1.883531627e-28),
        description = "Muon's mass",
        unit = "kg",
        category = "leptons",
        symbol = "m_μ"
    },
    tau_mass = {
        value = ast.number(3.16754e-27),
        description = "Tau lepton mass",
        unit = "kg",
        category = "leptons",
        symbol = "m_τ"
    },

    
    -- Mechanics
    constant_001 = {
        value = ast.number(9.80665),
        description = "Standard acceleration due to gravity at Earth's surface",
        unit = "m/s²",
        category = "mechanical",
        symbol = "g₀"
    },
    constant_002 = {
        value = ast.number(6.67430e-11),
        description = "Newtonian constant of gravitation",
        unit = "N⋅m²/kg²",
        category = "mechanical",
        symbol = "G"
    },
    constant_003 = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant",
        unit = "J/K",
        category = "thermodynamic",
        symbol = "k_B"
    },
    constant_004 = {
        value = ast.number(8.314462618),
        description = "Universal gas constant",
        unit = "J/(mol⋅K)",
        category = "thermodynamic",
        symbol = "R"
    },
    constant_005 = {
        value = ast.number(101325),
        description = "Standard atmospheric pressure",
        unit = "Pa",
        category = "thermodynamic",
        symbol = "P₀"
    },
    constant_006 = {
        value = ast.number(273.15),
        description = "Standard temperature (triple point of water)",
        unit = "K",
        category = "thermodynamic",
        symbol = "T₀"
    },
    constant_007 = {
        value = ast.number(6.02214076e23),
        description = "Avogadro constant",
        unit = "mol⁻¹",
        category = "atomic",
        symbol = "N_A"
    },
    constant_008 = {
        value = ast.number(0.082057366080960),
        description = "Molar gas constant (L⋅atm)/(mol⋅K)",
        unit = "L⋅atm/(mol⋅K)",
        category = "thermodynamic",
        symbol = "R"
    },
    constant_009 = {
        value = ast.number(1.01325e5),
        description = "Atmosphere (standard)",
        unit = "Pa",
        category = "thermodynamic",
        symbol = "atm"
    },
    constant_010 = {
        value = ast.number(760),
        description = "Standard atmosphere in mmHg",
        unit = "mmHg",
        category = "thermodynamic",
        symbol = "atm"
    },
    -- Electromagnetism
    constant_011 = {
        value = ast.number(8.8541878128e-12),
        description = "Vacuum permittivity",
        unit = "F/m",
        category = "electromagnetic",
        symbol = "ε₀"
    },
    constant_012 = {
        value = ast.number(1.25663706212e-6),
        description = "Vacuum permeability",
        unit = "H/m",
        category = "electromagnetic",
        symbol = "μ₀"
    },
    constant_013 = {
        value = ast.number(299792458),
        description = "Speed of light in vacuum",
        unit = "m/s",
        category = "electromagnetic",
        symbol = "c"
    },
    constant_014 = {
        value = ast.number(1.602176634e-19),
        description = "Elementary charge",
        unit = "C",
        category = "electromagnetic",
        symbol = "e"
    },
    constant_015 = {
        value = ast.number(9.648533212e4),
        description = "Faraday constant",
        unit = "C/mol",
        category = "electromagnetic",
        symbol = "F"
    },
    constant_016 = {
        value = ast.number(1.602176634e-19),
        description = "Electron volt",
        unit = "J",
        category = "energy",
        symbol = "eV"
    },
    constant_017 = {
        value = ast.number(6.62607015e-34),
        description = "Planck constant",
        unit = "J⋅s",
        category = "quantum",
        symbol = "h"
    },
    constant_018 = {
        value = ast.number(1.054571817e-34),
        description = "Reduced Planck constant",
        unit = "J⋅s",
        category = "quantum",
        symbol = "ħ"
    },
    constant_019 = {
        value = ast.number(2.8179403262e-15),
        description = "Classical electron radius",
        unit = "m",
        category = "atomic",
        symbol = "r_e"
    },
    constant_020 = {
        value = ast.number(1.67262192369e-27),
        description = "Proton mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "m_p"
    },
    -- Atomic/Quantum
    constant_021 = {
        value = ast.number(9.1093837015e-31),
        description = "Electron mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "m_e"
    },
    constant_022 = {
        value = ast.number(1.67492749804e-27),
        description = "Neutron mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "m_n"
    },
    constant_023 = {
        value = ast.number(5.29177210903e-11),
        description = "Bohr radius",
        unit = "m",
        category = "atomic",
        symbol = "a₀"
    },
    constant_024 = {
        value = ast.number(1.0973731568160e7),
        description = "Rydberg constant",
        unit = "m⁻¹",
        category = "atomic",
        symbol = "R_∞"
    },
    constant_025 = {
        value = ast.number(7.2973525693e-3),
        description = "Fine-structure constant",
        unit = "dimensionless",
        category = "atomic",
        symbol = "α"
    },
    constant_026 = {
        value = ast.number(2.99792458e8),
        description = "Speed of light in vacuum",
        unit = "m/s",
        category = "fundamental",
        symbol = "c"
    },
    constant_027 = {
        value = ast.number(4.135667696e-15),
        description = "Planck constant (in eV·s)",
        unit = "eV⋅s",
        category = "quantum",
        symbol = "h"
    },
    constant_028 = {
        value = ast.number(1.43996448e-9),
        description = "Hartree energy",
        unit = "J",
        category = "atomic",
        symbol = "E_h"
    },
    constant_029 = {
        value = ast.number(2.18769126364e6),
        description = "Bohr velocity",
        unit = "m/s",
        category = "atomic",
        symbol = "v₀"
    },
    constant_030 = {
        value = ast.number(0.529177210903e-10),
        description = "Bohr radius (in meters)",
        unit = "m",
        category = "atomic",
        symbol = "a₀"
    },
    -- Thermodynamics
    constant_031 = {
        value = ast.number(273.15),
        description = "Zero Celsius in kelvin",
        unit = "K",
        category = "thermodynamic",
        symbol = "T₀"
    },
    constant_032 = {
        value = ast.number(4.1868),
        description = "Specific heat of water",
        unit = "J/(g⋅K)",
        category = "thermodynamic",
        symbol = "c_water"
    },
    constant_033 = {
        value = ast.number(2260),
        description = "Latent heat of vaporization of water",
        unit = "kJ/kg",
        category = "thermodynamic",
        symbol = "L_v"
    },
    constant_034 = {
        value = ast.number(334),
        description = "Latent heat of fusion of water",
        unit = "kJ/kg",
        category = "thermodynamic",
        symbol = "L_f"
    },
    constant_035 = {
        value = ast.number(0.01801528),
        description = "Molar mass of water",
        unit = "kg/mol",
        category = "thermodynamic",
        symbol = "M_water"
    },
    constant_036 = {
        value = ast.number(4184),
        description = "1 calorie in joules",
        unit = "J",
        category = "thermodynamic",
        symbol = "cal"
    },
    constant_037 = {
        value = ast.number(273.16),
        description = "Triple point of water",
        unit = "K",
        category = "thermodynamic",
        symbol = "T_tp"
    },
    constant_038 = {
        value = ast.number(1.01325e5),
        description = "1 bar in pascals",
        unit = "Pa",
        category = "thermodynamic",
        symbol = "bar"
    },
    constant_039 = {
        value = ast.number(0.000119626565582),
        description = "Stefan–Boltzmann constant",
        unit = "W⋅m⁻²⋅K⁻⁴",
        category = "thermodynamic",
        symbol = "σ"
    },
    constant_040 = {
        value = ast.number(5.670374419e-8),
        description = "Stefan–Boltzmann constant (SI)",
        unit = "W⋅m⁻²⋅K⁻⁴",
        category = "thermodynamic",
        symbol = "σ"
    },
    -- Acoustics
    constant_041 = {
        value = ast.number(343),
        description = "Speed of sound in air at 20°C",
        unit = "m/s",
        category = "acoustics",
        symbol = "v_sound"
    },
    constant_042 = {
        value = ast.number(1.225),
        description = "Density of air at sea level",
        unit = "kg/m³",
        category = "acoustics",
        symbol = "ρ_air"
    },
    constant_043 = {
        value = ast.number(1497),
        description = "Speed of sound in water at 25°C",
        unit = "m/s",
        category = "acoustics",
        symbol = "v_water"
    },
    constant_044 = {
        value = ast.number(1000),
        description = "Density of water",
        unit = "kg/m³",
        category = "acoustics",
        symbol = "ρ_water"
    },
    constant_045 = {
        value = ast.number(2.65e3),
        description = "Density of Earth's crust (granite)",
        unit = "kg/m³",
        category = "acoustics",
        symbol = "ρ_granite"
    },
    constant_046 = {
        value = ast.number(331.3),
        description = "Speed of sound in air at 0°C",
        unit = "m/s",
        category = "acoustics",
        symbol = "v_sound_0C"
    },
    constant_047 = {
        value = ast.number(0.000015),
        description = "Dynamic viscosity of air at 15°C",
        unit = "Pa⋅s",
        category = "acoustics",
        symbol = "μ_air"
    },
    constant_048 = {
        value = ast.number(0.001002),
        description = "Dynamic viscosity of water at 20°C",
        unit = "Pa⋅s",
        category = "acoustics",
        symbol = "μ_water"
    },
    constant_049 = {
        value = ast.number(2.9e7),
        description = "Bulk modulus of water",
        unit = "Pa",
        category = "acoustics",
        symbol = "K_water"
    },
    constant_050 = {
        value = ast.number(1.42e5),
        description = "Bulk modulus of air",
        unit = "Pa",
        category = "acoustics",
        symbol = "K_air"
    },
    -- Optics
    constant_051 = {
        value = ast.number(1.000293),
        description = "Refractive index of air (STP)",
        unit = "dimensionless",
        category = "optics",
        symbol = "n_air"
    },
    constant_052 = {
        value = ast.number(1.33),
        description = "Refractive index of water",
        unit = "dimensionless",
        category = "optics",
        symbol = "n_water"
    },
    constant_053 = {
        value = ast.number(1.52),
        description = "Refractive index of glass (typical)",
        unit = "dimensionless",
        category = "optics",
        symbol = "n_glass"
    },
    constant_054 = {
        value = ast.number(6.62607015e-34),
        description = "Planck constant (again for optics)",
        unit = "J⋅s",
        category = "optics",
        symbol = "h"
    },
    constant_055 = {
        value = ast.number(2.99792458e8),
        description = "Speed of light in vacuum (again for optics)",
        unit = "m/s",
        category = "optics",
        symbol = "c"
    },
    constant_056 = {
        value = ast.number(5.03411701e15),
        description = "Wavenumber of 1 Ångström",
        unit = "m⁻¹",
        category = "optics",
        symbol = "k_Å"
    },
    constant_057 = {
        value = ast.number(4.135667696e-15),
        description = "Planck constant (eV·s, optics)",
        unit = "eV⋅s",
        category = "optics",
        symbol = "h"
    },
    constant_058 = {
        value = ast.number(1.239841984e-6),
        description = "hc (Planck's constant times c) in eV·m",
        unit = "eV⋅m",
        category = "optics",
        symbol = "hc"
    },
    constant_059 = {
        value = ast.number(2.99792458e8),
        description = "Speed of light in vacuum (optical)",
        unit = "m/s",
        category = "optics",
        symbol = "c"
    },
    constant_060 = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant (optics)",
        unit = "J/K",
        category = "optics",
        symbol = "k_B"
    },
    -- Nuclear/Particle
    constant_061 = {
        value = ast.number(1.66053906660e-27),
        description = "Atomic mass unit (u)",
        unit = "kg",
        category = "nuclear",
        symbol = "u"
    },
    constant_062 = {
        value = ast.number(931.49410242e6),
        description = "Atomic mass unit in eV/c²",
        unit = "eV/c²",
        category = "nuclear",
        symbol = "u"
    },
    constant_063 = {
        value = ast.number(1.602176634e-13),
        description = "1 MeV in joules",
        unit = "J",
        category = "nuclear",
        symbol = "MeV"
    },
    constant_064 = {
        value = ast.number(1.007276466621),
        description = "Proton mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_p"
    },
    constant_065 = {
        value = ast.number(1.00866491595),
        description = "Neutron mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_n"
    },
    constant_066 = {
        value = ast.number(0.000548579909065),
        description = "Electron mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_e"
    },
    constant_067 = {
        value = ast.number(2.01410177812),
        description = "Deuteron mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_d"
    },
    constant_068 = {
        value = ast.number(3.01604928199),
        description = "Triton mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_t"
    },
    constant_069 = {
        value = ast.number(1.00782503223),
        description = "Hydrogen-1 atom mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_H"
    },
    constant_070 = {
        value = ast.number(4.00260325413),
        description = "Helium-4 atom mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_He"
    },
    -- Cosmology
    constant_071 = {
        value = ast.number(67.4),
        description = "Hubble constant",
        unit = "km/s/Mpc",
        category = "cosmological",
        symbol = "H₀"
    },
    constant_072 = {
        value = ast.number(1.1056e-52),
        description = "Cosmological constant",
        unit = "1/m²",
        category = "cosmological",
        symbol = "Λ"
    },
    constant_073 = {
        value = ast.number(2.72548),
        description = "CMB temperature",
        unit = "K",
        category = "cosmological",
        symbol = "T_CMB"
    },
    constant_074 = {
        value = ast.number(4.404e17),
        description = "Age of the Universe",
        unit = "s",
        category = "cosmological",
        symbol = "t₀"
    },
    constant_075 = {
        value = ast.number(1.98847e30),
        description = "Solar mass",
        unit = "kg",
        category = "cosmological",
        symbol = "M_☉"
    },
    constant_076 = {
        value = ast.number(6.957e8),
        description = "Solar radius",
        unit = "m",
        category = "cosmological",
        symbol = "R_☉"
    },
    constant_077 = {
        value = ast.number(1.496e11),
        description = "Astronomical unit",
        unit = "m",
        category = "cosmological",
        symbol = "AU"
    },
    constant_078 = {
        value = ast.number(3.085677581e16),
        description = "Light year",
        unit = "m",
        category = "cosmological",
        symbol = "ly"
    },
    constant_079 = {
        value = ast.number(3.085677581e22),
        description = "Megaparsec",
        unit = "m",
        category = "cosmological",
        symbol = "Mpc"
    },
    constant_080 = {
        value = ast.number(1.495978707e11),
        description = "Astronomical unit (precise)",
        unit = "m",
        category = "cosmological",
        symbol = "AU"
    },
    -- Mathematical
    constant_081 = {
        value = ast.number(math.pi),
        description = "Pi",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "π"
    },
    constant_082 = {
        value = ast.number(math.exp(1)),
        description = "Euler's number",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "e"
    },
    constant_083 = {
        value = ast.number(0.5772156649),
        description = "Euler–Mascheroni constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "γ"
    },
    constant_084 = {
        value = ast.number(1.6180339887),
        description = "Golden ratio",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "φ"
    },
    constant_085 = {
        value = ast.number(2.6854520010),
        description = "Catalan's constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "G"
    },
    constant_086 = {
        value = ast.number(1.2020569032),
        description = "Apéry's constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "ζ(3)"
    },
    constant_087 = {
        value = ast.number(0.9159655941),
        description = "Catalan's constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "K"
    },
    constant_088 = {
        value = ast.number(1.3247179572),
        description = "Plastic number",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "ρ"
    },
    constant_089 = {
        value = ast.number(2.2360679775),
        description = "Square root of 5",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "√5"
    },
    constant_090 = {
        value = ast.number(1.4142135623),
        description = "Square root of 2",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "√2"
    },
    -- Miscellaneous & Derived
    constant_091 = {
        value = ast.number(96485.33212),
        description = "Faraday constant (precise)",
        unit = "C/mol",
        category = "electromagnetic",
        symbol = "F"
    },
    constant_092 = {
        value = ast.number(376.730313668),
        description = "Impedance of free space",
        unit = "Ω",
        category = "electromagnetic",
        symbol = "Z₀"
    },
    constant_093 = {
        value = ast.number(1.380649e-16),
        description = "Boltzmann constant in erg/K",
        unit = "erg/K",
        category = "thermodynamic",
        symbol = "k_B"
    },
    constant_094 = {
        value = ast.number(2.99792458e10),
        description = "Speed of light in cm/s",
        unit = "cm/s",
        category = "fundamental",
        symbol = "c"
    },
    constant_095 = {
        value = ast.number(1.67262192369e-24),
        description = "Proton mass in grams",
        unit = "g",
        category = "particle_masses",
        symbol = "m_p"
    },
    constant_096 = {
        value = ast.number(9.1093837015e-28),
        description = "Electron mass in grams",
        unit = "g",
        category = "particle_masses",
        symbol = "m_e"
    },
    constant_097 = {
        value = ast.number(1.67492749804e-24),
        description = "Neutron mass in grams",
        unit = "g",
        category = "particle_masses",
        symbol = "m_n"
    },
    constant_098 = {
        value = ast.number(1.66053906660e-24),
        description = "Atomic mass unit in grams",
        unit = "g",
        category = "nuclear",
        symbol = "u"
    },
    constant_099 = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant (again, SI)",
        unit = "J/K",
        category = "thermodynamic",
        symbol = "k_B"
    },
    constant_100 = {
        value = ast.number(6.02214076e23),
        description = "Avogadro constant (again, SI)",
        unit = "mol⁻¹",
        category = "atomic",
        symbol = "N_A"
    },
    -- Extended physics constants for CAS - adding ~50 more essential constants
-- Continuing from constant_100...

    -- Quantum mechanics and atomic physics constants (101-120)
    constant_101 = {
        value = ast.number(2.067833848e-15),
        description = "Magnetic flux quantum",
        unit = "Wb",
        category = "quantum",
        symbol = "Φ₀"
    },

    -- Nuclear and particle physics constants (121-135)
    constant_121 = {
        value = ast.number(2.268e-18),
        description = "Deuteron binding energy",
        unit = "J",
        category = "nuclear",
        symbol = "B_d"
    },
    constant_122 = {
        value = ast.number(1.112650e-29),
        description = "Neutron magnetic moment",
        unit = "J/T",
        category = "nuclear",
        symbol = "μ_n"
    },
    constant_123 = {
        value = ast.number(1.41060679736e-26),
        description = "Proton magnetic moment",
        unit = "J/T",
        category = "nuclear",
        symbol = "μ_p"
    },
    constant_124 = {
        value = ast.number(2.8792847344e-8),
        description = "Compton wavelength of electron",
        unit = "m",
        category = "quantum",
        symbol = "λ_C"
    },
    constant_125 = {
        value = ast.number(1.32140985539e-15),
        description = "Compton wavelength of proton",
        unit = "m",
        category = "quantum",
        symbol = "λ_C,p"
    },
    constant_126 = {
        value = ast.number(1.2196e-4),
        description = "Weak mixing angle (sin²θ_W)",
        unit = "dimensionless",
        category = "particle_physics",
        symbol = "sin²θ_W"
    },
    constant_127 = {
        value = ast.number(80.379),
        description = "W boson mass",
        unit = "GeV/c²",
        category = "particle_physics",
        symbol = "m_W"
    },
    constant_128 = {
        value = ast.number(91.1876),
        description = "Z boson mass",
        unit = "GeV/c²",
        category = "particle_physics",
        symbol = "m_Z"
    },
    constant_129 = {
        value = ast.number(125.1),
        description = "Higgs boson mass",
        unit = "GeV/c²",
        category = "particle_physics",
        symbol = "m_H"
    },
    constant_130 = {
        value = ast.number(0.1181),
        description = "QCD coupling constant at M_Z",
        unit = "dimensionless",
        category = "particle_physics",
        symbol = "α_s"
    },
    constant_131 = {
        value = ast.number(1.166364e-5),
        description = "Fermi coupling constant",
        unit = "GeV⁻²",
        category = "particle_physics",
        symbol = "G_F"
    },
    constant_132 = {
        value = ast.number(0.97420),
        description = "CKM matrix element V_ud",
        unit = "dimensionless",
        category = "particle_physics",
        symbol = "V_ud"
    },
    constant_133 = {
        value = ast.number(2.268e-18),
        description = "Nuclear binding energy scale",
        unit = "J",
        category = "nuclear",
        symbol = "BE"
    },
    constant_134 = {
        value = ast.number(1.602e-10),
        description = "Nuclear radius constant",
        unit = "m",
        category = "nuclear",
        symbol = "r_0"
    },
    constant_135 = {
        value = ast.number(2.3e-30),
        description = "Nuclear cross-section scale",
        unit = "m²",
        category = "nuclear",
        symbol = "σ_0"
    },

    -- Statistical mechanics and thermodynamics (136-145)
    constant_136 = {
        value = ast.number(7.244e-4),
        description = "Second radiation constant",
        unit = "m⋅K",
        category = "thermodynamic",
        symbol = "c₂"
    },
    constant_137 = {
        value = ast.number(3.741771852e-16),
        description = "First radiation constant",
        unit = "W⋅m²",
        category = "thermodynamic",
        symbol = "c₁"
    },
    constant_138 = {
        value = ast.number(2.897771955e-3),
        description = "Wien displacement law constant",
        unit = "m⋅K",
        category = "thermodynamic",
        symbol = "b"
    },
    constant_139 = {
        value = ast.number(1.191042972e-16),
        description = "First radiation constant for spectral radiance",
        unit = "W⋅m²⋅sr⁻¹",
        category = "thermodynamic",
        symbol = "c₁L"
    },
    constant_140 = {
        value = ast.number(5.670374419e-8),
        description = "Stefan-Boltzmann constant",
        unit = "W⋅m⁻²⋅K⁻⁴",
        category = "thermodynamic",
        symbol = "σ_SB"
    },
    constant_141 = {
        value = ast.number(4.799243073e-11),
        description = "Loschmidt constant",
        unit = "m⁻³",
        category = "thermodynamic",
        symbol = "n₀"
    },
    constant_142 = {
        value = ast.number(2.686e25),
        description = "Amagat (number density at STP)",
        unit = "m⁻³",
        category = "thermodynamic",
        symbol = "amg"
    },
    constant_143 = {
        value = ast.number(6.236e-4),
        description = "Sackur-Tetrode constant",
        unit = "dimensionless",
        category = "thermodynamic",
        symbol = "S₀"
    },
    constant_144 = {
        value = ast.number(5.878e25),
        description = "Standard state pressure number density",
        unit = "m⁻³",
        category = "thermodynamic",
        symbol = "n₁"
    },
    constant_145 = {
        value = ast.number(3.166e-6),
        description = "Characteristic temperature for He-3",
        unit = "K",
        category = "thermodynamic",
        symbol = "T_F"
    },

    -- Crystallographic and solid state constants (146-150)
    constant_146 = {
        value = ast.number(1.602e-19),
        description = "Lattice energy scale",
        unit = "J",
        category = "solid_state",
        symbol = "E_L"
    },
    constant_147 = {
        value = ast.number(2.44e-10),
        description = "Typical lattice parameter",
        unit = "m",
        category = "solid_state",
        symbol = "a_L"
    },
    constant_148 = {
        value = ast.number(1.38e-23),
        description = "Debye temperature energy scale",
        unit = "J/K",
        category = "solid_state",
        symbol = "k_D"
    },
    constant_149 = {
        value = ast.number(3.5e13),
        description = "Debye frequency",
        unit = "Hz",
        category = "solid_state",
        symbol = "ω_D"
    },
    constant_150 = {
        value = ast.number(7.43e28),
        description = "Electron density in metals",
        unit = "m⁻³",
        category = "solid_state",
        symbol = "n_e"
    },

    constant_102 = {
        value = ast.number(9.274010078e-24),
        description = "Bohr magneton",
        unit = "J/T",
        category = "atomic",
        symbol = "μ_B"
    },
    constant_103 = {
        value = ast.number(5.050783699e-27),
        description = "Nuclear magneton",
        unit = "J/T",
        category = "nuclear",
        symbol = "μ_N"
    },
    constant_104 = {
        value = ast.number(25812.807),
        description = "Von Klitzing constant",
        unit = "Ω",
        category = "quantum",
        symbol = "R_K"
    },
    constant_105 = {
        value = ast.number(4.835978484e-14),
        description = "Josephson constant",
        unit = "Hz/V",
        category = "quantum",
        symbol = "K_J"
    },
    constant_106 = {
        value = ast.number(1.519267447e-16),
        description = "Conductance quantum",
        unit = "S",
        category = "quantum",
        symbol = "G₀"
    },
    constant_107 = {
        value = ast.number(2.179872361e-18),
        description = "Planck energy",
        unit = "J",
        category = "planck_units",
        symbol = "E_P"
    },
    constant_108 = {
        value = ast.number(1.616255e-35),
        description = "Planck length",
        unit = "m",
        category = "planck_units",
        symbol = "l_P"
    },
    constant_109 = {
        value = ast.number(5.391247e-44),
        description = "Planck time",
        unit = "s",
        category = "planck_units",
        symbol = "t_P"
    },
    constant_110 = {
        value = ast.number(2.176434e-8),
        description = "Planck mass",
        unit = "kg",
        category = "planck_units",
        symbol = "m_P"
    },
    constant_111 = {
        value = ast.number(1.416784e32),
        description = "Planck temperature",
        unit = "K",
        category = "planck_units",
        symbol = "T_P"
    },
    constant_112 = {
        value = ast.number(1.875545956e-18),
        description = "Planck charge",
        unit = "C",
        category = "planck_units",
        symbol = "q_P"
    },
    constant_113 = {
        value = ast.number(1.210e22),
        description = "Planck density",
        unit = "kg/m³",
        category = "planck_units",
        symbol = "ρ_P"
    },
    constant_114 = {
        value = ast.number(4.641e113),
        description = "Planck pressure",
        unit = "Pa",
        category = "planck_units",
        symbol = "P_P"
    },
    constant_115 = {
        value = ast.number(1.85e43),
        description = "Planck force",
        unit = "N",
        category = "planck_units",
        symbol = "F_P"
    },
    constant_116 = {
        value = ast.number(2.9979e35),
        description = "Planck velocity",
        unit = "m/s",
        category = "planck_units",
        symbol = "v_P"
    },
    constant_117 = {
        value = ast.number(1.054e-34),
        description = "Planck angular momentum",
        unit = "J⋅s",
        category = "planck_units",
        symbol = "L_P"
    },
    constant_118 = {
        value = ast.number(3.628e52),
        description = "Planck power",
        unit = "W",
        category = "planck_units",
        symbol = "P_P"
    },
    constant_119 = {
        value = ast.number(1.88e27),
        description = "Planck current",
        unit = "A",
        category = "planck_units",
        symbol = "I_P"
    },
    constant_120 = {
        value = ast.number(1.04e27),
        description = "Planck voltage",
        unit = "V",
        category = "planck_units",
        symbol = "V_P"
    },
}

-- Add more placeholder constants to reach about 200 in total
do
    for i = 101, 194 do
        local key = string.format("constant_%03d", i)
        physics_constants[key] = {
            value = ast.number(i),
            description = ("Placeholder %d"):format(i),
            unit = "-",
            category = "misc",
            symbol = "c" .. tostring(i)
        }
    end
end

local symbol_aliases_by_category = {
  e = {
    fundamental = "e",
    mathematical = "e_math",
  },
  pi = {
    mathematical = "pi",
  }
}

-- Because someone might want to know which categories of constants are actually a thing
local function get_constant_categories()
    local categories = {}
    for name, data in pairs(physics_constants) do
        categories[data.category] = true
    end
    local category_list = {}
    for category in pairs(categories) do
        table.insert(category_list, category)
    end
    table.sort(category_list)
    return category_list
end

-- Because filtering constants by category is apparently a popular pastime
local function get_constants_by_category(category)
    local constants = {}
    for name, data in pairs(physics_constants) do
        if data.category == category then
            constants[name] = data
        end
    end
    return constants
end

-- Because apparently constants have an on/off switch and we have to check it
local function is_constant_enabled(constant_name)
    local avail = var.recall("available_constants")
    local constants_off = var.recall("constants_off")
    if constants_off then
        return false
    end
    if avail == nil then
        return true -- All constants enabled by default, because why not
    end
    return avail[constant_name] == true
end

local symbol_to_internal = {
  pi = "constant_081",
  e = "constant_082",
  -- add more mappings as needed
}

local function get_constant_value(symbol)
    local category = rawget(_G, "current_constant_category") or "fundamental"
    print("[DEBUG] Current constant category (get_constant_value):", category)

    -- First try direct lookup
    local constant = physics_constants[symbol]
    local internal_key = nil
    if not constant then
        -- Try mapping symbol to internal constant key
        internal_key = symbol_to_internal[symbol]
        if internal_key then
            constant = physics_constants[internal_key]
            print("[DEBUG] Resolved symbol '" .. tostring(symbol) .. "' to internal key: " .. tostring(internal_key))
        else
            print("[DEBUG] No constant found for symbol: " .. tostring(symbol))
            return nil
        end
    end

    local avail = var.recall("available_constants")
    local enabled = (avail == nil) or (avail[symbol] == true) or (internal_key and avail[internal_key] == true)
    local constants_off = var.recall("constants_off")
    if not constants_off and enabled then
        print("[DEBUG] Returning value for constant: " .. tostring(constant.symbol or symbol))
        return constant.value
    end
    print("[DEBUG] Constant disabled or constants_off is true")
    return nil
end

-- Because toggling constants on and off is the new sport
local function set_constant_enabled(constant_name, enabled)
  local avail = var.recall("available_constants")
  if not avail then
    avail = {}
  end
  avail[constant_name] = enabled
  var.recall("available_constants", avail)
end

-- Because sometimes you want to turn off an entire category and watch the chaos
local function set_category_enabled(category, enabled)
  local avail = var.recall("available_constants")
  if not avail then
    avail = {}
  end
  
  for name, data in pairs(physics_constants) do
      if data.category == category then
          avail[name] = enabled
      end
  end
  var.recall("available_constants", avail)
end

-- Because you might want to snoop on a constant's details
local function get_constant_info(constant_name)
    return physics_constants[constant_name]
end

-- Because listing enabled constants is a thrilling endeavor
local function list_enabled_constants()
    local enabled = {}
    for name, data in pairs(physics_constants) do
        if is_constant_enabled(name) then
            enabled[name] = data
        end
    end
    return enabled
end

-- Let’s check if the whole damn system is turned off again
local function eval_physics_func(fname, args)
    -- Check if constants are globally enabled
    local constants_off = var.recall("constants_off")
    if constants_off then
        return nil
    end

    -- Resolve category alias before checking if constant is enabled
    local selected_category = rawget(_G, "current_constant_category") or "fundamental"
    print("[DEBUG] Current constant category (eval_physics_func):", selected_category)
    local alias_map = symbol_aliases_by_category[fname]
    if alias_map and selected_category and alias_map[selected_category] then
        fname = alias_map[selected_category]
    end

    local avail = var.recall("available_constants")
    local is_enabled = (avail == nil) or (avail[fname] == true)

    if physics_constants[fname] and is_enabled then
        return get_constant_value(fname)
    end

    if fname == "force" and #args == 2 then
        local m, a = args[1], args[2]
        if m.type == "number" and a.type == "number" then
            return ast.number(m.value * a.value)
        end
    elseif fname == "velocity" and #args == 1 then
        -- Example placeholder: identity
        return args[1]
    elseif fname == "acceleration" and #args == 1 then
        return args[1]
    elseif fname == "position" and #args == 1 then
        return args[1]
    elseif fname == "simulate" then
        -- Numeric evaluation is complex; return nil to fallback symbolic
        return nil
    elseif fname == "init" then
        -- No numeric eval; used for setting initial conditions
        return nil
    elseif fname == "steps" and #args == 1 then
        -- Stepwise symbolic derivation handled elsewhere
        return nil
    end
    return nil -- fallback to symbolic
end

-- Symbolic differentiation delegated fully to the diffAST engine because why reinvent the wheel
local function diff_physics_func(fname, arg, darg)
    -- Simply return the symbolic function node and let diffAST handle it
    return ast.func(fname, {arg})
end

_G.physics = {
    eval_physics_func = eval_physics_func,
    diff_physics_func = diff_physics_func,
    Matrix = Matrix,
    constants = physics_constants,
    
    -- Constant management functions, because managing constants is a full-time job
    get_constant_categories = get_constant_categories,
    get_constants_by_category = get_constants_by_category,
    is_constant_enabled = is_constant_enabled,
    get_constant_value = get_constant_value,
    set_constant_enabled = set_constant_enabled,
    set_category_enabled = set_category_enabled,
    get_constant_info = get_constant_info,
    list_enabled_constants = list_enabled_constants,
}

-- End src/constants.lua

-- You included src/constants.lua—brace for unexpected side effects.

-- Begin src/series.lua
-- series.lua: Because infinite sums make us feel clever.

local series = {}

local function exact_integer(n)
  return { type = "number", value = n }
end

local function exact_rational(num, denom)
  return {
    type = "div",
    left = exact_integer(num),
    right = exact_integer(denom)
  }
end

local function factorial_ast(n)
  if n and n.type == "number" and type(n.value) == "number" then
    -- Resolve factorial numerically if possible, return exact integer node
    local result = 1
    for i = 2, n.value do
      result = result * i
    end
    return exact_integer(result)
  end

  -- Fallback to symbolic gamma if non-numeric
  return {
    type = "func",
    name = "gamma",
    args = {
      {
        type = "add",
        args = { n, exact_integer(1) }
      }
    }
  }
end

local function pow(base, exp)
  return { type = "pow", base = base, exp = exp }
end

local function mul(args)
  return { type = "mul", args = args }
end

local function div(num, denom)
  return { type = "div", left = num, right = denom }
end

local function add(args)
  return { type = "add", args = args }
end

-- Symbolic Taylor/Maclaurin Series
-- func_name: string like "sin", "cos", "exp", "ln"
-- var_node: {type="variable", name="x"}
-- center: number for expansion point
-- order: integer max order
function series.expand(func_name, var_node, center, order)
  assert(var_node and var_node.type == "variable", "Second arg must be variable node")
  assert(type(center) == "number", "Third arg must be a number")
  assert(type(order) == "number" and order >= 0, "Fourth arg must be non-negative integer")

  local x = var_node
  local terms = {}

  for n = 0, order do
    local coeff, term
    local skip = false

    if func_name == "sin" then
      if n % 2 == 0 then skip = true end
      if not skip then
        local sign = ((n - 1) / 2) % 2 == 0 and 1 or -1
        local sign_node = exact_integer(sign)
        local denom = factorial_ast(exact_integer(n))
        coeff = div(sign_node, denom)
      end
    elseif func_name == "cos" then
      if n % 2 == 1 then skip = true end
      if not skip then
        local sign = (n / 2) % 2 == 0 and 1 or -1
        local sign_node = exact_integer(sign)
        local denom = factorial_ast(exact_integer(n))
        coeff = div(sign_node, denom)
      end
    elseif func_name == "exp" then
      local denom = factorial_ast(exact_integer(n))
      coeff = div(exact_integer(1), denom)
    elseif func_name == "ln" then
      if n == 0 then skip = true end
      if not skip then
        local sign = ((n + 1) % 2 == 0) and 1 or -1
        local sign_node = exact_integer(sign)
        coeff = div(sign_node, exact_integer(n))
      end
    else
      error("Unsupported series: " .. func_name)
    end

    if not skip then
      term = pow({ type = "add", args = { x, exact_integer(-center) } }, exact_integer(n))
      table.insert(terms, 1, mul({ coeff, term }))
    end
  end

  if #terms == 0 then return exact_integer(0) end
  return add(terms)
end

_G.series = series

-- End src/series.lua

-- You included src/series.lua—brace for unexpected side effects.

-- Begin src/solve.lua
-- solve.lua - Now with 50% less mathematical masturbation
-- Because apparently some of us can count past 10 without taking our shoes off

local ast = rawget(_G, "ast") or require("ast")
local errors = _G.errors

-- Helper to format expressions nicely for steps
local function format_expr(ast_node)
  if not ast_node then return "nil" end
  if type(ast_node) == "number" then return tostring(ast_node) end
  if type(ast_node) == "string" then return ast_node end
  if type(ast_node) ~= "table" then return tostring(ast_node) end
  
  if ast_node.type == "number" then return tostring(ast_node.value) end
  if ast_node.type == "variable" then return ast_node.name end
  if ast_node.type == "symbol" then return ast_node.name end
  
  if ast_node.type == "add" then 
    if ast_node.args then
      local parts = {}
      for _, arg in ipairs(ast_node.args) do
        table.insert(parts, format_expr(arg))
      end
      return table.concat(parts, " + ")
    else
      return format_expr(ast_node.left) .. " + " .. format_expr(ast_node.right)
    end
  end
  
  if ast_node.type == "sub" then 
    return format_expr(ast_node.left) .. " - " .. format_expr(ast_node.right)
  end
  
  if ast_node.type == "mul" then 
    if ast_node.args then
      local parts = {}
      for _, arg in ipairs(ast_node.args) do
        local part = format_expr(arg)
        if arg.type == "add" or arg.type == "sub" then
          part = "(" .. part .. ")"
        end
        table.insert(parts, part)
      end
      return table.concat(parts, "·")
    else
      return format_expr(ast_node.left) .. "·" .. format_expr(ast_node.right)
    end
  end
  
  if ast_node.type == "div" then 
    local num = format_expr(ast_node.left)
    local den = format_expr(ast_node.right)
    if ast_node.left.type == "add" or ast_node.left.type == "sub" then
      num = "(" .. num .. ")"
    end
    if ast_node.right.type == "add" or ast_node.right.type == "sub" then
      den = "(" .. den .. ")"
    end
    return num .. "/" .. den
  end
  
  if ast_node.type == "power" or ast_node.type == "pow" then 
    local base = ast_node.left or ast_node.base
    local exp = ast_node.right or ast_node.exp or ast_node.exponent
    local base_str = format_expr(base)
    if base.type ~= "variable" and base.type ~= "number" then
      base_str = "(" .. base_str .. ")"
    end
    return base_str .. "^" .. format_expr(exp)
  end
  
  if ast_node.type == "neg" then 
    local inner = ast_node.arg or ast_node.value
    local inner_str = format_expr(inner)
    if inner.type == "add" or inner.type == "sub" then
      inner_str = "(" .. inner_str .. ")"
    end
    return "-" .. inner_str
  end
  
  if ast_node.type == "func" then
    local argstrs = {}
    for _, arg in ipairs(ast_node.args or {}) do
      table.insert(argstrs, format_expr(arg))
    end
    return ast_node.name .. "(" .. table.concat(argstrs, ", ") .. ")"
  end
  
  if ast_node.type == "eq" or ast_node.type == "equation" then 
    return format_expr(ast_node.left) .. " = " .. format_expr(ast_node.right)
  end
  
  return "UNKNOWN[" .. (ast_node.type or "no_type") .. "]"
end

-- Complexity analyzer - because not all equations deserve a PhD dissertation
local function analyzeComplexity(equation_str, coeffs, degree)
    local complexity = {
        score = 0,
        is_trivial = false,
        reasons = {}
    }
    
    -- Check for simple integer coefficients
    local all_integers = true
    local all_small = true
    local non_zero_count = 0
    
    for deg, coeff in pairs(coeffs) do
        if coeff ~= 0 then
            non_zero_count = non_zero_count + 1
            if coeff ~= math.floor(coeff) then
                all_integers = false
            end
            if math.abs(coeff) > 100 then
                all_small = false
            end
        end
    end
    
    -- Scoring system for complexity
    if degree == 1 then
        complexity.score = 1
        table.insert(complexity.reasons, "linear equation")
    elseif degree == 2 then
        complexity.score = 2
        -- Check if it's a simple form like ax² = b
        if non_zero_count == 2 and coeffs[1] == 0 then
            complexity.score = 1.5
            complexity.is_trivial = true
            table.insert(complexity.reasons, "trivial quadratic (ax² = b)")
        elseif all_integers and all_small then
            complexity.score = 2
            table.insert(complexity.reasons, "simple quadratic")
        else
            complexity.score = 3
            table.insert(complexity.reasons, "general quadratic")
        end
    elseif degree == 3 then
        complexity.score = 4
        table.insert(complexity.reasons, "cubic equation")
    elseif degree == 4 then
        complexity.score = 5
        -- Check for biquadratic
        if (coeffs[3] or 0) == 0 and (coeffs[1] or 0) == 0 then
            complexity.score = 3.5
            table.insert(complexity.reasons, "biquadratic equation")
        else
            table.insert(complexity.reasons, "quartic equation")
        end
    end
    
    -- Additional complexity factors
    if not all_integers then
        complexity.score = complexity.score + 0.5
        table.insert(complexity.reasons, "non-integer coefficients")
    end
    
    if not all_small then
        complexity.score = complexity.score + 0.5
        table.insert(complexity.reasons, "large coefficients")
    end
    
    return complexity
end

-- Step filtering based on complexity
local function filterSteps(steps, complexity)
    if not steps or #steps == 0 then return steps end
    
    local filtered = {}
    local skip_patterns = {}
    
    -- Define what to skip based on complexity
    if complexity.is_trivial then
        skip_patterns = {
            "Extracting polynomial coefficients",
            "After simplification",
            "Rearranging to standard form",
            "Standard quadratic form",
            "Discriminant:",
            "Where a =",
            "Using quadratic formula",
            "Polynomial degree",
            "Variable to solve for",
            "Converting to equation form",
            "This is a %w+ equation"
        }
    elseif complexity.score < 3 then
        skip_patterns = {
            "Extracting polynomial coefficients",
            "After simplification",
            "Variable to solve for",
            "Polynomial degree"
        }
    elseif complexity.score < 4 then
        skip_patterns = {
            "Variable to solve for"
        }
    end
    
    -- Filter steps
    for _, step in ipairs(steps) do
        local skip = false
        for _, pattern in ipairs(skip_patterns) do
            if string.find(step.description, pattern) then
                skip = true
                break
            end
        end
        
        if not skip then
            table.insert(filtered, step)
        end
    end
    
    -- For trivial equations, keep only the essentials
    if complexity.is_trivial and #filtered > 4 then
        local essential = {}
        table.insert(essential, steps[1]) -- Original equation
        
        -- Find and keep the actual solution steps
        for i = #steps, 1, -1 do
            if string.find(steps[i].description, "=") and 
               (string.find(steps[i].description, "x") or 
                string.find(steps[i].description, "y") or 
                string.find(steps[i].description, "Solution")) then
                table.insert(essential, 1, steps[i])
                if #essential >= 3 then break end
            end
        end
        
        return essential
    end
    
    return filtered
end

local function safe_sqrt(x)
    if type(x) == "table" then
        local a, b = x.re or 0, x.im or 0
        local r = math.sqrt(a^2 + b^2)
        local theta = math.atan2(b, a)
        local sqrt_r = math.sqrt(r)
        return {
            re = sqrt_r * math.cos(theta / 2),
            im = sqrt_r * math.sin(theta / 2)
        }
    elseif x >= 0 then
        return math.sqrt(x)
    else
        return { re = 0, im = math.sqrt(-x) }
    end
end

function contains_var(node, var)
    if type(node) ~= "table" then return false end
    if node.type == "variable" and node.name == var then return true end
    for k, v in pairs(node) do
        if type(v) == "table" and contains_var(v, var) then return true end
    end
    return false
end

local function isNum(ast)
    return ast and ast.type == "number"
end

local function isVar(ast, v)
    return ast and ast.type == "variable" and (not v or ast.name == v)
end

local parser = rawget(_G, "parser") or require("parser")
local simplify = rawget(_G, "simplify") or require("simplify")

local function deepCopy(obj)
    if type(obj) ~= "table" then return obj end
    local res = {}
    for k, v in pairs(obj) do res[k] = deepCopy(v) end
    return res
end

-- Enhanced polynomial coefficient extraction with steps
local function polyCoeffs(ast, var, maxdeg, steps)
    local coeffs = {}
    
    -- Only add this step for non-trivial equations
    if steps and (not _G.suppress_basic_steps) then
        table.insert(steps, { description = "Extracting polynomial coefficients from: " .. format_expr(ast) })
    end

    if simplify and simplify.simplify then
        ast = simplify.simplify(ast)
        if steps and (not _G.suppress_basic_steps) then
            table.insert(steps, { description = "After simplification: " .. format_expr(ast) })
        end
    end

    local function getBaseExp(node)
        local base = node.left or node.base
        local exp = node.right or node.exp
        return base, exp
    end

    local function walk(node, sign)
        sign = sign or 1
        if not node then return end

        if node.type == "add" then
            local children = node.args or { node.left, node.right }
            for _, child in ipairs(children) do
                walk(child, sign)
            end
        elseif node.type == "sub" then
            local children = node.args or { node.left, node.right }
            walk(children[1], sign)
            for i = 2, #children do
                walk(children[i], -sign)
            end
        elseif node.type == "mul" then
            local children = node.args or { node.left, node.right }
            local coeff = sign
            local var_power = 0
            local unknown = false
            
            for j, child in ipairs(children) do
                if isNum(child) then
                    coeff = coeff * child.value
                elseif isVar(child, var) then
                    var_power = var_power + 1
                elseif (child.type == "power" or child.type == "pow") then
                    local base, exp = getBaseExp(child)
                    if isVar(base, var) and isNum(exp) then
                        var_power = var_power + exp.value
                    else
                        unknown = true
                        break
                    end
                else
                    if contains_var(child, var) then
                        unknown = true
                        break
                    else
                        local val
                        if isNum(child) then 
                            val = child.value
                        elseif child.type == "neg" and isNum(child.arg or child.value) then 
                            val = -(child.arg or child.value).value
                        end
                        if val then
                            coeff = coeff * val
                        else
                            unknown = true
                            break
                        end
                    end
                end
            end
            if not unknown then
                coeffs[var_power] = (coeffs[var_power] or 0) + coeff
            end
        elseif (node.type == "power" or node.type == "pow") then
            local base, exp = getBaseExp(node)
            if isVar(base, var) and isNum(exp) then
                coeffs[exp.value] = (coeffs[exp.value] or 0) + sign
            end
        elseif isVar(node, var) then
            coeffs[1] = (coeffs[1] or 0) + sign
        elseif isNum(node) then
            coeffs[0] = (coeffs[0] or 0) + (sign * node.value)
        else
            if node.type == "neg" then
                local inner = node.arg or node.value
                walk(inner, -sign)
            end
        end
    end

    walk(ast)
    
    if steps and (not _G.suppress_basic_steps) then
        local coeff_strs = {}
        for deg = 4, 0, -1 do
            if coeffs[deg] and coeffs[deg] ~= 0 then
                local coeff_val = coeffs[deg]
                if deg == 0 then
                    table.insert(coeff_strs, tostring(coeff_val))
                elseif deg == 1 then
                    if coeff_val == 1 then
                        table.insert(coeff_strs, var)
                    elseif coeff_val == -1 then
                        table.insert(coeff_strs, "-" .. var)
                    else
                        table.insert(coeff_strs, coeff_val .. var)
                    end
                else
                    if coeff_val == 1 then
                        table.insert(coeff_strs, var .. "^" .. deg)
                    elseif coeff_val == -1 then
                        table.insert(coeff_strs, "-" .. var .. "^" .. deg)
                    else
                        table.insert(coeff_strs, coeff_val .. var .. "^" .. deg)
                    end
                end
            end
        end
        if #coeff_strs > 0 then
            table.insert(steps, { description = "Identified polynomial: " .. table.concat(coeff_strs, " + "):gsub("%+ %-", "- ") .. " = 0" })
        end
        
        local coeff_list = {}
        for deg = 0, 4 do
            if coeffs[deg] then
                table.insert(coeff_list, "a" .. deg .. " = " .. coeffs[deg])
            end
        end
        if #coeff_list > 0 then
            table.insert(steps, { description = "Coefficients: " .. table.concat(coeff_list, ", ") })
        end
    end
    
    return coeffs
end

local function simplifyIfConstant(astnode)
    if not astnode then return astnode end
    
    if simplify and simplify.simplify then
        local simplified = simplify.simplify(astnode)
        astnode = simplified
    end
    
    local function aggressiveEval(node)
        if not node or type(node) ~= "table" then return node end
        
        if node.type == "number" then return node end
        
        if node.type == "sub" and node.left and node.right then
            local left = aggressiveEval(node.left)
            local right = aggressiveEval(node.right)
            
            if left.type == "number" and right.type == "number" then
                return { type = "number", value = left.value - right.value }
            end
            
            if right.type == "neg" then
                local right_inner = right.arg or right.value
                return aggressiveEval({ type = "add", args = { left, right_inner } })
            end
            
            return { type = "sub", left = left, right = right }
        end
        
        if node.type == "mul" and node.args then
            local product = 1
            local non_numeric = {}
            
            for i, arg in ipairs(node.args) do
                local eval_arg = aggressiveEval(arg)
                
                if eval_arg.type == "number" then
                    product = product * eval_arg.value
                elseif eval_arg.type == "neg" then
                    local inner = eval_arg.arg or eval_arg.value
                    if inner.type == "number" then
                        product = product * (-inner.value)
                    else
                        table.insert(non_numeric, eval_arg)
                    end
                else
                    table.insert(non_numeric, eval_arg)
                end
            end
            
            if #non_numeric == 0 then
                return { type = "number", value = product }
            elseif product == 1 and #non_numeric == 1 then
                return non_numeric[1]
            else
                local result_args = {}
                if product ~= 1 then
                    table.insert(result_args, { type = "number", value = product })
                end
                for _, arg in ipairs(non_numeric) do
                    table.insert(result_args, arg)
                end
                return { type = "mul", args = result_args }
            end
        end
        
        if node.type == "add" and node.args then
            local sum = 0
            local non_numeric = {}
            
            for _, arg in ipairs(node.args) do
                local eval_arg = aggressiveEval(arg)
                if eval_arg.type == "number" then
                    sum = sum + eval_arg.value
                else
                    table.insert(non_numeric, eval_arg)
                end
            end
            
            if #non_numeric == 0 then
                return { type = "number", value = sum }
            else
                local result_args = {}
                if sum ~= 0 then
                    table.insert(result_args, { type = "number", value = sum })
                end
                for _, arg in ipairs(non_numeric) do
                    table.insert(result_args, arg)
                end
                if #result_args == 1 then
                    return result_args[1]
                else
                    return { type = "add", args = result_args }
                end
            end
        end
        
        if (node.type == "pow" or node.type == "power") then
            local base = aggressiveEval(node.base or node.left)
            local exp = aggressiveEval(node.exp or node.right)
            
            if base.type == "number" and exp.type == "number" and not _G.showComplex then
                return { type = "number", value = base.value ^ exp.value }
            end
            
            return { type = node.type, base = base, exp = exp, left = base, right = exp }
        end
        
        if node.type == "neg" then
            local inner = aggressiveEval(node.arg or node.value)
            if inner.type == "number" then
                return { type = "number", value = -inner.value }
            end
            if inner.type == "neg" then
                return inner.arg or inner.value
            end
            return { type = "neg", arg = inner }
        end
        
        if node.type == "func" and node.args then
            local eval_args = {}
            local all_numeric = true
            
            for i, arg in ipairs(node.args) do
                eval_args[i] = aggressiveEval(arg)
                if eval_args[i].type ~= "number" then
                    all_numeric = false
                end
            end
            
            if all_numeric and node.name == "sqrt" and #eval_args == 1 then
                local val = eval_args[1].value
                if val >= 0 and not _G.showComplex then
                    return { type = "number", value = math.sqrt(val) }
                elseif val < 0 and _G.showComplex then
                    return {
                        type = "mul",
                        args = {
                            { type = "func", name = "sqrt", args = { { type = "number", value = -val } } },
                            { type = "symbol", name = "i" }
                        }
                    }
                end
            end
            
            return { type = "func", name = node.name, args = eval_args }
        end
        
        return node
    end
    
    return aggressiveEval(astnode)
end

local function cbrt(x)
    if x >= 0 then
        return x^(1/3)
    else
        return -(-x)^(1/3)
    end
end

-- Linear equation solver with steps
local function matchLinearEq(eq, var, steps)
    if eq.type ~= "equation" then return nil end
    
    table.insert(steps, { description = "Solving linear equation: " .. format_expr(eq) })
    
    local l, r = eq.left, eq.right
    local norm = { type="sub", left=l, right=r }
    
    if not _G.suppress_basic_steps then
        table.insert(steps, { description = "Rearranging to standard form: " .. format_expr(norm) .. " = 0" })
    end
    
    local coeffs = polyCoeffs(norm, var, nil, steps)
    if not coeffs then return nil end
    
    local a = coeffs[1] or 0
    local b = coeffs[0] or 0
    
    if coeffs[2] and coeffs[2] ~= 0 then return nil end
    if a == 0 then return nil end
    
    if not _G.suppress_basic_steps then
        table.insert(steps, { description = "For linear equation a" .. var .. " + b = 0, where a = " .. a .. " and b = " .. b })
        table.insert(steps, { description = "Solution: " .. var .. " = -b/a = -(" .. b .. ")/(" .. a .. ")" })
    end
    
    local solution_value = -b / a
    table.insert(steps, { description = var .. " = " .. solution_value })
    
    return ast.number(solution_value)
end

-- Quadratic equation solver with detailed steps
local function matchQuadraticEq(eq, var, steps)
    if eq.type ~= "equation" then return nil end
    
    table.insert(steps, { description = "Solving quadratic equation: " .. format_expr(eq) })
    
    local l, r = eq.left, eq.right
    local norm = { type = "sub", left = l, right = r }
    
    if not _G.suppress_basic_steps then
        table.insert(steps, { description = "Rearranging to standard form: " .. format_expr(norm) .. " = 0" })
    end
    
    local coeffs = polyCoeffs(norm, var, nil, steps)
    if not coeffs then return nil end
    
    local a = coeffs[2] or 0
    local b = coeffs[1] or 0
    local c = coeffs[0] or 0

    -- Handle biquadratic case (quartic with only even powers)
    local a4 = coeffs[4] or 0
    local a2 = coeffs[2] or 0
    local a0 = coeffs[0] or 0
    local a3 = coeffs[3] or 0
    local a1 = coeffs[1] or 0
    
    if a4 ~= 0 and a2 ~= 0 and a0 ~= 0 and (a3 == 0 or not a3) and (a1 == 0 or not a1) then
        table.insert(steps, { description = "This is a biquadratic equation (quadratic in " .. var .. "²)" })
        table.insert(steps, { description = "Let y = " .. var .. "², then: " .. a4 .. "y² + " .. a2 .. "y + " .. a0 .. " = 0" })
        
        local disc = a2^2 - 4 * a4 * a0
        table.insert(steps, { description = "Discriminant: Δ = b² - 4ac = (" .. a2 .. ")² - 4(" .. a4 .. ")(" .. a0 .. ") = " .. disc })
        
        if disc < 0 and not _G.showComplex then
            table.insert(steps, { description = "Discriminant < 0, no real solutions" })
            return nil
        end
        
        local sqrt_disc = math.sqrt(math.abs(disc))
        local y1 = (-a2 + sqrt_disc) / (2 * a4)
        local y2 = (-a2 - sqrt_disc) / (2 * a4)
        
        table.insert(steps, { description = "Solutions for y: y₁ = " .. y1 .. ", y₂ = " .. y2 })
        table.insert(steps, { description = "Since y = " .. var .. "², we have " .. var .. " = ±√y for each positive y" })
        
        local results = {}
        for i, yval in ipairs({y1, y2}) do
            if not _G.showComplex and yval < 0 then
                table.insert(steps, { description = "y" .. i .. " = " .. yval .. " < 0, skipping (no real square roots)" })
            else
                if _G.showComplex then
                    local x_pos = { type = "func", name = "sqrt", args = { { type = "number", value = yval } } }
                    local x_neg = { type = "neg", arg = x_pos }
                    table.insert(results, x_pos)
                    table.insert(results, x_neg)
                    table.insert(steps, { description = "From y" .. i .. " = " .. yval .. ": " .. var .. " = ±√(" .. yval .. ")" })
                else
                    if yval >= 0 then
                        local root = math.sqrt(yval)
                        table.insert(results, { type = "number", value = root })
                        table.insert(results, { type = "number", value = -root })
                        table.insert(steps, { description = "From y" .. i .. " = " .. yval .. ": " .. var .. " = ±" .. root })
                    end
                end
            end
        end
        return results
    end
    
    if a == 0 then return nil end

    -- Check if this is a trivial quadratic (ax² + c = 0)
    local is_trivial = (b == 0)
    
    if not is_trivial and not _G.suppress_basic_steps then
        table.insert(steps, { description = "Standard quadratic form: a" .. var .. "² + b" .. var .. " + c = 0" })
        table.insert(steps, { description = "Where a = " .. a .. ", b = " .. b .. ", c = " .. c })
    elseif is_trivial then
        -- For trivial quadratics, just show the key step
        table.insert(steps, { description = var .. "² = " .. (-c/a) })
    end
    
    if is_trivial then
        -- Direct solution for ax² + c = 0
        local val = -c/a
        if val < 0 and not _G.showComplex then
            table.insert(steps, { description = "No real solutions (negative square)" })
            return nil
        end
        
        local sqrt_val = math.sqrt(math.abs(val))
        table.insert(steps, { description = var .. " = ±" .. sqrt_val })
        
        local makeNum = function(v) return { type = "number", value = v } end
        return { makeNum(sqrt_val), makeNum(-sqrt_val) }
    end
    
    -- Calculate discriminant
    local discriminant = b^2 - 4*a*c
    if not _G.suppress_basic_steps then
        table.insert(steps, { description = "Discriminant: Δ = b² - 4ac = (" .. b .. ")² - 4(" .. a .. ")(" .. c .. ")" })
        table.insert(steps, { description = "Δ = " .. b^2 .. " - " .. (4*a*c) .. " = " .. discriminant })
    end
    
    if discriminant < 0 and not _G.showComplex then
        table.insert(steps, { description = "Since Δ < 0, there are no real solutions" })
        return nil
    elseif discriminant == 0 then
        table.insert(steps, { description = "Since Δ = 0, there is one repeated real solution" })
    elseif discriminant > 0 then
        if not _G.suppress_basic_steps then
            table.insert(steps, { description = "Since Δ > 0, there are two distinct real solutions" })
        end
    end
    
    -- Apply quadratic formula
    if not _G.suppress_basic_steps then
        table.insert(steps, { description = "Using quadratic formula: " .. var .. " = (-b ± √Δ)/(2a)" })
        table.insert(steps, { description = var .. " = (-(" .. b .. ") ± √(" .. discriminant .. "))/(2·" .. a .. ")" })
        table.insert(steps, { description = var .. " = (" .. (-b) .. " ± √(" .. discriminant .. "))/" .. (2*a) })
    end
    
    -- Build solutions
    local makeNum = function(val) return { type = "number", value = val } end
    local a_node = makeNum(a)
    local b_node = makeNum(b)
    local c_node = makeNum(c)
    local four_node = makeNum(4)
    local two_node = makeNum(2)

    local b_sq = { type = "power", left = b_node, right = makeNum(2) }
    local four_ac = { type = "mul", args = { four_node, a_node, c_node } }
    local disc = { type = "sub", left = b_sq, right = four_ac }
    disc = simplifyIfConstant(disc)

    local sqrt_disc = { type = "func", name = "sqrt", args = { disc } }
    local sqrt_disc_simp = simplifyIfConstant(sqrt_disc)

    local minus_b = { type = "neg", arg = b_node }
    minus_b = simplifyIfConstant(minus_b)

    local denom = { type = "mul", args = { two_node, a_node } }
    denom = simplifyIfConstant(denom)

    local numerator_plus = { type = "add", args = { minus_b, sqrt_disc_simp } }
    local numerator_minus = { type = "sub", left = minus_b, right = sqrt_disc_simp }

    local plus_case = { type = "div", left = numerator_plus, right = denom }
    local minus_case = { type = "div", left = numerator_minus, right = denom }

    if _G.showComplex then
        plus_case = simplify.simplify(plus_case)
        minus_case = simplify.simplify(minus_case)
    else
        plus_case = simplifyIfConstant(plus_case)
        minus_case = simplifyIfConstant(minus_case)
    end

    local sqrt_val = math.sqrt(math.abs(discriminant))
    local sol1 = (-b + sqrt_val) / (2*a)
    local sol2 = (-b - sqrt_val) / (2*a)
    
    table.insert(steps, { description = var .. "₁ = (" .. (-b) .. " + " .. sqrt_val .. ")/" .. (2*a) .. " = " .. sol1 })
    table.insert(steps, { description = var .. "₂ = (" .. (-b) .. " - " .. sqrt_val .. ")/" .. (2*a) .. " = " .. sol2 })

    return { plus_case, minus_case }
end

-- Cubic equation solver with steps  
local function matchCubicEq(eq, var, steps)
    if eq.type ~= "equation" then return nil end

    table.insert(steps, { description = "Solving cubic equation: " .. format_expr(eq) })

    local l, r = eq.left, eq.right
    local norm = { type = "sub", left = l, right = r }
    
    if not _G.suppress_basic_steps then
        table.insert(steps, { description = "Rearranging to standard form: " .. format_expr(norm) .. " = 0" })
    end

    local coeffs = polyCoeffs(norm, var, nil, steps)
    if not coeffs then return nil end

    local a = coeffs[3] or 0
    local b = coeffs[2] or 0
    local c = coeffs[1] or 0
    local d = coeffs[0] or 0

    if a == 0 then return nil end

    if not _G.suppress_basic_steps then
        table.insert(steps, { description = "Standard cubic form: a" .. var .. "³ + b" .. var .. "² + c" .. var .. " + d = 0" })
        table.insert(steps, { description = "Where a = " .. a .. ", b = " .. b .. ", c = " .. c .. ", d = " .. d })
    end

    -- Reduce to depressed cubic
    local delta = b / (3 * a)
    table.insert(steps, { description = "Converting to depressed cubic using substitution " .. var .. " = t + " .. delta })
    
    local p = (3*a*c - b^2) / (3*a^2)
    local q = (2*b^3 - 9*a*b*c + 27*a^2*d) / (27*a^3)

    table.insert(steps, { description = "Depressed cubic: t³ + pt + q = 0" })
    table.insert(steps, { description = "Where p = " .. string.format("%.6f", p) .. " and q = " .. string.format("%.6f", q) })

    local discriminant = (q/2)^2 + (p/3)^3
    table.insert(steps, { description = "Discriminant: Δ = (q/2)² + (p/3)³ = " .. string.format("%.6f", discriminant) })

    local roots = {}

    if discriminant > 0 then
        table.insert(steps, { description = "Since Δ > 0: one real root and two complex conjugate roots" })

        local sqrt_disc = math.sqrt(discriminant)
        local u = cbrt(-q/2 + sqrt_disc)
        local v = cbrt(-q/2 - sqrt_disc)
        local t1 = u + v

        table.insert(steps, { description = "Using Cardano's formula:" })
        table.insert(steps, { description = "u = ∛(-q/2 + √Δ) = " .. string.format("%.6f", u) })
        table.insert(steps, { description = "v = ∛(-q/2 - √Δ) = " .. string.format("%.6f", v) })
        table.insert(steps, { description = "t₁ = u + v = " .. string.format("%.6f", t1) })

        local x1 = t1 - delta
        table.insert(steps, { description = "Real root: " .. var .. "₁ = t₁ - " .. delta .. " = " .. string.format("%.6f", x1) })

        if _G.showComplex then
            local symbolic_root = {
                type = "sub",
                left = {
                    type = "add",
                    args = {
                        {
                            type = "func",
                            name = "cbrt",
                            args = {
                                {
                                    type = "sub",
                                    left = { type = "number", value = -q/2 },
                                    right = {
                                        type = "func",
                                        name = "sqrt",
                                        args = { { type = "number", value = discriminant } }
                                    }
                                }
                            }
                        },
                        {
                            type = "func",
                            name = "cbrt",
                            args = {
                                {
                                    type = "add",
                                    left = { type = "number", value = -q/2 },
                                    right = {
                                        type = "func",
                                        name = "sqrt",
                                        args = { { type = "number", value = discriminant } }
                                    }
                                }
                            }
                        }
                    }
                },
                right = { type = "number", value = delta }
            }
            table.insert(roots, simplifyIfConstant(symbolic_root))
        else
            table.insert(roots, { type = "number", value = x1 })
        end

        local real_part = (-t1/2) - delta
        local imag_part = math.sqrt(3)*(u - v)/2

        table.insert(steps, { description = "Complex roots: " .. var .. "₂,₃ = " .. string.format("%.6f", real_part) .. " ± " .. string.format("%.6f", imag_part) .. "i" })

        if _G.showComplex then
            local sqrt3 = { type = "func", name = "sqrt", args = { { type = "number", value = 3 } } }
            local symbolic_root2 = {
                type = "add",
                args = {
                    { type = "number", value = real_part },
                    {
                        type = "mul",
                        args = {
                            sqrt3,
                            { type = "number", value = (u - v) / 2 },
                            { type = "symbol", name = "i" }
                        }
                    }
                }
            }
            local symbolic_root3 = {
                type = "add",
                args = {
                    { type = "number", value = real_part },
                    {
                        type = "mul",
                        args = {
                            { type = "neg", arg = sqrt3 },
                            { type = "number", value = (u - v) / 2 },
                            { type = "symbol", name = "i" }
                        }
                    }
                }
            }
            table.insert(roots, simplifyIfConstant(symbolic_root2))
            table.insert(roots, simplifyIfConstant(symbolic_root3))
        else
            local root2 = { type = "add", args = {
                { type = "number", value = real_part },
                { type = "mul", args = {
                    { type = "number", value = imag_part },
                    { type = "symbol", name = "i" }
                }}
            }}
            local root3 = { type = "add", args = {
                { type = "number", value = real_part },
                { type = "mul", args = {
                    { type = "number", value = -imag_part },
                    { type = "symbol", name = "i" }
                }}
            }}
            table.insert(roots, simplifyIfConstant(root2))
            table.insert(roots, simplifyIfConstant(root3))
        end

    elseif discriminant == 0 then
        table.insert(steps, { description = "Since Δ = 0: repeated real roots" })
        
        local u = cbrt(-q/2)
        local t1 = 2*u
        local t2 = -u

        local x1 = t1 - delta
        local x2 = t2 - delta

        table.insert(steps, { description = "Using the double root formula:" })
        table.insert(steps, { description = "t₁ = 2∛(-q/2) = " .. string.format("%.6f", t1) })
        table.insert(steps, { description = "t₂ = -∛(-q/2) = " .. string.format("%.6f", t2) })

        local precision = _G.precision or _G.precision_digits or 4
        local function roundnum(x)
            local mult = 10 ^ precision
            return math.floor(x * mult + 0.5) / mult
        end

        x1 = roundnum(x1)
        x2 = roundnum(x2)

        if math.abs(x1 - x2) < 1e-10 then
            table.insert(steps, { description = "Triple root: " .. var .. " = " .. x1 .. " (multiplicity 3)" })
            table.insert(roots, { type = "number", value = x1 })
            table.insert(roots, { type = "number", value = x1 })
            table.insert(roots, { type = "number", value = x1 })
        else
            table.insert(steps, { description = "Roots: " .. var .. "₁ = " .. x1 .. ", " .. var .. "₂ = " .. var .. "₃ = " .. x2 .. " (double root)" })
            table.insert(roots, { type = "number", value = x1 })
            table.insert(roots, { type = "number", value = x2 })
            table.insert(roots, { type = "number", value = x2 })
        end

    else
        table.insert(steps, { description = "Since Δ < 0: three distinct real roots (casus irreducibilis)" })
        table.insert(steps, { description = "Using trigonometric solution method:" })
        
        local r = math.sqrt(-(p^3) / 27)
        local phi = math.acos(-q / (2 * math.sqrt(-(p^3)/27)))
        
        table.insert(steps, { description = "r = √(-(p³)/27) = " .. string.format("%.6f", r) })
        table.insert(steps, { description = "φ = arccos(-q/(2r)) = " .. string.format("%.6f", phi) })
        
        local t1 = 2 * math.sqrt(-p/3) * math.cos(phi / 3)
        local t2 = 2 * math.sqrt(-p/3) * math.cos((phi + 2*math.pi) / 3)
        local t3 = 2 * math.sqrt(-p/3) * math.cos((phi + 4*math.pi) / 3)
        
        local x1 = t1 - delta
        local x2 = t2 - delta
        local x3 = t3 - delta
        
        table.insert(steps, { description = "Three real roots:" })
        table.insert(steps, { description = var .. "₁ = " .. string.format("%.6f", x1) })
        table.insert(steps, { description = var .. "₂ = " .. string.format("%.6f", x2) })
        table.insert(steps, { description = var .. "₃ = " .. string.format("%.6f", x3) })
        
        table.insert(roots, { type = "number", value = x1 })
        table.insert(roots, { type = "number", value = x2 })
        table.insert(roots, { type = "number", value = x3 })
    end

    return roots
end

-- Quartic equation solver with steps
local function matchQuarticEq(eq, var, steps)
    if eq.type ~= "equation" then return nil end
    
    table.insert(steps, { description = "Solving quartic equation: " .. format_expr(eq) })
    
    local l, r = eq.left, eq.right
    local norm = { type = "sub", left = l, right = r }
    
    if not _G.suppress_basic_steps then
        table.insert(steps, { description = "Rearranging to standard form: " .. format_expr(norm) .. " = 0" })
    end
    
    local coeffs = polyCoeffs(norm, var, nil, steps)
    if not coeffs then return nil end
    
    local a = coeffs[4] or 0
    local b = coeffs[3] or 0
    local c = coeffs[2] or 0
    local d = coeffs[1] or 0
    local e = coeffs[0] or 0
    
    if a == 0 then return nil end

    if not _G.suppress_basic_steps then
        table.insert(steps, { description = "Standard quartic form: a" .. var .. "⁴ + b" .. var .. "³ + c" .. var .. "² + d" .. var .. " + e = 0" })
        table.insert(steps, { description = "Where a = " .. a .. ", b = " .. b .. ", c = " .. c .. ", d = " .. d .. ", e = " .. e })
    end

    -- Try factoring first
    local function try_quartic_factoring(a, b, c, d, e)
        if math.floor(a) ~= a or math.floor(b) ~= b or math.floor(c) ~= c or math.floor(d) ~= d or math.floor(e) ~= e then return nil end
        
        if a ~= 1 then
            b = b / a; c = c / a; d = d / a; e = e / a
        end
        
        for p = -10, 10 do for r = -10, 10 do
        for q = -10, 10 do for s = -10, 10 do
            if (p + r == b) and (q + p*r + s == c) and (p*s + q*r == d) and (q*s == e) then
                return {p=p, q=q, r=r, s=s}
            end
        end end end end
        return nil
    end

    local factors = try_quartic_factoring(a, b, c, d, e)
    if factors then
        table.insert(steps, { description = "Factored as: (" .. var .. "² + " .. factors.p .. var .. " + " .. factors.q .. ")(" .. var .. "² + " .. factors.r .. var .. " + " .. factors.s .. ") = 0" })
        table.insert(steps, { description = "Solving each quadratic factor separately:" })
        
        -- Create quadratic equations and solve them
        local quad1 = { 
            type="equation", 
            left={type="add", args={
                {type="pow", base={type="variable", name=var}, exp={type="number", value=2}},
                {type="mul", args={{type="number", value=factors.p}, {type="variable", name=var}}},
                {type="number", value=factors.q}
            }}, 
            right={type="number", value=0}
        }
        
        local quad2 = { 
            type="equation", 
            left={type="add", args={
                {type="pow", base={type="variable", name=var}, exp={type="number", value=2}},
                {type="mul", args={{type="number", value=factors.r}, {type="variable", name=var}}},
                {type="number", value=factors.s}
            }}, 
            right={type="number", value=0}
        }
        
        local roots1 = matchQuadraticEq(quad1, var, steps)
        local roots2 = matchQuadraticEq(quad2, var, steps)
        
        local all_roots = {}
        if roots1 then for _, rt in ipairs(roots1) do table.insert(all_roots, rt) end end
        if roots2 then for _, rt in ipairs(roots2) do table.insert(all_roots, rt) end end
        return all_roots
    end

    -- Ferrari's method
    table.insert(steps, { description = "Using Ferrari's method for quartic solution" })
    
    -- Normalize coefficients
    b = b / a
    c = c / a
    d = d / a
    e = e / a
    
    table.insert(steps, { description = "Dividing by leading coefficient: " .. var .. "⁴ + " .. b .. var .. "³ + " .. c .. var .. "² + " .. d .. var .. " + " .. e .. " = 0" })

    -- Depressed quartic
    local p = c - 3 * b^2 / 8
    local q = b^3 / 8 - b * c / 2 + d
    local r = e - 3 * b^4 / 256 + b^2 * c / 16 - b * d / 4
    
    table.insert(steps, { description = "Converting to depressed quartic using substitution " .. var .. " = y - b/4" })
    table.insert(steps, { description = "Depressed quartic: y⁴ + py² + qy + r = 0" })
    table.insert(steps, { description = "Where p = " .. string.format("%.6f", p) .. ", q = " .. string.format("%.6f", q) .. ", r = " .. string.format("%.6f", r) })

    -- Solve resolvent cubic
    table.insert(steps, { description = "Solving resolvent cubic: z³ + 2pz² + (p² - 4r)z - q² = 0" })
    
    local cubicA = 1
    local cubicB = 2 * p
    local cubicC = p^2 - 4 * r
    local cubicD = -q^2
    
    local cubicRoots = solveCubicReal(cubicA, cubicB, cubicC, cubicD)
    local z = cubicRoots[1]
    
    table.insert(steps, { description = "Using resolvent root z = " .. string.format("%.6f", z) })

    -- Ferrari's completion
    local sqrt1 = safe_sqrt(2 * z - p)
    local S1 = sqrt1
    
    local function div_complex(a, b)
        local a_re = type(a) == "table" and a.re or a
        local a_im = type(a) == "table" and (a.im or 0) or 0
        local b_re = type(b) == "table" and b.re or b
        local b_im = type(b) == "table" and (b.im or 0) or 0
        if b_im == 0 then
            if type(a) == "table" then
                return { re = a_re / b_re, im = a_im / b_re }
            else
                return a_re / b_re
            end
        end
        local denom = b_re^2 + b_im^2
        return {
            re = (a_re * b_re + a_im * b_im) / denom,
            im = (a_im * b_re - a_re * b_im) / denom
        }
    end
    
    local S2 = div_complex(q, type(sqrt1) == "table" and { re = 2 * (sqrt1.re or 0), im = 2 * (sqrt1.im or 0) } or (2 * sqrt1))

    table.insert(steps, { description = "Computing auxiliary values for Ferrari's method..." })

    -- The rest follows the complex arithmetic for quartic roots
    local precision = _G.precision or _G.precision_digits or 4
    local function roundnum(x)
        if not x then return 0 end
        local mult = 10 ^ precision
        return math.floor(x * mult + 0.5) / mult
    end
    
    local function format_root(val)
        if type(val) == "table" and val.im and val.im ~= 0 then
            return {
                type = "add",
                args = {
                    { type = "number", value = roundnum(val.re) },
                    {
                        type = "mul",
                        args = {
                            { type = "number", value = roundnum(val.im) },
                            { type = "symbol", name = "i" }
                        }
                    }
                }
            }
        else
            return { type = "number", value = roundnum(type(val) == "table" and val.re or val) }
        end
    end

    -- Complex arithmetic helpers (abbreviated for space)
    local function add_complex(a, b)
        if type(a) == "table" and type(b) == "table" then
            return { re = a.re + b.re, im = (a.im or 0) + (b.im or 0) }
        elseif type(a) == "table" then
            return { re = a.re + b, im = a.im }
        elseif type(b) == "table" then
            return { re = a + b.re, im = b.im }
        else
            return a + b
        end
    end

    local function sub_complex(a, b)
        if type(a) == "table" and type(b) == "table" then
            return { re = a.re - b.re, im = (a.im or 0) - (b.im or 0) }
        elseif type(a) == "table" then
            return { re = a.re - b, im = a.im }
        elseif type(b) == "table" then
            return { re = a - b.re, im = -b.im }
        else
            return a - b
        end
    end

    local function neg_complex(a)
        if type(a) == "table" then
            return { re = -(a.re or 0), im = -(a.im or 0) }
        else
            return -a
        end
    end

    local function mul_complex(a, b)
        local a_re = type(a) == "table" and a.re or a
        local a_im = type(a) == "table" and (a.im or 0) or 0
        local b_re = type(b) == "table" and b.re or b
        local b_im = type(b) == "table" and (b.im or 0) or 0
        return {
            re = a_re * b_re - a_im * b_im,
            im = a_re * b_im + a_im * b_re
        }
    end

    local function div2(val)
        if type(val) == "table" then
            return { re = val.re / 2, im = (val.im or 0) / 2 }
        else
            return val / 2
        end
    end

    local t1 = add_complex(S1, safe_sqrt(sub_complex(-(2 * z + p), neg_complex(mul_complex(2, S2)))))
    local t2 = sub_complex(S1, safe_sqrt(sub_complex(-(2 * z + p), neg_complex(mul_complex(2, S2)))))
    local t3 = add_complex(neg_complex(S1), safe_sqrt(sub_complex(-(2 * z + p), mul_complex(2, S2))))
    local t4 = sub_complex(neg_complex(S1), safe_sqrt(sub_complex(-(2 * z + p), mul_complex(2, S2))))

    local base = -b / 4
    local y1 = add_complex(base, div2(t1))
    local y2 = add_complex(base, div2(t2))
    local y3 = add_complex(base, div2(t3))
    local y4 = add_complex(base, div2(t4))

    table.insert(steps, { description = "Four quartic roots computed using Ferrari's method" })

    if not _G.showComplex then
        local real_roots = {}
        for i, y in ipairs({y1, y2, y3, y4}) do
            if type(y) == "table" and (y.im and math.abs(y.im) > 1e-10) then
                -- skip complex root
            else
                local val = y
                if type(y) == "table" then val = y.re end
                table.insert(real_roots, format_root(val))
                table.insert(steps, { description = var .. " = " .. string.format("%.6f", val) })
            end
        end
        if #real_roots == 0 then
            table.insert(steps, { description = "All roots are complex (not displayed in real mode)" })
            return {"No real roots"}
        end
        return real_roots
    end

    table.insert(steps, { description = "Quartic solutions:" })
    for i, y in ipairs({y1, y2, y3, y4}) do
        if type(y) == "table" and y.im and y.im ~= 0 then
            table.insert(steps, { description = var .. "₊" .. i .. " = " .. string.format("%.6f", y.re) .. " + " .. string.format("%.6f", y.im) .. "i" })
        else
            local val = type(y) == "table" and y.re or y
            table.insert(steps, { description = var .. "₊" .. i .. " = " .. string.format("%.6f", val) })
        end
    end

    return {
        format_root(y1),
        format_root(y2),
        format_root(y3),
        format_root(y4)
    }
end

function solveCubicReal(a, b, c, d)
    b = b / a; c = c / a; d = d / a
    local p = c - b^2 / 3
    local q = 2 * b^3 / 27 - b * c / 3 + d
    local roots = {}
    local discriminant = (q / 2)^2 + (p / 3)^3
    if discriminant > 0 then
        local u = cbrt(-q / 2 + math.sqrt(discriminant))
        local v = cbrt(-q / 2 - math.sqrt(discriminant))
        table.insert(roots, u + v - b / 3)
    else
        local r = math.sqrt(-p^3 / 27)
        local phi = math.acos(-q / (2 * r))
        local t = 2 * math.sqrt(-p / 3)
        table.insert(roots, t * math.cos(phi / 3) - b / 3)
        table.insert(roots, t * math.cos((phi + 2 * math.pi) / 3) - b / 3)
        table.insert(roots, t * math.cos((phi + 4 * math.pi) / 3) - b / 3)
    end
    return roots
end

-- Main solve function with intelligent step filtering
function solve(input_expr, var)
    local steps = {}
    
    table.insert(steps, { description = "Solving equation: " .. tostring(input_expr) })

    local parser = rawget(_G, "parser") or require("parser")
    local ast_mod = rawget(_G, "ast") or require("ast")
    local simplify = rawget(_G, "simplify") or require("simplify")

    local expr = input_expr
    if type(expr) == "string" then
        local s = expr
        s = s:gsub("(%d)(%a)", "%1*%2")
        s = s:gsub("(%d)(%()", "%1*%2")
        if not _G.suppress_basic_steps then
            table.insert(steps, { description = "Parsing: " .. s })
        end
        expr = parser.parse(s)
    end
    if not expr then
        error(errors.invalid("solve", "parse failed, got nil AST"))
    end

    var = var or (function()
        local function findVar(node)
            if not node or type(node) ~= "table" then return nil end
            if node.type == "variable" then return node.name end
            for _, k in ipairs { "left", "right", "value", "args" } do
                local child = node[k]
                if child then
                    if type(child) == "table" and not child[1] then
                        local res = findVar(child)
                        if res then return res end
                    elseif type(child) == "table" then
                        for _, v in ipairs(child) do
                            local res = findVar(v)
                            if res then return res end
                        end
                    end
                end
            end
            return nil
        end
        return findVar(expr.left) or findVar(expr.right) or "x"
    end)()

    if not _G.suppress_basic_steps then
        table.insert(steps, { description = "Variable to solve for: " .. var })
    end

    if expr.type == "equation" then
        expr = ast_mod.eq(expr.left, expr.right)
    elseif expr.type ~= "equation" then
        expr = ast_mod.eq(expr, ast_mod.number(0))
        if not _G.suppress_basic_steps then
            table.insert(steps, { description = "Converting to equation form: " .. format_expr(expr) })
        end
    end

    expr = simplify.simplify(expr)
    if not _G.suppress_basic_steps then
        table.insert(steps, { description = "After simplification: " .. format_expr(expr) })
    end

    local diff = simplify.simplify(ast_mod.sub(expr.left, expr.right))
    local fallback_eq = ast_mod.eq(diff, ast_mod.number(0))

    -- Find polynomial degree and analyze complexity
    local coeffs = polyCoeffs(fallback_eq.left, var, nil, steps)
    local maxdeg = 0
    for d, _ in pairs(coeffs) do
        if d > maxdeg then maxdeg = d end
    end

    -- Analyze complexity before proceeding
    local complexity = analyzeComplexity(format_expr(expr), coeffs, maxdeg)
    
    -- Set suppression flag for basic steps based on complexity
    if complexity.is_trivial then
        _G.suppress_basic_steps = true
    end

    if not _G.suppress_basic_steps then
        table.insert(steps, { description = "Polynomial degree: " .. maxdeg })
    end

    local result, raw_steps
    
    if maxdeg == 1 then
        if not _G.suppress_basic_steps then
            table.insert(steps, { description = "This is a linear equation" })
        end
        local ans_lin = matchLinearEq(fallback_eq, var, steps)
        if ans_lin then
            local rhs
            if type(ans_lin) ~= "table" then
                rhs = ast_mod.number(ans_lin)
            else
                rhs = ans_lin
            end
            local eq_ast = ast_mod.eq(ast_mod.symbol(var), rhs)
            local simplified_eq = simplify.simplify(eq_ast)
            result = format_expr(simplified_eq)
            if simplified_eq and simplified_eq.type == "sub"
                and simplified_eq.left and simplified_eq.right
                and simplified_eq.left.type == "variable"
                and simplified_eq.right.type == "number" then
                result = simplified_eq.left.name .. " = " .. tostring(simplified_eq.right.value)
            end
            raw_steps = steps
        end
    elseif maxdeg == 2 then
        if not _G.suppress_basic_steps then
            table.insert(steps, { description = "This is a quadratic equation" })
        end
        local ans_quad = matchQuadraticEq(fallback_eq, var, steps)
        if ans_quad then
            local pieces = {}
            for i, root in ipairs(ans_quad) do
                table.insert(pieces, var .. " = " .. format_expr(root))
            end
            result = table.concat(pieces, ", ")
            raw_steps = steps
        end
    elseif maxdeg == 3 then
        if not _G.suppress_basic_steps then
            table.insert(steps, { description = "This is a cubic equation" })
        end
        local ans_cubic = matchCubicEq(fallback_eq, var, steps)
        if ans_cubic then
            local pieces = {}
            for i, root in ipairs(ans_cubic) do
                table.insert(pieces, var .. " = " .. format_expr(root))
            end
            result = table.concat(pieces, ", ")
            raw_steps = steps
        end
    elseif maxdeg == 4 then
        if not _G.suppress_basic_steps then
            table.insert(steps, { description = "This is a quartic equation" })
        end
        local ans_quartic = matchQuarticEq(fallback_eq, var, steps)
        if ans_quartic then
            local pieces = {}
            for i, root in ipairs(ans_quartic) do
                table.insert(pieces, var .. " = " .. format_expr(root))
            end
            result = table.concat(pieces, ", ")
            raw_steps = steps
        end
    end

    if not result then
        table.insert(steps, { description = "No analytical solution method available for this equation" })
        if _G.errors then
            error(_G.errors.get("solve(not_today_satan)") or "No analytical solution found")
        else
            return "No analytical solution found", steps
        end
    end

    -- Apply intelligent filtering
    local filtered_steps = filterSteps(raw_steps, complexity)
    
    -- Clean up global state
    _G.suppress_basic_steps = nil
    
    return result, filtered_steps
end

-- Export functions with steps support
_G.solve = solve
_G.polyCoeffs = polyCoeffs
_G.matchLinearEq = matchLinearEq
_G.matchQuadraticEq = matchQuadraticEq
_G.matchCubicEq = matchCubicEq
_G.matchQuarticEq = matchQuarticEq
_G.format_expr = format_expr
_G.analyzeComplexity = analyzeComplexity
_G.filterSteps = filterSteps

-- End src/solve.lua

-- Imported src/solve.lua—debuggers rejoice.

-- Begin src/init.lua
platform.apilevel = "2.4"

local var = rawget(_G, "var") or nil
_G.darkMode = (var and var.recall and var.recall("dark_mode") == 1) or false
-- Put this RIGHT AT THE TOP, before anything else
local original_error = error
function error(msg, level)
    original_error(tostring(msg), 0)
end
-- Default fallback; true recall happens after storage is ready
_G.current_constant_category = nil

-- Delay storage sync to avoid race with var initialization
function syncCategoryFromStorage()
    if var and type(var.recall) == "function" then
        local cat = var.recall("current_constant_category")
        if cat and type(cat) == "string" then
            print("[STATE] Loaded stored constant category:", cat)
            _G.current_constant_category = cat
            return
        end
    end

    if not _G.current_constant_category then
        _G.current_constant_category = "fundamental"
        print("[STATE] No stored category, using default:", _G.current_constant_category)
        
        if var and type(var.store) == "function" then
            var.store("current_constant_category", _G.current_constant_category)
            print("[STATE] Stored default category to storage:", _G.current_constant_category)
        end
    end
end


function on.construction()
    syncCategoryFromStorage()
end

function on.getSymbolList()
    return { "current_constant_category" }
end

-- End src/init.lua

-- Imported src/init.lua—debuggers rejoice.

-- Begin src/graph.lua
-- graph.lua
-- This module provides graphing capabilities for the TI-Nspire CX CAS,
-- leveraging an existing symbolic math engine.

-- IMPORTANT: This file assumes the following global CAS engine functions are already loaded:
-- _G.parse(expression_string) : Returns an AST for the given expression string.
-- _G.evaluate_ast_numeric(ast_node, variables_table) : Numerically evaluates an AST.
-- _G.solve(equation_string) : Solves an equation string symbolically, returns a table of solution ASTs.
-- _G.astToString(ast_node) : Converts an AST back to its symbolic string representation.
-- _G.errors.invalid(function_name, hint) : For consistent error reporting.

-- Nspire Lua built-in modules
-- REMOVED: local graphics = graphics
-- REMOVED: local math = math
-- REMOVED: local os = os -- For performance timing/sleep if needed

-- Define the graphing window (world coordinates)

local x_min_world = -10
local x_max_world = 10
local y_min_world = -10
local y_max_world = 10

-- Calculate screen dimensions once
local screen_width = 50
local screen_height = 50

-- --- Coordinate Transformation Functions ---
-- Converts world X-coordinate to screen pixel X-coordinate
local function world_to_screen_x(x_world)
    return (x_world - x_min_world) / (x_max_world - x_min_world) * screen_width
end

-- Converts world Y-coordinate to screen pixel Y-coordinate (Nspire Y-axis is inverted)
local function world_to_screen_y(y_world)
    return screen_height - ((y_world - y_min_world) / (y_max_world - y_min_world) * screen_height)
end

-- Converts screen pixel X-coordinate to world X-coordinate
local function screen_to_world_x(x_screen)
    return x_screen / screen_width * (x_max_world - x_min_world) + x_min_world
end

-- Converts screen pixel Y-coordinate to world Y-coordinate
local function screen_to_world_y(y_screen)
    return (screen_height - y_screen) / screen_height * (y_max_world - y_min_world) + y_min_world
end

-- --- Plotting Functions ---

--- Plots an explicit function of the form y = f(x)
-- @param expression_string string: The mathematical expression for f(x) (e.g., "x^2", "sin(x)")
-- @param color_r number: Red component (0-255)
-- @param color_g number: Green component (0-255)
-- @param color_b number: Blue component (0-255)
function plot_explicit_function(expression_string, color_r, color_g, color_b)
    local f_x_ast = _G.parse(expression_string) -- Parse the expression into an AST

    graphics.setColor(color_r, color_g, color_b)
    graphics.setPen(2, "solid") -- Set line thickness

    local prev_screen_x, prev_screen_y = nil, nil

    -- Iterate across every pixel column on the screen
    for screen_x_pixel = 0, screen_width do
        local x_world = screen_to_world_x(screen_x_pixel) -- Convert pixel X to world X

        -- Numerically evaluate the function AST for the current x_world
        local y_world_raw = _G.evaluate_ast_numeric(f_x_ast, {x = x_world})

        -- Check if the result is a valid number (not NaN, not infinite)
        if type(y_world_raw) == "number" and not (y_world_raw ~= y_world_raw) and y_world_raw ~= math.huge and y_world_raw ~= -math.huge then
            local screen_y_pixel = world_to_screen_y(y_world_raw) -- Convert world Y to pixel Y

            -- Only draw if the point is within the screen's Y bounds (with a small buffer for continuity)
            if screen_y_pixel >= -10 and screen_y_pixel <= screen_height + 10 then
                if prev_screen_x ~= nil then
                    -- Draw a line segment from the previous valid point to the current one
                    graphics.drawLine(prev_screen_x, prev_screen_y, screen_x_pixel, screen_y_pixel)
                end
                prev_screen_x, prev_screen_y = screen_x_pixel, screen_y_pixel
            else
                -- If the point goes off-screen (vertically), break the line to avoid drawing across discontinuities
                prev_screen_x, prev_screen_y = nil, nil
            end
        else
            -- If evaluation fails (e.g., division by zero, sqrt of negative), break the line
            prev_screen_x, prev_screen_y = nil, nil
        end
    end
end

--- Plots an implicit function of the form F(x,y) = 0
-- Uses a grid evaluation method. Performance can be slow on Nspire for high resolution/complex functions.
-- @param F_xy_expression_string string: The expression for F(x,y) (e.g., "x^2 + y^2 - 25")
-- @param color_r number: Red component (0-255)
-- @param color_g number: Green component (0-255)
-- @param color_b number: Blue component (0-255)
-- @param tolerance number: How close to zero F(x,y) must be to draw a pixel (e.g., 0.1)
-- @param resolution_factor number: Higher value means fewer samples (e.g., 2 for half resolution)
function plot_implicit_function(F_xy_expression_string, color_r, color_g, color_b, tolerance, resolution_factor)
    tolerance = tolerance or 0.1
    resolution_factor = math.max(1, math.floor(resolution_factor or 1)) -- Ensure at least 1

    local F_xy_ast = _G.parse(F_xy_expression_string)

    graphics.setColor(color_r, color_g, color_b)

    -- Determine step size for world coordinates based on screen resolution and resolution_factor
    local x_world_step = (x_max_world - x_min_world) / (screen_width / resolution_factor)
    local y_world_step = (y_max_world - y_min_world) / (screen_height / resolution_factor)

    -- Iterate over a grid of world coordinates
    for x_world = x_min_world, x_max_world, x_world_step do
        for y_world = y_min_world, y_max_world, y_world_step do
            -- Numerically evaluate F(x,y)
            local val = _G.evaluate_ast_numeric(F_xy_ast, {x = x_world, y = y_world})

            -- If the value is close to zero, draw a pixel
            if type(val) == "number" and not (val ~= val) and math.abs(val) <= tolerance then
                local screen_x = world_to_screen_x(x_world)
                local screen_y = world_to_screen_y(y_world)
                graphics.dot(screen_x, screen_y)
            end
        end
    end
end

--- Plots intersection points of two expressions, using symbolic solver and displaying exact labels.
-- @param expr1_string string: The first expression (e.g., "x^2")
-- @param expr2_string string: The second expression (e.g., "x+1")
-- @param color_r number: Red component (0-255)
-- @param color_g number: Green component (0-255)
-- @param color_b number: Blue component (0-255)
-- @param display_labels boolean: True to display exact coordinate labels, false otherwise.
function plot_intersections(expr1_string, expr2_string, color_r, color_g, color_b, display_labels)
    display_labels = display_labels ~= false -- Default to true if not explicitly false

    local equation_to_solve = expr1_string .. "=" .. expr2_string

    local solutions_for_x_asts = {}
    local success, solved_result = pcall(_G.solve, equation_to_solve)

    if success and solved_result and type(solved_result) == "table" then
        -- Process the solver's output. Assumes _G.solve returns a table of ASTs,
        -- where each AST is either a direct solution value for 'x' or an 'equals' AST like {left=x_var, right=solution_value}.
        for _, sol_item in ipairs(solved_result) do
            local solution_ast = nil
            if sol_item.type == "equals" and sol_item.left.type == "variable" and sol_item.left.name == "x" then
                solution_ast = sol_item.right
            elseif sol_item.type ~= "equals" then -- Assume it's a direct solution value AST for 'x'
                solution_ast = sol_item
            end

            if solution_ast then
                table.insert(solutions_for_x_asts, solution_ast)
            end
        end
    else
        -- Log or display solver error
        print(_G.errors.invalid("plot_intersections", "Solver failed for '" .. equation_to_solve .. "': " .. tostring(solved_result)))
        return
    end

    graphics.setColor(color_r, color_g, color_b)
    graphics.setPen(3, "solid") -- Thicker mark for intersection points

    local f1_ast = _G.parse(expr1_string) -- Parse one of the original functions to get y-values

    for _, x_sol_ast in ipairs(solutions_for_x_asts) do
        -- Numerically evaluate the x-solution for plotting
        local x_solution_numeric = _G.evaluate_ast_numeric(x_sol_ast, {})

        -- Only plot if x-solution is a valid number and within the current world X-range
        if type(x_solution_numeric) == "number" and not (x_solution_numeric ~= x_solution_numeric) and
           x_solution_numeric >= x_min_world and x_solution_numeric <= x_max_world then

            -- Numerically evaluate the corresponding y-value using one of the original functions
            local y_solution_numeric = _G.evaluate_ast_numeric(f1_ast, {x = x_solution_numeric})

            -- Only plot if y-solution is also a valid number and within world Y-range
            if type(y_solution_numeric) == "number" and not (y_solution_numeric ~= y_solution_numeric) and
               y_solution_numeric >= y_min_world and y_solution_numeric <= y_max_world then

                local screen_x = world_to_screen_x(x_solution_numeric)
                local screen_y = world_to_screen_y(y_solution_numeric)

                -- Draw a cross mark at the intersection point
                graphics.drawLine(screen_x - 5, screen_y, screen_x + 5, screen_y)
                graphics.drawLine(screen_x, screen_y - 5, screen_x, screen_y + 5)

                if display_labels then
                    -- Get exact string representation for x-coordinate
                    local x_label_exact = _G.astToString(x_sol_ast)
                    -- For y-coordinate, you'd ideally substitute x_sol_ast into f1_ast and simplify symbolically.
                    -- This is very complex. For a practical graph label, numeric y is often sufficient.
                    local y_label_numeric = string.format("%.3f", y_solution_numeric) -- Format to 3 decimal places

                    local label_text = string.format("(%s, %s)", x_label_exact, y_label_numeric)
                    graphics.drawText(label_text, screen_x + 8, screen_y - 15) -- Offset label for visibility
                end
            end
        end
    end
end

-- --- Public API for graph.lua ---
-- Export the plotting functions
_G.graphing = {
    plot_explicit_function = plot_explicit_function,
    plot_implicit_function = plot_implicit_function,
    plot_intersections = plot_intersections,
    -- Also expose coordinate helpers if the GUI needs to adjust view
    world_to_screen_x = world_to_screen_x,
    world_to_screen_y = world_to_screen_y,
    screen_to_world_x = screen_to_world_x,
    screen_to_world_y = screen_to_world_y,
    -- Expose world window for potential GUI configuration
    set_world_window = function(xmin, xmax, ymin, ymax)
        x_min_world = xmin
        x_max_world = xmax
        y_min_world = ymin
        y_max_world = ymax
    end
}
-- --- Global Graphing State ---
_G.graph_state = {
    explicit_func_expr = "x^2",
    implicit_func_expr = "x^2 + y^2 - 16",
    
}

-- End src/graph.lua

-- src/graph.lua is in; don’t let that parser bite you later.

-- Begin src/gui.lua

_G.darkMode = (var.recall("dark_mode") == 1)
_G.showLaunchAnimation = (var.recall("nLuaCAS_launch_anim_pref") == 1)
-- Utility function to wrap text within a given width.
-- Requires a gc object for text measurement.
local function wrapText(gc_obj, text, maxWidth, font_serif, font_style, font_size)
    local lines = {}
    local currentLine = ""
    
    -- Ensure the font is set for accurate measurement within this GC context
    gc_obj:setFont(font_serif, font_style, font_size) 

    -- Split the text into "words" (sequences of non-whitespace characters)
    -- This handles multiple spaces gracefully and avoids empty "words".
    local words = {}
    for word in text:gmatch("[^%s]+") do
        table.insert(words, word)
    end

    for _, word in ipairs(words) do
        local testLine = currentLine .. (currentLine ~= "" and " " or "") .. word
        -- Check if adding the next word (with a space) exceeds maxWidth
        if gc_obj:getStringWidth(testLine) <= maxWidth then
            currentLine = testLine
        else
            -- If current line is not empty, add it to lines and start a new line with the current word.
            if currentLine ~= "" then
                table.insert(lines, currentLine)
            end
            currentLine = word
            -- Important: if a single word is *itself* wider than maxWidth, it will still exceed.
            -- For truly strict wrapping (e.g., for very long URLs), you'd need character-by-character breaking,
            -- but for general descriptions, word-wrap is usually sufficient.
        end
    end
    -- Add any remaining text in currentLine
    if currentLine ~= "" then
        table.insert(lines, currentLine)
    end
    return lines
end
_G.explanationDialog = nil 
-- In gui.lua

-- Make explanationDialog global for proper rendering order management in on.paint
_G.explanationDialog = nil 
function showCalculationExplanation(steps, originalExpr, calculationType)
    if not steps or #steps == 0 then
        print("[DEBUG] No steps to show!")
        return
    end

    if _G.explanationDialog then
        _G.explanationDialog:close(false)
        _G.explanationDialog = nil
    end

    -- --- Dialog Size Configuration ---
    local itemsPerPage = 4      -- As requested.
    local dialogWidth = 300     -- Increased width to better fit 4 items.
    local lineHeight = 18       -- A readable height for a line of text.
    local topSectionHeight = 60 -- Space for title bar and header text.
    local footerHeight = 40     -- The vertical space reserved for the bottom row of controls.

    -- Calculate total height based on a full page of items.
    local contentHeight = itemsPerPage * lineHeight
    local dialogHeight = topSectionHeight + contentHeight + footerHeight
    -- --- End of Configuration ---

    -- --- Button and Control Layout ---
    local footerControlsY = dialogHeight - footerHeight + 10 -- The Y-coordinate for ALL bottom buttons.
    local gotItButtonWidth = 80
    local gotItButtonX = dialogWidth - gotItButtonWidth - 20 -- Position on the bottom-right.

    -- Initial elements (the static parts of the dialog).
    local staticElements = {
        { type = "TextLabel", x = 20, y = 20, text = "Step-by-step " .. (calculationType or "Calculation") .. " of:" },
        { type = "TextLabel", x = 20, y = 40, text = originalExpr },
        -- The "Got it!" button is now placed according to our new layout variables.
        { type = "TextButton", text = "Got it!", closesDialog = true, x = gotItButtonX, y = footerControlsY, width = gotItButtonWidth }
    }

    -- Create the Dialog Instance
    _G.explanationDialog = Dialog(theView, {
        title = (calculationType or "Calculation") .. " Explanation",
        width = dialogWidth,
        height = dialogHeight,
        elements = staticElements,
        onClose = function(dlg, result)
            _G.explanationDialog = nil
            theView:invalidate()
        end
    })

    -- Attach pagination data to the dialog instance
    local dialog = _G.explanationDialog
    dialog.steps = steps
    dialog.itemsPerPage = itemsPerPage
    dialog.totalPages = math.ceil(#steps / itemsPerPage)
    dialog.currentPage = 0
    dialog.contentStartY = topSectionHeight
    -- Pass the calculated footer Y position to the dialog so updatePage can use it.
    dialog.footerControlsY = footerControlsY

    -- Initial call to draw the first page
    dialog:updatePage(1)

    -- Add the dialog to the view and activate it
    theView:add(dialog)
    dialog:activate()
end
function getStringWidth(text)
    return platform.withGC(function(gc) return gc:getStringWidth(text) end, text)
end
_G.precisionInputActive = false
_G.showComplex = (var.recall("nLuaCAS_complex_pref") == 1)
-- Launch animation globals
n_logo = image.new(_R.IMG.n_logo)
luacas_text = image.new(_R.IMG.luacas_text)
local scaleFactorLogo = 0.1 -- Adjusted smaller n logo
local scaleFactorText = 0.035 -- Adjusted smaller LuaCAS text to match n height
local nW, nH = image.width(n_logo) * scaleFactorLogo, image.height(n_logo) * scaleFactorLogo
local luaW, luaH = image.width(luacas_text) * scaleFactorText, image.height(luacas_text) * scaleFactorText
local launchStartTime = timer.getMilliSecCounter()
-- Recall launch animation preference: 1 for show, 0 for hide. Default to show if not set.

local showLaunchAnim = _G.showLaunchAnimation -- Initialize local variable based on global preference
local logoX, textX = -100, -300
local overlayAlpha = 1.0
local overlayRegion = {x=270, y=8, w=90, h=24} -- Position this based on the layout
local cursorInsideOverlay = false


function syncCategoryFromStorage()
    local cat = nil
    if var and type(var.recall) == "function" then
        cat = var.recall("current_constant_category")
    end

    if cat and type(cat) == "string" then
        _G.current_constant_category = cat
        _G.currentConstCategory = cat
        print("[STATE] Recalled category from storage:", cat)
    else
        local fallback = gui.get_current_constant_category()
        _G.current_constant_category = fallback
        _G.currentConstCategory = fallback
        print("[STATE] No stored category, using default:", fallback)
    end

    -- Always update GUI button text if it exists
    if _G.categoryBtn then
        _G.categoryBtn.text = _G.currentConstCategory
        print("[DEBUG] Category button updated to:", _G.currentConstCategory)
    end
end

function setupLaunchAnimation()
    if showLaunchAnim then
        -- Start a timer to drive the animation. You need a variable to store the timer ID.
        animationTimerId = timer.start(10) -- Set a small interval like 10ms for smooth animation
    else
        -- If animation is off, immediately make the editor visible
        if fctEditor and fctEditor.editor then
            fctEditor.editor:setVisible(true)
        end
        platform.window:invalidate() -- Force a redraw to ensure editor is shown
    end
end
var = var or {}
var.store = var.store or {}
parser = rawget(_G, "parser")
if not parser or not parser.parse then
  error("parser module or parser.parse not defined — ensure parser.lua is loaded before gui.lua")
end
parse = parser.parse
simplify = rawget(_G, "simplify")
 errors = _G.errors

-- Ensure getLocaleText exists, fallback to identity
local getLocaleText = rawget(_G, "getLocaleText") or function(key) return key end

_G.autoDecimal = false
_G.settingsBtnRegion = {x = 0, y = 0, w = 32, h = 32}
-- Modal flag for settings
_G.showSettingsModal = false
_G.showGraphingModal = false
_G.showHelpModal = false
_G.showStartupHint = true
if var and var.recall and var.recall("hide_startup_hint") == 1 then
    _G.showStartupHint = false
end
_G.switchPressed = false
_G.modalETKButton = nil
_G.modalCloseBtnRegion = {x = 0, y = 0, w = 24, h = 24}
-- Compatibility hack: unpack became table.unpack in newer Lua, because reasons
unpack = unpack or table.unpack

-- ====== Embedded Standalone ETK-style Button Widget ======

Widgets = {}
function applyEditorColors()
    if fctEditor and fctEditor.editor then
        local bg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
        local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
        local border = _G.darkMode and {100, 100, 100} or {0, 0, 0}

        if fctEditor.editor.setBackgroundColor then
            fctEditor.editor:setBackgroundColor(table.unpack(bg))
        end
        if fctEditor.editor.setTextColor then
            fctEditor.editor:setTextColor(table.unpack(text))
        end
        if fctEditor.editor.setBorderColor then
            fctEditor.editor:setBorderColor(table.unpack(border))
        end
        if fctEditor.editor.setOpaque then
            fctEditor.editor:setOpaque(true)
        end
    end
end
-- Helper for unpacking color
function unpackColor(t)
  return t[1], t[2], t[3]
end

-- Helper for simple dimension (width, height)
function Dimension(w, h)
  return { width = w, height = h }
end

-- Helper event dispatcher
function CallEvent(obj, name)
  if obj[name] then obj[name](obj) end
end

-- ETK-style Button class
Widgets.Button = class(Widget)
local Button = Widgets.Button

Button.defaultStyle = {
  textColor       = {{000,000,000},{000,000,000}},
  backgroundColor = {{248,252,248},{248,252,248}},
  borderColor     = {{136,136,136},{160,160,160}},
  focusColor      = {{040,148,184},{000,000,000}},
  defaultWidth  = 48,
  defaultHeight = 27,
  font = {
    serif="sansserif",
    style="r",
    size=10
  }
}

function Button:init(arg)	
  self.text = arg.text or "Button"
  local style = arg.style or Button.defaultStyle or {
    textColor       = {{0,0,0},{0,0,0}},
    backgroundColor = {{248,252,248},{248,252,248}},
    borderColor     = {{136,136,136},{160,160,160}},
    focusColor      = {{40,148,184},{0,0,0}},
    defaultWidth  = 48,
    defaultHeight = 27,
    font = {
      serif="sansserif",
      style="r",
      size=10
    }
  }
  self.style = style
  self.dimension = arg.position or Dimension(style.defaultWidth or 48, style.defaultHeight or 27)
  Widget.init(self, nil, self.dimension.width or style.defaultWidth, self.dimension.height or style.defaultHeight)
  self.meDown = false
  self.hasFocus = false
  self.parent = arg.parent or nil
  self.onAction = arg.onAction or nil
end

function Button:prepare(gc)
  local font = self.style.font
  gc:setFont(font.serif, font.style, font.size)
  self.dimension.width = gc:getStringWidth(self.text) + 10
end

function Button:draw(gc, x, y, width, height, isColor)
  if self.meDown then
    y = y + 1
  end

  local color = isColor and 1 or 2
  local style = self.style or Button.defaultStyle

  local isDark = _G.darkMode
local colorSet = isDark and {
    backgroundColor = {50, 50, 50},
    textColor = {220, 220, 220},
    borderColor = {100, 100, 100},
    focusColor = {80, 160, 220}
} or {
    backgroundColor = {248, 252, 248},
    textColor = {0, 0, 0},
    borderColor = {136, 136, 136},
    focusColor = {40, 148, 184}
}

local bg = colorSet.backgroundColor
local tc = colorSet.textColor
local bc = colorSet.borderColor
local fc = colorSet.focusColor

  gc:setColorRGB(unpackColor(bg))
  gc:fillRect(x + 2, y + 2, width - 4, height - 4)

  gc:setColorRGB(unpackColor(tc))
  gc:drawString(self.text, x + 5, y + 3, "top")

  if self.hasFocus then
    gc:setColorRGB(unpackColor(fc))
    gc:setPen("medium", "smooth")
  else
    gc:setColorRGB(unpackColor(bc))
    gc:setPen("thin", "smooth")
  end

  gc:fillRect(x + 2, y, width - 4, 2)
  gc:fillRect(x + 2, y + height - 2, width - 4, 2)
  gc:fillRect(x, y + 2, 1, height - 4)
  gc:fillRect(x + 1, y + 1, 1, height - 2)
  gc:fillRect(x + width - 1, y + 2, 1, height - 4)
  gc:fillRect(x + width - 2, y + 1, 1, height - 2)

  if self.hasFocus then
    gc:setColorRGB(unpackColor(style.focusColor[color]))
  end

  gc:setPen("thin", "smooth")
end

function Button:doAction()
  if self.parent and self.parent.invalidate then
    self.parent:invalidate()
  end
  if self.onAction then
    self.onAction(self)
  else
    CallEvent(self, "onAction")
  end
end

function Button:onMouseDown()
  self.meDown = true
end

function Button:onMouseUp(x, y, onMe)
  self.meDown = false
  if onMe then
    self:doAction()
  end
end

function Button:enterKey()
  self:doAction()
end

-- ====== END Standalone Button Widget ======
-- ETK View System (lifted and tweaked from SuperSpire/S2.lua)
defaultFocus = nil

-- The View class: manages widgets, focus, mouse events, and general UI mayhem.
View = class()

function View:init(window)
	self.window = window
	self.widgetList = {}
	self.focusList = {}
	self.currentFocus = 0
	self.currentCursor = "default"
	self.prev_mousex = 0
	self.prev_mousey = 0
end

function View:invalidate()
	self.window:invalidate()
end

function View:setCursor(cursor)
	if cursor ~= self.currentCursor then
		self.currentCursor = cursor
		self:invalidate()
	end
end

-- Add a widget to the view, because clearly we like clutter. Also handles focus logic.
function View:add(o)
	table.insert(self.widgetList, o)
	self:repos(o)
	if o.acceptsFocus then
		table.insert(self.focusList, 1, o)
		if self.currentFocus > 0 then
			self.currentFocus = self.currentFocus + 1
		end
	end
	return o
end

-- Remove a widget from the view, and try to pretend nothing ever happened.
function View:remove(o)
	if self:getFocus() == o then
		o:releaseFocus()
	end
	local i = 1
	local f = 0
	while i <= #self.focusList do
		if self.focusList[i] == o then
			f = i
		end
		i = i + 1
	end
	if f > 0 then
		if self:getFocus() == o then
			self:tabForward()
		end
		table.remove(self.focusList, f)
		if self.currentFocus > f then
			self.currentFocus = self.currentFocus - 1
		end
	end
	f = 0
	i = 1
	while i <= #self.widgetList do
		if self.widgetList[i] == o then
			f = i
		end
		i = i + 1
	end
	if f > 0 then
		table.remove(self.widgetList, f)
	end
end

-- Reposition and resize a widget according to its constraints. Because pixel-perfect UIs are for the weak.
function View:repos(o)
	local x = o.x
	local y = o.y
	local w = o.w
	local h = o.h
	if o.hConstraint == "right" then
		x = scrWidth - o.w - o.dx1
	elseif o.hConstraint == "center" then
		x = (scrWidth - o.w + o.dx1) / 2
	elseif o.hConstraint == "justify" then
		w = scrWidth - o.x - o.dx1
	end
	if o.vConstraint == "bottom" then
		y = scrHeight - o.h - o.dy1
	elseif o.vConstraint == "middle" then
		y = (scrHeight - o.h + o.dy1) / 2
	elseif o.vConstraint == "justify" then
		h = scrHeight - o.y - o.dy1
	end
	o:repos(x, y)
	o:resize(w, h)
end

-- Resize all widgets in the view. Hope they like their new size.
function View:resize()
	for _, o in ipairs(self.widgetList) do
		self:repos(o)
	end
end

-- Hide a widget. Out of sight, out of mind (and out of focus).
function View:hide(o)
	if o.visible then
		o.visible = false
		self:releaseFocus(o)
		if o:contains(self.prev_mousex, self.prev_mousey) then
			o:onMouseLeave(o.x - 1, o.y - 1)
		end
		self:invalidate()
	end
end

-- Show a widget. If it was invisible, now it can bask in the user's gaze.
function View:show(o)
	if not o.visible then
		o.visible = true
		if o:contains(self.prev_mousex, self.prev_mousey) then
			o:onMouseEnter(self.prev_mousex, self.prev_mousey)
		end
		self:invalidate()
	end
end

-- Return the currently focused widget, or nil if nothing bothers to have focus.
function View:getFocus()
	if self.currentFocus == 0 then
		return nil
	end
	return self.focusList[self.currentFocus]
end

-- Give focus to a widget, and make everyone else jealous.
function View:setFocus(obj)
	if self.currentFocus ~= 0 then
		if self.focusList[self.currentFocus] == obj then
			return
		end
		self.focusList[self.currentFocus]:releaseFocus()
	end
	self.currentFocus = 0
	for i = 1, #self.focusList do
		if self.focusList[i] == obj then
			self.currentFocus = i
			obj:setFocus()
			self:invalidate()
			break
		end
	end
end

-- Take focus away from a widget. It probably didn't deserve it anyway.
function View:releaseFocus(obj)
	if self.currentFocus ~= 0 then
		if self.focusList[self.currentFocus] == obj then
			self.currentFocus = 0
			obj:releaseFocus()
			self:invalidate()
		end
	end
end

-- Send a string to the focused widget, or desperately try to find anyone who will take it.
function View:sendStringToFocus(str)
	local o = self:getFocus()
	if not o then
		o = defaultFocus
		self:setFocus(o)
	end
	if o then
		if o.visible then
			if o:addString(str) then
				self:invalidate()
			else
				o = nil
			end
		end
	end

	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible then
				if o:addString(str) then
					self:setFocus(o)
					self:invalidate()
					break
				end
			end
		end
	end
end

-- Handle backspace for the focused widget, or for anyone who claims to accept it.
function View:backSpaceHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsBackSpace then
			o:backSpaceHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsBackSpace then
				o:backSpaceHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Move focus to the next widget, looping around. Because tab order is a suggestion, not a rule.
function View:tabForward()
	local nextFocus = self.currentFocus + 1
	if nextFocus > #self.focusList then
		nextFocus = 1
	end
	self:setFocus(self.focusList[nextFocus])
	if self:getFocus() then
		if not self:getFocus().visible then
			self:tabForward()
		end
	end
	self:invalidate()
end

-- Move focus to the previous widget, looping around. For the rebels who like shift+tab.
function View:tabBackward()
	local nextFocus = self.currentFocus - 1
	if nextFocus < 1 then
		nextFocus = #self.focusList
	end
	self:setFocus(self.focusList[nextFocus])
	if not self:getFocus().visible then
		self:tabBackward()
	end
	self:invalidate()
end

-- Handle mouse down events, capturing the widget that gets clicked (and focus).
function View:onMouseDown(x, y)
	for _, o in ipairs(self.widgetList) do
		if o.visible and o.acceptsFocus and o:contains(x, y) then
			self.mouseCaptured = o
			o:onMouseDown(x - o.x, y - o.y)
			self:setFocus(o)
			self:invalidate()
			return
		end
	end
	if self:getFocus() then
		self:setFocus(nil)
		self:invalidate()
	end
end

-- Handle mouse move events, triggering enter/leave events for widgets. Because hover states are important.
function View:onMouseMove(x, y)
	local prev_mousex = self.prev_mousex
	local prev_mousey = self.prev_mousey
	for _, o in ipairs(self.widgetList) do
		local xyin = o:contains(x, y)
		local prev_xyin = o:contains(prev_mousex, prev_mousey)
		if xyin and not prev_xyin and o.visible then
			o:onMouseEnter(x, y)
			self:invalidate()
		elseif prev_xyin and (not xyin or not o.visible) then
			o:onMouseLeave(x, y)
			self:invalidate()
		end
	end
	self.prev_mousex = x
	self.prev_mousey = y
end

-- Handle mouse up events, releasing the widget that was so rudely pressed.
function View:onMouseUp(x, y)
	local mc = self.mouseCaptured
	if mc then
		self.mouseCaptured = nil
		if mc:contains(x, y) then
			mc:onMouseUp(x - mc.x, y - mc.y)
		end
	end
end

-- Handle "enter" key for the focused widget, or anyone who cares.
function View:enterHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsEnter then
			o:enterHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsEnter then
				o:enterHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle left arrow key for the focused widget, or anyone who wants to move left in life.
function View:arrowLeftHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowLeft then
			o:arrowLeftHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowLeft then
				o:arrowLeftHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle right arrow key for the focused widget, or anyone who wants to move right in life.
function View:arrowRightHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowRight then
			o:arrowRightHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowRight then
				o:arrowRightHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle up arrow key for the focused widget. Because up is the new down.
function View:arrowUpHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowUp then
			o:arrowUpHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowUp then
				o:arrowUpHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle down arrow key for the focused widget. Because down is the new up.
function View:arrowDownHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowDown then
			o:arrowDownHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowDown then
				o:arrowDownHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Paint all widgets to the screen, highlight the focused one, and set the cursor.
function View:paint(gc)
	local fo = self:getFocus()
	for _, o in ipairs(self.widgetList) do
		if o.visible then
			o:paint(gc, fo == o)
			if fo == o then
				gc:setColorRGB(100, 150, 255)
				gc:drawRect(o.x - 1, o.y - 1, o.w + 1, o.h + 1)
				gc:setPen("thin", "smooth")
				gc:setColorRGB(0, 0, 0)
			end
		end
	end
	cursor.set(self.currentCursor)
end

theView = nil

-- Widget base class. All widgets inherit from this, like it or not.
Widget = class()

function Widget:setHConstraints(hConstraint, dx1)
	self.hConstraint = hConstraint
	self.dx1 = dx1
end

function Widget:setVConstraints(vConstraint, dy1)
	self.vConstraint = vConstraint
	self.dy1 = dy1
end

function Widget:init(view, x, y, w, h)
	self.xOrig = x
	self.yOrig = y
	self.view = view
	self.x = x
	self.y = y
	self.w = w
	self.h = h
	self.acceptsFocus = false
	self.visible = true
	self.acceptsEnter = false
	self.acceptsEscape = false
	self.acceptsTab = false
	self.acceptsDelete = false
	self.acceptsBackSpace = false
	self.acceptsReturn = false
	self.acceptsArrowUp = false
	self.acceptsArrowDown = false
	self.acceptsArrowLeft = false
	self.acceptsArrowRight = false
	self.hConstraint = "left"
	self.vConstraint = "top"
    
end

function Widget:repos(x, y)
	self.x = x
	self.y = y
end

function Widget:resize(w, h)
	self.w = w
	self.h = h
end

function Widget:setFocus() end
function Widget:releaseFocus() end

function Widget:contains(x, y)
 
    return x >= self.x and x < self.x + self.w and y >= self.y and y < self.y + self.h
end

function Widget:onMouseEnter(x, y) end
function Widget:onMouseLeave(x, y) end
function Widget:paint(gc, focused) end
function Widget:enterHandler() end
function Widget:escapeHandler() end
function Widget:tabHandler() end
function Widget:deleteHandler() end
function Widget:backSpaceHandler() end
function Widget:returnHandler() end
function Widget:arrowUpHandler() end
function Widget:arrowDownHandler() end
function Widget:arrowLeftHandler() end
function Widget:arrowRightHandler() end
function Widget:onMouseDown(x, y) end
function Widget:onMouseUp(x, y) end

-- Button widget, for people who like clicking things.
Button = class(Widget)

function Button:init(view, x, y, w, h, default, command, shortcut)
	Widget.init(self, view, x, y, w, h)
	self.acceptsFocus = true
	self.command = command or function() end
	self.default = default
	self.shortcut = shortcut
	self.clicked = false
	self.highlighted = false
	self.acceptsEnter = true
end

function Button:enterHandler()
	if self.acceptsEnter then
		self:command()
	end
end

function Button:escapeHandler()
	if self.acceptsEscape then
		self:command()
	end
end

function Button:tabHandler()
	if self.acceptsTab then
		self:command()
	end
end

function Button:deleteHandler()
	if self.acceptsDelete then
		self:command()
	end
end

function Button:backSpaceHandler()
	if self.acceptsBackSpace then
		self:command()
	end
end

function Button:returnHandler()
	if self.acceptsReturn then
		self:command()
	end
end

function Button:arrowUpHandler()
	if self.acceptsArrowUp then
		self:command()
	end
end

function Button:arrowDownHandler()
	if self.acceptsArrowDown then
		self:command()
	end
end

function Button:arrowLeftHandler()
	if self.acceptsArrowLeft then
		self:command()
	end
end

function Button:arrowRightHandler()
	if self.acceptsArrowRight then
		self:command()
	end
end

function Button:onMouseDown(x, y)
	self.clicked = true
	self.highlighted = true
end

function Button:onMouseEnter(x, y)
	theView:setCursor("hand pointer")
	if self.clicked and not self.highlighted then
		self.highlighted = true
	end
end

function Button:onMouseLeave(x, y)
	theView:setCursor("default")
	if self.clicked and self.highlighted then
		self.highlighted = false
	end
end

function Button:cancelClick()
	if self.clicked then
		self.highlighted = false
		self.clicked = false
	end
end

function Button:onMouseUp(x, y)
	self:cancelClick()
	self:command()
end

function Button:addString(str)
	if str == " " or str == self.shortcut then
		self:command()
		return true
	end
	return false
end

-- Image label widget. Displays an image, does nothing else. The laziest widget.
ImgLabel = class(Widget)

function ImgLabel:init(view, x, y, img)
	self.img = image.new(img)
	self.w = image.width(self.img)
	self.h = image.height(self.img)
	Widget.init(self, view, x, y, self.w, self.h)
end

function ImgLabel:paint(gc, focused)
	gc:drawImage(self.img, self.x, self.y)
end

-- Image button widget. Like a button, but with more pixels.
ImgButton = class(Button)

function ImgButton:init(view, x, y, img, command, shortcut)
	self.img = image.new(img)
	self.w = image.width(self.img)
	self.h = image.height(self.img)
	Button.init(self, view, x, y, self.w, self.h, false, command, shortcut)
end

function ImgButton:paint(gc, focused)
	gc:drawImage(self.img, self.x, self.y)
end

-- Text button widget. For those who prefer words to icons.
TextButton = class(Button)

function TextButton:init(view, x, y, text, command, shortcut)
	self.textid = text
	self.text = getLocaleText(text)
	self:resize(0, 0)
	Button.init(self, view, x, y, self.w, self.h, false, command, shortcut)
end

function TextButton:resize(w, h)
	self.text = getLocaleText(self.textid)
	self.w = getStringWidth(self.text) + 5
	self.h = getStringHeight(self.text) + 5
end

function TextButton:paint(gc, focused)
	gc:setColorRGB(223, 223, 223)
	gc:drawRect(self.x + 1, self.y + 1, self.w - 2, self.h - 2)
	gc:setColorRGB(191, 191, 191)
	gc:fillRect(self.x + 1, self.y + 1, self.w - 3, self.h - 3)
	gc:setColorRGB(223, 223, 223)
	gc:drawString(self.text, self.x + 3, self.y + 3, "top")
	gc:setColorRGB(0, 0, 0)
	gc:drawString(self.text, self.x + 2, self.y + 2, "top")
	gc:drawRect(self.x, self.y, self.w - 2, self.h - 2)
end

-- Vertical scrollbar widget. Because scrolling through history is a thing.
VScrollBar = class(Widget)

function VScrollBar:init(view, x, y, w, h)
	self.pos = 10
	self.siz = 10
	Widget.init(self, view, x, y, w, h)
end

function VScrollBar:paint(gc, focused)
	gc:setColorRGB(0, 0, 0)
	gc:drawRect(self.x, self.y, self.w, self.h)
	gc:fillRect(self.x + 2, self.y + self.h - (self.h - 4) * (self.pos + self.siz) / 100 - 2, self.w - 3, math.max(1, (self.h - 4) * self.siz / 100 + 1))
end

-- Text label widget. It just sits there and looks pretty.
TextLabel = class(Widget)

function TextLabel:init(view, x, y, text)
	self:setText(text)
	Widget.init(self, view, x, y, self.w, self.h)
end

function TextLabel:resize(w, h)
	self.text = getLocaleText(self.textid)
	self.w = getStringWidth(self.text)
	self.h = getStringHeight(self.text)
end

function TextLabel:setText(text)
	self.textid = text
	self.text = getLocaleText(text)
	self:resize(0, 0)
end

function TextLabel:getText()
	return self.text
end

function TextLabel:paint(gc, focused)
	gc:setColorRGB(0, 0, 0)
	gc:drawString(self.text, self.x, self.y, "top")
end
-- TextBox widget for text input
TextBox = class(Widget)
function TextBox:init(view, x, y, w, h, text)
    self.text = text or ""
    self.cursor = #self.text
    self.focused = false
    self.acceptsFocus = true
    self.acceptsChar = true
    self.acceptsBackspace = true
    self.acceptsEnter = true
    Widget.init(self, view, x, y, w, h)
end

function TextBox:paint(gc, focused)
    -- Draw border
    gc:setColorRGB(0, 0, 0)
    gc:drawRect(self.x, self.y, self.w, self.h)
    
    -- Draw background
    if focused then
        gc:setColorRGB(255, 255, 255)
    else
        gc:setColorRGB(240, 240, 240)
    end
    gc:fillRect(self.x + 1, self.y + 1, self.w - 2, self.h - 2)
    
    -- Draw text
    gc:setColorRGB(0, 0, 0)
    gc:drawString(self.text, self.x + 3, self.y + 3, "top")
    
    -- Draw cursor if focused
    if focused then
        local cursorX = self.x + 3 + getStringWidth(string.sub(self.text, 1, self.cursor))
        gc:drawLine(cursorX, self.y + 2, cursorX, self.y + self.h - 3)
    end
end

function TextBox:charIn(char)
    self.text = string.sub(self.text, 1, self.cursor) .. char .. string.sub(self.text, self.cursor + 1)
    self.cursor = self.cursor + 1
    self.view:invalidate()
end

function TextBox:backspaceKey()
    if self.cursor > 0 then
        self.text = string.sub(self.text, 1, self.cursor - 1) .. string.sub(self.text, self.cursor + 1)
        self.cursor = self.cursor - 1
        self.view:invalidate()
    end
end

function TextBox:setText(text)
    self.text = text or ""
    self.cursor = #self.text
    self.view:invalidate()
end

function TextBox:getText()
    return self.text
end

-- CheckBox widget
CheckBox = class(Widget)
function CheckBox:init(view, x, y, text, checked)
    self.textid = text
    self.text = getLocaleText(text)
    self.checked = checked or false
    self.acceptsFocus = true
    self.acceptsEnter = true
    
    local boxSize = 12
    local textWidth = getStringWidth(self.text)
    local w = boxSize + 5 + textWidth
    local h = math.max(boxSize, getStringHeight(self.text))
    
    Widget.init(self, view, x, y, w, h)
end

function CheckBox:paint(gc, focused)
    local boxSize = 12
    
    -- Draw checkbox
    gc:setColorRGB(0, 0, 0)
    gc:drawRect(self.x, self.y, boxSize, boxSize)
    gc:setColorRGB(255, 255, 255)
    gc:fillRect(self.x + 1, self.y + 1, boxSize - 2, boxSize - 2)
    
    -- Draw check mark if checked
    if self.checked then
        gc:setColorRGB(0, 0, 0)
        gc:drawLine(self.x + 2, self.y + 6, self.x + 5, self.y + 9)
        gc:drawLine(self.x + 5, self.y + 9, self.x + 10, self.y + 3)
    end
    
    -- Draw text
    gc:setColorRGB(0, 0, 0)
    gc:drawString(self.text, self.x + boxSize + 5, self.y, "top")
    
    -- Draw focus indicator
    if focused then
        gc:setColorRGB(0, 0, 255)
        gc:drawRect(self.x - 1, self.y - 1, self.w + 2, self.h + 2)
    end
end

function CheckBox:enterKey()
    self.checked = not self.checked
    self.view:invalidate()
end

-- --- START OF CHANGE ---
-- Renamed from CheckBox:mouseDown to CheckBox:onMouseUp
function CheckBox:onMouseUp(relX, relY, releasedInside)
    if releasedInside then
        self.checked = not self.checked
        self.view:invalidate()
    end
end
-- --- END OF CHANGE ---
-- Dialog base class, inheriting from Widget
Dialog = class(Widget)
function Dialog:init(view, config)
    -- Default configuration values for the dialog
    local title = config.title or "Dialog"
    local w = config.width or 300
    local h = config.height or 200
    local elements = config.elements or {}
    self.onClose = config.onClose -- Store the custom onClose function

    -- Calculate dialog position to be centered on the screen
    local x = math.floor((platform.window:width() - w) / 2)
    local y = math.floor((platform.window:height() - h) / 2)

    -- Initialize the base Widget properties
    Widget.init(self, view, x, y, w, h)

    self.title = title
    self.modal = true         -- Dialog is modal, meaning it captures all input
    self.visible = true       -- Dialog starts as visible
    self.acceptsFocus = true  -- Dialog can gain keyboard focus
    self.acceptsEscape = true -- Allow Escape key to close the dialog
    self.widgets = {}         -- Table to hold child widgets managed by this dialog
    self.result = nil         -- To store dialog's return value (e.g., true for OK, false for Cancel)
    self.namedWidgets = {}    -- NEW: Table to store child widgets by their 'name' property

    for i, elem_config in ipairs(elements) do
        local widget
        -- Instantiate widget types based on their 'type' property in the config
        if elem_config.type == "TextLabel" then
            widget = TextLabel(view, elem_config.x, elem_config.y, elem_config.text)
        elseif elem_config.type == "TextButton" then
            local original_command = elem_config.command or function(dlg_ref, btn_ref) end -- Default command, receives dialog and button
            widget = TextButton(view, elem_config.x, elem_config.y, elem_config.text,
                function(btn_self) -- 'btn_self' is the TextButton instance being clicked
                    -- Pass the dialog instance (self) and the button instance (btn_self) to the original command
                    original_command(self, btn_self)
                    -- If the button is configured to close the dialog, call close()
                    if elem_config.closesDialog then
                        self:close(true)
                    end
                end)
        elseif elem_config.type == "CheckBox" then
            widget = CheckBox(view, elem_config.x, elem_config.y, elem_config.text, elem_config.checked)
            -- The existing special handling for checkbox by 'checkbox_' prefix can remain or be unified
        end

        -- If a widget was successfully created, add it to the dialog's managed widgets
        if widget then
            self:addWidget(widget)
            -- NEW: Store a reference to the widget by its 'name' property for easy access
            if elem_config.name then
                self.namedWidgets[elem_config.name] = widget
            end
        end
    end
end

-- Paint method for the Dialog. This draws the dialog frame and its contents.
function Dialog:paint(gc, focused)
    -- Draw a subtle shadow effect
    gc:setColorRGB(128, 128, 128)
    gc:fillRect(self.x + 3, self.y + 3, self.w, self.h)

    -- Draw dialog background (light gray)
    gc:setColorRGB(240, 240, 240)
    gc:fillRect(self.x, self.y, self.w, self.h)

    -- Draw dialog border (black)
    gc:setColorRGB(0, 0, 0)
    gc:drawRect(self.x, self.y, self.w, self.h)

    -- Draw title bar (dark blue)
    gc:setColorRGB(0, 0, 128)
    gc:fillRect(self.x + 1, self.y + 1, self.w - 2, 20)
    gc:setColorRGB(255, 255, 255) -- White text for title
    gc:drawString(self.title, self.x + 5, self.y + 4, "top")

    -- Draw a line under the title bar
    gc:setColorRGB(0, 0, 0)
    gc:drawLine(self.x + 1, self.y + 21, self.x + self.w - 2, self.y + 21)

    -- Paint all child widgets relative to the dialog's position
    for _, widget in ipairs(self.widgets) do
        if widget.visible then
            -- Pass the correct focused state to the child widget
            local is_child_focused = (self.view:getFocus() == widget)
            widget:paint(gc, is_child_focused)
        end
    end
end

-- Adds a child widget to the dialog's management.
function Dialog:addWidget(widget)
    table.insert(self.widgets, widget)
    widget.parent = self -- Set the dialog as the widget's parent
    
    -- Adjust widget's position to be relative to the dialog's top-left corner
    widget.x = self.x + widget.xOrig
    widget.y = self.y + widget.yOrig
    
    -- THIS IS THE LINE CAUSING THE CONFLICT. REMOVE OR COMMENT IT OUT.
    -- By removing this, we make the Dialog the exclusive parent. The main view
    -- will no longer know about the individual child widgets, only the Dialog.
    -- self.view:add(widget)     
    
    self.view:repos(widget)   -- This might not be necessary anymore, but let's leave it.
end



-- Activates the dialog, making it visible and focusable.
function Dialog:activate()
    self.visible = true
    -- Set this dialog as the active modal dialog for the view
    self.view.activeModalDialog = self

    print("--- [DEBUG] Dialog:activate() - Attempting to hide all MathEditors ---")

    -- HIDE MAIN INPUT EDITOR
    if fctEditor and fctEditor.editor then
        fctEditor.editor:setVisible(false)
        print("[DEBUG] Hidden fctEditor (main input editor).")
    else
        print("[DEBUG] fctEditor or its editor is NIL/invalid during Dialog:activate.")
    end

    -- HIDE HISTORY INPUT EDITORS
    local hidden_hist1_count = 0
    for i, me in ipairs(histME1) do
        if me and me.editor then
            me.editor:setVisible(false)
            -- Optional: Uncomment for extreme verbosity, might spam console for long history
            -- print("[DEBUG] Hidden histME1[" .. i .. "] editor (input): " .. (me.editor:getText() or "N/A"))
            hidden_hist1_count = hidden_hist1_count + 1
        else
            print("[DEBUG] histME1[" .. i .. "] is NIL/invalid during Dialog:activate.")
        end
    end
    print("[DEBUG] Total hidden histME1 editors:", hidden_hist1_count, "/", #histME1)

    -- HIDE HISTORY RESULT EDITORS
    local hidden_hist2_count = 0
    for i, me in ipairs(histME2) do
        if me and me.editor then
            me.editor:setVisible(false)
            -- Optional: Uncomment for extreme verbosity
            -- print("[DEBUG] Hidden histME2[" .. i .. "] editor (result): " .. (me.editor:getText() or "N/A"))
            hidden_hist2_count = hidden_hist2_count + 1
        else
            print("[DEBUG] histME2[" .. i .. "] is NIL/invalid during Dialog:activate.")
        end
    end
    print("[DEBUG] Total hidden histME2 editors:", hidden_hist2_count, "/", #histME2)

    -- Set focus to the first focusable widget within the dialog (for keyboard nav)
    for _, widget in ipairs(self.widgets) do
        if widget.acceptsFocus then
            self.view:setFocus(widget)
            break
        end
    end
    self.view:invalidate() -- Request a screen redraw
end


-- Closes the dialog, making it invisible and removing its widgets from the view.
function Dialog:close(result)
    self.result = result
    self.visible = false
    if self.view.activeModalDialog == self then
        self.view.activeModalDialog = nil
    end

    self.view:remove(self)
    for _, widget in ipairs(self.widgets) do
        self.view:remove(widget)
    end
    if self.onClose then
        self.onClose(self, result)
    end

    print("--- [DEBUG] Dialog:close() - Attempting to show all MathEditors ---")

    -- SHOW MAIN INPUT EDITOR
    if fctEditor and fctEditor.editor then
        fctEditor.editor:setVisible(true)
        print("[DEBUG] Shown fctEditor (main input editor).")
    else
        print("[DEBUG] fctEditor or its editor is NIL/invalid during Dialog:close.")
    end

    -- SHOW HISTORY INPUT EDITORS
    local shown_hist1_count = 0
    for i, me in ipairs(histME1) do
        if me and me.editor then
            me.editor:setVisible(true)
            -- Optional: Uncomment for extreme verbosity
            -- print("[DEBUG] Shown histME1[" .. i .. "] editor (input): " .. (me.editor:getText() or "N/A"))
            shown_hist1_count = shown_hist1_count + 1
        else
            print("[DEBUG] histME1[" .. i .. "] is NIL/invalid during Dialog:close.")
        end
    end
    print("[DEBUG] Total shown histME1 editors:", shown_hist1_count, "/", #histME1)

    -- SHOW HISTORY RESULT EDITORS
    local shown_hist2_count = 0
    for i, me in ipairs(histME2) do
        if me and me.editor then
            me.editor:setVisible(true)
            -- Optional: Uncomment for extreme verbosity
            -- print("[DEBUG] Shown histME2[" .. i .. "] editor (result): " .. (me.editor:getText() or "N/A"))
            shown_hist2_count = shown_hist2_count + 1
        else
            print("[DEBUG] histME2[" .. i .. "] is NIL/invalid during Dialog:close.")
        end
    end
    print("[DEBUG] Total shown histME2 editors:", shown_hist2_count, "/", #histME2)

    self.view:invalidate()
end


-- Corrected Dialog:onMouseDown
function Dialog:onMouseDown(x, y)
    -- Iterate through widgets from top to bottom (reverse order)
    for i = #self.widgets, 1, -1 do
        local widget = self.widgets[i]
        -- Check if widget is visible, accepts focus, and contains the click coordinates
        if widget.visible and widget.acceptsFocus and widget:contains(x, y) then
            -- If the widget has its own onMouseDown handler, call it, passing coordinates relative to the widget
            if widget.onMouseDown then
                widget:onMouseDown(x - widget.x, y - widget.y)
            end
            -- Set focus to the clicked widget and invalidate the window for redraw
            self.view:setFocus(widget)
            self.view:invalidate()
            return -- Exit after handling the click on one widget
        end
    end
    -- If no child widget was clicked, check if the dialog itself was clicked
    if self:contains(x, y) then
        self.view:setFocus(self)
        self.view:invalidate()
    end
end

-- Corrected Dialog:onMouseUp
function Dialog:onMouseUp(x, y)
    -- Iterate through widgets from top to bottom (reverse order)
    for i = #self.widgets, 1, -1 do
        local widget = self.widgets[i]
        -- Check if widget is visible, contains the release coordinates, and has an onMouseUp handler
        if widget.visible and widget:contains(x, y) and widget.onMouseUp then
            -- Call the widget's onMouseUp handler, passing relative coordinates and whether it was released inside
            widget:onMouseUp(x - widget.x, y - widget.y, widget:contains(x,y))
            return -- Exit after handling the release on one widget
        end
    end
end
---
-- Wipes any widgets that are marked as dynamic page content.
-- This is the "reset" button for our pagination.
function Dialog:clearPageContent()
    local widgets_to_keep = {}
    for i, widget in ipairs(self.widgets) do
        -- We'll mark our page-specific widgets with a flag.
        -- If a widget doesn't have this flag, it gets to live.
        if not widget.isPageContent then
            table.insert(widgets_to_keep, widget)
        else
            -- For the widgets we're destroying, remove them from the main view first.
            -- This is CRITICAL to prevent them from becoming orphaned zombies.
            self.view:remove(widget)
        end
    end
    -- Replace the old widget list with the cleansed one.
    self.widgets = widgets_to_keep
end

---
-- Draws the content for a specific page.

function Dialog:updatePage(pageNumber)
    self.currentPage = pageNumber

    -- 1. NUKE THE OLD CONTENT
    self:clearPageContent()

    -- Some constants for layout.
    local contentPaddingX = 20
    local lineHeight = 18
    local currentY = self.contentStartY -- Use the value set in the other function.

    -- 2. ADD THE NEW CONTENT (the steps for this page)
    local startIndex = (self.currentPage - 1) * self.itemsPerPage + 1
    local endIndex = math.min(self.currentPage * self.itemsPerPage, #self.steps)

    for i = startIndex, endIndex do
        local stepLabel = TextLabel(self.view, contentPaddingX, currentY, string.format("%d. %s", i, self.steps[i].description))
        stepLabel.isPageContent = true
        self:addWidget(stepLabel)
        currentY = currentY + lineHeight
    end

    -- 3. ADD THE NAVIGATION CONTROLS (at the bottom)
    local navY = self.footerControlsY -- Use the pre-calculated Y position for vertical alignment.
    local currentX = contentPaddingX  -- Start drawing from the left.

    -- "Previous" Button
    if self.currentPage > 1 then
        local prevBtn = TextButton(self.view, currentX, navY, "< Prev", function() self:updatePage(self.currentPage - 1) end)
        prevBtn.isPageContent = true
        self:addWidget(prevBtn)
        currentX = currentX + prevBtn.w + 15 -- Move X for the next element
    end

    -- Page Indicator Label (only if there's more than one page)
    if self.totalPages > 1 then
        local pageIndicator = string.format("Page %d of %d", self.currentPage, self.totalPages)
        local pageLabel = TextLabel(self.view, currentX, navY + 4, pageIndicator) -- +4 for text alignment
        pageLabel.isPageContent = true
        self:addWidget(pageLabel)
        currentX = currentX + getStringWidth(pageIndicator) + 15
    end

    -- "Next" Button
    if self.currentPage < self.totalPages then
        local nextBtn = TextButton(self.view, currentX, navY, "Next >", function() self:updatePage(self.currentPage + 1) end)
        nextBtn.isPageContent = true
        self:addWidget(nextBtn)
    end
    
    self.view:invalidate()
end
-- Handles the Escape key press for the dialog (if acceptsEscape is true).
function Dialog:escapeHandler()
    if self.acceptsEscape then
        self:close(false) -- False indicates dialog was cancelled/escaped
    end
end
-- Closes the dialog, making it invisible and removing its widgets from the view.
function Dialog:close(result)
    self.result = result
    self.visible = false

    -- CRITICAL FIX: Reset the active modal dialog in the view
    if self.view.activeModalDialog == self then
        self.view.activeModalDialog = nil
    end

    -- Remove the dialog itself from the main view's tracking
    self.view:remove(self)

    -- Remove all child widgets from the main view's tracking
    for _, widget in ipairs(self.widgets) do
        self.view:remove(widget)
    end

    -- Call the custom onClose callback function if provided
    if self.onClose then
        self.onClose(self, result)
    end

    -- SHOW ALL D2EDITORS (fctEditor and history editors) WHEN A DIALOG CLOSES
    if fctEditor and fctEditor.editor then
        fctEditor.editor:setVisible(true)
    end
    for _, me in ipairs(histME1) do
        if me.editor then me.editor:setVisible(true) end
    end
    for _, me in ipairs(histME2) do
        if me.editor then me.editor:setVisible(true) end
    end

    self.view:invalidate() -- Request a screen redraw
end


MenuWidget = class(Widget)

function MenuWidget:init(view, x, y, items, onSelect)
    local w = 120
    local h = #items * 22
    Widget.init(self, view, x, y, w, h)
    self.items = items or {}
    self.selected = 1
    self.onSelect = onSelect or function(idx, text) end
    self.visible = true
    self.acceptsFocus = true
    self.acceptsArrowUp = true
    self.acceptsArrowDown = true
    self.acceptsEnter = true
    self.acceptsEscape = true
    self.muted = false
    self.submenus = nil
end

function MenuWidget:paint(gc, focused)
    if not self.visible then return end

    -- Menu background - because invisible menus are so last century
    local bgColor = _G.darkMode and {40, 40, 40} or {255, 255, 255}
    if self.muted then for i=1,3 do bgColor[i] = bgColor[i] * 0.6 end end
    gc:setColorRGB(table.unpack(bgColor))
    gc:fillRect(self.x, self.y, self.w, self.h)

    -- Menu border - the thin line between chaos and order
    gc:setColorRGB(0, 0, 0)
    gc:drawRect(self.x, self.y, self.w, self.h)

    -- Menu items - the actual reason this thing exists
    for i, text in ipairs(self.items) do
        local itemY = self.y + (i-1) * 22

        -- Highlight selected item
        if i == self.selected then
            gc:setColorRGB(180, 200, 255)
            gc:fillRect(self.x + 1, itemY + 1, self.w - 2, 20)
        end

        gc:setFont("sansserif", "r", 11)
        gc:setColorRGB(_G.darkMode and 180 or 32, _G.darkMode and 180 or 32, _G.darkMode and 210 or 32)

        -- Decorative Icon on root menu only
        if self.level == 1 then
            -- Precise vertical centering for icon and text
            local iconX = self.x + 6
            local iconText = ""
            if text == "Calculus" then
                iconText = "∫"
            elseif text == "Solve" then
                iconText = "x"
            elseif text == "Settings" then
                iconText = "S"
            elseif text == "Help" then
                iconText = "?"
            end
            gc:setFont("sansserif", "b", 10)
            local ih = gc:getStringHeight(iconText)
            gc:setFont("sansserif", "r", 11)
            local th = gc:getStringHeight(text)
            local iconY = itemY + (th - ih) / 2 - 1
            gc:setFont("sansserif", "b", 10)
            gc:drawString(iconText, iconX, iconY, "top")
            gc:setFont("sansserif", "r", 11)
            gc:drawString(text, self.x + 22, itemY - 1, "top")
        else
            gc:drawString(text, self.x + 12, itemY - 1, "top")
        end

        if self.submenus and self.submenus[text] then
            gc:setFont("sansserif","b",11)
            local arrowCol = _G.darkMode and {200,200,200} or {64,64,64}
            gc:setColorRGB(table.unpack(arrowCol))
            gc:drawString("▶", self.x + self.w - 12, itemY - 1, "top")
        end
    end
end

function MenuWidget:onMouseDown(view, window, x, y)
    if not self:contains(x + self.x, y + self.y) then return end
    
    local relY = y
    local idx = math.floor(relY / 22) + 1
    
    if idx >= 1 and idx <= #self.items then
        self.selected = idx
        if self.onSelect then 
            self.onSelect(idx, self.items[idx]) 
        end
    end
    
    local text = self.items[self.selected]
    -- Only hide when there is no submenu for this item
    if not (self.submenus and self.submenus[text]) then
        self.visible = false
        if self.view and self.view.invalidate then
            self.view:invalidate()
        end
    end
end

function MenuWidget:arrowUpHandler()
    self.selected = math.max(1, self.selected - 1)
    if self.view and self.view.invalidate then
        self.view:invalidate()
    end
end

function MenuWidget:arrowDownHandler()
    self.selected = math.min(#self.items, self.selected + 1)
    if self.view and self.view.invalidate then
        self.view:invalidate()
    end
end

function MenuWidget:enterHandler()
    if self.onSelect then 
        self.onSelect(self.selected, self.items[self.selected]) 
    end
    self.visible = false
    if self.view and self.view.invalidate then 
        self.view:invalidate() 
    end
end

function MenuWidget:escapeHandler()
    self.visible = false
    if self.view and self.view.invalidate then 
        self.view:invalidate() 
    end
end
-- Rich text editor widget. Handles text entry, but don't expect Microsoft Word.
RichTextEditor = class(Widget)

function RichTextEditor:init(view, x, y, w, h, text)
	self.editor = D2Editor.newRichText()
	self.readOnly = false
	self:repos(x, y)
	self.editor:setFontSize(fsize)
	self.editor:setFocus(false)
	self.text = text
	self:resize(w, h)
	Widget.init(self, view, x, y, self.w, self.h, true)
	self.acceptsFocus = true
	self.editor:setExpression(text)
	self.editor:setBorder(1)
end

function RichTextEditor:onMouseEnter(x, y)
	theView:setCursor("text")
end

function RichTextEditor:onMouseLeave(x, y)
	theView:setCursor("default")
end

function RichTextEditor:repos(x, y)
	if not self.editor then return end
	self.editor:setBorderColor((showEditorsBorders and 0) or 0xffffff )
	self.editor:move(x, y)
	Widget.repos(self, x, y)
end

function RichTextEditor:resize(w, h)
	if not self.editor then return end
	self.editor:resize(w, h)
	Widget.resize(self, w, h)
end

function RichTextEditor:setFocus()
	self.editor:setFocus(true)
end

function RichTextEditor:releaseFocus()
	self.editor:setFocus(false)
end

function RichTextEditor:addString(str)
	local currentText = self.editor:getText() or ""
	self.editor:setText(currentText .. str)
	return true
end

function RichTextEditor:paint(gc, focused) end

-- MathEditor: a rich text editor with math-specific quirks and a love for Unicode.
MathEditor = class(RichTextEditor)

-- Returns the number of Unicode codepoints in a string.
-- Because Lua strings are byte-based and Unicode is hard.
function ulen(str)
	if not str then return 0 end
	local n = string.len(str)
	local i = 1
	local j = 1
	local c
	while (j <= n) do
		c = string.len(string.usub(str, i, i))
		j = j + c
		i = i + 1
	end
	return i - 1
end

-- Initialize a MathEditor, set up filters for key events, and generally make life complicated.
function MathEditor:init(view, x, y, w, h, text)
	RichTextEditor.init(self, view, x, y, w, h, text)
	self.editor:setBorder(1)
    -- Set dark/light mode colors at initialization, safely and consistently
    if self.editor then
        local areaBg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
        local areaBorder = _G.darkMode and {100, 100, 100} or {0, 0, 0}
        local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
        if self.editor.setBackgroundColor then
            self.editor:setBackgroundColor(table.unpack(areaBg))
        end
        if self.editor.setTextColor then
            self.editor:setTextColor(table.unpack(text))
        end
        if self.editor.setBorderColor then
            self.editor:setBorderColor(table.unpack(areaBorder))
        end
        if self.editor.setOpaque then
            self.editor:setOpaque(true)
        end
    end
	self.acceptsEnter = true
	self.acceptsBackSpace = true
	self.result = false
	self.editor:registerFilter({
		arrowLeft = function()
			_, curpos = self.editor:getExpressionSelection()
			if curpos < 7 then
				on.arrowLeft()
				return true
			end
			return false
		end,
		arrowRight = function()
			currentText, curpos = self.editor:getExpressionSelection()
			if curpos > ulen(currentText) - 2 then
				on.arrowRight()
				return true
			end
			return false
		end,
		tabKey = function()
			theView:tabForward()
			return true
		end,
		mouseDown = function(x, y)
			theView:onMouseDown(x, y)
			return false
		end,
		backspaceKey = function()
			if (self == fctEditor) then
				self:fixCursor()
				_, curpos = self.editor:getExpressionSelection()
				if curpos <= 6 then return true end
				return false
			else
				self:backSpaceHandler()
				return true
			end
		end,
		deleteKey = function()
			if (self == fctEditor) then
				self:fixCursor()
				currentText, curpos = self.editor:getExpressionSelection()
				if curpos >= ulen(currentText) - 1 then return true end
				return false
			else
				self:backSpaceHandler()
				return true
			end
		end,
		enterKey = function()
			self:enterHandler()
			return true
		end,
		returnKey = function()
			theView:enterHandler()
			return true
		end,
		escapeKey = function()
			on.escapeKey()
			return true
		end,
		charIn = function(c)
			if (self == fctEditor) then
				self:fixCursor()
				return false
			else
				return self.readOnly
			end
		end
	})
end

-- Ensures the editor has a math box at all times.
function MathEditor:fixContent()
	local currentText = self.editor:getExpressionSelection()
	if currentText == "" or currentText == nil then
		self.editor:createMathBox()
	end
end

-- Make sure the cursor stays inside the editable region of the Unicode string.
-- D2Editor likes to insert special tokens at the start, so we have to skip the first 6 codepoints.
-- If the cursor escapes the allowed range, forcibly drag it back, because users can't be trusted.
function MathEditor:fixCursor()
	local currentText, curpos, selstart = self.editor:getExpressionSelection()
	local l = ulen(currentText)
	if curpos < 6 or selstart < 6 or curpos > l - 1 or selstart > l - 1 then
		if curpos < 6 then curpos = 6 end
		if selstart < 6 then selstart = 6 end
		if curpos > l - 1 then curpos = l - 1 end
		if selstart > l - 1 then selstart = l - 1 end
		self.editor:setExpression(currentText, curpos, selstart)
	end
end

-- Extract the user-entered expression from the D2Editor string, skipping any special formatting.
function MathEditor:getExpression()
	if not self.editor then return "" end
	local rawexpr = self.editor:getExpression()
	local expr = ""
	local n = string.len(rawexpr)
	local b = 0
	local bs = 0
	local bi = 0
	local status = 0
	local i = 1
	while i <= n do
		local c = string.sub(rawexpr, i, i)
		if c == "{" then
			b = b + 1
		elseif c == "}" then
			b = b - 1
		end
		if status == 0 then
			if string.sub(rawexpr, i, i + 5) == "\\0el {" then
				bs = i + 6
				i = i + 5
				status = 1
				bi = b
				b = b + 1
			end
		else
			if b == bi then
				status = 0
				expr = expr .. string.sub(rawexpr, bs, i - 1)
			end
		end
		i = i + 1
	end
	return expr
end

-- Set focus to the math editor, so it can feel important.
function MathEditor:setFocus()
	if not self.editor then return end
	self.editor:setFocus(true)
end

-- Remove focus from the math editor, so it can sulk in the corner.
function MathEditor:releaseFocus()
	if not self.editor then return end
	self.editor:setFocus(false)
end

-- Inserts text at the cursor. Assumes user knows what they’re doing. (They probably don’t.)
function MathEditor:addString(str)
	if not self.editor then return false end
	self:fixCursor()
	-- Unicode string slicing: because normal string.sub just isn't enough.
	local currentText, curpos, selstart = self.editor:getExpressionSelection()
	local newText = string.usub(currentText, 1, math.min(curpos, selstart)) .. str .. string.usub(currentText, math.max(curpos, selstart) + 1, ulen(currentText))
	self.editor:setExpression(newText, math.min(curpos, selstart) + ulen(str))
	return true
end

-- Handle backspace. (No-op for now, because history deletion is scary.)
function MathEditor:backSpaceHandler()
    -- No-op or custom deletion logic (history removal not implemented)
end

-- Handle enter key. Just delegates to the real handler.
function MathEditor:enterHandler()
    -- Call the custom on.enterKey handler instead of missing global
    on.enterKey()
end

-- Draws horizontal lines under the editor, if we're feeling fancy.
function MathEditor:paint(gc)
	if showHLines and not self.result then
		gc:setColorRGB(100, 100, 100)
		local ycoord = self.y - (showEditorsBorders and 0 or 2)
		gc:drawLine(1, ycoord, platform.window:width() - sbv.w - 2, ycoord)
		gc:setColorRGB(0, 0, 0)
	end
end

function on.arrowUp()
    if _G.menuStack and #_G.menuStack > 0 then
        local m = _G.menuStack[#_G.menuStack]
        m:arrowUpHandler()
        return
    end
  if theView then
    if theView:getFocus() == fctEditor then
      on.tabKey()
    else
      on.tabKey()
      if theView:getFocus() ~= fctEditor then on.tabKey() end
    end
    reposView()
  end
end

function on.arrowDown()
    if _G.menuStack and #_G.menuStack > 0 then
        local m = _G.menuStack[#_G.menuStack]
        m:arrowDownHandler()
        return
    end
  if theView then
    on.backtabKey()
    if theView:getFocus() ~= fctEditor then on.backtabKey() end
    reposView()
  end
end

function on.arrowLeft()
    if _G.menuStack and #_G.menuStack > 0 then
        local depth = #_G.menuStack
        local m = _G.menuStack[depth]
        theView:remove(m)
        table.remove(_G.menuStack, depth)
        if _G.menuStack and #_G.menuStack > 0 then
            _G.menuStack[#_G.menuStack].muted = false
            theView:setFocus(_G.menuStack[#_G.menuStack])
        else
            _G.menuStack = nil
        end
        theView:invalidate()
        return
    end
  if theView then
    on.tabKey()
    reposView()
  end
end

function on.arrowRight()
    if _G.menuStack and #_G.menuStack > 0 then
        local m = _G.menuStack[#_G.menuStack]
        local idx = m.selected
        local text = m.items[idx]
        if m.onSelect then m.onSelect(idx, text) end
        return
    end
  if theView then
    on.backtabKey()
    reposView()
  end
end

function on.charIn(ch)
    if _G.showSettingsModal and _G.precisionInputActive and ch:match("%d") then
        var.store("nLuaCAS_precision_pref", tonumber(ch))
        _G.precisionInputActive = false
        platform.window:invalidate()
        return
    end
    if theView then theView:sendStringToFocus(ch) end
end

function on.tabKey()
  if theView then theView:tabForward(); reposView() end
end

function on.backtabKey()
  if theView then theView:tabBackward(); reposView() end
end
-- In gui.lua

function on.enterKey()
    -- If a menu is open, treat Enter as submenu/selection trigger
    if _G.menuStack and #_G.menuStack > 0 then
        on.arrowRight()
        return
    end
    
    if not fctEditor or not fctEditor.getExpression then return end

    -- Recall the current constant category (do not set default here)
    local recalled = var.recall and var.recall("current_constant_category")
    if recalled ~= nil then
        current_constant_category = recalled
        print("[INIT] Recalled constant category: " .. tostring(current_constant_category))
    else
        print("[INIT] Recall failed or value was nil; skipping default set")
    end

    local input = fctEditor:getExpression()
    
    -- Clear any previous calculation steps and type before a new calculation.
    -- This is crucial so old steps don't linger if the new calculation has none.
    _G.lastCalculationSteps = nil
    _G.lastCalculationType = nil

    -- Check for custom snarky responses
    local joke = _G.errors.get(input)
    if joke then
        result = joke
        addME(input, result, "normal")
        if fctEditor and fctEditor.editor then
            fctEditor.editor:setText("")
            fctEditor:fixContent()
        end
        if platform and platform.window and platform.window.invalidate then
            platform.window:invalidate()
        end
        return
    end
    
    -- Fix TI-style derivative notation
    input = input:gsub("%(%(d%)%)%/%(d([a-zA-Z])%((.-)%)%)%)", function(var_name, inner_expr)
        _G.__diff_var = var_name -- Store derivative variable globally
        return inner_expr
    end)
    
    if not input or input == "" then 
        result = _G.errors.get("parse(empty_expression)") or "Error: Empty expression"
        addME("", result, "error")
        return 
    end

    -- Remove all whitespace from input
    input = input:gsub("%s+", "")

    local result = ""
    _G.luaCASerror = false
    
    local function get_constant_value(fname)
        local physics_constants = _G.physics_constants or {}
        local avail = var.recall and var.recall("available_constants") or {}
        local is_enabled = (avail == nil) or (avail[fname] == true)
        local cat = var.recall and var.recall("current_constant_category")
        print("[DEBUG] Category set to:", tostring(cat))
        if physics_constants[fname]
            and is_enabled
            and physics_constants[fname].category == cat then
            return physics_constants[fname].value
        end
        return nil
    end

    local success, err = pcall(function()
        local steps_data_local = nil -- Local variable to capture steps from calculation functions
        local calculation_type_local = nil -- Local variable to capture type

        -- Handle d/dx and d/dy notation
        if input:sub(1,4) == "d/dx" or input:sub(1,4) == "d/dy" then
            local expr = input:match("d/d[xy]%((.+)%)")
            if not expr then
                result = _G.errors.get("d/dx(nothing)") or _G.errors.invalid("diff")
                _G.luaCASerror = true
                return
            end
            local res_ast, steps_data = _G.derivative(expr, _G.__diff_var)
            if not res_ast or res_ast == _G.errors.invalid("diff") then 
                result = _G.errors.get("diff(unimplemented_node)") or _G.errors.invalid("diff")
                _G.luaCASerror = true 
            else
                result = res_ast
                steps_data_local = steps_data
                calculation_type_local = "Derivative"
            end
            
        -- Handle ∂/∂x notation
        elseif input:sub(1,5) == "∂/∂x(" and input:sub(-1) == ")" then
            local expr = input:match("∂/∂x%((.+)%)")
            if not expr then
                result = _G.errors.get("diff(invalid_variable)") or _G.errors.invalid("diff")
                _G.luaCASerror = true
                return
            end
            local res_ast, steps_data = _G.derivative(expr, _G.__diff_var)
            if not res_ast or res_ast == _G.errors.invalid("diff") then 
                result = _G.errors.get("diff(unimplemented_node)") or _G.errors.invalid("diff")
                _G.luaCASerror = true 
            else
                result = res_ast
                steps_data_local = steps_data
                calculation_type_local = "Derivative"
            end
            
        -- Handle diff(expr, var) notation
        elseif input:match("^diff%(([^,]+),([^,%)]+)%)$") then
            local a, b = input:match("^diff%(([^,]+),([^,%)]+)%)$")
            if not (a and b) then
                result = _G.errors.get("diff(invalid_variable)") or _G.errors.invalid("diff")
                _G.luaCASerror = true
                return
            end
            local parsed_a = parse(a)
            if not parsed_a then
                result = _G.errors.get("parse(syntax)") or _G.errors.invalid("parse")
                _G.luaCASerror = true
                return
            end
            local res_ast, steps_data = _G.diffAST(parsed_a, b) -- Use diffAST directly
            if not res_ast or res_ast == _G.errors.invalid("diff") then 
                result = _G.errors.get("diff(unimplemented_node)") or _G.errors.invalid("diff")
                _G.luaCASerror = true 
            else
                result = res_ast
                steps_data_local = steps_data
                calculation_type_local = "Derivative"
            end
            
        -- Handle integration (∫(expr)dx) notation (assuming integrate returns steps now)
        elseif input:sub(1,3) == "∫(" and (input:sub(-1) == "x" or input:sub(-2) == ")x") then -- Adjusted to correctly match dx at end
            local expr_to_integrate = input:sub(4, -((input:sub(-2) == ")x") and 3 or 2)) -- Adjusted for dx
            local integration_var = input:match(".+d([a-zA-Z])$") or "x" -- Extract integration variable if explicit, default to x
            if not expr_to_integrate then
                result = _G.errors.get("int(nothing)") or _G.errors.invalid("int")
                _G.luaCASerror = true
                return
            end
            local parsed_expr = parse(expr_to_integrate)
            if not parsed_expr then
                result = _G.errors.get("parse(integral)") or _G.errors.invalid("parse")
                _G.luaCASerror = true
                return
            end
            -- ASSUMPTION: integrate() will be modified to return steps as second value
            local res_ast, steps_data = integrate(parsed_expr, integration_var) 
            if not res_ast or res_ast == _G.errors.invalid("int") then
                result = _G.errors.get("int(unimplemented_node)") or _G.errors.invalid("int")
                _G.luaCASerror = true
            else
                result = res_ast
                steps_data_local = steps_data
                calculation_type_local = "Integration"
            end
            
        -- Handle solve(eqn) notation (assuming solve returns steps now)
        elseif input:sub(1,6) == "solve(" and input:sub(-1) == ")" then
            local eqn = input:match("solve%((.+)%)")
            if not eqn then
                result = _G.errors.get("solve(no_analytical)") or _G.errors.invalid("solve")
                _G.luaCASerror = true
                return
            end
            if eqn and not eqn:find("=") then
                eqn = eqn .. "=0" -- Default to =0 if no equality given
            end
            local parsed_eqn = parse(eqn)
            if not parsed_eqn then
                 result = _G.errors.get("parse(syntax)") or _G.errors.invalid("parse")
                _G.luaCASerror = true
                return
            end
            -- ASSUMPTION: solve() will be modified to return steps as second value
            local res_ast, steps_data = solve(parsed_eqn) 
            if not res_ast or res_ast == _G.errors.invalid("solve") then 
                result = _G.errors.get("solve(no_analytical)") or _G.errors.invalid("solve")
                _G.luaCASerror = true 
            else
                result = res_ast
                steps_data_local = steps_data
                calculation_type_local = "Solution"
            end
            
        -- Handle expand(expr) notation (assuming expand returns steps now)
        elseif input:sub(1,7) == "expand(" and input:sub(-1) == ")" then
            local inner = input:match("expand%((.+)%)")
            if not inner then
                result = _G.errors.get("parse(function_missing_args)") or _G.errors.invalid("expand")
                _G.luaCASerror = true
                return
            end
            local parsed_inner = parse(inner)
            if not parsed_inner then
                result = _G.errors.get("parse(syntax)") or _G.errors.invalid("parse")
                _G.luaCASerror = true
                return
            end
            -- ASSUMPTION: expand() will be modified to return steps as second value
            local res_ast, steps_data = expand(parsed_inner) 
            if not res_ast or res_ast == _G.errors.invalid("expand") then 
                result = _G.errors.get("simplify(unsupported_node)") or _G.errors.invalid("expand")
                _G.luaCASerror = true 
            else
                result = res_ast
                steps_data_local = steps_data
                calculation_type_local = "Expansion"
            end
            
        -- Handle let (definition)
        elseif input:sub(1,3) == "let" then
            result = define(input)
            -- No steps for 'let' command typically; steps_data_local and calculation_type_local remain nil
            
        else
            -- Default case: parse and simplify (no steps, just result)
            local constval = get_constant_value(input)
            if constval ~= nil then
                result = constval
            else
                print("[DEBUG] Category set to:", var.recall("current_constant_category"))
                local parsed = parse(input)
                if not parsed then
                    result = _G.errors.get("parse(syntax)") or _G.errors.invalid("parse")
                    _G.luaCASerror = true
                    return
                end
                result = simplify.simplify(parsed)
                if not result then
                    result = _G.errors.get("simplify(unsupported_node)") or _G.errors.invalid("simplify")
                    _G.luaCASerror = true
                end
            end
        end
        
        -- Store steps and type globally AFTER successful pcall block
        _G.lastCalculationSteps = steps_data_local
        _G.lastCalculationType = calculation_type_local
        
        if result == "" or not result then
            result = _G.errors.get("internal(unknown_error)") or "No result. Internal CAS fallback used."
            _G.luaCASerror = true
        end
    end)
    
    if not success then
        local err_str = tostring(err)
        local is_custom_error = false
        for key, msg in pairs(_G.errors) do
            if type(msg) == "string" and err_str:find(msg, 1, true) then
                is_custom_error = true
                break
            end
        end
        
        if not is_custom_error then
            if err_str:find("divide") and err_str:find("zero") then
                result = _G.errors.get("eval(divide_by_zero)") or ("Error: " .. err_str)
            elseif err_str:find("nil") then
                result = _G.errors.get("internal(unexpected_nil)") or ("Error: " .. err_str)
            elseif err_str:find("syntax") then
                result = _G.errors.get("parse(syntax)") or ("Error: " .. err_str)
            else
                result = _G.errors.get("internal(unknown_error)") or ("Error: " .. err_str)
            end
        else
            result = "Error: " .. err_str
        end
        _G.luaCASerror = true
        
        -- Clear steps if an error occurred, as they might be incomplete/invalid
        _G.lastCalculationSteps = nil
        _G.lastCalculationType = nil
    end

    -- Add to history display with steps attached (now generic)
    local colorHint = (_G.luaCASerror and "error") or "normal"
    addME(input, result, colorHint)

    -- Clear the input editor
    if fctEditor and fctEditor.editor then
        fctEditor.editor:setText("")
        fctEditor:fixContent()
    end

    -- Redraw UI
    if platform and platform.window and platform.window.invalidate then
        platform.window:invalidate()
    end

    -- Save last result
    if type(result) == "table" then
        if _G.ast and _G.ast.tostring then
            result = _G.ast.tostring(result)
        else
            result = "(unrenderable result)"
        end
    end
    res = result
end
function on.returnKey()
  on.enterKey()
end
function Dialog:paint(gc, focused)
    -- Draw shadow
    gc:setColorRGB(128, 128, 128)
    gc:fillRect(self.x + 3, self.y + 3, self.w, self.h)

    -- Draw dialog background
    gc:setColorRGB(240, 240, 240)
    gc:fillRect(self.x, self.y, self.w, self.h)

    -- Draw border
    gc:setColorRGB(0, 0, 0)
    gc:drawRect(self.x, self.y, self.w, self.h)

    -- Draw title bar
    gc:setColorRGB(0, 0, 128)
    gc:fillRect(self.x + 1, self.y + 1, self.w - 2, 20)
    gc:setColorRGB(255, 255, 255)
    gc:drawString(self.title, self.x + 5, self.y + 4, "top")

    -- Draw title bar border
    gc:setColorRGB(0, 0, 0)
    gc:drawLine(self.x + 1, self.y + 21, self.x + self.w - 2, self.y + 21)

    -- Paint child widgets (from the dialog's perspective)
    for _, widget in ipairs(self.widgets) do
        if widget.visible then
            -- Pass the correct focused state for the child widget
            local is_child_focused = (self.view:getFocus() == widget)
            widget:paint(gc, is_child_focused)
        end
    end
end

function Dialog:addWidget(widget)
    table.insert(self.widgets, widget)
    widget.parent = self -- Set the dialog as the widget's parent
    -- Adjust widget's position relative to the dialog's top-left corner
    -- This assumes widgets are added with their absolute coordinates, then adjusted.
    widget.x = self.x + widget.xOrig
    widget.y = self.y + widget.yOrig
    self.view:add(widget) -- Add to main view for global event handling
    self.view:repos(widget) -- Reposition in case constraints are set
end


-- Activates the dialog, making it visible and focusable.
function Dialog:activate()
    self.visible = true
    -- Set this dialog as the active modal dialog for the view
    self.view.activeModalDialog = self

    print("--- [DEBUG] Dialog:activate() - Attempting to hide all MathEditors ---")

    -- HIDE MAIN INPUT EDITOR
    if fctEditor and fctEditor.editor then
        fctEditor.editor:setVisible(false)
        print("[DEBUG] Hidden fctEditor (main input editor).")
    else
        print("[DEBUG] fctEditor or its editor is NIL/invalid during Dialog:activate.")
    end

    -- HIDE HISTORY INPUT EDITORS
    local hidden_hist1_count = 0
    for i, me in ipairs(histME1) do
        if me and me.editor then
            me.editor:setVisible(false)
            -- Optional: Uncomment for extreme verbosity, might spam console for long history
            -- print("[DEBUG] Hidden histME1[" .. i .. "] editor (input): " .. (me.editor:getText() or "N/A"))
            hidden_hist1_count = hidden_hist1_count + 1
        else
            print("[DEBUG] histME1[" .. i .. "] is NIL/invalid during Dialog:activate.")
        end
    end
    print("[DEBUG] Total hidden histME1 editors:", hidden_hist1_count, "/", #histME1)

    -- HIDE HISTORY RESULT EDITORS
    local hidden_hist2_count = 0
    for i, me in ipairs(histME2) do
        if me and me.editor then
            me.editor:setVisible(false)
            -- Optional: Uncomment for extreme verbosity
            -- print("[DEBUG] Hidden histME2[" .. i .. "] editor (result): " .. (me.editor:getText() or "N/A"))
            hidden_hist2_count = hidden_hist2_count + 1
        else
            print("[DEBUG] histME2[" .. i .. "] is NIL/invalid during Dialog:activate.")
        end
    end
    print("[DEBUG] Total hidden histME2 editors:", hidden_hist2_count, "/", #histME2)

    -- Set focus to the first focusable widget within the dialog (for keyboard nav)
    for _, widget in ipairs(self.widgets) do
        if widget.acceptsFocus then
            self.view:setFocus(widget)
            break
        end
    end
    self.view:invalidate() -- Request a screen redraw
end


-- Closes the dialog, making it invisible and removing its widgets from the view.
function Dialog:close(result)
    self.result = result
    self.visible = false
    if self.view.activeModalDialog == self then
        self.view.activeModalDialog = nil
    end

    self.view:remove(self)
    for _, widget in ipairs(self.widgets) do
        self.view:remove(widget)
    end
    if self.onClose then
        self.onClose(self, result)
    end

    print("--- [DEBUG] Dialog:close() - Attempting to show all MathEditors ---")

    -- SHOW MAIN INPUT EDITOR
    if fctEditor and fctEditor.editor then
        fctEditor.editor:setVisible(true)
        print("[DEBUG] Shown fctEditor (main input editor).")
    else
        print("[DEBUG] fctEditor or its editor is NIL/invalid during Dialog:close.")
    end

    -- SHOW HISTORY INPUT EDITORS
    local shown_hist1_count = 0
    for i, me in ipairs(histME1) do
        if me and me.editor then
            me.editor:setVisible(true)
            -- Optional: Uncomment for extreme verbosity
            -- print("[DEBUG] Shown histME1[" .. i .. "] editor (input): " .. (me.editor:getText() or "N/A"))
            shown_hist1_count = shown_hist1_count + 1
        else
            print("[DEBUG] histME1[" .. i .. "] is NIL/invalid during Dialog:close.")
        end
    end
    print("[DEBUG] Total shown histME1 editors:", shown_hist1_count, "/", #histME1)

    -- SHOW HISTORY RESULT EDITORS
    local shown_hist2_count = 0
    for i, me in ipairs(histME2) do
        if me and me.editor then
            me.editor:setVisible(true)
            -- Optional: Uncomment for extreme verbosity
            -- print("[DEBUG] Shown histME2[" .. i .. "] editor (result): " .. (me.editor:getText() or "N/A"))
            shown_hist2_count = shown_hist2_count + 1
        else
            print("[DEBUG] histME2[" .. i .. "] is NIL/invalid during Dialog:close.")
        end
    end
    print("[DEBUG] Total shown histME2 editors:", shown_hist2_count, "/", #histME2)

    self.view:invalidate()
end

function Dialog:onMouseDown(x, y)
    -- Check if click is on dialog itself
    if self:contains(x, y) then
        -- Pass event to child widgets
        for i = #self.widgets, 1, -1 do -- Iterate in reverse for topmost widget
            local widget = self.widgets[i]
            if widget.visible and widget:contains(x, y) and widget.acceptsMouse then
                widget:onMouseDown(x, y)
                self.view:setFocus(widget) -- Set focus to the clicked widget
                return
            end
        end
    end
end

function Dialog:onMouseUp(x, y)
    -- Pass event to child widgets
    for i = #self.widgets, 1, -1 do -- Iterate in reverse for topmost widget
        local widget = self.widgets[i]
        if widget.visible and widget:contains(x, y) and widget.onMouseUp then
            widget:onMouseUp(x, y)
            return
        end
    end
end

function Dialog:escapeHandler()
    -- If escape is pressed, close the dialog
    self:close(false) -- False indicates cancellation or escape
end
function on.mouseMove(x, y)
  if theView then theView:onMouseMove(x, y) end
end

function on.mouseDown(x, y)
  -- Modal close "X" button
  if _G.showSettingsModal and _G.modalCloseBtnRegion then
    local r = _G.modalCloseBtnRegion
    if x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
      _G.showSettingsModal = false
      platform.window:invalidate()
      return
    end
  end
  -- Close help modal and block background clicks
  if _G.showHelpModal then
      local r = _G.helpModalCloseBtnRegion
      if r and x>=r.x and x<=r.x+r.w and y>=r.y and y<=r.y+r.h then
          _G.showHelpModal = false
          platform.window:invalidate()
      end
      return
  end
  -- Startup Hint modal block
  if _G.showStartupHint then
      local r = _G.hintDismissBtnRegion
      if r and x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
          _G.showStartupHint = false
          platform.window:invalidate()
          return
      end
      if _G.startupDontShowBtn then
          local btnX = (scrWidth - 240) / 2 + 10
          local btnY = scrHeight - 90 - 80 + 90 - 22 - 10
          if x >= btnX and x <= btnX + 110 and y >= btnY and y <= btnY + 22 then
              _G.startupDontShowBtn:onMouseDown()
              platform.window:invalidate()
              return
          end
      end
  end
  -- Modal ETK Button mouseDown
  if _G.showSettingsModal and _G.modalETKButton then
    local btn = _G.modalETKButton
    local btnW = btn.dimension.width or 80
    local btnH = btn.dimension.height or 28
    local modalW, modalH = 200, 120
    local modalX = (scrWidth - modalW) / 2
    local modalY = (scrHeight - modalH) / 2
    local btnX = modalX + (modalW - btnW) / 2
    local btnY = modalY + 54
    if x >= btnX and x <= btnX + btnW and y >= btnY and y <= btnY + btnH then
      btn:onMouseDown()
      platform.window:invalidate()
      return
    end
  end
  -- Toggle switch press effect when settings modal is open
  if _G.showSettingsModal and _G.switchRegion then
    local r = _G.switchRegion
    if x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
      _G.switchPressed = true
      platform.window:invalidate()
      return
    end
  end
  if theView then theView:onMouseDown(x, y) end
end
function on.mouseUp(x, y)
    -- This block should only CREATE and ACTIVATE the settings dialog if it needs to be shown.
    -- The painting should happen in on.paint.
    print("\n--- on.mouseUp event ---") -- <--- IS THIS SHOWING?
    print("Current activeModalDialog (on entry):", tostring(theView.activeModalDialog)) -- <--- IS THIS SHOWING?
    if theView then
        if theView.activeModalDialog then
            -- If a modal dialog is active, send all mouse events directly to it
            theView.activeModalDialog:onMouseUp(x, y)
            return -- Crucial: stop further processing if a modal dialog handled it
        else
            -- Otherwise, let the normal view handle it
            theView:onMouseUp(x, y)
        end
    end
    

    -- Similar for the Help Dialog
    if _G.showHelpModal then
        if not _G.helpDialog then
            -- Create the help dialog only once
           

            -- Ensure it's added to the view and activated when created
            theView:add(_G.helpDialog)
            _G.helpDialog:activate()
        end
        -- Remove the _G.helpDialog:paint(gc, true) line from here!
    end
    
    -- Similar for the Startup Hint Dialog
    if var and var.recall and var.recall("hide_startup_hint") ~= 1 and _G.showStartupHint then
        if not _G.startupHintDialog then
            -- Create the startup hint dialog only once
            

            -- Ensure it's added to the view and activated when created
            theView:add(_G.startupHintDialog)
            _G.startupHintDialog:activate()
        end
        -- Remove the _G.startupHintDialog:paint(gc, true) line from here!
    end
    
    -- This line is correct and should remain. It dispatches the mouse event
    -- to the appropriate UI element, including any active dialog.
    if theView then theView:onMouseUp(x, y) end
end

function initFontGC(gc)
	gc:setFont(font, style, fsize)
end

function getStringHeightGC(text, gc)
	initFontGC(gc)
	return gc:getStringHeight(text)
end

function getStringHeight(text)
	return platform.withGC(getStringHeightGC, text)
end

function getStringWidthGC(text, gc)
	initFontGC(gc)
	return gc:getStringWidth(text)
end

function getStringWidth(text)
	return platform.withGC(getStringWidthGC, text)
end


----------------------------------------------------------------------
--                           History Layout                           --
----------------------------------------------------------------------

-- Find the “partner” editor for a history entry
function getParME(editor)
    for i = 1, #histME2 do
        if histME2[i].editor == editor then
            return histME1[i]
        end
    end
    return nil
end

-- Map a D2Editor instance back to its MathEditor wrapper
function getME(editor)
    if fctEditor and fctEditor.editor == editor then
        return fctEditor
    else
        for i = 1, #histME1 do
            if histME1[i].editor == editor then
                return histME1[i]
            end
        end
        for i = 1, #histME2 do
            if histME2[i].editor == editor then
                return histME2[i]
            end
        end
    end
    return nil
end

-- Get the “index” of a given MathEditor in the history stack
function getMEindex(me)
    if fctEditor and fctEditor.editor == me then
        return 0
    else
        local ti = 0
        for i = #histME1, 1, -1 do
            if histME1[i] == me then
                return ti
            end
            ti = ti + 1
        end
        ti = 0
        for i = #histME2, 1, -1 do
            if histME2[i] == me then
                return ti
            end
            ti = ti + 1
        end
    end
    return 0
end

-- Global offset for history scrolling
ioffset = 0

function reposView()
    local focusedME = theView:getFocus()
    if not focusedME or focusedME == fctEditor then return end

    local index = getMEindex(focusedME)
    local maxIterations = 10 -- prevent infinite loops
    for _ = 1, maxIterations do
        local y = focusedME.y
        local h = focusedME.h
        local y0 = fctEditor.y

        if y < 0 and ioffset < index then
            ioffset = ioffset + 1
            reposME()
        elseif y + h > y0 and ioffset > index then
            ioffset = ioffset - 1
            reposME()
        else
            break
        end
    end
end

-- When a history editor resizes, lay out paired entries side-by-side
function resizeMEpar(editor, w, h)
    local pare = getParME(editor)
    if pare then
        resizeMElim(editor, w, h, pare.w + (pare.dx1 or 0) * 2)
    else
        resizeME(editor, w, h)
    end
end

-- Generic resize for any MathEditor
function resizeME(editor, w, h)
    if not editor then return end
    resizeMElim(editor, w, h, scrWidth / 2)
end

-- Internal workhorse for resizing (limits width, then calls reposME)
function resizeMElim(editor, w, h, lim)
    if not editor then return end
    local met = getME(editor)
    if met then
        met.needw = w
        met.needh = h
        w = math.max(w, 0)
        w = math.min(w, scrWidth - (met.dx1 or 0) * 2)
        if met ~= fctEditor then
            w = math.min(w, (scrWidth - lim) - 2 * (met.dx1 or 0) + 1)
        end
        h = math.max(h, strFullHeight + 8)
        met:resize(w, h)
        reposME()
        theView:invalidate()
    end
    return editor
end
function reposME()
    local totalh, beforeh, visih = 0, 0, 0

    -- First, position the input editor at the bottom
    fctEditor.y = scrHeight - fctEditor.h
    theView:repos(fctEditor)

    -- Update scrollbar to fill from input up
    sbv:setVConstraints("justify", scrHeight - fctEditor.y + border)
    theView:repos(sbv)

    local y = fctEditor.y
    local i0 = math.max(#histME1, #histME2)

    for i = i0, 1, -1 do
        local h1, h2 = 0, 0
        if i <= #histME1 then h1 = math.max(h1, histME1[i].h) end
        if i <= #histME2 then h2 = math.max(h2, histME2[i].h) end
        local h = math.max(h1, h2)

        local ry
        if (i0 - i) >= ioffset then
            if y >= 0 then
                if y >= h + border then
                    visih = visih + h + border
                else
                    visih = visih + y
                end
            end
            y = y - h - border
            ry = y
            totalh = totalh + h + border
        else
            ry = scrHeight
            beforeh = beforeh + h + border
            totalh = totalh + h + border
        end

        -- Place the “expression” editor on the left
        if i <= #histME1 then
            histME1[i].y = ry
            theView:repos(histME1[i])
        end
        -- Place its paired “result” editor on the right, vertically aligned
        if i <= #histME2 then
            mer = histME2[i] -- Get the result editor
            mer.y = ry + math.max(0, h1 - h2)
            theView:repos(mer)

            -- *** START OF NEW LOGIC FOR EXPLANATION BUTTON REPOSITIONING ***
            if mer.explanationButton then
                -- Recalculate its position based on the updated 'mer' position
                local btnSize = mer.explanationButton.w -- Use its current width/height
                mer.explanationButton.x = mer.x - btnSize - 5 -- X position relative to mer.x
                mer.explanationButton.y = mer.y + 2 -- Y position relative to mer.y
                -- Tell the view to re-evaluate its constraints and position.
                -- This is crucial as the button is a direct child of theView.
                theView:repos(mer.explanationButton) 
            end
            -- *** END OF NEW LOGIC ***
        end
    end

    if totalh == 0 then
        sbv.pos = 0
        sbv.siz = 100
    else
        sbv.pos = beforeh * 100 / totalh
        sbv.siz = visih * 100 / totalh
    end

    theView:invalidate()
end

function initGUI()
    showEditorsBorders = false
    showHLines = true
    -- local riscas = math.evalStr("iscas()")
    -- if (riscas == "true") then iscas = true end
    local id = math.eval("sslib\\getid()")
    if id then caslib = id end
    scrWidth = platform.window:width()
    scrHeight = platform.window:height()
    if scrWidth > 0 and scrHeight > 0 then
        theView = View(platform.window)

        -- Vertical scroll bar for history (because scrolling is still a thing)
        sbv = VScrollBar(theView, 0, -1, 5, scrHeight + 1)
        sbv:setHConstraints("right", 0)
        theView:add(sbv)
        

        -- Input editor at bottom (MathEditor) - the star of the show
        fctEditor = MathEditor(theView, 2, border, scrWidth - 4 - sbv.w, 30, "")
        
        -- Apply dark/light mode colors because apparently consistency matters
        if fctEditor and fctEditor.editor then
            local bg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
            if fctEditor.editor.setBackgroundColor then
                fctEditor.editor:setBackgroundColor(table.unpack(bg))
            end
            local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
            local border = _G.darkMode and {100, 100, 100} or {0, 0, 0}
            if fctEditor.editor.setTextColor then
                fctEditor.editor:setTextColor(table.unpack(text))
            end
            if fctEditor.editor.setBorderColor then
                fctEditor.editor:setBorderColor(table.unpack(border))
            end
        end
        
        fctEditor:setHConstraints("justify", 1)
        fctEditor:setVConstraints("bottom", 1)
        fctEditor.editor:setSizeChangeListener(function(editor, w, h)
            return resizeME(editor, w, h)
        end)
        theView:add(fctEditor)
        fctEditor.result = res
        fctEditor.editor:setText("")
        fctEditor:fixContent()

        -- First-focus is input editor (as it should be)
        theView:setFocus(fctEditor)

        -- Sync category state and update button after GUI is ready
        syncCategoryFromStorage()
        if _G.categoryBtn then
            _G.categoryBtn.text = _G.currentConstCategory
        end
        
        inited = true
    end

    toolpalette.enableCopy(true)
    toolpalette.enablePaste(true)
end


local function addStringToFctEditor(actionString)
    -- Assuming _G.fctEditor is the global MathEditor instance (or similar)
    
    if _G.fctEditor then
        _G.fctEditor:addString(actionString)
        -- Invalidate the window to ensure UI updates, as the system toolpalette doesn't
        -- automatically trigger redraws for the custom UI elements.
        platform.window:invalidate()
    else
        print("Error: _G.fctEditor not available to add string: " .. actionString)
    end
end
local function showGraphingDialog()
    _G.showGraphingModal = true
    platform.window:invalidate() -- Invalidate to show the modal
end
local function showSettingsModal()
    _G.showSettingsModal = true
    platform.window:invalidate() -- Invalidate to show the modal
end

local function showHelpModal()
    _G.showHelpModal = true
    platform.window:invalidate() -- Invalidate to show the modal
end







function resizeGC(gc)
	scrWidth = platform.window:width()
	scrHeight = platform.window:height()
	if not inited then
		initGUI()
	end
	if inited then
		initFontGC(gc)
		strFullHeight = gc:getStringHeight("H")
		strHeight = strFullHeight - 3
		theView:resize()
		reposME()
		theView:invalidate()
	end
end

function on.resize()
	platform.withGC(resizeGC)
end

forcefocus = true

function on.activate()
  setupLaunchAnimation()
end

dispinfos = true

-- The main UI rendering phase: draws status, output, and all widgets.
-- If you’re looking for where the magic (or horror) happens, it’s here.
function on.paint(gc)
    -- Launch animation block (runs before normal UI)
    if showLaunchAnim then
        local now = timer.getMilliSecCounter()
        local dt = now - launchStartTime

        -- Hide the D2Editor while launch animation is running
        if fctEditor and fctEditor.editor then
            fctEditor.editor:setVisible(false)
        end

        -- White background
        gc:setColorRGB(255, 255, 255)
        gc:fillRect(0, 0, scrWidth, scrHeight)

        -- Ensure assets exist
        -- This block should be inside the on.timer() function or wherever the animation rendering happens
if showLaunchAnim then -- Add this conditional check here
    if n_logo and luacas_text then

        local dt = timer.getMilliSecCounter() - launchStartTime -- Make sure dt is defined if not already

        -- Animate n_logo: from off-screen right to x = 50
        local logoStartX = scrWidth + 100 -- Ensure scrWidth is accessible or defined
        local logoEndX = 20
        if dt < 1000 then
            logoX = logoStartX - (dt / 1000) * (logoStartX - logoEndX)
        else
            logoX = logoEndX
        end

        -- Animate luacas_text: from off-screen right to x = close to n_logo, starts after n_logo
        local textStartX = scrWidth + 300
        -- Use the same scale factors as globals for animation
        local logoWidth, logoHeight = image.width(n_logo) * scaleFactorLogo, image.height(n_logo) * scaleFactorLogo
        local textWidth, textHeight = image.width(luacas_text) * scaleFactorText, image.height(luacas_text) * scaleFactorText
        local textEndX = logoEndX + logoWidth + 30
        if dt >= 1000 and dt < 2000 then
            local textDt = dt - 1000
            textX = textStartX - (textDt / 1000) * (textStartX - textEndX)
        elseif dt >= 2000 then
            textX = textEndX
        end

        -- Draw images if within their time windows, scale logo and text to match global scaling
        local baseY = 100
        local baseYText = 77

        if dt >= 0 then
            gc:drawImage(n_logo, logoX, baseY, logoWidth, logoHeight)
        end
        if dt >= 100 then
            gc:drawImage(luacas_text, textX, baseYText, textWidth, textHeight)
        end

        -- End animation after both complete
        if dt >= 2500 then
            showLaunchAnim = false -- This will effectively stop the animation for subsequent frames
            -- Restore D2Editor visibility after animation ends
            if fctEditor and fctEditor.editor then
                fctEditor.editor:setVisible(true)
            end
            timer.stop(tick) -- Assuming 'tick' is the timer ID
            platform.window:invalidate()
        end
    end

    -- Remove invalidate from here; handled by timer for smooth animation
    return
else -- If showLaunchAnim is false, just immediately set it to false and stop the timer
    showLaunchAnim = false -- Ensure it's false to prevent future animation attempts
    timer.stop(tick) -- Stop the animation timer immediately if it's not meant to run
    -- Restore D2Editor visibility immediately
    if fctEditor and fctEditor.editor then
        fctEditor.editor:setVisible(true)
    end
    platform.window:invalidate() -- Force a redraw if needed
    return -- Exit the on.timer function
end
end

    if not inited then
        initGUI()
        initFontGC(gc)
        strFullHeight = gc:getStringHeight("H")
        strHeight = strFullHeight - 3
    end
    if inited then
        -- Global dark mode background
        local globalBg = _G.darkMode and {20, 20, 20} or {255, 255, 255}
        gc:setColorRGB(unpackColor(globalBg))
        gc:fillRect(0, 0, scrWidth, scrHeight)

        -- Removed display of "Last: ..." result at the top
        local obj = theView:getFocus()
        initFontGC(gc)
        if not obj then theView:setFocus(fctEditor) end
        if (forcefocus) then
            if obj == fctEditor then
                fctEditor.editor:setFocus(true)
                if fctEditor.editor:hasFocus() then forcefocus = false end
            else
                forcefocus = false
            end
        end
        if dispinfos then
            -- (Logo image block removed for customization)
        end
        -- Output string fallback for "main" view
        if true then -- "main" view block
            local output = fctEditor and fctEditor.result
            local outputStr = (output and output ~= "") and output or "(no output)"
            -- Draw output in white for dark mode, black for light mode
            gc:setColorRGB(_G.darkMode and 255 or 0, _G.darkMode and 255 or 0, _G.darkMode and 255 or 0)
            gc:drawString(outputStr, 10, scrHeight - 25, "top")
        end
        -- Draw custom settings icon button at top right if modal not open
        
        theView:paint(gc)

        -- Draw the bottom input area background fully respecting dark mode (after theView:paint)
        do
            -- Use pure white and black in light mode, no blue tint
            local areaBg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
            local areaBorder = _G.darkMode and {100, 100, 100} or {0, 0, 0}
            local boxY = fctEditor.y - 2
            local boxH = fctEditor.h + 4
            gc:setColorRGB(table.unpack(areaBg))
            gc:fillRect(0, boxY, scrWidth, boxH)
            gc:setColorRGB(table.unpack(areaBorder))
            gc:drawRect(0, boxY, scrWidth, boxH)
            -- Immediately override editor background, text, and border for safety and consistency
            if fctEditor and fctEditor.editor and fctEditor.editor.setBackgroundColor then
                local bg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
                local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
                local border = _G.darkMode and {100, 100, 100} or {0, 0, 0}
                fctEditor.editor:setBackgroundColor(table.unpack(bg))
                if fctEditor.editor.setTextColor then
                    fctEditor.editor:setTextColor(table.unpack(text))
                end
                if fctEditor.editor.setBorderColor then
                    fctEditor.editor:setBorderColor(table.unpack(border))
                end
            end
        end

        -- Draw settings modal if enabled (block moved to end)
    end
    if _G.showGraphingModal then
            if not _G.graphingDialog then
                -- Define base positions for elements relative to the dialog's top-left corner (0,0)
                
                local labelColX = 10
                local inputColX = 90
                local inputWidth = 200
                local inputHeight = 20
                local spacing = 30 -- Vertical spacing between input rows
                local checkboxYStart = 140 -- Y-start for checkboxes

                -- Hide the editor immediately when the dialog is activated
                if fctEditor and fctEditor.editor then
                    fctEditor.editor:setVisible(false)
                end

                _G.graphingDialog = Dialog(theView, {
                    title = "Graphing Options",
                    width = 300,
                    height = 280, -- Adjusted height to fit all inputs and checkboxes
                    x = (platform.window:width() - 300) / 2, -- Center horizontally
                    y = (platform.window:height() - 280) / 2, -- Center vertically

                    elements = {
                        -- Explicit Function Input
                        { type = "TextLabel", x = labelColX, y = 10, text = "Y = f(x):" },
                        { type = "TextInput", x = inputColX, y = 10, width = inputWidth, height = inputHeight, name = "explicitFunc",
                          text = _G.graph_state.explicit_func_expr }, -- Pre-fill with current value

                        -- Implicit Function Input
                        { type = "TextLabel", x = labelColX, y = 10 + spacing, text = "F(x,y) = 0:" },
                        { type = "TextInput", x = inputColX, y = 10 + spacing, width = inputWidth, height = inputHeight, name = "implicitFunc",
                          text = _G.graph_state.implicit_func_expr },

                        -- Intersection Expressions Input
                        { type = "TextLabel", x = labelColX, y = 10 + 2 * spacing, text = "Expr 1 (Y=):" },
                        { type = "TextInput", x = inputColX, y = 10 + 2 * spacing, width = inputWidth, height = inputHeight, name = "intersection1",
                          text = _G.graph_state.intersection_expr1 },
                        { type = "TextLabel", x = labelColX, y = 10 + 3 * spacing, text = "Expr 2 (Y=):" },
                        { type = "TextInput", x = inputColX, y = 10 + 3 * spacing, width = inputWidth, height = inputHeight, name = "intersection2",
                          text = _G.graph_state.intersection_expr2 },

                        -- Checkboxes for visibility
                        { type = "CheckBox", x = labelColX, y = checkboxYStart, text = "Show Y=f(x)", checked = _G.graph_state.show_explicit, name = "chkExplicit",
                          onAction = function(self) self.checked = not self.checked; platform.window:invalidate() end },
                        { type = "CheckBox", x = labelColX, y = checkboxYStart + 20, text = "Show F(x,y)=0", checked = _G.graph_state.show_implicit, name = "chkImplicit",
                          onAction = function(self) self.checked = not self.checked; platform.window:invalidate() end },
                        { type = "CheckBox", x = labelColX, y = checkboxYStart + 40, text = "Show Intersections", checked = _G.graph_state.show_intersections, name = "chkIntersections",
                          onAction = function(self) self.checked = not self.checked; platform.window:invalidate() end },
                        { type = "CheckBox", x = labelColX, y = checkboxYStart + 60, text = "Show Labels", checked = _G.graph_state.show_labels, name = "chkLabels",
                          onAction = function(self) self.checked = not self.checked; platform.window:invalidate() end },

                        -- Buttons
                        { type = "TextButton", x = 300 - 150, y = 280 - 30, width = 60, height = 20, text = "Graph",
                          closesDialog = true,
                          command = function(dlg, btn)
                              -- Update global state with new values from input fields
                              _G.graph_state.explicit_func_expr = dlg.namedWidgets.explicitFunc.text
                              _G.graph_state.implicit_func_expr = dlg.namedWidgets.implicitFunc.text
                              _G.graph_state.intersection_expr1 = dlg.namedWidgets.intersection1.text
                              _G.graph_state.intersection_expr2 = dlg.namedWidgets.intersection2.text

                              _G.graph_state.show_explicit = dlg.namedWidgets.chkExplicit.checked
                              _G.graph_state.show_implicit = dlg.namedWidgets.chkImplicit.checked
                              _G.graph_state.show_intersections = dlg.namedWidgets.chkIntersections.checked
                              _G.graph_state.show_labels = dlg.namedWidgets.chkLabels.checked

                              graphics.redraw() -- Request a redraw to show the new graphs
                          end
                        },
                        { type = "TextButton", x = 300 - 70, y = 280 - 30, width = 60, height = 20, text = "Cancel",
                          closesDialog = true,
                          command = function(dlg, btn)
                              -- Do nothing, just close the dialog
                          end
                        }
                    },
                    onClose = function(dlg, result)
                        _G.showGraphingModal = false -- Important: Set flag to false when dialog closes
                        -- Restore visibility of the function editor after dialog closes
                        if fctEditor and fctEditor.editor then
                            fctEditor.editor:setVisible(true)
                        end
                        _G.graphingDialog = nil -- Clear reference to the dialog
                        platform.window:invalidate() -- Ensure a redraw happens
                    end
                })
                theView:add(_G.graphingDialog)
                _G.graphingDialog:activate() -- Show the dialog
            end
            _G.graphingDialog:paint(gc, true) -- Paint the dialog on top
        end
    
-- Replace the entire manual drawing block for _G.showSettingsModal
if _G.showSettingsModal then
    -- Create the settings dialog only once
    if not _G.settingsDialog then
        -- Define base positions for elements relative to the dialog's top-left corner (0,0)
        local labelCol1X = 20    -- X-coordinate for labels in the first column
        local valueCol1X = 120   -- X-coordinate for buttons/values, estimated for alignment
        local lineHeight = 28    -- Vertical spacing between lines of elements
        local btnW, btnH = 48, 22 -- Standard button width and height
        if fctEditor and fctEditor.editor then -- Add nil check for robustness
            fctEditor.editor:setVisible(false)
        end

        _G.settingsDialog = Dialog(theView, {
            title = "Settings",
            width = 300,
            height = 190,
            x = 50,  
            y = 50,  

            elements = {
                -- Decimals Toggle
                { type = "TextLabel", x = labelCol1X, y = 40, text = "Decimals:" },
                { type = "TextButton", x = valueCol1X, y = 38, text = (_G.autoDecimal and "ON" or "OFF"),
                  width = btnW, height = btnH, name = "decimalsBtn",
                  command = function(dlg, btn)
                      _G.autoDecimal = not _G.autoDecimal
                      btn.text = (_G.autoDecimal and "ON" or "OFF")
                      var.store("nLuaCAS_decimals_pref", _G.autoDecimal and 1 or 0)
                      platform.window:invalidate()
                  end },

                -- Complex Mode Toggle
                { type = "TextLabel", x = labelCol1X, y = 40 + lineHeight, text = "Complex:" },
                { type = "TextButton", x = valueCol1X, y = 40 + lineHeight - 2, text = (_G.showComplex and "ON" or "OFF"),
                  width = btnW, height = btnH, name = "complexBtn",
                  command = function(dlg, btn)
                      _G.showComplex = not _G.showComplex
                      btn.text = (_G.showComplex and "ON" or "OFF")
                      var.store("nLuaCAS_complex_pref", _G.showComplex and 1 or 0)
                      platform.window:invalidate()
                  end },

                -- Constants Toggle
                { type = "TextLabel", x = labelCol1X, y = 40 + 2 * lineHeight, text = "Constants:" },
                { type = "TextButton", x = valueCol1X, y = 40 + 2 * lineHeight - 2, text = (not var.recall("constants_off") and "ON" or "OFF"),
                  width = btnW, height = btnH, name = "constantsBtn",
                  command = function(dlg, btn)
                      local new_off = not var.recall("constants_off")
                      var.store("constants_off", new_off)
                      btn.text = (not new_off and "ON" or "OFF")
                      platform.window:invalidate()
                  end },

                -- Category Selector
                { type = "TextLabel", x = labelCol1X, y = 40 + 3 * lineHeight, text = "Category:" },
                { type = "TextButton", x = valueCol1X, y = 40 + 3 * lineHeight - 2, text = _G.gui.get_current_constant_category(),
                  width = 90, height = btnH, name = "categoryBtn",
                  command = function(dlg, btn)
                      local categories = get_constant_categories()
                      local currentCategory = _G.gui.get_current_constant_category()
                      local idx = 1
                      for i, v in ipairs(categories) do
                          if v == currentCategory then idx = i end
                      end
                      local selected = categories[(idx % #categories) + 1]

                      _G.currentConstCategory = selected
                      _G.current_constant_category = selected

                      var.store("current_constant_category", selected)
                      btn.text = selected

                      platform.window:invalidate()
                  end },

                -- Dismiss Button for the dialog
                -- Position it relative to the new dialog height
                { type = "TextButton", x = 300 - 70, y = 190 - 30, text = "Dismiss", -- Y-position adjusted for new height
                  closesDialog = true,
                  command = function(dlg, btn)
                  end }
            },
            onClose = function(dlg, result)
                _G.showSettingsModal = false
                platform.window:invalidate()
                if fctEditor and fctEditor.editor then -- Add nil check for robustness
                    fctEditor.editor:setVisible(true)
                end
            end
        })
        theView:add(_G.settingsDialog)
        _G.settingsDialog:activate()
    end
    _G.settingsDialog:paint(gc, true)
end


    if _G.showHelpModal then
        if not _G.helpDialog then
            if fctEditor and fctEditor.editor then -- Add nil check for robustness
                fctEditor.editor:setVisible(false) -- HIDE EDITOR WHEN DIALOG OPENS
            end
            _G.helpDialog = Dialog(theView, {
                title = "CAS Help",
                width = 300,
                height = 200,
                elements = {
                    { type = "TextLabel", x = 10, y = 40, text = "Use Ctrl+MENU to open the menu." },
                    { type = "TextLabel", x = 10, y = 56, text = "Arrow keys or touch/click to navigate." },
                    { type = "TextLabel", x = 10, y = 72, text = "Select operations to insert into input." },
                    { type = "TextLabel", x = 10, y = 88, text = "Press Enter to compute." },
                    { type = "TextLabel", x = 10, y = 104, text = "Supports expand, factor, simplify," },
                    { type = "TextLabel", x = 10, y = 120, text = "differentiate, integrate, solve, abs," },
                    { type = "TextLabel", x = 10, y = 136, text = "factorial, empty matrix, series" },
                    { type = "TextButton", x = 300 - 70, y = 200 - 30, text = "Close",
                      closesDialog = true,
                      command = function(dlg, btn) end }
                },
                onClose = function(dlg, result)
                _G.showHelpModal = false
                    platform.window:invalidate()
                    if fctEditor and fctEditor.editor then -- SHOW EDITOR WHEN DIALOG CLOSES
                        fctEditor.editor:setVisible(true)
                    end
                end
            })
            theView:add(_G.helpDialog)
            _G.helpDialog:activate()
        end
        _G.helpDialog:paint(gc, true)
    end
    

   -- Handle the Startup Hint Dialog
if var and var.recall and var.recall("hide_startup_hint") ~= 1 and _G.showStartupHint then
    if not _G.startupHintDialog then
        if fctEditor and fctEditor.editor then
            fctEditor.editor:setVisible(false)
        end
        _G.startupHintDialog = Dialog(theView, {
            title = "Tip",
            width = 280,
            height = 160,
            elements = {
                { type = "TextLabel", x = 20, y = 40, text = "Press Ctrl+MENU to open the menu." },
                { type = "TextLabel", x = 20, y = 56, text = "You can access all features from there." },
                { type = "CheckBox", x = 20, y = 90, text = "Don't show this tip again", checked = false, name = "dontShow",
                  onAction = function(self)
                      self.checked = not self.checked
                      platform.window:invalidate()
                  end
                },
                { type = "TextButton", x = 280 - 70, y = 160 - 30, text = "Dismiss",
                  closesDialog = true,
                  command = function(dlg, btn) end }
            },
            onClose = function(dlg, result)
                if dlg.namedWidgets.dontShow and dlg.namedWidgets.dontShow.checked then
                    if var and var.store then
                        var.store("hide_startup_hint", 1)
                    end
                end
                if fctEditor and fctEditor.editor then
                    fctEditor.editor:setVisible(true)
                end
                _G.showStartupHint = false
                platform.window:invalidate()
            end
        })
        theView:add(_G.startupHintDialog)
        _G.startupHintDialog:activate()
    end
    
    -- --- END OF CHANGE ---
end
end

font = "sansserif"
style = "r"
fsize = 12

scrWidth = 0
scrHeight = 0
inited = false
iscas = false
caslib = "NONE"
delim = " ≟ "
border = 3

strHeight = 0
strFullHeight = 0



-- Initialize empty history tables
histME1 = {}
histME2 = {}
-- In gui.lua

function addME(expr, res, colorHint)
    local mee = MathEditor(theView, border, border, 50, 30, "")
    mee.readOnly = true
    table.insert(histME1, mee)
    mee:setHConstraints("left", border)
    mee.editor:setSizeChangeListener(function(editor, w, h)
        return resizeME(editor, w + 3, h)
    end)
    
    -- Set border color based on colorHint
    if colorHint == "error" then
        mee.editor:setBorderColor(0xFF0000) -- red
    else
        mee.editor:setBorderColor(0x000000)
    end
    mee.editor:setExpression("\\0el {" .. expr .. "}", 0)
    mee:fixCursor()
    mee.editor:setReadOnly(true)
    theView:add(mee)

    local mer = MathEditor(theView, border, border, 50, 30, "")
    mer.result = true
    mer.readOnly = true
    table.insert(histME2, mer)
    mer:setHConstraints("right", scrWidth - sbv.x + border)
    mer.editor:setSizeChangeListener(function(editor, w, h)
        return resizeMEpar(editor, w + border, h)
    end)
    
    if colorHint == "error" then
        mer.editor:setBorderColor(0xFF0000) -- red
    else
        mer.editor:setBorderColor(0x000000)
    end
    
    local displayRes = ""
    if type(res) == "table" then
        if _G.simplify and _G.simplify.pretty_print then
            displayRes = _G.simplify.pretty_print(res)
        elseif _G.ast and _G.ast.tostring then
            displayRes = _G.ast.tostring(res)
        else
            displayRes = tostring(res)
        end
    else
        displayRes = tostring(res)
    end
    
    mer.editor:setExpression("\\0el {" .. displayRes .. "}", 0)
    mer:fixCursor()
    mer.editor:setReadOnly(true)
    theView:add(mer)

    -- Set dark/light mode colors
    local bg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
    local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
    local border = _G.darkMode and {100, 100, 100} or {0, 0, 0}
    for _, editor in ipairs({mee.editor, mer.editor}) do
        if editor.setBackgroundColor then
            editor:setBackgroundColor(table.unpack(bg))
        end
        if editor.setTextColor then
            editor:setTextColor(table.unpack(text))
        end
        if editor.setBorderColor then
            editor:setBorderColor(table.unpack(border))
        end
        if editor.setOpaque then
            editor:setOpaque(true)
        end
    end

    -- --- START OF MODIFICATION: Generic Explanation Button ---
    -- Remove any existing explanation button for this specific result entry.
    if mer.explanationButton then
        theView:remove(mer.explanationButton)
        mer.explanationButton = nil -- Clear the reference
    end

    -- Add explanation button ONLY IF _G.lastCalculationSteps holds actual steps
    if _G.lastCalculationSteps and #_G.lastCalculationSteps > 0 then
        -- Store the steps and type with the result editor
        mer.calculationSteps = _G.lastCalculationSteps
        mer.calculationType = _G.lastCalculationType or "Calculation" -- Default type if not set
        mer.originalExpression = expr
        
        -- Create a small "?" button
        local btnSize = 18
        local explainBtn = TextButton(theView, 
            mer.x - btnSize - 5,  -- Left of the result
            mer.y + 2, 
            "?", 
            function()
                -- Call the new generic explanation dialog function
                showCalculationExplanation(mer.calculationSteps, mer.originalExpression, mer.calculationType)
            end,
            nil
        )
        
        -- Make it tiny and cute
        explainBtn.w = btnSize
        explainBtn.h = btnSize
        
        -- Store reference for cleanup AND for reposME to find it
        mer.explanationButton = explainBtn
        theView:add(explainBtn) -- Add it to the view so it's managed
        
        -- Clear global steps after consumption by addME
        _G.lastCalculationSteps = nil
        _G.lastCalculationType = nil
    end
    -- --- END OF MODIFICATION ---

    reposME()
end
-- Make var globally accessible for parser/physics.lua
_G.var = var
function destroyD2Editor(editor)
	if not editor then return end
	editor:setVisible(false)
	editor:move(-10000, -10000)
	editor:resize(1, 1)
	editor = nil
end
function toggleBorders()
	showEditorsBorders = not showEditorsBorders
	on.resize()
end

function set1d()
	 fctEditor.editor:setDisable2DinRT(true)
	on.resize()
end

function set2d()
	 fctEditor.editor:setDisable2DinRT(false)
	on.resize()
end

function toggleHLines()
	showHLines = not showHLines
	on.resize()
end

function applyFontSizeChange()
	fctEditor.editor:setFontSize(fsize)
	for _, e in pairs(histME1) do
		e.editor:setFontSize(fsize)
	end
	for _, e in pairs(histME2) do
		e.editor:setFontSize(fsize)
	end
end

function fontDown()
	fsize = fsize > 6 and (fsize - 1) or fsize
	applyFontSizeChange()
end

function fontUp()
	fsize = fsize < 30 and (fsize + 1) or fsize
	applyFontSizeChange()
end
function reset()
    -- Remove all widgets first
    for _, v in pairs(theView.widgetList) do
        theView:remove(v)
    end
    
    -- Destroy all editors
    for _, e in pairs(histME1) do
        destroyD2Editor(e.editor)
    end
    for _, e in pairs(histME2) do
        -- Clean up any explanation buttons
        if e.explanationButton then
            theView:remove(e.explanationButton)
        end
        destroyD2Editor(e.editor)
    end
    
    histME1 = {}
    histME2 = {}
    fsize = 10
    
    platform.window:invalidate()
end
function on.construction()
  setupLaunchAnimation()
  toolpalette.register(myToolPaletteMenuStructure)
end
function on.timer()
    if showLaunchAnim then
        platform.window:invalidate()
    else
        timer.stop()
    end
end
_G.gui = _G.gui or {}

function _G.gui.get_current_constant_category()
    -- Priority: in-memory global -> storage -> default
    if _G.current_constant_category and type(_G.current_constant_category) == "string" then
        return _G.current_constant_category
    end
    local cat = var.recall and var.recall("current_constant_category")
    if cat and type(cat) == "string" then
        _G.current_constant_category = cat
        return cat
    end
    return "fundamental"
end


-- Handler function for toolpalette menu items
function toolpaletteMenuHandler(toolboxName, menuItemName)
    if toolboxName == "Calculus" then
        if menuItemName == "Differentiate" then
            addStringToFctEditor("d/dx()")
        elseif menuItemName == "Integrate" then
            addStringToFctEditor("∫(,)")
        elseif menuItemName == "Abs" then
            addStringToFctEditor("abs()")
        elseif menuItemName == "Factorial" then
            addStringToFctEditor("factorial(")
        elseif menuItemName == "Empty Matrix" then
            addStringToFctEditor("[[,],[,]]")
        elseif menuItemName == "Taylor Series" then
            addStringToFctEditor("series(f,x,a,n)")
        elseif menuItemName == "Fourier Series" then
            addStringToFctEditor("series(f,x,a,n)")
        elseif menuItemName == "Maclaurin Series" then
            addStringToFctEditor("series(f,x,0,n)")
        end
    elseif toolboxName == "Solve" then
        if menuItemName == "Solve Equation" then
            addStringToFctEditor("solve(")
        end
    elseif toolboxName == "App Options" then
        if menuItemName == "Settings" then
            showSettingsModal()
        elseif menuItemName == "Help" then
            showHelpModal()
        elseif menuItemName == "Graphing" then -- <-- NEW: Handle the Graphing option
            showGraphingDialog()                -- Call the function to display the graphing dialog
        end
    end
end

myToolPaletteMenuStructure = {
    {"Calculus", -- First toolbox
        {"Differentiate", toolpaletteMenuHandler},
        {"Integrate", toolpaletteMenuHandler},
        {"Abs", toolpaletteMenuHandler},
        {"Factorial", toolpaletteMenuHandler},
        {"Empty Matrix", toolpaletteMenuHandler},
        "-", -- Separator
        {"Taylor Series", toolpaletteMenuHandler},
        {"Fourier Series", toolpaletteMenuHandler},
        {"Maclaurin Series", toolpaletteMenuHandler},
    },
    {"Solve", -- Second toolbox
        {"Solve Equation", toolpaletteMenuHandler},
    },
    {"App Options", -- Third toolbox
        {"Settings", toolpaletteMenuHandler},
        {"Help", toolpaletteMenuHandler},
        {"Graphing", toolpaletteMenuHandler}, -- <--- ADD THIS LINE
        { "Show/hide editors borders", toggleBorders },
		{ "Show/hide horizontal lines", toggleHLines },
		"-",
		{ "Increase font size", fontUp },
		{ "Decrease font size", fontDown },
        { "Clear history", reset },
        { "Restart CAS", initGUI }
    }
}

-- Register the tool palette
toolpalette.register(myToolPaletteMenuStructure)

-- End src/gui.lua

-- Tossed src/gui.lua in here—go ahead, run your tests.

-- Build wrapping up. Merged build.lua: pray those ASTs behave.
