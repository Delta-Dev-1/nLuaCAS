-- Autogenerated build. If you’re reading this, something probably broke upstream.

-- Begin src/exact.lua
platform.apilevel = "2.4"
table.unpack = table.unpack or unpack

local exact = {}
exact.__index = exact

-- Greatest Common Divisor
function exact.gcd(a, b)
    while b ~= 0 do a, b = b, a % b end
    return math.abs(a)
end

-- Check integer
function exact.isInteger(n)
    return type(n) == "number" and math.floor(n) == n
end

-- Detect if value is exact type
function exact.isExact(x)
    return type(x) == "table" and getmetatable(x) == exact
end

-- Less than
function exact.lt(a, b)
    a, b = exact.toExact(a), exact.toExact(b)
    if a.type == "integer" and b.type == "integer" then return a.value < b.value end
    if a.type == "rational" or b.type == "rational" then
        local an = (a.type == "rational") and a.num or a.value * b.den
        local ad = (a.type == "rational") and a.den or b.den
        local bn = (b.type == "rational") and b.num or b.value * a.den
        local bd = (b.type == "rational") and b.den or a.den
        return an * bd < bn * ad
    end
    error("Comparison not implemented")
end

-- Less than or equal
function exact.leq(a, b)
    return exact.lt(a, b) or exact.eq(a, b)
end

-- Greater than or equal
function exact.geq(a, b)
    return not exact.lt(b, a)
end

-- Negation
function exact.neg(x)
    x = exact.toExact(x)
    if x.type == "integer" then return exact.newInteger(-exact.tonumber(x.value)) end
    if x.type == "rational" then return exact.newRational(-x.num, x.den) end
    error("Negation not implemented")
end

-- Square root (only rational roots for now)
function exact.sqrt(x)
    x = exact.toExact(x)
    if x.type == "integer" then
        local n = exact.tonumber(x.value)
        if type(n) ~= "number" then error("sqrt: not a number") end
        local root = math.sqrt(n)
        if exact.isInteger(root) then return exact.newInteger(root) end
    end
    error("Sqrt not implemented for type")
end

-- Power
function exact.pow(a, b)
    a, b = exact.toExact(a), exact.toExact(b)
    local bval = exact.tonumber(b.value)
    if b.type == "integer" and exact.isInteger(bval) then
        local result = 1
        local base = exact.tonumber(a.value)
        for _ = 1, math.abs(bval) do
            result = result * base
        end
        if bval < 0 then return exact.newRational(1, result) end
        return exact.newInteger(result)
    end
    error("Power not implemented")
end

-- Wraps Lua primitive to exact
function exact.new(x)
    return exact.toExact(x)
end

-- Extracts Lua number
function exact.tonumber(x)
    if type(x) == "number" then return x end
    if type(x) == "table" then
        if x.type == "integer" then return x.value end
        if x.type == "rational" then return x.num / x.den end
        if x.type == "float" then return x.value end
    end
    return nil  -- For non-number types, return nil (not a table)
end

-- Convert to exact type
function exact.toExact(x)
    -- If x is an AST node wrapping a value, unwrap recursively
    if type(x) == "table" and x.type == "number" and x.value ~= nil then
        return exact.toExact(x.value)
    end

    if exact.isExact(x) then return x end
    if exact.isInteger(x) then return exact.newInteger(x) end
    return exact.newFloat(x)
end

-- Normalize operands
function exact.normalize(a, b)
    return exact.toExact(a), exact.toExact(b)
end

-- Integer constructor
function exact.newInteger(n)
    assert(exact.isInteger(n), "Not an integer")
    return setmetatable({type="integer", value=n}, exact)
end

-- Rational constructor
function exact.newRational(num, den)
    assert(den ~= 0, "Denominator cannot be zero")
    local g = exact.gcd(num, den)
    local sign = den < 0 and -1 or 1
    return setmetatable({type="rational", num=num/g * sign, den=math.abs(den)/g}, exact)
end

-- Float wrapper (minimal use)
function exact.newFloat(n)
    return setmetatable({type="float", value=n}, exact)
end

-- String conversion
function exact:__tostring()
    if self.type == "integer" then return tostring(self.value) end
    if self.type == "rational" then return self.num .. "/" .. self.den end
    if self.type == "float" then return tostring(self.value) end
    return "<exact?>"
end

function exact.__add(a, b)
    a, b = exact.normalize(a, b)
    local allowed = {integer=true, rational=true, float=true}
    if not (allowed[a.type] and allowed[b.type]) then
        return {type="add", args={a, b}}
    end
    if a.type == "integer" and b.type == "integer" then
        return exact.newInteger(a.value + b.value)
    elseif a.type == "rational" and b.type == "rational" then
        return exact.newRational(a.num * b.den + b.num * a.den, a.den * b.den)
    elseif a.type == "integer" and b.type == "rational" then
        return exact.newRational(a.value * b.den + b.num, b.den)
    elseif a.type == "rational" and b.type == "integer" then
        return exact.newRational(a.num + b.value * a.den, a.den)
    elseif a.type == "float" and b.type == "float" then
        return exact.newFloat(a.value + b.value)
    elseif a.type == "float" and (b.type == "integer" or b.type == "rational") then
        local na, nb = exact.tonumber(a), exact.tonumber(b)
        if type(na) ~= "number" or type(nb) ~= "number" then
            return {type="add", args={a, b}}
        end
        return exact.newFloat(na + nb)
    elseif b.type == "float" and (a.type == "integer" or a.type == "rational") then
        local na, nb = exact.tonumber(a), exact.tonumber(b)
        if type(na) ~= "number" or type(nb) ~= "number" then
            return {type="add", args={a, b}}
        end
        return exact.newFloat(na + nb)
    end
    return {type="add", args={a, b}}
end

-- Subtraction
function exact.__sub(a, b)
    return exact.__add(a, exact.neg(b))
end

function exact.__mul(a, b)
    a, b = exact.normalize(a, b)
    local allowed = {integer=true, rational=true, float=true}
    if not (allowed[a.type] and allowed[b.type]) then
        return {type="mul", args={a, b}}
    end
    if a.type == "integer" and b.type == "integer" then
        return exact.newInteger(a.value * b.value)
    elseif a.type == "rational" and b.type == "rational" then
        return exact.newRational(a.num * b.num, a.den * b.den)
    elseif a.type == "integer" and b.type == "rational" then
        return exact.newRational(a.value * b.num, b.den)
    elseif a.type == "rational" and b.type == "integer" then
        return exact.newRational(a.num * b.value, a.den)
    elseif a.type == "float" and b.type == "float" then
        return exact.newFloat(a.value * b.value)
    elseif a.type == "float" and (b.type == "integer" or b.type == "rational") then
        local na, nb = exact.tonumber(a), exact.tonumber(b)
        if type(na) ~= "number" or type(nb) ~= "number" then
            return {type="mul", args={a, b}}
        end
        return exact.newFloat(na * nb)
    elseif b.type == "float" and (a.type == "integer" or a.type == "rational") then
        local na, nb = exact.tonumber(a), exact.tonumber(b)
        if type(na) ~= "number" or type(nb) ~= "number" then
            return {type="mul", args={a, b}}
        end
        return exact.newFloat(na * nb)
    end
    return {type="mul", args={a, b}}
end

function exact.__div(a, b)
    a, b = exact.normalize(a, b)
    local allowed = {integer=true, rational=true, float=true}
    if not (allowed[a.type] and allowed[b.type]) then
        return {type="div", args={a, b}}
    end
    if (b.type == "integer" and b.value == 0) or (b.type == "rational" and b.num == 0) or (b.type == "float" and b.value == 0) then
        error("Div by zero")
    end
    if a.type == "integer" and b.type == "integer" then
        return exact.newRational(a.value, b.value)
    elseif a.type == "rational" and b.type == "rational" then
        return exact.newRational(a.num * b.den, a.den * b.num)
    elseif a.type == "integer" and b.type == "rational" then
        return exact.newRational(a.value * b.den, b.num)
    elseif a.type == "rational" and b.type == "integer" then
        return exact.newRational(a.num, a.den * b.value)
    elseif a.type == "float" and b.type == "float" then
        return exact.newFloat(a.value / b.value)
    elseif a.type == "float" and (b.type == "integer" or b.type == "rational") then
        local na, nb = exact.tonumber(a), exact.tonumber(b)
        if type(na) ~= "number" or type(nb) ~= "number" then
            return {type="div", args={a, b}}
        end
        return exact.newFloat(na / nb)
    elseif b.type == "float" and (a.type == "integer" or a.type == "rational") then
        local na, nb = exact.tonumber(a), exact.tonumber(b)
        if type(na) ~= "number" or type(nb) ~= "number" then
            return {type="div", args={a, b}}
        end
        return exact.newFloat(na / nb)
    end
    return {type="div", args={a, b}}
end

function exact.__eq(a, b)
    a, b = exact.normalize(a, b)
    -- Only compare if both are numbers handled by exact (integer, rational, float)
    if not ((a.type == "integer" or a.type == "rational" or a.type == "float") and
            (b.type == "integer" or b.type == "rational" or b.type == "float")) then
        return false
    end
    if a.type == "integer" and b.type == "integer" then
        return a.value == b.value
    elseif a.type == "rational" and b.type == "rational" then
        return a.num * b.den == b.num * a.den
    elseif a.type == "integer" and b.type == "rational" then
        return a.value * b.den == b.num
    elseif a.type == "rational" and b.type == "integer" then
        return a.num == b.value * a.den
    elseif a.type == "float" and b.type == "float" then
        return a.value == b.value
    elseif (a.type == "float" and (b.type == "integer" or b.type == "rational")) or
           (b.type == "float" and (a.type == "integer" or a.type == "rational")) then
        return exact.tonumber(a) == exact.tonumber(b)
    end
    return false
end

-- AST Conversion
function exact.fromAST(node)
    if node.type ~= "number" then return nil end
    return exact.toExact(node.value)
end

function exact.toAST(exact_num)
    if exact_num.type == "integer" then return {type="number", value=exact_num.value} end
    if exact_num.type == "rational" then
        return {type="div", left={type="number", value=exact_num.num}, right={type="number", value=exact_num.den}}
    end
    error("Cannot convert to AST")
end

-- Legacy API Wrappers
function exact.from(x) return exact.toExact(x) end
function exact.add(a, b) return a + b end
function exact.sub(a, b) return a - b end
function exact.mul(a, b) return a * b end
function exact.div(a, b) return a / b end
function exact.eq(a, b) return a == b end
function exact.is_number(x) return exact.isExact(x) end

-- Register globally
print("[exact] Full patched exact module loaded")
_G.exact = exact

-- End src/exact.lua

-- src/exact.lua is in; don’t let that parser bite you later.

-- Begin src/errors.lua
local errors_table = {
  ["parse(series)"] = "Error: Failed to parse the series expression. Did you use correct syntax?",
  ["parse(integral)"] = "Error: Integral parsing failed. Make sure your integral syntax is correct.",
  ["d/dx(nothing)"] = "Error: Derivative operator used without an expression. What do you want to differentiate?",
  ["simplify(series)"] = "Error: Could not simplify the series expression. This is math, not magic.",
  ["simplify(integral)"] = "Error: Integral simplification failed. Did you expect miracles?",
  ["int(series)"] = "Error: Integration of series failed. Try something simpler, genius.",
  ["int(by_parts)"] = "Error: Integration by parts failed. Maybe try harder or give up.",
}

-- Separate invalid function to avoid overwriting and recursion hell
local function invalid_error(typ)
  return "Error: Invalid " .. (typ or "expression") .. ". Can't make sense of that garbage."
end

-- Assign errors_table directly to _G.errors but keep invalid separate
_G.errors = errors_table
_G.errors.invalid = invalid_error

function _G.errors.get(key)
  if _G.errors and type(_G.errors) == "table" then
    return _G.errors[key]
  end
  return nil
end

function handleParseError(context)
  if context == "series" then
    error(_G.errors.get("parse(series)") or _G.errors.invalid("parse"))
  elseif context == "integral" then
    error(_G.errors.get("parse(integral)") or _G.errors.invalid("parse"))
  elseif context == "derivative" then
    error(_G.errors.get("d/dx(nothing)") or _G.errors.invalid("diff"))
  else
    error(_G.errors.invalid("parse"))
  end
end

function handleSimplifyError(context)
  if context == "series" then
    error(_G.errors.get("simplify(series)") or _G.errors.invalid("simplify"))
  elseif context == "integral" then
    error(_G.errors.get("simplify(integral)") or _G.errors.invalid("simplify"))
  else
    error(_G.errors.invalid("simplify"))
  end
end

function handleIntegralError(context)
  if context == "series" then
    error(_G.errors.get("int(series)") or _G.errors.invalid("int"))
  elseif context == "by_parts" then
    error(_G.errors.get("int(by_parts)") or _G.errors.invalid("int"))
  else
    error(_G.errors.invalid("int"))
  end
end

_G.handleParseError = handleParseError
_G.handleSimplifyError = handleSimplifyError
_G.handleIntegralError = handleIntegralError

-- End src/errors.lua

-- Just added src/errors.lua—hope your logic is watertight.

-- Begin src/ast.lua

-- Abstract Syntax Tree (AST) library for symbolic math
-- Defines constructors, utilities, transformation tools for symbolic expressions.
-- Built to be cold, deterministic, and unreasonably explicit.

table.unpack = unpack

-- Use simplify.pretty_print for all string conversion of ASTs
local ok, simplify = pcall(require, "simplify")
if ok and simplify and simplify.pretty_print then
  function ast_tostring(ast)
    return simplify.pretty_print(ast)
  end
  ast.tostring = ast_tostring
end

-- Recursively print AST structure with optional indentation
-- For when you want to debug something by yelling at trees
function ast_debug_print(ast, indent)
    indent = indent or ""
    if type(ast) ~= "table" then
        print(indent .. tostring(ast))
        return
    end
    if ast.type then
        local desc = ast.type
        if ast.name then desc = desc .. " (" .. tostring(ast.name) .. ")" end
        print(indent .. desc)
        if ast.value ~= nil then print(indent .. "  value: " .. tostring(ast.value)) end
        if ast.name ~= nil and ast.type ~= "variable" then print(indent .. "  name: " .. tostring(ast.name)) end
        if ast.args then
            print(indent .. "  args:")
            for i, arg in ipairs(ast.args) do
                ast_debug_print(arg, indent .. "    ")
            end
        end
        -- Print left/right for binary nodes
        if ast.left then
            print(indent .. "  left:")
            ast_debug_print(ast.left, indent .. "    ")
        end
        if ast.right then
            print(indent .. "  right:")
            ast_debug_print(ast.right, indent .. "    ")
        end
    else
        for k, v in pairs(ast) do
            print(indent .. tostring(k) .. ":")
            ast_debug_print(v, indent .. "  ")
        end
    end
end

-- If you're not using these, you're probably doing something wrong
-- Node constructors (convenience)
function ast_number(val) return { type = "number", value = val } end
function ast_symbol(name) return { type = "variable", name = name } end
function ast_func(name, args) return { type = "func", name = name, args = args or {} } end
function ast_binop(op, left, right) return { type = op, left = left, right = right } end
function ast_neg(val) return { type = "neg", arg = val } end
function ast_pow(base, exp) return { type = "pow", base = base, exp = exp } end
function ast_raw(str) return { type = "raw", value = str } end


-- Patch all AST node constructors to auto-set tostring metamethod
-- So you can print them and pretend you understand the output
-- Make all AST nodes print pretty with print(ast)
local ast_mt = {
  __tostring = function(self)
    if _G.ast_tostring then
      return _G.ast_tostring(self)
    elseif _G.simplify and _G.simplify.pretty_print then
      return _G.simplify.pretty_print(self)
    else
      return "[AST]"
    end
  end
}
-- Patch constructors to set metatable for all AST nodes
local function set_ast_mt(node)
  if type(node) == "table" and node.type and getmetatable(node) ~= ast_mt then
    setmetatable(node, ast_mt)
    -- Recursively set for children
    if node.args then
      for _, v in ipairs(node.args) do set_ast_mt(v) end
    end
    if node.left then set_ast_mt(node.left) end
    if node.right then set_ast_mt(node.right) end
    if node.base then set_ast_mt(node.base) end
    if node.exp then set_ast_mt(node.exp) end
    if node.value and type(node.value) == "table" then set_ast_mt(node.value) end
    -- Patch matrix rows if present
    if node.rows then
      for _, row in ipairs(node.rows) do
        for i, cell in ipairs(row) do
          row[i] = set_ast_mt(cell)
        end
      end
    end
  end
  return node
end

function ast_matrix(rows)
  return set_ast_mt({ type = "matrix", rows = rows })
end

-- Deep copy an AST — because shallow regret isn't enough
function ast_deepcopy(obj)
    if type(obj) ~= "table" then return obj end
    local res = {}
    for k, v in pairs(obj) do
        res[k] = ast_deepcopy(v)
    end
    return res
end

-- Structural equality check for ASTs
-- Tests whether two expressions are indistinguishably boring
function ast_equal(a, b)
    if type(a) ~= type(b) then return false end
    if type(a) ~= "table" then return a == b end
    for k, v in pairs(a) do
        if not ast_equal(v, b[k]) then return false end
    end
    for k, v in pairs(b) do
        if not ast_equal(v, a[k]) then return false end
    end
    return true
end

-- Depth-first traversal of the AST
-- Applies a function to every node, top-down
function ast_traverse(ast, fn)
    fn(ast)
    if type(ast) == "table" then
        if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
            for _, v in ipairs(ast.args) do
                ast_traverse(v, fn)
            end
        else
            for k, v in pairs(ast) do
                if type(v) == "table" then ast_traverse(v, fn) end
            end
        end
    end
end

-- Like traverse, but returns a new AST
-- Good for transformations and bad ideas
function ast_map(ast, fn)
    if type(ast) ~= "table" then return fn(ast) end
    local mapped = {}
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        mapped.type = ast.type
        mapped.args = {}
        if ast.name then mapped.name = ast.name end
        for i, v in ipairs(ast.args) do
            mapped.args[i] = ast_map(v, fn)
        end
    else
        for k, v in pairs(ast) do
            mapped[k] = ast_map(v, fn)
        end
    end
    return fn(mapped)
end

-- Replace all occurrences of a subtree with another
-- Think copy/paste but with slightly more guilt
function ast_substitute(ast, target, replacement)
    if ast_equal(ast, target) then return ast_deepcopy(replacement) end
    if type(ast) ~= "table" then return ast end
    local res = {}
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        res.type = ast.type
        if ast.name then res.name = ast.name end
        res.args = {}
        for i, v in ipairs(ast.args) do
            res.args[i] = ast_substitute(v, target, replacement)
        end
    else
        for k, v in pairs(ast) do
            res[k] = ast_substitute(v, target, replacement)
        end
    end
    return res
end

-- Collect all variable symbols in the AST
-- Returns a set-like table of every symbol that dares to show up
function ast_vars(ast, found)
    found = found or {}
    if type(ast) ~= "table" then return found end
    if ast.type == "variable" then found[ast.name] = true end
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        for _, v in ipairs(ast.args) do
            ast_vars(v, found)
        end
    else
        for k, v in pairs(ast) do
            ast_vars(v, found)
        end
    end
    return found
end

-- Count the total number of nodes in an AST
-- Like measuring code size, but with more branches
function ast_size(ast)
    if type(ast) ~= "table" then return 1 end
    local sum = 1
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        for _, v in ipairs(ast.args) do sum = sum + ast_size(v) end
    else
        for k, v in pairs(ast) do sum = sum + ast_size(v) end
    end
    return sum
end

-- Computes the maximum depth of the AST
-- Deep code is not necessarily smart code
function ast_depth(ast)
    if type(ast) ~= "table" then return 0 end
    local maxd = 0
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        for _, v in ipairs(ast.args) do
            local d = ast_depth(v)
            if d > maxd then maxd = d end
        end
    else
        for k, v in pairs(ast) do
            local d = ast_depth(v)
            if d > maxd then maxd = d end
        end
    end
    return 1 + maxd
end


-- Original AST to string printer (for debugging)
function ast_tostring_raw(ast)
    if type(ast) ~= "table" then return tostring(ast) end
    if ast.type == "number" then return tostring(ast.value) end
    if ast.type == "variable" then return ast.name end
    if ast.type == "func" then
        local args = {}
        for i, v in ipairs(ast.args) do args[i] = ast_tostring_raw(v) end
        return ast.name .. "(" .. table.concat(args, ",") .. ")"
    end
    if ast.type == "neg" then
        return "-(" .. ast_tostring_raw(ast.arg) .. ")"
    end
    if ast.type == "pow" then
        return "(" .. ast_tostring_raw(ast.base) .. ")^(" .. ast_tostring_raw(ast.exp) .. ")"
    end
    if ast.type == "add" then
        local parts = {}
        for i, v in ipairs(ast.args) do
            parts[i] = ast_tostring_raw(v)
        end
        return "(" .. table.concat(parts, " + ") .. ")"
    end
    if ast.type == "sub" then
        return "(" .. ast_tostring_raw(ast.left) .. ") - (" .. ast_tostring_raw(ast.right) .. ")"
    end
    if ast.type == "mul" then
        local parts = {}
        for i, v in ipairs(ast.args) do
            parts[i] = ast_tostring_raw(v)
        end
        -- Nice form: 2x, x2 for two args, otherwise with *
        if #parts == 2 then
            local a, b = ast.args[1], ast.args[2]
            if ast_is_number(a) and ast_is_variable(b) then
                return tostring(a.value) .. parts[2]
            elseif ast_is_variable(a) and ast_is_number(b) then
                return parts[1] .. tostring(b.value)
            end
        end
        return table.concat(parts, "*")
    end
    if ast.type == "div" then
        return "(" .. ast_tostring_raw(ast.left) .. ")/(" .. ast_tostring_raw(ast.right) .. ")"
    end
    if ast.type == "raw" then
        return "[RAW:" .. tostring(ast.value) .. "]"
    end
    -- fallback
    local str = "{" .. (ast.type or "?")
    for k, v in pairs(ast) do
        if k ~= "type" then str = str .. "," .. k .. "=" .. ast_tostring_raw(v) end
    end
    return str .. "}"
end

-- AST node type test helpers
function ast_is_number(node)
    return type(node) == "table" and node.type == "number"
end
function ast_is_variable(node)
    return type(node) == "table" and node.type == "variable"
end
function ast_is_func(node, fname)
    return type(node) == "table" and node.type == "func" and (not fname or node.name == fname)
end
function ast_is_op(node, op)
    return type(node) == "table" and node.type == op
end


-- Evaluate the AST numerically if it's purely numeric
-- Warning: does not handle symbolic stupidity
function ast_eval_numeric(ast, env)
    env = env or {}
    if ast.type == "number" then return ast.value end
    if ast.type == "variable" then
        return env[ast.name] or error("Unbound variable: " .. tostring(ast.name))
    end
    if ast.type == "func" then
        local argv = {}
        for i, v in ipairs(ast.args) do
            argv[i] = ast_eval_numeric(v, env)
        end
        if math[ast.name] then
            return math[ast.name](table.unpack(argv))
        elseif ast.name == "ln" then
            return math.log(argv[1])
        elseif ast.name == "log" then
            return math.log10(argv[1])
        elseif ast.name == "gamma" then
            local n = argv[1]
            if n > 0 and math.floor(n) == n then
                local factorial = 1
                for i = 1, n - 1 do
                    factorial = factorial * i
                end
                return factorial
            elseif n == 0.5 then
                return math.sqrt(math.pi)
            else
                error("Gamma function not implemented for value: " .. tostring(n))
            end
        else
            error("Unknown function: " .. ast.name)
        end
    end
    if ast.type == "add" then
        local sum = 0
        for _, v in ipairs(ast.args) do
            sum = sum + ast_eval_numeric(v, env)
        end
        return sum
    end
    if ast.type == "sub" then
        return ast_eval_numeric(ast.left, env) - ast_eval_numeric(ast.right, env)
    end
    if ast.type == "mul" then
        local prod = 1
        for _, v in ipairs(ast.args) do
            prod = prod * ast_eval_numeric(v, env)
        end
        return prod
    end
    if ast.type == "div" then
        return ast_eval_numeric(ast.left, env) / ast_eval_numeric(ast.right, env)
    end
    if ast.type == "pow" then
        return ast_eval_numeric(ast.base, env) ^ ast_eval_numeric(ast.exp, env)
    end
    if ast.type == "neg" then
        return -ast_eval_numeric(ast.arg, env)
    end
    error("Unsupported node in ast_eval_numeric: " .. tostring(ast.type))
end

-- Pattern match against an AST using a pattern
-- Binds variables, fails if it sees something it doesn’t like
function ast_match(pattern, ast, bindings)
    bindings = bindings or {}
    if type(pattern) ~= "table" then
        if pattern == ast then return bindings else return nil end
    end
    if pattern.var then
        if bindings[pattern.var] then
            return ast_equal(bindings[pattern.var], ast) and bindings or nil
        else
            bindings[pattern.var] = ast
            return bindings
        end
    end
    if type(ast) ~= "table" then return nil end
    if pattern.type and pattern.type ~= ast.type then return nil end
    if (pattern.type == "add" or pattern.type == "mul" or pattern.type == "func") and pattern.args then
        if #pattern.args ~= #ast.args then return nil end
        for i = 1, #pattern.args do
            local sub = ast_match(pattern.args[i], ast.args[i], bindings)
            if not sub then return nil end
            bindings = sub
        end
    else
        for k, v in pairs(pattern) do
            if k ~= "var" and k ~= "args" then
                local sub = ast_match(v, ast[k], bindings)
                if not sub then return nil end
                bindings = sub
            end
        end
    end
    return bindings
end

-- Export all as ast.*
ast = {
    number = ast_number,
    symbol = ast_symbol,
    variable = ast_symbol,
    func = ast_func,
    binop = ast_binop,
    neg = ast_neg,
    pow = ast_pow,
    raw = ast_raw,
    matrix = ast_matrix,

    -- Shorthand binary operation constructors
    add = function(...) return { type = "add", args = {...} } end,
    sub = function(l, r) return ast_binop("sub", l, r) end,
    mul = function(...) return { type = "mul", args = {...} } end,
    div = function(l, r) return ast_binop("div", l, r) end,
    pow = function(l, r) return ast_pow(l, r) end,
    neg = ast_neg,
    eq = function(left, right) return { type = "equation", left = left, right = right } end,

    deepcopy = ast_deepcopy,
    equal = ast_equal,
    traverse = ast_traverse,
    map = ast_map,
    substitute = ast_substitute,
    vars = ast_vars,
    size = ast_size,
    depth = ast_depth,
    tostring = ast_tostring,

    is_number = ast_is_number,
    is_variable = ast_is_variable,
    is_func = ast_is_func,
    is_op = ast_is_op,

    eval_numeric = ast_eval_numeric,
    match = ast_match,
    debug_print = ast_debug_print,
}

-- Flattens nested additive/multiplicative trees
-- Useful for canonicalization, sorting, or general misuse
function ast_flatten_add(node)
    if not ast_is_op(node, "add") then return { node } end
    local parts = {}
    local function collect(n)
        if ast_is_op(n, "add") then
            for _, v in ipairs(n.args) do
                collect(v)
            end
        else
            table.insert(parts, n)
        end
    end
    collect(node)
    table.sort(parts, function(a, b) return ast_tostring(a) < ast_tostring(b) end)
    return parts
end

-- Flattens nested additive/multiplicative trees
-- Useful for canonicalization, sorting, or general misuse
function ast_flatten_mul(node)
    if not ast_is_op(node, "mul") then return { node } end
    local parts = {}
    local function collect(n)
        if ast_is_op(n, "mul") then
            for _, v in ipairs(n.args) do
                collect(v)
            end
        else
            table.insert(parts, n)
        end
    end
    collect(node)
    table.sort(parts, function(a, b) return ast_tostring(a) < ast_tostring(b) end)
    return parts
end

ast.flatten_add = ast_flatten_add
ast.flatten_mul = ast_flatten_mul

-- Generic AST node constructor
function ast_node(typ, opts)
    local node = { type = typ }
    for k, v in pairs(opts or {}) do
        node[k] = v
    end
    return node
end
ast.node = ast_node
_G.ast_node = ast.node
_G.ast = ast






-- Wildcard pattern constructor for integration matching
function ast_wildcard(varname)
    return { var = varname }
end
ast.wildcard = ast_wildcard
_G.wildcard = ast_wildcard

_G.ast_debug_print = ast_debug_print


-- Patch ast.eval_numeric to support physics functions without cyclic load errors
do
  local old_eval_numeric = ast.eval_numeric

  function ast.eval_numeric(node, env)
    env = env or {}
    -- Lazy-load physics module to break cyclic dependency
    local physics = _G.physics or require("physics")

    if node.type == "func" then
      local args_eval = {}
      for i, arg in ipairs(node.args) do
        args_eval[i] = ast.eval_numeric(arg, env)
      end

      if math[node.name] then
        return math[node.name](table.unpack(args_eval))
      end

      if node.name == "ln" then return math.log(args_eval[1]) end
      if node.name == "log" then return math.log10(args_eval[1]) end
      if node.name == "gamma" then
        local n = args_eval[1]
        if n > 0 and math.floor(n) == n then
          local fact = 1
          for i = 1, n - 1 do fact = fact * i end
          return fact
        elseif n == 0.5 then
          return math.sqrt(math.pi)
        else
          error("Gamma function not implemented for value: " .. tostring(n))
        end
      end

      -- Delegate to physics evaluation if available
      local phys_val = physics.eval_physics_func(node.name, node.args)
      if phys_val ~= nil then
        return ast.eval_numeric(phys_val, env)
      end

      error("Unknown function: " .. tostring(node.name))
    else
      return old_eval_numeric(node, env)
    end
  end

  ast.eval_numeric = ast.eval_numeric
end

-- End src/ast.lua

-- Integrated src/ast.lua: let’s hope it compiles this time.

-- Begin src/parser.lua
-- parser.lua: Because writing your own parser is the best way to avoid happiness.
--
-- For those who care about "compatibility": yes, the API is still the same.
--   tokenize(expr) => {tokens} -- like anyone remembers the output.
--   buildAST(tokens) => ast    -- because trees are the only way to understand math.
--   parseExpr(tokens, idx) => ast, nextIdx -- because recursion is fun until it isn't.
--
-- Now with more "features" you didn't ask for: error nagging, big numbers, functions, brackets, sneaky multiplication, negative numbers, and, because why not, matrix parsing.

local parser = {}
local init = rawget(_G, "init")
local errors = rawget(_G, "errors") or {
  invalid = function(fn, hint)
    return "parse(" .. (fn or "?") .. "): " .. (hint or "unknown error. also: _G.errors was nil.")
  end
}

-- Because seeing your AST in tree form is the only joy you'll get today.
local function print_ast(ast, indent)
  indent = indent or ""
  if type(ast) ~= "table" then
    print(indent .. tostring(ast))
    return
  end
  if ast.type then
    local desc = ast.type
    if ast.name then desc = desc .. " (" .. tostring(ast.name) .. ")" end
    print(indent .. desc)
    if ast.value ~= nil then print(indent .. "  value: " .. tostring(ast.value)) end
    if ast.name ~= nil and ast.type ~= "variable" then print(indent .. "  name: " .. tostring(ast.name)) end
    if ast.args then
      print(indent .. "  args:")
      for i, arg in ipairs(ast.args) do
        print_ast(arg, indent .. "    ")
      end
    end
    if ast.rows then
      print(indent .. "  rows:")
      for i, row in ipairs(ast.rows) do
        print(indent .. "    row " .. i .. ":")
        for j, elem in ipairs(row) do
          print_ast(elem, indent .. "      ")
        end
      end
    end
    if ast.base then
      print(indent .. "  base:")
      print_ast(ast.base, indent .. "    ")
    end
    if ast.exp then
      print(indent .. "  exp:")
      print_ast(ast.exp, indent .. "    ")
    end
    if ast.left then
      print(indent .. "  left:")
      print_ast(ast.left, indent .. "    ")
    end
    if ast.right then
      print(indent .. "  right:")
      print_ast(ast.right, indent .. "    ")
    end
  else
    for k, v in pairs(ast) do
      print(indent .. tostring(k) .. ":")
      print_ast(v, indent .. "  ")
    end
  end
end
parser.print_ast = print_ast
_G.print_ast = print_ast

-- Tokenizer: Because parsing math without slicing it into tiny pieces would be too easy.

local function utf8char(str, i)
  local b1 = str:byte(i)
  if not b1 then return nil, 0 end
  if b1 < 0x80 then
    return str:sub(i, i), 1
  elseif b1 < 0xE0 and #str >= i + 1 then
    return str:sub(i, i + 1), 2
  elseif b1 < 0xF0 and #str >= i + 2 then
    return str:sub(i, i + 2), 3
  elseif b1 < 0xF8 and #str >= i + 3 then
    return str:sub(i, i + 3), 4
  else
    -- Invalid start byte or incomplete sequence, treat as one byte to avoid infinite loop
    return str:sub(i, i), 1
  end
end

-- Adjust is_alpha to recognize ascii letters and greek utf8 letters (add more if needed)
local function is_alpha(c)
  -- ASCII letters
  if c:match("^[%a_]$") then return true end
  -- Common Greek letters and others can be added here
  -- For demo, accept anything with byte length > 1 (non-ASCII)
  if #c > 1 then return true end
  return false
end

function parser.tokenize(expr)
  local tokens = {}
  local i = 1
  local len = #expr
  while i <= len do
    local c, clen = utf8char(expr, i)
    if not c or clen == 0 then break end

    if c:match('%s') then
      -- whitespace
      i = i + clen
    -- Improved special handling for (d/dx) derivative pattern
    elseif expr:sub(i, i+4) == "(d/dx" and expr:sub(i+5, i+5) == ")" then
      table.insert(tokens, {type="derivative"})
      i = i + 6 -- skip full "(d/dx)"
    elseif c:match('%d') or (c == '.' and (i+clen <= len) and expr:sub(i+clen,i+clen):match('%d')) then
      -- number, read full numeric token
      local num = c
      i = i + clen
      while i <= len do
        local nc, nclen = utf8char(expr, i)
        if not nc or not (nc:match('%d') or nc == '.') then break end
        num = num .. nc
        i = i + nclen
      end
      table.insert(tokens, {type="number", value=tonumber(num)})
      print(string.format("Token: [number] %s", num))
    elseif c == '∫' then
      table.insert(tokens, {type="integral", value=c})
      print(string.format("Token: [integral] %s", c))
      i = i + clen
    elseif is_alpha(c) then
      -- identifier/function
      local ident = c
      i = i + clen
      while i <= len do
        local nc, nclen = utf8char(expr, i)
        if not nc then break end
        if is_alpha(nc) or nc:match('%d') then
          ident = ident .. nc
          i = i + nclen
        else
          break
        end
      end
      table.insert(tokens, {type="ident", value=ident})
      print(string.format("Token: [ident] %s", ident))
    elseif c == '"' or c == "'" then
      -- string literal
      local quote = c
      local j = i + clen
      local str = ''
      while j <= len do
        local cc, cclen = utf8char(expr, j)
        if not cc then break end
        if cc == quote then break end
        str = str .. cc
        j = j + cclen
      end
      if j > len then
        error(errors.invalid('tokenize', 'unterminated string literal'))
      end
      table.insert(tokens, {type='string', value=str})
      print(string.format("Token: [string] %s", str))
      i = j + clen -- skip closing quote
    elseif c == ')' then
      -- Special handling for closing parenthesis after (d/dx
      if #tokens > 0 and tokens[#tokens].type == "derivative_start" then
        tokens[#tokens].type = "derivative"
      else
        table.insert(tokens, {type=c, value=c})
      end
      i = i + clen
    elseif c == ',' or c == '(' or c == '[' or c == ']' or
           c == '+' or c == '-' or c == '*' or c == '/' or c == '^' or
           c == '!' or c == '=' or c == '∫' then
      local ttype
      if c == ',' then ttype = ','
      elseif c == '(' then ttype = c
      elseif c == '[' or c == ']' then ttype = c
      elseif c == '=' then ttype = "equals"
      elseif c == '∫' then ttype = "integral"
      elseif c == '+' or c == '-' or c == '*' or c == '/' or c == '^' or c == '!' then ttype = "op"
      else ttype = "unknown" end
      table.insert(tokens, {type=ttype, value=c})
      print(string.format("Token: [%s] %s", ttype, c))
      i = i + clen
    else
      error(errors.invalid("tokenize", "unknown character: " .. c))
    end
  end

  -- Insert commas between adjacent tensor brackets like '][' to fix TI calculator formatting
  local j = 2
  while j <= #tokens do
    local t1, t2 = tokens[j-1], tokens[j]
    if t1.type == ']' and t2.type == '[' then
      table.insert(tokens, j, {type=",", value=","})
      j = j + 1
    end
    j = j + 1
  end

  -- Insert implicit multiplication tokens as before
  local j = 2
  while j <= #tokens do
    local t1, t2 = tokens[j-1], tokens[j]
    if (t1.type == 'number' or t1.type == ')' ) and
       (t2.type == 'ident' or t2.type == '(' or t2.type == '[') then
      table.insert(tokens, j, {type="op", value="*"})
      j = j + 1
    end
    j = j + 1
  end

  print("Final token list:")
  for _, tok in ipairs(tokens) do
    print(string.format("  %s : %s", tok.type, tostring(tok.value)))
  end
  return tokens
end

-- Parser: Because recursion is the only way to feel alive.
--   Now with precedence, unary minus, function calls, and, of course, matrices.


-- Tensor parsing: supports arbitrary rank tensors (nested lists of expressions).
local function parse_tensor(tokens, idx)
  -- Expect '[' to start tensor.
  assert(tokens[idx] and tokens[idx].type == '[',
         errors.invalid("parse_tensor", "expected '[' to start tensor (did you mean to type something else?)"))

  local function parse_elements(i)
    local elements = {}
    local first = true
    while true do
      if tokens[i] and tokens[i].type == '[' then
        -- Recursively parse a sub-tensor and always wrap as {type="tensor", elements=...}
        local sub_elems, ni = parse_elements(i + 1)
        table.insert(elements, {type = "tensor", elements = sub_elems})
        i = ni
      elseif tokens[i] and tokens[i].type ~= ']' then
        -- Parse a scalar element
        local elem, ni = parser.parseExpr(tokens, i)
        if type(elem) == "number" then
          table.insert(elements, { type = "number", value = elem })
        else
          table.insert(elements, elem)
        end
        i = ni
      end
      if tokens[i] and tokens[i].type == ',' then
        i = i + 1
        first = false
      elseif tokens[i] and tokens[i].type == ']' then
        return elements, i + 1
      else
        break
      end
    end
    error(errors.invalid("parse_tensor", "expected ',' or ']' in tensor definition"))
  end

  local i = idx + 1
  if tokens[i] and tokens[i].type == ']' then
    return {type="tensor", elements={}}, i + 1
  end

  local elements, ni = parse_elements(i)
  return {type="tensor", elements=elements}, ni
end

-- Handles literals, variables, function calls, parentheses, matrices, and unary minus.
-- Also wraps things in factorials if someone thought 'x!' was a good idea. Because, why not.
local function make_var(x) return {type="variable", name=x} end -- Because variables need love too.

-- Integral parsing: parses ∫(expression, variable)
local function parse_integral(tokens, idx)
  -- ∫(expression, variable) format
  local tok = tokens[idx]
  assert(tok and tok.type == "integral", "expected ∫ symbol")

  assert(tokens[idx + 1] and tokens[idx + 1].type == "(", "expected '(' after ∫")

  local expr, i = parser.parseExpr(tokens, idx + 2)
  assert(tokens[i] and tokens[i].type == ",", "expected ',' after integral expression")

  local var_token = tokens[i + 1]
  assert(var_token and var_token.type == "ident", "expected variable name after ',' in integral")

  assert(tokens[i + 2] and tokens[i + 2].type == ")", "expected ')' to close integral")

  return {
    type = "func",
    name = "int",
    args = { expr, { type = "variable", name = var_token.value } }
  }, i + 3
end

local function parse_primary(tokens, idx)
  local tok = tokens[idx]
  if not tok then return nil, idx end

  local function wrap_factorial(node, i)
    if tokens[i] and tokens[i].type == "op" and tokens[i].value == "!" then
      return {
        type = "func",
        name = "factorial",
        args = { node }
      }, i + 1
    end
    return node, i
  end

  -- Derivative node: (d/dx)(expr) pattern
  if tok.type == "derivative" then
    local expr, ni = parser.parseExpr(tokens, idx + 1)
    return {type="derivative", respect_to="x", expr=expr}, ni
  end

  if tok.type == "integral" then
    return parse_integral(tokens, idx)
  elseif tok.type == "number" then
    return wrap_factorial({type="number", value=tok.value}, idx+1)
  elseif tok.type == "ident" then
    if tokens[idx + 1] and tokens[idx + 1].type == "(" then
      -- Special handling for series(func, var, center, order)
      if tok.value == "series" then
        local i = idx + 2
        local func_expr, ni = parser.parseExpr(tokens, i)
        if not (tokens[ni] and tokens[ni].type == ",") then error("Error: Failed to parse the series expression. Did you use correct syntax?") end
        local var_node, ni2 = parser.parseExpr(tokens, ni + 1)
        if not (tokens[ni2] and tokens[ni2].type == ",") then error("Error: Failed to parse the series expression. Did you use correct syntax?") end
        local center_node, ni3 = parser.parseExpr(tokens, ni2 + 1)
        if not (tokens[ni3] and tokens[ni3].type == ",") then error("Error: Failed to parse the series expression. Did you use correct syntax?") end
        local order_node, ni4 = parser.parseExpr(tokens, ni3 + 1)
        if not (tokens[ni4] and tokens[ni4].type == ")") then error("Error: Failed to parse the series expression. Did you use correct syntax?") end
        return {
          type = "series",
          func = func_expr,
          var = var_node,
          center = center_node,
          order = order_node
        }, ni4 + 1
      end
      -- Function call detected (non-series)
      local args = {}
      local i = idx + 2
      if tokens[i] and tokens[i].type ~= ")" then
        local arg_node
        arg_node, i = parser.parseExpr(tokens, i)
        table.insert(args, arg_node)
        while tokens[i] and tokens[i].type == "," do
          local next_arg
          next_arg, i = parser.parseExpr(tokens, i + 1)
          table.insert(args, next_arg)
        end
      end
      assert(tokens[i] and tokens[i].type == ")", "expected ')' after function arguments")
      return wrap_factorial({ type="func", name=tok.value, args=args }, i + 1)
    else
      local physics_constants = _G.physics and _G.physics.constants or nil
      if physics_constants and physics_constants[tok.value] then
        -- Use deepcopy to avoid shared state for constant value nodes
        local deepcopy = rawget(_G, "deepcopy") or function(tbl)
          if type(tbl) ~= "table" then return tbl end
          local t2 = {}
          for k, v in pairs(tbl) do
            t2[k] = type(v) == "table" and deepcopy(v) or v
          end
          return t2
        end
        local constant_entry = physics_constants[tok.value]
        local val_node = deepcopy(constant_entry.value)
        local node = {type="constant", name=tok.value, value=val_node}
        return wrap_factorial(node, idx + 1)
      else
        return wrap_factorial({type="variable", name=tok.value}, idx + 1)
      end
    end
  elseif tok.type == '(' then
    -- Detect general derivative notation (d)/(dx)(expr)
    if tokens[idx+1] and tokens[idx+1].type == 'ident' and tokens[idx+1].value == 'd' then
      if tokens[idx+2] and tokens[idx+2].type == ')' and
   tokens[idx+3] and tokens[idx+3].type == 'op' and tokens[idx+3].value == '/' and
   tokens[idx+4] and tokens[idx+4].type == '(' and
   tokens[idx+5] and tokens[idx+5].type == 'ident' and tokens[idx+5].value == 'dx' and
   tokens[idx+6] and tokens[idx+6].type == ')' then
        local expr, ni = parser.parseExpr(tokens, idx + 7)
        return {
            type = "derivative",
            respect_to = "x",
            expr = expr
        }, ni
      end
    end
    local node, ni = parser.parseExpr(tokens, idx+1)
    assert(tokens[ni] and tokens[ni].type == ')', "expected ')'")
    return wrap_factorial(node, ni+1)
  elseif tok.type == '[' then
    local tensor, ni = parse_tensor(tokens, idx)
    return wrap_factorial(tensor, ni)
  elseif tok.type == 'string' then
    return {type='string', value=tok.value}, idx + 1
  elseif tok.type == "op" and tok.value == '-' then
    local expr, ni = parser.parseExpr(tokens, idx+1)
    return wrap_factorial({type="neg", value=expr}, ni)
  else
    error("unexpected token at parse_primary: " .. (tok.type or '?'))
  end
end

-- Parses exponentiation. Right-associative, because math teachers said so.
local function parse_power(tokens, idx)
  local left, i = parse_primary(tokens, idx)
  while tokens[i] and tokens[i].type == "op" and tokens[i].value == '^' do
    local right
    right, i = parse_primary(tokens, i+1)
    left = {type="pow", base=left, exp=right}
  end
  return left, i
end

-- Handles multiplication, division, and reciprocal logic.
-- Because a/b is really just a*1/b, right? (Sure, let's pretend.)
local function parse_term(tokens, idx)
  -- Parse the first factor, because you have to start somewhere.
  local factors = {}
  local i = idx
  local node, ni = parse_power(tokens, i)
  table.insert(factors, node)
  i = ni
  while tokens[i] and tokens[i].type == "op" and (tokens[i].value == '*' or tokens[i].value == '/') do
    local op = tokens[i].value
    local right
    right, i = parse_power(tokens, i+1)
    if op == '*' then
      table.insert(factors, right)
    else
      -- Division: because why not multiply by the reciprocal and confuse everyone.
      table.insert(factors, {type="pow", base=right, exp={type="number", value=-1}})
    end
  end
  if #factors == 1 then
    return factors[1], i
  else
    return {type="mul", args=factors}, i
  end
end

-- The real entry point for expressions. Supports + and -, but mostly supports your suffering.
-- Folds everything into a single add tree so simplify() doesn't go on strike.
function parser.parseExpr(tokens, idx)
  idx = idx or 1
  local terms = {}
  local signs = {}
  local node, i = parse_term(tokens, idx)
  table.insert(terms, node)
  table.insert(signs, 1)
  while tokens[i] and tokens[i].type == "op" and (tokens[i].value == '+' or tokens[i].value == '-') do
    local op = tokens[i].value
    local right
    right, i = parse_term(tokens, i+1)
    if op == '+' then
      table.insert(terms, right)
      table.insert(signs, 1)
    else
      -- Instead of wrapping just numbers in neg, wrap the whole right term
      table.insert(terms, right)
      table.insert(signs, -1)
    end
  end
  -- Flatten into n-ary add, handling subtraction as add of negative (because why not make it harder?)
  if #terms == 1 then
    if tokens[i] and tokens[i].type == "equals" then
      local rhs, next_i = parser.parseExpr(tokens, i + 1)
      return {type = "equation", left = node, right = rhs}, next_i -- Because equations make everything more complicated.
    end
    return node, i
  else
    local args = {}
    for j = 1, #terms do
      if signs[j] == 1 then
        table.insert(args, terms[j])
      else
        table.insert(args, {type="neg", value=terms[j]})
      end
    end
    local add_node = {type="add", args=args}
    if tokens[i] and tokens[i].type == "equals" then
      local rhs, next_i = parser.parseExpr(tokens, i + 1)
      return {type = "equation", left = add_node, right = rhs}, next_i -- Because why stop at arithmetic when you can do algebra?
    end
    return add_node, i
  end
end

-- Wraps parseExpr and checks for leftovers.
-- If you forgot a bracket, this will find it and yell at you.
function parser.buildAST(tokens)
  local ast, idx = parser.parseExpr(tokens, 1)
  if idx <= #tokens then
    error(errors.invalid("parse", "unexpected " .. tostring(tokens[idx].type or "?") .. " (you left something behind)"))
  end
  return ast
end

function parser.parse(expr)
  -- Get physics constants table and category from global
  local constants = _G.physics and _G.physics.constants or nil
  local constants_off = _G.var and _G.var.recall and _G.var.recall("constants_off")
  local current_category = _G.current_constant_category or "fundamental"

  -- Tokenize first, then replace identifier tokens with constants if appropriate
  local tokens = parser.tokenize(expr)

  -- Replace identifiers matching constant symbols after tokenizing
  if constants and not constants_off then
      for _, tok in ipairs(tokens) do
          if tok.type == "ident" and constants[tok.value] then
              if _G.physics.is_constant_enabled(tok.value) and
                 (not current_category or constants[tok.value].category == current_category or constants[tok.value].category == nil) then
                  -- Replace identifier with constant name if symbol matches
                  tok.type = "constant"
                  tok.name = tok.value
                  tok.value = nil
              end
          end
      end
  end

  -- Proceed with building AST etc...
  local ok, ast_or_err = pcall(parser.buildAST, tokens)
  if not ok then
    local err_msg = tostring(ast_or_err)
    if err_msg:match("parse%(series%)") then
      error(errors.invalid("parse(series)", err_msg))
    elseif err_msg:match("parse%(integral%)") then
      error(errors.invalid("parse(integral)", err_msg))
    elseif err_msg:match("parse%(derivative%)") then
      error(errors.invalid("parse(derivative)", err_msg))
    elseif err_msg:match("parse%(matrix%)") then
      error(errors.invalid("parse(matrix)", err_msg))
    else
      error(errors.invalid("parse", err_msg))
    end
  end
  -- Automatically simplify after parsing if possible
  local simplified = rawget(_G, "simplify") and _G.simplify.simplify_step and _G.simplify.simplify_step(ast_or_err) or ast_or_err

  -- Evaluate factorial and integral nodes if possible (replace factorial(func(number)) with number node, and int(number, var) with number node)
  local function evaluate_nodes(node)
      if type(node) ~= "table" then return node end

      -- Evaluate factorial for numeric args
      if node.type == "func" and node.name == "factorial" and node.args and #node.args == 1 then
          local arg = evaluate_nodes(node.args[1])
          if arg.type == "number" and _G.evaluateFactorial then
              return { type = "number", value = _G.evaluateFactorial(arg.value) }
          end
          node.args[1] = arg
          return node
      end

      -- Evaluate integral if expr is numeric
      if node.type == "func" and node.name == "int" and node.args and #node.args == 2 then
          local expr = evaluate_nodes(node.args[1])
          local var = evaluate_nodes(node.args[2])
          if expr.type == "number" and var.type == "variable" and _G.evaluateIntegral then
              return { type = "number", value = _G.evaluateIntegral(expr.value, var.name) }
          end
          node.args[1] = expr
          node.args[2] = var
          return node
      end

      -- Recurse
      if node.args then
          for i, arg in ipairs(node.args) do
              node.args[i] = evaluate_nodes(arg)
          end
      elseif node.value then
          node.value = evaluate_nodes(node.value)
      end
      return node
  end

  local evaluated = evaluate_nodes(simplified)
  return evaluated
end

_G.parser = parser
_G.parse = parser.parse

_G.parser = parser

-- Expose a direct solve_equation interface for global use, because everyone wants to solve everything.
if _G.solve_equation then
  _G.solve = function(expr)
    local ast = parser.parse(expr)
    return _G.solve_equation(ast)
  end
end

-- Wraps two arguments in a 'sub' node, because subtraction isn't just minus.
function parser.make_sub(left, right)
  return {type = "sub", left = left, right = right}
end

-- Wraps two arguments in a 'div' node, because division is just misunderstood multiplication.
function parser.make_div(num, denom)
  return {type = "div", left = num, right = denom}
end


-- Greek letter aliases (UTF-8 mapped to standard names)
-- Greek letter aliases for physics constants (assumes Constants table exists)
if _G.Constants then
    -- Basic Greek alphabet
    Constants[utf8(945)] = Constants["alpha"] or Constants[utf8(945)]  -- α (fine structure already exists)
Constants[utf8(946)] = Constants["beta"]                           -- β  
Constants[utf8(947)] = Constants["gamma"]                          -- γ
Constants[utf8(948)] = Constants["delta"]                          -- δ
Constants[utf8(949)] = Constants["epsilon"] or Constants[utf8(949).."0"] -- ε (permittivity already exists)
Constants[utf8(950)] = Constants["zeta"]                           -- ζ
Constants[utf8(951)] = Constants["eta"]                            -- η
Constants[utf8(952)] = Constants["theta"]                          -- θ
Constants[utf8(953)] = Constants["iota"]                           -- ι
Constants[utf8(954)] = Constants["kappa"]                          -- κ
Constants[utf8(955)] = Constants["lambda"]                         -- λ
Constants[utf8(956)] = Constants["mu"] or Constants[utf8(956).."0"] -- μ (permeability already exists)
Constants[utf8(957)] = Constants["nu"]                             -- ν
Constants[utf8(958)] = Constants["xi"]                             -- ξ
Constants[utf8(959)] = Constants["omicron"]                        -- ο
Constants[utf8(960)] = Constants["pi"]                             -- π (already exists)
Constants[utf8(961)] = Constants["rho"]                            -- ρ
Constants[utf8(962)] = Constants["sigma_final"]                    -- ς (final sigma)
Constants[utf8(963)] = Constants["sigma"]                          -- σ
Constants[utf8(964)] = Constants["tau"]                            -- τ
Constants[utf8(965)] = Constants["upsilon"]                        -- υ
Constants[utf8(966)] = Constants["phi"]                            -- φ
Constants[utf8(967)] = Constants["chi"]                            -- χ
Constants[utf8(968)] = Constants["psi"]                            -- ψ
Constants[utf8(969)] = Constants["omega"]                          -- ω

-- Greek letters (uppercase)
Constants[utf8(913)] = Constants["Alpha"]                          -- Α
Constants[utf8(914)] = Constants["Beta"]                           -- Β
Constants[utf8(915)] = Constants["Gamma"]                          -- Γ
Constants[utf8(916)] = Constants["Delta"]                          -- Δ
Constants[utf8(917)] = Constants["Epsilon"]                        -- Ε
Constants[utf8(918)] = Constants["Zeta"]                           -- Ζ
Constants[utf8(919)] = Constants["Eta"]                            -- Η
Constants[utf8(920)] = Constants["Theta"]                          -- Θ
Constants[utf8(921)] = Constants["Iota"]                           -- Ι
Constants[utf8(922)] = Constants["Kappa"]                          -- Κ
Constants[utf8(923)] = Constants["Lambda"]                         -- Λ
Constants[utf8(924)] = Constants["Mu"]                             -- Μ
Constants[utf8(925)] = Constants["Nu"]                             -- Ν
Constants[utf8(926)] = Constants["Xi"]                             -- Ξ
Constants[utf8(927)] = Constants["Omicron"]                        -- Ο
Constants[utf8(928)] = Constants["Pi"]                             -- Π
Constants[utf8(929)] = Constants["Rho"]                            -- Ρ
Constants[utf8(931)] = Constants["Sigma"]                          -- Σ
Constants[utf8(932)] = Constants["Tau"]                            -- Τ
Constants[utf8(933)] = Constants["Upsilon"]                        -- Υ
Constants[utf8(934)] = Constants["Phi"]                            -- Φ
Constants[utf8(935)] = Constants["Chi"]                            -- Χ
Constants[utf8(936)] = Constants["Psi"]                            -- Ψ
Constants[utf8(937)] = Constants["Omega"]                          -- Ω

-- PHYSICS-SPECIFIC CONSTANTS AND ALIASES

-- Common physics symbols
Constants[utf8(8463)] = Constants["h"] or Constants["planck"]      -- ℏ (reduced Planck)
Constants["hbar"] = Constants[utf8(8463)]

-- Mass-energy relations
Constants[utf8(956).."e"] = Constants["me"]                        -- μe (electron mass)
Constants[utf8(956).."p"] = Constants["mp"]                        -- μp (proton mass) 
Constants[utf8(956).."n"] = Constants["mn"]                        -- μn (neutron mass)

-- Coupling constants
Constants[utf8(945).."s"] = Constants["strong_coupling"]           -- αs (strong coupling)
Constants[utf8(945).."em"] = Constants[utf8(945)]                  -- αem (electromagnetic, same as fine structure)

-- Particle physics masses (if you add them)
Constants[utf8(956).."_e"] = Constants["electron_mass"]            -- μ_e
Constants[utf8(956).."_"..utf8(956)] = Constants["muon_mass"]      -- μ_μ (muon)
Constants[utf8(956).."_"..utf8(964)] = Constants["tau_mass"]       -- μ_τ (tau)
Constants["m_W"] = Constants["w_boson_mass"]                       -- W boson
Constants["m_Z"] = Constants["z_boson_mass"]                       -- Z boson
Constants["m_H"] = Constants["higgs_mass"]                         -- Higgs
Constants["m_t"] = Constants["top_mass"]                          -- top quark
Constants["m_b"] = Constants["bottom_mass"]                       -- bottom quark
Constants["m_c"] = Constants["charm_mass"]                        -- charm quark
Constants["m_s"] = Constants["strange_mass"]                      -- strange quark
Constants["m_u"] = Constants["up_mass"]                           -- up quark
Constants["m_d"] = Constants["down_mass"]                         -- down quark

-- QCD scale
Constants[utf8(923).."_QCD"] = Constants["lambda_qcd"]            -- Λ_QCD
Constants[utf8(952).."_QCD"] = Constants["theta_qcd"]             -- θ_QCD

-- Weinberg angle
Constants[utf8(952).."_W"] = Constants["weinberg_angle"]          -- θ_W
Constants["sin2"..utf8(952).."_W"] = Constants["sin2_theta_w"]    -- sin²θ_W

-- Cosmological constants
Constants[utf8(923)] = Constants["cosmological_constant"]         -- Λ
Constants[utf8(937).."_m"] = Constants["matter_density"]          -- Ω_m
Constants[utf8(937).."_"..utf8(923)] = Constants["dark_energy"]  -- Ω_Λ
Constants[utf8(937).."_b"] = Constants["baryon_density"]          -- Ω_b
Constants["H_0"] = Constants["hubble_constant"]                   -- H₀

-- Thermodynamic
Constants[utf8(946)] = Constants["inverse_temperature"]           -- β = 1/(kT)
Constants[utf8(963).."_SB"] = Constants["stefan_boltzmann"]       -- σ_SB

-- CKM matrix elements (quark mixing)
Constants["V_ud"] = Constants["ckm_ud"]
Constants["V_us"] = Constants["ckm_us"] 
Constants["V_ub"] = Constants["ckm_ub"]
Constants["V_cd"] = Constants["ckm_cd"]
Constants["V_cs"] = Constants["ckm_cs"]
Constants["V_cb"] = Constants["ckm_cb"]
Constants["V_td"] = Constants["ckm_td"]
Constants["V_ts"] = Constants["ckm_ts"]
Constants["V_tb"] = Constants["ckm_tb"]

-- PMNS matrix elements (neutrino mixing)
Constants[utf8(952).."_12"] = Constants["solar_angle"]           -- θ₁₂
Constants[utf8(952).."_23"] = Constants["atmospheric_angle"]     -- θ₂₃  
Constants[utf8(952).."_13"] = Constants["reactor_angle"]         -- θ₁₃
Constants[utf8(948).."_CP"] = Constants["cp_phase"]              -- δ_CP

-- Neutrino mass differences
Constants[utf8(916).."m2_21"] = Constants["delta_m21_squared"]   -- Δm²₂₁
Constants[utf8(916).."m2_31"] = Constants["delta_m31_squared"]   -- Δm²₃₁

-- Running couplings (scale dependent)
Constants[utf8(945).."("..utf8(956)..")"] = Constants["running_alpha"]     -- α(μ)
Constants[utf8(945).."s("..utf8(956)..")"] = Constants["running_alphas"]   -- αs(μ)

-- Renormalization scales  
Constants[utf8(956).."_R"] = Constants["renormalization_scale"]  -- μ_R
Constants[utf8(956).."_F"] = Constants["factorization_scale"]    -- μ_F

-- Effective field theory cutoffs
Constants[utf8(923).."_UV"] = Constants["uv_cutoff"]             -- Λ_UV
Constants[utf8(923).."_IR"] = Constants["ir_cutoff"]             -- Λ_IR

-- Supersymmetry parameters
Constants["M_SUSY"] = Constants["susy_scale"]
Constants["tan"..utf8(946)] = Constants["tan_beta"]              -- tan β
Constants[utf8(956).."_SUSY"] = Constants["susy_mu"]             -- μ_SUSY

-- Axion physics
Constants["f_a"] = Constants["axion_decay_constant"]             -- f_a
Constants[utf8(952).."_strong"] = Constants["strong_cp_angle"]   -- θ_strong

-- Dark matter
Constants[utf8(963).."_SI"] = Constants["dm_si_cross_section"]   -- σ_SI
Constants[utf8(963).."_SD"] = Constants["dm_sd_cross_section"]   -- σ_SD
Constants["<"..utf8(963).."v>"] = Constants["dm_annihilation"]   -- ⟨σv⟩

-- Extra dimensions
Constants["M_D"] = Constants["extra_dim_scale"]
Constants["R_extra"] = Constants["extra_dim_radius"]

-- String theory scale
Constants["M_string"] = Constants["string_scale"]
Constants["M_Pl"] = Constants["planck_mass"]

-- AdS/CFT
Constants["L_AdS"] = Constants["ads_radius"]
Constants["c_central"] = Constants["central_charge"]

-- Instantons and topology
Constants[utf8(952)] = Constants["theta_angle"]                  -- θ
Constants["w"] = Constants["winding_number"]
end

-- End src/parser.lua

-- src/parser.lua has arrived. Prepare to blame someone.

-- Begin src/factorial.lua
-- factorial.lua
-- Converts symbolic factorial calls to Gamma-based equivalents
-- Works even when you feed it algebra instead of numbers, which is both useful and terrifying

-- Numerical fallback (not actually used in AST transforms)
-- Just here for completeness, or when someone evaluates factorial(5) directly
-- Lanczos approximation for Gamma function, accurate for most real numbers
local lanczos_coef = {
  676.5203681218851, -1259.1392167224028, 771.32342877765313,
  -176.61502916214059, 12.507343278686905, -0.13857109526572012,
  9.9843695780195716e-6, 1.5056327351493116e-7
}

local function gamma(z)
  if z < 0.5 then
    -- Reflection formula for negative arguments
    return math.pi / (math.sin(math.pi * z) * gamma(1 - z))
  else
    z = z - 1
    local x = 0.99999999999980993
    for i = 1, #lanczos_coef do
      x = x + lanczos_coef[i] / (z + i)
    end
    local t = z + #lanczos_coef - 0.5
    return math.sqrt(2 * math.pi) * t^(z + 0.5) * math.exp(-t) * x
  end
end

-- General factorial using Gamma, valid for real/complex domain
local function factorial(n)
  return gamma(n + 1)
end

-- Matches factorial(x) and returns gamma(x + 1)
-- Strictly cosmetic — lets us pretend we know how to differentiate factorials
local function matchFactorial(ast)
  if ast.type == "func" and ast.name == "factorial" and ast.args and #ast.args == 1 then
    local arg = ast.args[1]
    -- Convert factorial(n) to gamma(n+1)
    return {
      type = "func",
      name = "gamma",
      args = {
        {
          type = "add",
          args = { arg, { type = "number", value = 1 } }  -- ← Fixed: Use args array
        }
      }
    }
  end
  return ast
end

-- Walks the AST and replaces every factorial(...) with gamma(... + 1)
-- Recursively rewrites child nodes as well, whether they like it or not
function transformFactorial(ast)
  if type(ast) ~= "table" then return ast end
  
  -- Transform factorial(n) → gamma(n+1)
  if ast.type == "func" and ast.name == "factorial" and ast.args and #ast.args == 1 then
    local arg = transformFactorial(ast.args[1])
    return {
      type = "func",
      name = "gamma",
      args = {
        {
          type = "add",
          args = { arg, { type = "number", value = 1 } }  -- ← Fixed: Use args array
        }
      }
    }
  end
  
  local out = {}
  for k, v in pairs(ast) do
    if type(v) == "table" then
      if #v > 0 then
        out[k] = {}
        for i = 1, #v do
          out[k][i] = transformFactorial(v[i])
        end
      else
        out[k] = transformFactorial(v)
      end
    else
      out[k] = v
    end
  end
  return out
end

-- Evaluate the Gamma function numerically using the Lanczos approximation
local function evaluateGamma(z)
  return gamma(z)
end

-- Evaluate the factorial numerically using the Gamma function
local function evaluateFactorial(n)
  return factorial(n)
end

_G.transformFactorial = transformFactorial
_G.evaluateGamma = evaluateGamma  -- Expose evaluateGamma globally
_G.evaluateFactorial = evaluateFactorial  -- Expose evaluateFactorial globally

-- End src/factorial.lua

-- src/factorial.lua makes your code richer. Or at least gout-ridden.

-- Begin src/simplify.lua
local simplify = {}



-- Helper: get precision from flag or default
local function get_precision()
    
    -- local prec = var and var.recall and var.recall("nLuaCAS_precision_pref")
    -- if type(prec) == "number" and prec >= 0 then return prec end
    return nil 
end

-- Helper: round to precision
local function round_to_precision(val, precision)
    local mult = 10 ^ (precision or 4)
    return math.floor(val * mult + 0.5) / mult
end
local ast = rawget(_G, "ast") or require("ast")
local parser = rawget(_G, "parser") or require("parser")

-- ===== UTILITY FUNCTIONS (The Boring But Essential Shit) =====

local function num(n) return {type="number", value=n} end
local function var(name) return {type="variable", name=name} end

local function is_num(e) return e and e.type == "number" end
local function is_var(e) return e and e.type == "variable" end
local function is_pow(e) return e and e.type == "pow" end
local function is_add(e) return e and e.type == "add" end
local function is_mul(e) return e and e.type == "mul" end
local function is_sin(e) return e and e.type == "sin" end
local function is_cos(e) return e and e.type == "cos" end
local function is_ln(e) return e and e.type == "ln" end
local function is_exp(e) return e and e.type == "exp" end

local function deepcopy(t)
    if type(t) ~= "table" then return t end
    local c = {}
    for k,v in pairs(t) do c[k] = deepcopy(v) end
    return c
end

-- ===== TENSOR MULTIPLICATION HELPER =====
local function tensor_multiply(t1, t2)
    if not (t1 and t1.type == "tensor" and t2 and t2.type == "tensor") then
        return nil
    end

    local function is_vector(t)
        for _, e in ipairs(t.elements) do
            if e.type == "tensor" then return false end
        end
        return true
    end

    local function is_matrix(t)
        for _, row in ipairs(t.elements) do
            if row.type ~= "tensor" then return false end
        end
        return true
    end

    if is_vector(t1) and is_vector(t2) then
        -- Dot product
        local sum = 0
        for i=1, math.min(#t1.elements, #t2.elements) do
            local e1, e2 = t1.elements[i], t2.elements[i]
            if e1.type == "number" and e2.type == "number" then
                sum = sum + e1.value * e2.value
            else
                return nil -- Non-numeric elements, bail
            end
        end
        return { type = "number", value = sum }
    elseif is_matrix(t1) and is_matrix(t2) then
        -- Matrix multiplication: (m x n) * (n x p)
        local m = #t1.elements
        local n = #t1.elements[1].elements
        local n2 = #t2.elements
        local p = #t2.elements[1].elements
        if n ~= n2 then return nil end

        local result = {}
        for i=1,m do
            local row = {}
            for j=1,p do
                local sum = 0
                for k=1,n do
                    local a = t1.elements[i].elements[k]
                    local b = t2.elements[k].elements[j]
                    if a.type == "number" and b.type == "number" then
                        sum = sum + a.value * b.value
                    else
                        return nil
                    end
                end
                table.insert(row, { type = "number", value = sum })
            end
            table.insert(result, { type = "tensor", elements = row })
        end
        return { type = "tensor", elements = result }
    elseif is_matrix(t1) and is_vector(t2) then
        -- Matrix * vector
        local m = #t1.elements
        local n = #t1.elements[1].elements
        local len = #t2.elements
        if n ~= len then return nil end

        local result = {}
        for i=1,m do
            local sum = 0
            for j=1,n do
                local a = t1.elements[i].elements[j]
                local b = t2.elements[j]
                if a.type == "number" and b.type == "number" then
                    sum = sum + a.value * b.value
                else
                    return nil
                end
            end
            table.insert(result, { type = "number", value = sum })
        end
        return { type = "tensor", elements = result }
    else
        return nil -- Unsupported tensor shapes
    end
end

-- Helper: pretty print AST nodes for debugging (recursive)
local function ast_to_string(node, visited, depth)
    visited = visited or {}
    depth = depth or 0
    local indent = string.rep("  ", depth)
    if type(node) ~= "table" then
        return tostring(node)
    end
    if visited[node] then
        return indent .. "<cycle>"
    end
    visited[node] = true
    local parts = {}
    table.insert(parts, indent .. "{")
    for k, v in pairs(node) do
        local keystr = tostring(k)
        if type(v) == "table" then
            table.insert(parts, indent .. "  " .. keystr .. " = " .. ast_to_string(v, visited, depth + 1))
        else
            table.insert(parts, indent .. "  " .. keystr .. " = " .. tostring(v))
        end
    end
    table.insert(parts, indent .. "}")
    return table.concat(parts, "\n")
end

-- Simple hash for expression comparison
local function expr_hash(expr)
    if type(expr) ~= "table" then return tostring(expr) end
    
    local parts = {expr.type}
    if expr.type == "number" then
        table.insert(parts, tostring(expr.value))
    elseif expr.type == "variable" then
        table.insert(parts, expr.name)
    elseif expr.type == "pow" then
        table.insert(parts, expr_hash(expr.base))
        table.insert(parts, expr_hash(expr.exp))
    elseif expr.type == "sin" or expr.type == "cos" or expr.type == "ln" or expr.type == "exp" then
        table.insert(parts, expr_hash(expr.arg))
    elseif (expr.type == "add" or expr.type == "mul") and expr.args then
        local arg_hashes = {}
        for _, arg in ipairs(expr.args) do
            table.insert(arg_hashes, expr_hash(arg))
        end
        table.sort(arg_hashes) -- Commutative operations
        for _, hash in ipairs(arg_hashes) do
            table.insert(parts, hash)
        end
    end
    
    return table.concat(parts, "|")
end

local function expr_equal(a, b)
    return expr_hash(a) == expr_hash(b)
end

-- ===== STEP 1: FLATTEN ASSOCIATIVE OPERATIONS =====
-- Because nested additions/multiplications are the devil

local function flatten(expr)
    if not (is_add(expr) or is_mul(expr)) or not expr.args then return expr end
    
    local flattened = {}
    local op_type = expr.type
    
    local function collect_args(e)
        if e.type == op_type and e.args then
            for _, arg in ipairs(e.args) do
                collect_args(arg)
            end
        else
            table.insert(flattened, e)
        end
    end
    
    for _, arg in ipairs(expr.args) do
        collect_args(arg)
    end
    
    return {type = op_type, args = flattened}
end

-- ===== STEP 2: SORT ARGUMENTS FOR COMMUTATIVITY =====
-- Because order matters for consistency, not math

local function get_power_of_var(expr, var_name)
    -- Return exponent if expr is base^exp where base is var_name
    if expr.type == "pow" and expr.base.type == "variable" and expr.base.name == var_name then
        if expr.exp.type == "number" then
            return expr.exp.value
        end
    elseif expr.type == "variable" and expr.name == var_name then
        return 1
    elseif expr.type == "number" then
        return 0
    end
    return nil -- Cannot determine power
end

local function sort_args(expr)
    if not ((expr.type == "add" or expr.type == "mul") and expr.args) then return expr end
    
    local sorted_args = deepcopy(expr.args)
    -- If addition, try to sort by power of x ascending
    if expr.type == "add" then
        table.sort(sorted_args, function(a, b)
            local a_pow = get_power_of_var(a, "x")
            local b_pow = get_power_of_var(b, "x")
            if a_pow and b_pow then
                return a_pow < b_pow
            elseif a_pow then
                return true
            elseif b_pow then
                return false
            else
                return expr_hash(a) < expr_hash(b)
            end
        end)
    else
        -- For multiplication, keep original expr_hash sorting
        table.sort(sorted_args, function(a, b)
            return expr_hash(a) < expr_hash(b)
        end)
    end
    
    return {type = expr.type, args = sorted_args}
end

-- ===== STEP 3: CONSTANT FOLDING (The Easy Wins) =====

-- fold_constants: The Elegant Edition
-- Because your original was apparently written by someone who thinks math is optional

local function fold_constants(expr)
    if not expr or type(expr) ~= "table" then return expr end
    if expr.type == "<unknown>" then return expr end

    -- Helper: create a number node (because apparently this needs to be a function)
    local function make_num(val)
        return { type = "number", value = val }
    end

    -- Helper: round number to current precision if needed
    local function round_number_if_needed(expr)
        if expr and expr.type == "number" then
            local p = get_precision()
            if p and p >= 0 then
                return { type = "number", value = round_to_precision(expr.value, p) }
            end
        end
        return expr
    end

    -- Helper: extract numeric value from node, handling negation gracefully
    local function extract_numeric_value(node)
        if node.type == "number" then
            return node.value, true
        elseif node.type == "neg" then
            local inner = node.arg or node.value
            if inner and inner.type == "number" then
                return -inner.value, true
            end
        end
        return nil, false
    end

    -- Handle addition: collect numbers, preserve everything else
    if expr.type == "add" and expr.args then
        local numeric_sum = 0
        local non_numeric_terms = {}
        local found_numbers = false

        for _, term in ipairs(expr.args) do
            local folded_term = fold_constants(term)
            local numeric_val, is_numeric = extract_numeric_value(folded_term)
            
            if is_numeric then
                numeric_sum = numeric_sum + numeric_val
                found_numbers = true
            else
                table.insert(non_numeric_terms, folded_term)
            end
        end

        -- Assemble the result with mathematical dignity
        local result_terms = {}
        if found_numbers and numeric_sum ~= 0 then
            table.insert(result_terms, make_num(numeric_sum))
        end
        for _, term in ipairs(non_numeric_terms) do
            table.insert(result_terms, term)
        end

        -- Return the most elegant representation
        if #result_terms == 0 then return round_number_if_needed(make_num(0)) end
        if #result_terms == 1 then return round_number_if_needed(result_terms[1]) end
        return { type = "add", args = result_terms }
    end

    -- Handle multiplication: the source of your discriminant trauma
    if expr.type == "mul" and expr.args then
        local numeric_product = 1
        local non_numeric_factors = {}
        local found_numbers = false

        for _, factor in ipairs(expr.args) do
            local folded_factor = fold_constants(factor)
            local numeric_val, is_numeric = extract_numeric_value(folded_factor)
            
            if is_numeric then
                numeric_product = numeric_product * numeric_val
                found_numbers = true
            else
                table.insert(non_numeric_factors, folded_factor)
            end
        end

        -- PATCH: Distribute numeric factors over negations
        local patched_factors = {}
        for _, factor in ipairs(non_numeric_factors) do
            if factor.type == "neg" and factor.arg then
                -- Distribute all previous numeric_product into the negation
                table.insert(patched_factors, {type = "mul", args = {{type="number", value = -1 * numeric_product}, fold_constants(factor.arg)}})
                numeric_product = 1
                found_numbers = false
            else
                table.insert(patched_factors, factor)
            end
        end
        non_numeric_factors = patched_factors

        -- Handle the mathematical realities
        if numeric_product == 0 then return round_number_if_needed(make_num(0)) end

        -- Assemble result with appropriate elegance
        local result_factors = {}
        if found_numbers and (numeric_product ~= 1 or #non_numeric_factors == 0) then
            table.insert(result_factors, make_num(numeric_product))
        end
        for _, factor in ipairs(non_numeric_factors) do
            table.insert(result_factors, factor)
        end

        if #result_factors == 0 then return round_number_if_needed(make_num(1)) end
        if #result_factors == 1 then return round_number_if_needed(result_factors[1]) end
        return { type = "mul", args = result_factors }
    end

    -- Handle subtraction: where your quadratic dreams go to die
    if expr.type == "sub" and expr.left and expr.right then
        local left = fold_constants(expr.left)
        local right = fold_constants(expr.right)

        -- Extract numeric values for direct computation
        local left_val, left_is_num = extract_numeric_value(left)
        local right_val, right_is_num = extract_numeric_value(right)

        -- Handle pure numeric subtraction
        if left_is_num and right_is_num then
            return round_number_if_needed(make_num(left_val - right_val))
        end

        -- Handle subtraction of negative: a - (-b) = a + b
        if right.type == "neg" then
            local right_inner = right.arg or right.value
            return fold_constants({ type = "add", args = { left, right_inner } })
        end

        -- Handle special case: 0 - x = -x
        if left_is_num and left_val == 0 then
            return fold_constants({ type = "neg", arg = right })
        end

        -- Handle special case: x - 0 = x
        if right_is_num and right_val == 0 then
            return round_number_if_needed(left)
        end

        return { type = "sub", left = left, right = right }
    end

    -- Handle division: because completeness matters
    if expr.type == "div" and expr.left and expr.right then
        local left = fold_constants(expr.left)
        local right = fold_constants(expr.right)

        local left_val, left_is_num = extract_numeric_value(left)
        local right_val, right_is_num = extract_numeric_value(right)

        if left_is_num and right_is_num and right_val ~= 0 then
            return round_number_if_needed(make_num(left_val / right_val))
        end

        -- x / 1 = x
        if right_is_num and right_val == 1 then
            return round_number_if_needed(left)
        end

        -- 0 / x = 0 (assuming x ≠ 0)
        if left_is_num and left_val == 0 then
            return round_number_if_needed(make_num(0))
        end

        return { type = "div", left = left, right = right }
    end

    -- Handle powers: because your quadratic formula demands it
    if expr.type == "pow" then
        local base = fold_constants(expr.base or expr.left)
        local exp = fold_constants(expr.exp or expr.right)

        local base_val, base_is_num = extract_numeric_value(base)
        local exp_val, exp_is_num = extract_numeric_value(exp)

        -- Simplify i^2 = -1
        if base.type == "symbol" and base.name == "i" and exp_is_num and exp_val == 2 then
            return round_number_if_needed(make_num(-1))
        end

        -- Handle numeric powers
        if base_is_num and exp_is_num and not _G.showComplex then
            -- Special cases to avoid numerical disasters
            if base_val == 0 and exp_val > 0 then return round_number_if_needed(make_num(0)) end
            if base_val == 0 and exp_val == 0 then return round_number_if_needed(make_num(1)) end
            if exp_val == 0 then return round_number_if_needed(make_num(1)) end
            if exp_val == 1 then return round_number_if_needed(base) end
            return round_number_if_needed(make_num(base_val ^ exp_val))
        end

        -- x^0 = 1
        if exp_is_num and exp_val == 0 then
            return round_number_if_needed(make_num(1))
        end

        -- x^1 = x
        if exp_is_num and exp_val == 1 then
            return round_number_if_needed(base)
        end

        -- 0^x = 0 (for positive x)
        if base_is_num and base_val == 0 then
            return round_number_if_needed(make_num(0))
        end

        -- 1^x = 1
        if base_is_num and base_val == 1 then
            return round_number_if_needed(make_num(1))
        end

        return { type = "pow", base = base, exp = exp }
    end

    -- Handle negation: with proper respect for double negatives
    if expr.type == "neg" then
        local inner = fold_constants(expr.arg or expr.value)
        local inner_val, inner_is_num = extract_numeric_value(inner)

        if inner_is_num then
            return round_number_if_needed(make_num(-inner_val))
        end

        -- Handle double negation: -(-x) = x
        if inner.type == "neg" then
            return fold_constants(inner.arg or inner.value)
        end

        return { type = "neg", arg = inner }
    end

    -- Handle functions: sqrt, sin, cos, etc.
    if expr.type == "func" and expr.args then
        local folded_args = {}
        local all_numeric = true
        
        for i, arg in ipairs(expr.args) do
            folded_args[i] = fold_constants(arg)
            if not extract_numeric_value(folded_args[i]) then
                all_numeric = false
            end
        end

        -- Handle sqrt of numeric values, including sqrt(-1) = i
        if expr.name == "sqrt" and #folded_args == 1 then
            local val, is_num = extract_numeric_value(folded_args[1])
            if is_num then
                if val >= 0 and not _G.showComplex then
                    return round_number_if_needed(make_num(math.sqrt(val)))
                elseif val == -1 then
                    return { type = "symbol", name = "i" }
                end
            end
        end

        -- Handle root(n, x) = x^(1/n)
        if expr.name == "root" and #folded_args == 2 then
            return {
                type = "pow",
                base = folded_args[2],
                exp = { type = "div", left = make_num(1), right = folded_args[1] }
            }
        end

        return { type = "func", name = expr.name, args = folded_args }
    end

    -- For everything else, recursively fold children
    local result = {}
    for k, v in pairs(expr) do
        if type(v) == "table" and k ~= "args" then
            result[k] = fold_constants(v)
        else
            result[k] = v
        end
    end

    -- At the end, round number if needed
    if result and result.type == "number" then
        result = round_number_if_needed(result)
    end
    return result
end

-- Helper: recursively simplify children before folding constants
local function fold_constants_recursive(expr)
    if type(expr) ~= "table" then return expr end
    -- Recursively process children
    local new_expr = deepcopy(expr)
    if is_num(new_expr) and new_expr.value == 0 then
        new_expr.value = 0  -- Normalize any -0 to 0
    end
    if new_expr.type == "pow" then
        new_expr.base = fold_constants_recursive(new_expr.base)
        new_expr.exp = fold_constants_recursive(new_expr.exp)
    elseif new_expr.type == "sin" or new_expr.type == "cos" or new_expr.type == "ln" or new_expr.type == "exp" then
        new_expr.arg = fold_constants_recursive(new_expr.arg)
    elseif (new_expr.type == "add" or new_expr.type == "mul") and new_expr.args then
        for i = 1, #new_expr.args do
            new_expr.args[i] = fold_constants_recursive(new_expr.args[i])
        end
    elseif new_expr.type == "func" and new_expr.args then
        for i = 1, #new_expr.args do
            new_expr.args[i] = fold_constants_recursive(new_expr.args[i])
        end
    elseif new_expr.type == "neg" and new_expr.arg then
        new_expr.arg = fold_constants_recursive(new_expr.arg)
    elseif new_expr.type == "sub" and new_expr.left and new_expr.right then
        new_expr.left = fold_constants_recursive(new_expr.left)
        new_expr.right = fold_constants_recursive(new_expr.right)
    end
    return fold_constants(new_expr)
end

-- ===== STEP 4: COLLECT LIKE TERMS (The Real Work) =====

local function extract_coefficient_and_base(expr)
    if is_num(expr) then
        return expr.value, num(1)
    end
    
    if is_mul(expr) and expr.args then
        local coeff = 1
        local base_parts = {}
        
        for _, arg in ipairs(expr.args) do
            if is_num(arg) then
                coeff = coeff * arg.value
            else
                table.insert(base_parts, arg)
            end
        end
        
        local base
        if #base_parts == 0 then
            base = num(1)
        elseif #base_parts == 1 then
            base = base_parts[1]
        else
            base = {type = "mul", args = base_parts}
        end
        
        return coeff, base
    end
    
    return 1, expr
end

local function collect_like_terms(expr)
    if not (is_add(expr) and expr.args) then return expr end

    local groups = {}

    for _, term in ipairs(expr.args) do
        local t = term
        local sign = 1
        if t.type == "neg" then
            t = t.arg or t.value
            sign = -1
        end
        local coeff, base = extract_coefficient_and_base(t)
        coeff = coeff * sign
        local base_key = expr_hash(base)

        if groups[base_key] then
            groups[base_key].coeff = groups[base_key].coeff + coeff
        else
            groups[base_key] = {coeff = coeff, base = base}
        end
    end

    local result_terms = {}
    for _, group in pairs(groups) do
        if math.abs(group.coeff) > 1e-10 then -- Handle floating point errors
            if math.abs(group.coeff - 1) < 1e-10 and not expr_equal(group.base, num(1)) then
                -- Coefficient is 1, just use base
                table.insert(result_terms, group.base)
            elseif expr_equal(group.base, num(1)) then
                -- Base is 1, just use coefficient
                table.insert(result_terms, num(group.coeff))
            else
                -- Both matter
                table.insert(result_terms, {type = "mul", args = {num(group.coeff), group.base}})
            end
        end
    end

    if #result_terms == 0 then return num(0) end
    if #result_terms == 1 then return result_terms[1] end
    return {type = "add", args = result_terms}
end

-- ===== STEP 5: POWER SIMPLIFICATION =====

local function simplify_powers(expr)
    -- x^0 = 1
    if is_pow(expr) and is_num(expr.exp) and expr.exp.value == 0 then
        return num(1)
    end
    
    -- x^1 = x
    if is_pow(expr) and is_num(expr.exp) and expr.exp.value == 1 then
        return expr.base
    end
    
    -- (x^a)^b = x^(a*b)
    if is_pow(expr) and is_pow(expr.base) then
        local new_exp = {type = "mul", args = {expr.base.exp, expr.exp}}
        return {type = "pow", base = expr.base.base, exp = new_exp}
    end
    
    return expr
end

-- ===== STEP 6: COMBINE LIKE POWERS IN MULTIPLICATION =====

local function combine_powers(expr)
    if not (is_mul(expr) and expr.args) then return expr end

    local base_groups = {}
    local other_factors = {}

    for _, factor in ipairs(expr.args) do
        local base, exp
        if is_pow(factor) then
            base, exp = factor.base, factor.exp
        else
            base, exp = factor, num(1)
        end

        -- Guard: Skip exponent combination for tensors
        if base.type == "tensor" then
            table.insert(other_factors, factor)
        else
            local base_key = expr_hash(base)
            if base_groups[base_key] then
                -- Combine exponents: x^a * x^b = x^(a+b)
                base_groups[base_key].exponents = base_groups[base_key].exponents or {}
                table.insert(base_groups[base_key].exponents, exp)
            else
                base_groups[base_key] = {base = base, exponents = {exp}}
            end
        end
    end

    local result_factors = {}

    for _, group in pairs(base_groups) do
        if #group.exponents == 1 then
            if expr_equal(group.exponents[1], num(1)) then
                table.insert(result_factors, group.base)
            else
                table.insert(result_factors, {type = "pow", base = group.base, exp = group.exponents[1]})
            end
        else
            local combined_exp = {type = "add", args = group.exponents}
            table.insert(result_factors, {type = "pow", base = group.base, exp = combined_exp})
        end
    end

    -- Append the other factors (e.g., tensors) that were skipped for exponent combination
    for _, f in ipairs(other_factors) do
        table.insert(result_factors, f)
    end

    if #result_factors == 0 then return num(1) end
    if #result_factors == 1 then return result_factors[1] end
    return {type = "mul", args = result_factors}
end

-- ===== STEP 7: BASIC DISTRIBUTION =====

local function distribute_simple(expr)
    if not (is_mul(expr) and expr.args) then return expr end
    
    -- Look for a(b + c) pattern
    local additions = {}
    local other_factors = {}
    
    for _, factor in ipairs(expr.args) do
        if is_add(factor) and factor.args then
            table.insert(additions, factor)
        else
            table.insert(other_factors, factor)
        end
    end
    
    if #additions == 0 then return expr end
    
    -- Take first addition and distribute other factors into it
    local first_add = additions[1]
    local remaining_adds = {}
    for i = 2, #additions do
        table.insert(remaining_adds, additions[i])
    end
    
    local all_other_factors = {}
    for _, f in ipairs(other_factors) do
        table.insert(all_other_factors, f)
    end
    for _, f in ipairs(remaining_adds) do
        table.insert(all_other_factors, f)
    end
    
    local distributed_terms = {}
    for _, addend in ipairs(first_add.args) do
        local new_factors = {addend}
        for _, factor in ipairs(all_other_factors) do
            table.insert(new_factors, factor)
        end
        
        if #new_factors == 1 then
            table.insert(distributed_terms, new_factors[1])
        else
            table.insert(distributed_terms, {type = "mul", args = new_factors})
        end
    end
    
    return {type = "add", args = distributed_terms}
end

-- ===== STEP 8: SPECIAL EXPANSIONS =====

local function expand_special_cases(expr)
    -- (a + b)^2 = a^2 + 2ab + b^2
    if is_pow(expr) and is_num(expr.exp) and expr.exp.value == 2 then
        if is_add(expr.base) and expr.base.args and #expr.base.args == 2 then
            local a, b = expr.base.args[1], expr.base.args[2]
            return {
                type = "add",
                args = {
                    {type = "pow", base = a, exp = num(2)},
                    {type = "mul", args = {num(2), a, b}},
                    {type = "pow", base = b, exp = num(2)}
                }
            }
        end
    end
    
    return expr
end

-- ===== STEP 9: TRIGONOMETRIC IDENTITIES =====

local function apply_trig_identities(expr)
    -- sin^2(x) + cos^2(x) = 1
    if is_add(expr) and expr.args and #expr.args == 2 then
        local term1, term2 = expr.args[1], expr.args[2]
        
        -- Check if we have sin^2(x) and cos^2(x)
        if is_pow(term1) and is_pow(term2) and 
           is_num(term1.exp) and is_num(term2.exp) and
           term1.exp.value == 2 and term2.exp.value == 2 then
            
            if is_sin(term1.base) and is_cos(term2.base) and
               expr_equal(term1.base.arg, term2.base.arg) then
                return num(1)
            elseif is_cos(term1.base) and is_sin(term2.base) and
                   expr_equal(term1.base.arg, term2.base.arg) then
                return num(1)
            end
        end
    end
    
    return expr
end

-- ===== STEP 10: LOGARITHM IDENTITIES =====

local function apply_log_identities(expr)
    -- ln(e^x) = x
    if is_ln(expr) and is_exp(expr.arg) then
        return expr.arg.arg
    end
    
    -- e^(ln(x)) = x
    if is_exp(expr) and is_ln(expr.arg) then
        return expr.arg.arg
    end
    
    return expr
end

-- ===== MAIN SIMPLIFICATION ENGINE =====

-- Helper function to serialize AST nodes for debugging
local function ast_to_string(node, visited, depth)
    visited = visited or {}
    depth = depth or 0
    local indent = string.rep("  ", depth)
    if type(node) ~= "table" then
        return tostring(node)
    end
    if visited[node] then
        return indent .. "<cycle>"
    end
    visited[node] = true
    local parts = {}
    table.insert(parts, indent .. "{")
    for k, v in pairs(node) do
        local keystr = tostring(k)
        if type(v) == "table" then
            table.insert(parts, indent .. "  " .. keystr .. " = " .. ast_to_string(v, visited, depth + 1))
        else
            table.insert(parts, indent .. "  " .. keystr .. " = " .. tostring(v))
        end
    end
    table.insert(parts, indent .. "}")
    return table.concat(parts, "\n")
end


-- Save original simplify_step
local old_simplify_step = simplify.simplify_step or function(expr) return expr end

-- Override simplify_step to add tensor mul support
function simplify.simplify_step(expr)
    -- Tensor multiplication (dot/matrix product)
    if type(expr) == "table" and expr.type == "mul" and expr.args and #expr.args == 2 then
        local a, b = expr.args[1], expr.args[2]
        if a.type == "tensor" and b.type == "tensor" then
            local prod = tensor_multiply(a, b)
            if prod then
                if prod.type == "number" then
                    return prod
                end
                -- Recursively simplify the product result
                return simplify.simplify_step(prod)
            end
        end
    end

    -- Scalar-Tensor element-wise multiplication
    if type(expr) == "table" and expr.type == "mul" and expr.args and #expr.args == 2 then
        local a, b = expr.args[1], expr.args[2]
        if is_num(a) and b.type == "tensor" then
            local scaled = {}
            for i, e in ipairs(b.elements) do
                if e.type == "number" then
                    scaled[i] = { type = "number", value = a.value * e.value }
                else
                    return expr
                end
            end
            return { type = "tensor", elements = scaled }
        elseif a.type == "tensor" and is_num(b) then
            local scaled = {}
            for i, e in ipairs(a.elements) do
                if e.type == "number" then
                    scaled[i] = { type = "number", value = e.value * b.value }
                else
                    return expr
                end
            end
            return { type = "tensor", elements = scaled }
        end
    end

    -- Tensor addition or subtraction (element-wise for exactly two tensors)
    if type(expr) == "table" and expr.type == "add" and expr.args then
        local tensors = {}
        for _, arg in ipairs(expr.args) do
            if arg.type == "tensor" then
                table.insert(tensors, arg)
            else
                return expr -- Non-tensor terms present, skip
            end
        end
        if #tensors == 2 then
            local a, b = tensors[1], tensors[2]
            if #a.elements ~= #b.elements then return expr end
            local sum_elements = {}
            for i = 1, #a.elements do
                if a.elements[i].type == "number" and b.elements[i].type == "number" then
                    sum_elements[i] = { type = "number", value = a.elements[i].value + b.elements[i].value }
                else
                    return expr
                end
            end
            return { type = "tensor", elements = sum_elements }
        elseif #tensors > 2 then
            return expr -- Skip multi-term tensor sums for now
        end
    end

    -- Tensor subtraction with recursive simplification
    if type(expr) == "table" and expr.type == "sub" and expr.left and expr.right then
        local a = simplify.simplify_step(expr.left)
        local b = simplify.simplify_step(expr.right)
        if a.type == "tensor" and b.type == "tensor" then
            if #a.elements ~= #b.elements then return expr end
            local diff_elements = {}
            for i = 1, #a.elements do
                if a.elements[i].type == "number" and b.elements[i].type == "number" then
                    diff_elements[i] = { type = "number", value = a.elements[i].value - b.elements[i].value }
                else
                    return expr
                end
            end
            return { type = "tensor", elements = diff_elements }
        end
    end

    -- Tensor division: tensor / tensor reduces to scalar 1 if dot product nonzero
    if type(expr) == "table" and expr.type == "mul" and expr.args and #expr.args == 2 then
        local a, b = expr.args[1], expr.args[2]
        if is_pow(a) and a.base.type == "tensor" and is_num(a.exp) and a.exp.value == -1 and b.type == "tensor" then
            local prod = tensor_multiply(a.base, b)
            if prod and prod.type == "number" then
                if prod.value ~= 0 then
                    return { type = "number", value = 1 }
                else
                    return { type = "number", value = 0 }
                end
            end
        end
    end

    -- Tensor exponentiation: restrict to scalar exponents, handle positive integers
    if type(expr) == "table" and expr.type == "pow" and expr.base and expr.exp then
        if expr.base.type == "tensor" and is_num(expr.exp) then
            local k = expr.exp.value
            if k == -1 then
                return { type = "pow", base = expr.base, exp = { type = "number", value = -1 } }
            elseif k >= 1 and math.floor(k) == k then
                local result = expr.base
                for _ = 2, k do
                    result = tensor_multiply(result, expr.base) or expr
                end
                return result
            end
        end
    end

    ----------------------------------------------------------------------
    -- Automatic evaluation for numeric factorial
    if type(expr) == "table" and expr.type == "func" and expr.name == "factorial" and expr.args and #expr.args == 1 then
        local arg = simplify.simplify_step(expr.args[1])
        if arg.type == "number" and _G.evaluateFactorial then
            return { type = "number", value = _G.evaluateFactorial(arg.value) }
        end
        expr.args[1] = arg
        return expr
    end

    -- Automatic evaluation for integral (debug-enhanced version)
    if type(expr) == "table" and expr.type == "func" and expr.name == "int" and expr.args and #expr.args == 2 then
        print("Simplifying integral: ", simplify.pretty_print(expr))

        local inner = simplify.simplify_step(expr.args[1])
        local respect_to = simplify.simplify_step(expr.args[2])

        print("Inner after simplify: ", simplify.pretty_print(inner))
        print("Respect to after simplify: ", simplify.pretty_print(respect_to))

        if respect_to.type == "variable" and _G.integrate and _G.integrate.integrateAST then
            print("Calling _G.integrate.integrateAST with:")
            print("Inner: ", simplify.pretty_print(inner))
            print("Respect to: ", respect_to.name)
            local status, val = pcall(_G.integrate.integrateAST, inner, respect_to.name)
            print("Integration status: ", status)
            if status and type(val) == "table" then
                print("Integration result: ", simplify.pretty_print(val))
                return simplify.simplify_step(val)
            else
                print("Integration failed or returned non-table, val = ", val)
            end
        else
            print("Skipping integral: invalid respect_to or integrateAST missing")
        end

        expr.args[1] = inner
        expr.args[2] = respect_to
        return expr
    end
    ----------------------------------------------------------------------

    -- Fall back to original simplify_step
    return old_simplify_step(expr)
end

-- Original recursive simplify_step for internal use
local function simplify_step(expr)
    if type(expr) ~= "table" then return expr end
    if expr.type == "<unknown>" then
        print("Warning: encountered unknown AST node during simplification")
        return expr
    end
    -- Handle tensor AST node type (recursive for arbitrary depth)
    if expr.type == "tensor" and expr.elements then
        local function simplify_tensor_elements(elems)
            local simplified = {}
            for i, elem in ipairs(elems) do
                if type(elem) == "table" and elem.type == "tensor" and elem.elements then
                    simplified[i] = { type = "tensor", elements = simplify_tensor_elements(elem.elements) }
                else
                    simplified[i] = simplify_step(elem)
                end
            end
            return simplified
        end
        return { type = "tensor", elements = simplify_tensor_elements(expr.elements) }
    end

    -- Handle equation normalization: move right to left (left - right = 0)
    if expr.type == "equation" and expr.left and expr.right then
        local sub_expr = { type = "sub", left = expr.left, right = expr.right, _from_equation = true }
        return simplify_step(sub_expr)
    end

    -- Recursively simplify children first
    local new_expr = deepcopy(expr)

    -- Preserve subtraction by zero if part of an equation during solve
    if new_expr.type == "sub" and is_num(new_expr.right) and new_expr.right.value == 0 then
        if new_expr._from_equation then
            return new_expr
        else
            return simplify_step(new_expr.left)
        end
    end

    -- Only simplify known types; preserve unknown types
    local known_types = {
        number = true, variable = true, constant = true, pow = true, add = true, mul = true,
        sin = true, cos = true, ln = true, exp = true, integral = true, func = true, neg = true,
        series = true, sub = true, div = true
    }
    if not known_types[new_expr.type] then
        return new_expr
    end

    if new_expr.type == "pow" then
        new_expr.base = simplify_step(new_expr.base)
        new_expr.exp = simplify_step(new_expr.exp)
    elseif new_expr.type == "sin" or new_expr.type == "cos" or new_expr.type == "ln" or new_expr.type == "exp" then
        new_expr.arg = simplify_step(new_expr.arg)
    elseif (new_expr.type == "add" or new_expr.type == "mul") and new_expr.args then
        for i = 1, #new_expr.args do
            new_expr.args[i] = simplify_step(new_expr.args[i])
        end
    elseif new_expr.type == "neg" then
        local val_field = new_expr.arg or new_expr.value
        val_field = simplify_step(val_field)
        if val_field.type == "neg" then
            return simplify_step(val_field.arg or val_field.value)
        end
        new_expr.arg = val_field
        new_expr.value = nil
    elseif new_expr.type == "constant" then
        new_expr.value = simplify_step(new_expr.value)
        return new_expr.value
    end

    new_expr = flatten(new_expr)
    new_expr = sort_args(new_expr)
    new_expr = fold_constants_recursive(new_expr)
    new_expr = collect_like_terms(new_expr)
    new_expr = simplify_powers(new_expr)
    new_expr = combine_powers(new_expr)
    new_expr = distribute_simple(new_expr)
    new_expr = expand_special_cases(new_expr)
    new_expr = apply_trig_identities(new_expr)
    new_expr = apply_log_identities(new_expr)

    return new_expr
end

local function simplify_until_stable(expr, max_iterations)
    max_iterations = max_iterations or 20
    local iteration = 0
    local prev_hash = nil
    
    while iteration < max_iterations do
        expr = simplify_step(expr)
        local current_hash = expr_hash(expr)
        
        if current_hash == prev_hash then
            break -- Converged
        end
        
        prev_hash = current_hash
        iteration = iteration + 1
    end
    
    return expr
end

-- ===== PRETTY PRINTER =====

-- Improved precedence-aware parentheses logic
local function needs_parens(expr, parent_op, position)
    -- Precedence: higher number = binds tighter
    local precedence = {
        add = 1,
        sub = 1,
        mul = 2,
        div = 2,
        pow = 3,
        neg = 4,
        func = 5,
        sin = 5,
        cos = 5,
        ln = 5,
        exp = 5,
        sqrt = 5,
    }
    local expr_prec = precedence[expr.type] or 6
    local parent_prec = precedence[parent_op] or 0
    if not parent_op then return false end
    if expr_prec > parent_prec then return false end
    if expr_prec < parent_prec then return true end
    -- When precedence is equal, only pow is right-associative
    if parent_op == "pow" and position == "right" then return true end
    -- For subtraction and division, left and right children may need parens for clarity
    if (parent_op == "sub" or parent_op == "div") and position == "right" then return true end
    return false
end

-- Helper: should multiplication be shown as explicit * ?
local function should_show_multiplication(left, right)
    -- Omit * when: number followed by variable/power, variable by variable/power, power by variable/power, sqrt by variable/number/etc.
    local function is_sqrt(e)
        return e and (e.type == "sqrt" or (is_pow(e) and is_num(e.exp) and e.exp.value == 0.5))
    end
    if is_num(left) and (is_var(right) or is_pow(right) or is_sqrt(right)) then return false end
    if is_var(left) and (is_var(right) or is_pow(right) or is_sqrt(right)) then return false end
    if is_pow(left) and (is_var(right) or is_pow(right) or is_sqrt(right)) then return false end
    if is_sqrt(left) and (is_var(right) or is_num(right) or is_pow(right) or is_sqrt(right)) then return false end
    -- Omit * between closing paren and variable/number
    if left.type == "constant" and (is_var(right) or is_num(right)) then return false end
    return true
end

-- Helper: is a simple factor (number, variable, constant, or function call)
local function is_simple_factor(expr)
    return is_num(expr) or is_var(expr) or expr.type == "constant"
        or expr.type == "sin" or expr.type == "cos" or expr.type == "ln" or expr.type == "exp"
        or expr.type == "sqrt"
        or (expr.type == "func" and expr.name and expr.args)
end

local function pretty_print_internal(expr, parent_op, position)
    if not expr then return "<nil>" end

    if expr.type == "solutions" and expr.solutions then
        local parts = {}
        for i, sol in ipairs(expr.solutions) do
            local sol_str = pretty_print_internal(sol, nil, nil)
            table.insert(parts, "Solution " .. i .. ": " .. sol_str)
        end
        return table.concat(parts, "\n")
    end
    -- Numbers
    if is_num(expr) then
        if expr.value >= 0 then
            return tostring(expr.value)
        else
            return "(" .. tostring(expr.value) .. ")"
        end
    end
    -- Variable
    if is_var(expr) then
        return expr.name
    end
    -- Constants
    if expr.type == "constant" then
        return expr.name
    end
    -- Negation
    if expr.type == "neg" and expr.value then
        local inner = pretty_print_internal(expr.value, "neg", "right")
        if not is_simple_factor(expr.value) then
            inner = "(" .. inner .. ")"
        end
        return "-" .. inner
    end
    -- Power: x^y, also handle sqrt
    if is_pow(expr) then
        -- Square root pretty print
        if is_num(expr.exp) and expr.exp.value == 0.5 then
            local arg_str = pretty_print_internal(expr.base, "sqrt", "arg")
            -- Avoid excessive parentheses around simple factors or powers (like x^2)
            if not (is_simple_factor(expr.base) or is_pow(expr.base)) then
                arg_str = "(" .. arg_str .. ")"
            end
            return "√" .. arg_str
        end
        local base_str = pretty_print_internal(expr.base, "pow", "left")
        local exp_str = pretty_print_internal(expr.exp, "pow", "right")
        if needs_parens(expr.base, "pow", "left") then
            base_str = "(" .. base_str .. ")"
        end
        if needs_parens(expr.exp, "pow", "right") then
            exp_str = "(" .. exp_str .. ")"
        end
        return base_str .. "^" .. exp_str
    end
    -- Functions: sin, cos, ln, exp, sqrt, and custom
    if expr.type == "sin" or expr.type == "cos" or expr.type == "ln" or expr.type == "exp" then
        local fname = expr.type
        return fname .. "(" .. pretty_print_internal(expr.arg, nil, nil) .. ")"
    end
    if expr.type == "sqrt" then
        local arg_str = pretty_print_internal(expr.arg, "sqrt", "arg")
        -- Avoid excessive parentheses around simple factors or powers (like x^2)
        if not (is_simple_factor(expr.arg) or is_pow(expr.arg)) then
            arg_str = "(" .. arg_str .. ")"
        end
        return "√" .. arg_str
    end
    -- Pretty print for func("int", ...): display as integral
    if expr.type == "func" and expr.name == "int" and expr.args then
        local arg_str = pretty_print_internal(expr.args[1], nil, nil)
        local respect_to = "x"
        if expr.args[2] and expr.args[2].type == "variable" then
            respect_to = expr.args[2].name
        end
        return "∫" .. arg_str .. " d" .. respect_to
    end
    -- Pretty print for inverse trig: arcsin, arccos, arctan, etc.
    if expr.type == "func" and expr.name and expr.args and (
        expr.name == "arcsin" or expr.name == "arccos" or expr.name == "arctan" or expr.name == "arccot"
        or expr.name == "arccsc" or expr.name == "arcsec"
    ) then
        local arg_strs = {}
        for i, arg in ipairs(expr.args) do
            table.insert(arg_strs, pretty_print_internal(arg, nil, nil))
        end
        return expr.name .. "(" .. table.concat(arg_strs, ", ") .. ")"
    end
    -- Handle generic function nodes: func(name, args)
    if expr.type == "func" and expr.name and expr.args then
        local arg_strs = {}
        for i, arg in ipairs(expr.args) do
            table.insert(arg_strs, pretty_print_internal(arg, nil, nil))
        end
        return expr.name .. "(" .. table.concat(arg_strs, ", ") .. ")"
    end
    -- Addition with forced + C at the end
    if is_add(expr) and expr.args then
        local regular_terms = {}
        local constant_c = nil

        for _, arg in ipairs(expr.args) do
            if arg.type == "variable" and arg.name == "C" then
                constant_c = pretty_print_internal(arg, "add", "inner")
            else
                local s = pretty_print_internal(arg, "add", "inner")
                -- Parenthesize negative terms for clarity
                if is_num(arg) and arg.value < 0 then
                    s = "(" .. s .. ")"
                elseif arg.type == "neg" then
                    s = "(" .. s .. ")"
                end
                table.insert(regular_terms, s)
            end
        end

        local result = table.concat(regular_terms, " + ")
        if constant_c then
            if #regular_terms > 0 then
                result = result .. " + " .. constant_c
            else
                result = constant_c
            end
        end

        if needs_parens(expr, parent_op, position) then
            return "(" .. result .. ")"
        end
        return result
    end
    -- Multiplication (improved implicit multiplication logic, always print 2x not x*2)
    if is_mul(expr) and expr.args then
        local parts = {}
        local function is_simple_func(e)
            return e and (e.type == "sin" or e.type == "cos" or e.type == "ln" or e.type == "exp" or (e.type == "func"))
        end
        -- Sort: numbers first, then variables, then powers, then functions, then others
        local sorted_args = {}
        for i, arg in ipairs(expr.args) do sorted_args[i] = arg end
        table.sort(sorted_args, function(a, b)
            local function sort_key(e)
                if is_num(e) then return 1
                elseif is_var(e) then return 2
                elseif is_pow(e) then return 3
                elseif is_simple_func(e) then return 4
                else return 5 end
            end
            local ka, kb = sort_key(a), sort_key(b)
            if ka ~= kb then return ka < kb end
            -- If same type, keep original order for stability
            return false
        end)
        -- Suppress leading 1 * expr, unless it's the only argument
        if is_num(sorted_args[1]) and sorted_args[1].value == 1 and #sorted_args > 1 then
            table.remove(sorted_args, 1)
        end
        -- Now build pretty print from sorted_args
        for i, arg in ipairs(sorted_args) do
            local s = pretty_print_internal(arg, "mul", "inner")
            if i == 1 then
                table.insert(parts, s)
            else
                local prev = sorted_args[i-1]
                local prev_is_num = is_num(prev)
                local prev_is_var = is_var(prev)
                local prev_is_pow = is_pow(prev)
                local prev_is_func = is_simple_func(prev)
                local curr_is_num = is_num(arg)
                local curr_is_var = is_var(arg)
                local curr_is_pow = is_pow(arg)
                local curr_is_func = is_simple_func(arg)

                -- Implicit multiplication rules:
                -- 2x, 3sin(x), xy, x^2y, x^2sin(x), sin(x)y, etc.
                -- But: x*6, sin(x)*5, etc. should be explicit
                local implicit = false
                -- Number before variable/power/function: 2x, 3sin(x), 4x^2
                if prev_is_num and (curr_is_var or curr_is_pow or curr_is_func) then
                    implicit = true
                    table.insert(parts, s)
                -- Variable before variable/power/function: xy, xsin(x), x^2y, x^2sin(x)
                elseif prev_is_var and (curr_is_var or curr_is_pow or curr_is_func) then
                    -- Special: if variable before inverse trig function, add space
                    if curr_is_func and arg.type == "func"
                        and (arg.name == "arcsin" or arg.name == "arccos" or arg.name == "arctan"
                             or arg.name == "arccot" or arg.name == "arccsc" or arg.name == "arcsec")
                    then
                        implicit = true
                        table.insert(parts, " " .. s)
                    else
                        implicit = true
                        table.insert(parts, s)
                    end
                -- Power before variable/power/function: x^2y, x^2sin(x), (x^2)(y^3)
                elseif prev_is_pow and (curr_is_var or curr_is_pow or curr_is_func) then
                    implicit = true
                    table.insert(parts, s)
                -- Function before variable/power/function: sin(x)y, sin(x)x^2
                elseif prev_is_func and (curr_is_var or curr_is_pow) then
                    implicit = true
                    table.insert(parts, s)
                else
                    table.insert(parts, " * " .. s)
                end
            end
        end
        local result = table.concat(parts)
        if needs_parens(expr, parent_op, position) then
            return "(" .. result .. ")"
        end
        return result
    end
    -- Division
    if expr.type == "div" and expr.left and expr.right then
        -- If denominator is 1, just return numerator
        if is_num(expr.right) and expr.right.value == 1 then
            return pretty_print_internal(expr.left, parent_op, position)
        end
        local left_str = pretty_print_internal(expr.left, "div", "left")
        local right_str = pretty_print_internal(expr.right, "div", "right")
        if not is_simple_factor(expr.left) then
            left_str = "(" .. left_str .. ")"
        end
        if not is_simple_factor(expr.right) then
            right_str = "(" .. right_str .. ")"
        end
        return left_str .. "/" .. right_str
    end
    -- Subtraction
    if expr.type == "sub" and expr.left and expr.right then
        local left_str = pretty_print_internal(expr.left, "sub", "left")
        local right_str = pretty_print_internal(expr.right, "sub", "right")
        if not is_simple_factor(expr.left) then
            left_str = "(" .. left_str .. ")"
        end
        if not is_simple_factor(expr.right) then
            right_str = "(" .. right_str .. ")"
        end
        return left_str .. " - " .. right_str
    end
    -- Pretty print for integral nodes
    if expr.type == "integral" and expr.integrand and expr.respect_to then
        return "∫" .. pretty_print_internal(expr.integrand, nil, nil) .. " d" .. expr.respect_to
    end

    -- Pretty print for limit nodes
    if expr.type == "lim" and expr.expr and expr.var and expr.to then
        local expr_str = pretty_print_internal(expr.expr, nil, nil)
        local to_str = pretty_print_internal(expr.to, nil, nil)
        return "lim_(" .. expr.var .. "→" .. to_str .. ") " .. expr_str
    end
    -- Pretty print for series node
    if expr.type == "series" and expr.func and expr.var and expr.center and expr.order then
        local func_str = pretty_print_internal(expr.func, nil, nil)
        local varName_str = pretty_print_internal(expr.var, nil, nil)
        local center_str = pretty_print_internal(expr.center, nil, nil)
        local order_str = pretty_print_internal(expr.order, nil, nil)
        return "series(" .. func_str .. ", " .. varName_str .. ", " .. center_str .. ", " .. order_str .. ")"
    end

    -- Pretty print for plus-minus node ("pm")
    if expr.type == "pm" and expr.left and expr.right then
        local left_str = pretty_print_internal(expr.left, nil, nil)
        local right_str = pretty_print_internal(expr.right, nil, nil)
        return "(" .. left_str .. " ± " .. right_str .. ")"
    end

    -- Pretty print for tensor node (recursive for arbitrary depth)
    if expr.type == "tensor" and expr.elements then
        local function pretty_print_tensor_elements(elems)
            local strs = {}
            for i, elem in ipairs(elems) do
                if type(elem) == "table" and elem.type == "tensor" and elem.elements then
                    strs[i] = "[" .. table.concat(pretty_print_tensor_elements(elem.elements), ", ") .. "]"
                else
                    strs[i] = pretty_print_internal(elem, nil, nil)
                end
            end
            return strs
        end
        return "[" .. table.concat(pretty_print_tensor_elements(expr.elements), ", ") .. "]"
    end

    return "<unknown>"
end
-- Debug print full AST for any expression
function simplify.debug_print_ast(expr)
    print("DEBUG AST dump:\n" .. ast_to_string(expr))
end
-- Recursively round all number nodes (including those inside expressions like mul, add, etc.)
local function recursively_round_numbers(expr)
    if type(expr) ~= "table" then return expr end
    if expr.type == "number" and type(expr.value) == "number" then
        local p = get_precision()
        expr.value = round_to_precision(expr.value, p)
        return expr
    end
    local out = {}
    for k, v in pairs(expr) do
        if type(v) == "table" then
            out[k] = recursively_round_numbers(v)
        else
            out[k] = v
        end
    end
    setmetatable(out, getmetatable(expr))
    return out
end
-- ===== PUBLIC API =====

function simplify.simplify(expr)
    return simplify_until_stable(expr)
end

function simplify.pretty_print(expr)
    local display_expr = recursively_round_numbers(deepcopy(expr))
    return pretty_print_internal(display_expr, nil, nil)
end

function simplify.canonicalize(expr)
    -- Just normalize structure without aggressive simplification
    local normalized = deepcopy(expr)
    if (is_add(normalized) or is_mul(normalized)) and normalized.args then
        normalized = flatten(normalized)
        normalized = sort_args(normalized)
    end
    return normalized
end

function simplify.simplify_with_stats(expr)
    local max_iterations = 20
    local iteration = 0
    local prev_hash = nil
    
    while iteration < max_iterations do
        expr = simplify_step(expr)
        local current_hash = expr_hash(expr)
        
        if current_hash == prev_hash then
            break -- Converged
        end
        
        prev_hash = current_hash
        iteration = iteration + 1
    end
    
    return expr, {
        passes = iteration,
        converged = iteration < max_iterations
    }
end



-- Export to global if needed (keeping compatibility)
_G.simplify = simplify

-- End src/simplify.lua

-- Integrated src/simplify.lua: let’s hope it compiles this time.

-- Begin src/tensor.lua
local ast = _G.ast or error("AST module required")

local Tensor = {}
Tensor.__index = Tensor


-- Get shape of nested table recursively
local function get_shape(data)
  local shape = {}
  local cur = data
  while type(cur) == "table" do
    table.insert(shape, #cur)
    cur = cur[1]
  end
  return shape
end

-- Validate shape uniformity recursively
local function validate_shape(data, shape, level)
  level = level or 1
  if level > #shape then return true end
  if type(data) ~= "table" or #data ~= shape[level] then
    error("Shape mismatch at level "..level)
  end
  for _, v in ipairs(data) do
    validate_shape(v, shape, level + 1)
  end
end

-- Deep copy nested table
local function deep_copy(data)
  if type(data) ~= "table" then return data end
  local copy = {}
  for k,v in pairs(data) do
    copy[k] = deep_copy(v)
  end
  return copy
end

-- Recursive map over two tensors elementwise
local function map_recursive(t1_data, t2_data, fn, level, shape)
  if level > #shape then
    return fn(t1_data, t2_data)
  end
  local res = {}
  for i = 1, shape[level] do
    res[i] = map_recursive(t1_data[i], t2_data[i], fn, level + 1, shape)
  end
  return res
end

-- Recursive eval_numeric on nested data
local function eval_recursive(data, env)
  if type(data) ~= "table" then
    return ast.eval_numeric(data, env)
  end
  local res = {}
  for i, v in ipairs(data) do
    res[i] = eval_recursive(v, env)
  end
  return res
end

-- Recursive function to permute axes of nested tensor data
local function transpose_recursive(data, perm, level, old_shape)
  level = level or 1
  if level > #perm then
    return data
  end

  local new_dim_size = old_shape[perm[level]]
  local res = {}
  for i = 1, new_dim_size do
    -- Gather slice along axis perm[level]
    local function get_sliced(data, indices, cur_level)
      if cur_level > #perm then
        return data
      end
      local idx = indices[cur_level]
      return get_sliced(data[idx], indices, cur_level + 1)
    end

    -- Build indices array for recursive calls
    local function build_indices(level, fixed_index)
      if level > #perm then return {} end
      if level == level then
        local rest = build_indices(level + 1, fixed_index)
        table.insert(rest, 1, fixed_index)
        return rest
      else
        -- Return range over dimension (hacky, but for full transpose you need full iterator)
        local arr = {}
        for j=1, old_shape[perm[level]] do
          arr[j] = j
        end
        return arr
      end
    end

    -- Because full implementation is complicated, do a simpler approach:
    -- We'll transpose by swapping axes by recursively re-indexing
    -- For now, we'll leave this stubbed, returning data as-is (TODO)

    res[i] = data -- TODO: Implement full permutation
  end
  return res
end

-- Function to get value from nested tensor data by index array
local function get_element(data, indices)
  local cur = data
  for _, idx in ipairs(indices) do
    cur = cur[idx]
  end
  return cur
end

-- Function to set value in nested tensor data by index array
local function set_element(data, indices, value)
  local cur = data
  for i = 1, #indices - 1 do
    cur = cur[indices[i]]
  end
  cur[indices[#indices]] = value
end

-- Utility to generate all index tuples for given shape
local function index_iterator(shape)
  local indices = {}
  for i=1,#shape do indices[i] = 1 end

  return function()
    if not indices then return nil end
    local result = {table.unpack(indices)}
    -- increment indices
    for i = #indices, 1, -1 do
      indices[i] = indices[i] + 1
      if indices[i] > shape[i] then
        if i == 1 then
          indices = nil
          break
        else
          indices[i] = 1
        end
      else
        break
      end
    end
    return result
  end
end

-- Tensor constructor
function Tensor.new(data)
  assert(type(data) == "table", "Tensor must be constructed from nested table")
  local shape = get_shape(data)
  validate_shape(data, shape)
  local function wrap_numbers(d)
    if type(d) ~= "table" then
      if type(d) == "number" then
        return { type = "number", value = d }
      else
        return d
      end
    end
    local res = {}
    for k, v in pairs(d) do
      res[k] = wrap_numbers(v)
    end
    return res
  end

  local wrapped_data = wrap_numbers(data)
  return setmetatable({ type = "tensor", data = wrapped_data, shape = shape }, Tensor)
end

function Tensor:eval_numeric(env)
  return eval_recursive(self.data, env)
end

function Tensor:add(other)
  assert(#self.shape == #other.shape, "Shape rank mismatch for addition")
  for i=1,#self.shape do
    assert(self.shape[i] == other.shape[i], "Shape dimension mismatch for addition")
  end
  local res_data = map_recursive(self.data, other.data, ast.add, 1, self.shape)
  return Tensor.new(res_data)
end

function Tensor:mul(other)
  assert(#self.shape == #other.shape, "Shape rank mismatch for multiplication")
  for i=1,#self.shape do
    assert(self.shape[i] == other.shape[i], "Shape dimension mismatch for multiplication")
  end
  local res_data = map_recursive(self.data, other.data, ast.mul, 1, self.shape)
  local res_tensor = Tensor.new(res_data)
  return Tensor.new(res_tensor:eval_numeric({}))
end

-- Generalized transpose (permute axes)
function Tensor:transpose(perm)
  perm = perm or {}
  local rank = #self.shape
  if #perm == 0 then
    -- default reverse axes
    for i=rank,1,-1 do table.insert(perm, i) end
  end
  assert(#perm == rank, "Permutation length must equal tensor rank")
  local new_shape = {}
  for i=1, rank do
    new_shape[i] = self.shape[perm[i]]
  end

  -- TODO: full transpose requires complex recursive reindexing
  -- for now, stub to just return self, but shape updated
  -- WARNING: This won't actually rearrange data correctly
  return Tensor.new(deep_copy(self.data)) -- TODO: fix data permuting
end

-- Tensor contraction over specified axes
-- axes1 and axes2 are arrays of axis indices in self and other respectively to contract over
function Tensor:contract(other, axes1, axes2)
  assert(#axes1 == #axes2, "Must contract same number of axes")

  local rank1 = #self.shape
  local rank2 = #other.shape

  -- Validate axes
  for i=1,#axes1 do
    assert(axes1[i] >=1 and axes1[i] <= rank1, "axes1 out of range")
    assert(axes2[i] >=1 and axes2[i] <= rank2, "axes2 out of range")
    assert(self.shape[axes1[i]] == other.shape[axes2[i]], "Dimension mismatch for contraction axes")
  end

  -- Result shape is all axes of self not in axes1 + all axes of other not in axes2
  local result_shape = {}
  local used_axes1 = {}
  for _, a in ipairs(axes1) do used_axes1[a] = true end
  for i=1, rank1 do
    if not used_axes1[i] then table.insert(result_shape, self.shape[i]) end
  end
  local used_axes2 = {}
  for _, a in ipairs(axes2) do used_axes2[a] = true end
  for i=1, rank2 do
    if not used_axes2[i] then table.insert(result_shape, other.shape[i]) end
  end

  -- Helper to get index mapping
  local function build_indices(base_indices, shape, exclude_axes)
    local indices = {}
    local skip = {}
    for _, e in ipairs(exclude_axes) do skip[e] = true end
    local idx = 1
    for i=1,#shape do
      if not skip[i] then
        indices[idx] = base_indices[i]
        idx = idx + 1
      end
    end
    return indices
  end

  -- All indices iterator for given shape
  local function iter_indices(shape)
    local idxs = {}
    for i=1,#shape do idxs[i] = 1 end
    return function()
      if not idxs then return nil end
      local ret = {table.unpack(idxs)}
      for i=#idxs,1,-1 do
        idxs[i] = idxs[i] + 1
        if idxs[i] > shape[i] then
          if i == 1 then idxs = nil break end
          idxs[i] = 1
        else
          break
        end
      end
      return ret
    end
  end

  -- Indices for contracted axes shape
  local contract_shape = {}
  for i=1,#axes1 do
    table.insert(contract_shape, self.shape[axes1[i]])
  end

  -- Indices for non-contracted axes in self
  local non_contract_shape1 = {}
  local non_contract_axes1 = {}
  for i=1, rank1 do
    if not used_axes1[i] then
      table.insert(non_contract_shape1, self.shape[i])
      table.insert(non_contract_axes1, i)
    end
  end

  -- Indices for non-contracted axes in other
  local non_contract_shape2 = {}
  local non_contract_axes2 = {}
  for i=1, rank2 do
    if not used_axes2[i] then
      table.insert(non_contract_shape2, other.shape[i])
      table.insert(non_contract_axes2, i)
    end
  end

  local contract_iter = iter_indices(contract_shape)
  local non_contract_iter1 = iter_indices(non_contract_shape1)
  local non_contract_iter2 = iter_indices(non_contract_shape2)

  -- Create zero-initialized nested table for result
  local function create_nested_table(shape, level)
    if level > #shape then return ast.number(0) end
    local t = {}
    for i=1, shape[level] do
      t[i] = create_nested_table(shape, level + 1)
    end
    return t
  end

  local result_data = create_nested_table(result_shape, 1)

  -- Main contraction loop
  -- Iterate over all non contracted indices of self and other, then sum over contracted axes
  local idx1 = non_contract_iter1()
  while idx1 do
    local idx2 = non_contract_iter2()
    while idx2 do
      local sum = nil
      local contract_idx = iter_indices(contract_shape)()
      while contract_idx do
        -- Build full indices for self and other
        local full_idx_self = {}
        for i=1, rank1 do
          if used_axes1[i] then
            -- contracted axis, find position in axes1 to get index
            for pos, ax in ipairs(axes1) do
              if ax == i then full_idx_self[i] = contract_idx[pos] break end
            end
          else
            -- find position in non_contract_axes1
            for pos2, ax2 in ipairs(non_contract_axes1) do
              if ax2 == i then
                full_idx_self[i] = idx1[pos2]
                break
              end
            end
          end
        end
        local full_idx_other = {}
        for i=1, rank2 do
          if used_axes2[i] then
            for pos, ax in ipairs(axes2) do
              if ax == i then full_idx_other[i] = contract_idx[pos] break end
            end
          else
            for pos2, ax2 in ipairs(non_contract_axes2) do
              if ax2 == i then
                full_idx_other[i] = idx2[pos2]
                break
              end
            end
          end
        end
        -- Fetch elements
        local val1 = get_element(self.data, full_idx_self)
        local val2 = get_element(other.data, full_idx_other)
        local mul_val = ast.mul(val1, val2)
        if sum == nil then sum = mul_val else sum = ast.add(sum, mul_val) end
        contract_idx = iter_indices(contract_shape)()
      end
      -- Set result element
      local res_idx = {}
      for _, v in ipairs(idx1) do table.insert(res_idx, v) end
      for _, v in ipairs(idx2) do table.insert(res_idx, v) end
      set_element(result_data, res_idx, sum)
      idx2 = non_contract_iter2()
    end
    idx1 = non_contract_iter1()
  end

  return Tensor.new(result_data)
end

-- Default tensor multiplication: contract last axis of self with first axis of other
function Tensor:tensor_multiply(other)
  -- Default tensor multiplication contracts last axis of self with first axis of other
  local axes1 = { #self.shape }
  local axes2 = { 1 }
  return self:contract(other, axes1, axes2)
end

_G.Tensor = Tensor

-- Hook for AST simplifier to use for tensor multiplication
-- (This is not strictly needed here, but for clarity in patch context)

-- End src/tensor.lua

-- src/tensor.lua is in; don’t let that parser bite you later.

-- Begin src/trig.lua
-- trig.lua
-- Trig evaluation and symbolic helpers for nLuaCAS
-- Mostly here to pretend we remember SOHCAHTOA and the chain rule

local errors = _G.errors

-- Handles numeric evaluation of trig functions
-- Assumes degrees because radians scare most calculator users
-- Falls back to symbolic if it smells like algebra
-- Numeric trig evaluation (angle in degrees if constant input)
local function eval_trig_func(fname, arg)
  if type(arg) == "table" and arg.type == "number" then
    local val = arg.value
    -- Assume degrees for simple numbers (can adapt for radians)
    local rad = math.rad(val)
    if fname == "sin" then return ast.number(math.sin(rad)) end
    if fname == "cos" then return ast.number(math.cos(rad)) end
    if fname == "tan" then return ast.number(math.tan(rad)) end
    if fname == "cot" then return ast.number(1 / math.tan(rad)) end
    if fname == "sec" then return ast.number(1 / math.cos(rad)) end
    if fname == "csc" then return ast.number(1 / math.sin(rad)) end
  end
  -- Not a numeric constant: return nil, fall back to symbolic
  return nil -- fallback to symbolic; not a number
end

-- Applies the chain rule without asking for permission
-- Sins become cosines, cosines become negative sins, and so on
-- Symbolic differentiation of all trig functions (chain rule applied)
local function diff_trig_func(fname, arg, darg)
  if fname == "sin" then
    return ast.mul(ast.func("cos", {arg}), darg)
  elseif fname == "cos" then
    return ast.mul(ast.neg(ast.func("sin", {arg})), darg)
  elseif fname == "tan" then
    return ast.mul(ast.add(ast.number(1), ast.pow(ast.func("tan", {arg}), ast.number(2))), darg)
  elseif fname == "cot" then
    return ast.mul(ast.neg(ast.add(ast.number(1), ast.pow(ast.func("cot", {arg}), ast.number(2)))), darg)
  elseif fname == "sec" then
    return ast.mul(ast.mul(ast.func("sec", {arg}), ast.func("tan", {arg})), darg)
  elseif fname == "csc" then
    return ast.mul(ast.neg(ast.mul(ast.func("csc", {arg}), ast.func("cot", {arg}))), darg)
  end
  return error(errors.invalid("diff", "unknown trig function: " .. tostring(fname)))
end

-- Symbolic integration of trig functions
local function integrate_trig_func(fname, arg)
  if fname == "sin" then
    return ast.neg(ast.func("cos", {arg}))
  elseif fname == "cos" then
    return ast.func("sin", {arg})
  elseif fname == "tan" then
    return ast.neg(ast.func("ln", {ast.func("cos", {arg})}))
  elseif fname == "cot" then
    return ast.func("ln", {ast.func("sin", {arg})})
  elseif fname == "sec" then
    return ast.func("ln", {ast.add(ast.func("sec", {arg}), ast.func("tan", {arg}))})
  elseif fname == "csc" then
    return ast.neg(ast.func("ln", {ast.add(ast.func("csc", {arg}), ast.func("cot", {arg}))}))
  end
  return nil -- unknown trig function, fallback to unhandled
end

-- Bundle it up for the global namespace
-- Hopefully avoids circular dependency chaos
_G.trig = {
  eval_trig_func = eval_trig_func,
  diff_trig_func = diff_trig_func,
  integrate_trig_func = integrate_trig_func,
}

-- End src/trig.lua

-- Integrated src/trig.lua: let’s hope it compiles this time.

-- Begin src/derivative.lua
-- Derivative Engine (WIP)
-- Tries to symbolically differentiate expressions.
-- Some parts work. Some parts pretend to work.
-- Expect broken edge cases, unimplemented branches, and fallback logic.

local ast = rawget(_G, "ast") or require("ast")
local trig = rawget(_G, "trig")

-- Utility: shallow copy of a table
local function copy(tbl)
  if type(tbl) ~= "table" then return tbl end
  local t = {}
  for k,v in pairs(tbl) do t[k]=v end
  return t
end
-- Utility: check if AST is a constant (number)
local function is_const(ast)
  return ast.type == "number"
end

-- Utility: check if AST is a variable (symbol)
local function is_var(ast)
  return ast.type == "variable"
end

-- Utility: check if AST is a specific symbol
local function is_symbol(ast, name)
  return ast.type == "variable" and ast.name == name
end

-- Utility: limit AST node
local function lim(expr, var, to)
  return { type = 'lim', expr = expr, var = var, to = to }
end

-- Symbolic differentiation core. Tries to pretend it understands your math.
-- Falls back to limit definitions when it gives up.
local function diffAST(ast_node, var)
  if not ast_node then
    error("diffAST: invalid AST node passed in")
  end
  if type(ast_node) ~= "table" then
    error("diffAST: encountered non-AST node of type " .. type(ast_node))
  end
  var = var or "x"
  -- Numbers don't change. That's kind of the point.
  if ast_node.type == "number" then
    -- x → 1, everything else → 0. Classic.
    return ast.number(0)
  end
  -- x → 1, everything else → 0. Classic.
  if ast_node.type == "variable" then
    if ast_node.name == var then
      return ast.number(1)
    else
      return ast.number(0)
    end
  end
  -- Negation: signs flip, but rules stay the same.
  if ast_node.type == "neg" then
    return ast.neg(diffAST(ast_node.value, var))
  end
  -- Addition: term-wise differentiation. Nothing surprising.
  if ast_node.type == "add" then
    local deriv_args = {}
    for i, term in ipairs(ast_node.args) do
      deriv_args[i] = diffAST(term, var)
    end
    return ast.add(table.unpack(deriv_args))
  end
  -- Subtraction: just addition's grumpy cousin.
  if ast_node.type == "sub" then
    return ast.sub(diffAST(ast_node.left, var), diffAST(ast_node.right, var))
  end
  -- Multiplication: full product rule. Brace yourself.
  if ast_node.type == "mul" then
    local n = #ast_node.args
    local terms = {}
    for k = 1, n do
      local prod_args = {}
      for i = 1, n do
        if i == k then
          prod_args[i] = diffAST(ast_node.args[i], var)
        else
          prod_args[i] = copy(ast_node.args[i])
        end
      end
      terms[k] = ast.mul(table.unpack(prod_args))
    end
    return ast.add(table.unpack(terms))
  end
  -- Quotient rule. Surprisingly tidy, even here.
  if ast_node.type == "div" then
    local u = ast_node.left
    local v = ast_node.right
    local du = diffAST(u, var)
    local dv = diffAST(v, var)

    local numerator = ast.sub(
      ast.mul(du, copy(v)),
      ast.mul(copy(u), dv)
    )

    local denominator = ast.pow(copy(v), ast.number(2))

    return ast.div(numerator, denominator)
  end
  -- Powers: handles constants, variables, and full u^v chains.
  -- Tries to be clever with logs if needed.
  if ast_node.type == "pow" then
    local u, n = ast_node.base, ast_node.exp
    -- Case: u^c, c constant
    if is_const(n) then
      -- d/dx(u^c) = c*u^(c-1) * du/dx
      return ast.mul(
        ast.mul(copy(n), ast.pow(copy(u), ast.number(n.value - 1))),
        diffAST(u, var)
      )
    -- Case: c^v, c constant
    elseif is_const(u) then
      -- d/dx(c^v) = ln(c) * c^v * dv/dx
      return ast.mul(
        ast.mul(ast.func("ln", { copy(u) }), ast.pow(copy(u), copy(n))),
        diffAST(n, var)
      )
    else
      -- General case: d/dx(u^v) = u^v * (v' * ln(u) + v * u'/u)
      -- (by logarithmic differentiation)
      return ast.mul(
        ast.pow(copy(u), copy(n)),
        ast.add(
          ast.mul(diffAST(n, var), ast.func("ln", { copy(u) })),
          ast.mul(copy(n), ast.div(diffAST(u, var), copy(u)))
        )
      )
    end
  end
  -- Function differentiation: sin, exp, ln, etc.
  -- Tries trig.lua first. Falls back to hardcoded rules.
  -- Anything unknown? It gets the limit treatment.
  if ast_node.type == "func" then
    local fname = ast_node.name
    -- Support both .arg (single) and .args (list) notation
    local u = ast_node.arg or (ast_node.args and ast_node.args[1])
    local du = diffAST(u, var)
    -- Handle standard trig derivatives directly
    if fname == "sin" then
        return ast.mul(ast.func("cos", { copy(u) }), du)
    elseif fname == "cos" then
        return ast.neg(ast.mul(ast.func("sin", { copy(u) }), du))
    elseif fname == "tan" then
        return ast.mul(ast.pow(ast.func("sec", { copy(u) }), ast.number(2)), du)
    elseif fname == "sec" then
        return ast.mul(ast.mul(ast.func("sec", { copy(u) }), ast.func("tan", { copy(u) })), du)
    elseif fname == "csc" then
        return ast.neg(ast.mul(ast.func("csc", { copy(u) }), ast.func("cot", { copy(u) }), du))
    elseif fname == "cot" then
        return ast.neg(ast.mul(ast.pow(ast.func("csc", { copy(u) }), ast.number(2)), du))
    elseif fname == "arcsin" then
        return ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2))) })), du)
    elseif fname == "arccos" then
        return ast.neg(ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2))) })), du))
    elseif fname == "arctan" then
        return ast.mul(ast.div(ast.number(1), ast.add(ast.number(1), ast.pow(copy(u), ast.number(2)))), du)
    elseif fname == "arccsc" then
        return ast.neg(ast.mul(ast.div(ast.number(1), ast.mul(ast.func("abs", { copy(u) }), ast.func("sqrt", { ast.sub(ast.pow(copy(u), ast.number(2)), ast.number(1)) }))), du))
    elseif fname == "arcsec" then
        return ast.mul(ast.div(ast.number(1), ast.mul(ast.func("abs", { copy(u) }), ast.func("sqrt", { ast.sub(ast.pow(copy(u), ast.number(2)), ast.number(1)) }))), du)
    elseif fname == "arccot" then
        return ast.neg(ast.mul(ast.div(ast.number(1), ast.add(ast.number(1), ast.pow(copy(u), ast.number(2)))), du))
    end
    -- Use trig.lua for trigonometric differentiation if available
    if trig and trig.diff_trig_func then
      local trig_result = trig.diff_trig_func(fname, copy(u), du)
      if trig_result then return trig_result end
    end
    if fname == "exp" then
      return ast.mul(ast.func("exp", { copy(u) }), du)
    elseif fname == "ln" then
      return ast.mul(ast.div(ast.number(1), copy(u)), du)
    elseif fname == "log" then
      -- log(x) = ln(x) / ln(10), so derivative is 1/(x ln(10))
      return ast.mul(ast.div(ast.number(1), ast.mul(copy(u), ast.func("ln", { ast.number(10) }))), du)
    elseif fname == "sqrt" then
      -- d/dx sqrt(u) = 1/(2*sqrt(u)) * du/dx
      return ast.mul(ast.div(ast.number(1), ast.mul(ast.number(2), ast.func("sqrt", { copy(u) }))), du)
    elseif fname == "asin" then
      -- d/dx asin(u) = 1/sqrt(1-u^2) * du/dx
      return ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2))) })), du)
    elseif fname == "acos" then
      -- d/dx acos(u) = -1/sqrt(1-u^2) * du/dx
      return ast.mul(ast.neg(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2))) }))), du)
    elseif fname == "atan" then
      -- d/dx atan(u) = 1/(1+u^2) * du/dx
      return ast.mul(ast.div(ast.number(1), ast.add(ast.number(1), ast.pow(copy(u), ast.number(2)))), du)
    elseif fname == "sinh" then
      return ast.mul(ast.func("cosh", { copy(u) }), du)
    elseif fname == "cosh" then
      return ast.mul(ast.func("sinh", { copy(u) }), du)
    elseif fname == "tanh" then
      return ast.mul(ast.sub(ast.number(1), ast.pow(ast.func("tanh", { copy(u) }), ast.number(2))), du)
    elseif fname == "asinh" then
      return ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.add(ast.pow(copy(u), ast.number(2)), ast.number(1)) })), du)
    elseif fname == "acosh" then
      return ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.pow(copy(u), ast.number(2)), ast.number(1)) })), du)
    elseif fname == "atanh" then
      return ast.mul(ast.div(ast.number(1), ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2)))), du)
    elseif fname == "log10" then
      return ast.mul(ast.div(ast.number(1), ast.mul(copy(u), ast.func("ln", { ast.number(10) }))), du)
    elseif fname == "log2" then
      return ast.mul(ast.div(ast.number(1), ast.mul(copy(u), ast.func("ln", { ast.number(2) }))), du)
    elseif fname == "abs" then
      return ast.mul(ast.div(copy(u), ast.func("abs", { copy(u) })), du)
    elseif fname == "sign" then
      return ast.number(0)
    elseif fname == "floor" or fname == "ceil" or fname == "round" then
      -- Derivative is zero except at discontinuity
      return ast.number(0)
    elseif fname == "erf" then
      -- d/dx erf(u) = 2/sqrt(pi) * exp(-u^2) * du/dx
      return ast.mul(ast.mul(ast.div(ast.number(2), ast.func("sqrt", { ast.number(math.pi) })), ast.func("exp", { ast.neg(ast.pow(copy(u), ast.number(2))) })), du)
    elseif fname == "gamma" then
      -- d/dx gamma(u) = gamma(u) * digamma(u) * du/dx (digamma not implemented, fallback)
      return { type = "unimplemented_derivative", func = fname, arg = copy(u) }
    elseif fname == "digamma" then
      -- d/dx digamma(u) = trigamma(u) * du/dx
      return ast.mul(ast.func("trigamma", { copy(u) }), du)
    elseif fname == "trigamma" then
      -- d/dx trigamma(u) = polygamma(2, u) * du/dx
      return ast.mul(ast.func("polygamma", { ast.number(2), copy(u) }), du)
    else
      -- Fallback: Use limit definition for unknown function
      -- f'(x) = lim_{h->0} [f(x+h)-f(x)]/h
      local h = ast.symbol("__h__")
      local u_ph = ast.add(copy(u), h)
      local fxh = ast.func(fname, { u_ph })
      local fx = ast.func(fname, { copy(u) })
      local nume = ast.sub(fxh, fx)
      local denom = copy(h)
      if not denom or denom.type ~= "variable" then
          denom = ast.symbol("__h__")
      end
      local quot = ast.div(nume, denom)
      return lim(quot, "__h__", ast.number(0))
    end
  end
  -- No clue what this is. Marked for manual inspection later.
  -- As a safety fallback, return an unknown node
  local result = { type = "unhandled_node", original = ast_node }
  if type(result) ~= "table" or not result.type then
    error("diffAST: returned invalid AST node structure")
  end
  return result
end


-- Public interface: takes string input, returns simplified derivative AST.
-- If it doesn't break, it probably worked.
local function derivative(expr, var)
  -- Load parser
  local parser = rawget(_G, "parser") or require("parser")
  -- Input validation and debug print
  if type(expr) ~= "string" then
    error("Invalid input to derivative(): expected string, got " .. type(expr))
  end
  print("DEBUG: input to parser.parse =", expr)
  -- Parse expr string to AST
  local tree = parser.parse(expr)
  if not tree then
    error("Parsing failed: input = " .. expr)
  end
  local result = diffAST(tree, var)
  if type(result) ~= "table" or not result.type then
    error("Invalid derivative AST structure")
  end
  return (rawget(_G, "simplify") or require("simplify")).simplify(result)
end
_G.derivative = derivative
_G.diffAST = diffAST

-- End src/derivative.lua

-- Imported src/derivative.lua—debuggers rejoice.

-- Begin src/integrate.lua
-- Integral Engine (Enhanced Edition - Because Apparently We're Gluttons for Punishment)
-- Now with 300% more ways to fail spectacularly at symbolic integration
-- Features: Inverse trig functions, partial fractions, and other mathematical nightmares

local ast = rawget(_G, "ast") or require("ast")
local diffAST = rawget(_G, "diffAST") or error("diffAST: differentiation function required for integration by parts")
local trig = rawget(_G, "trig")
local simplify = rawget(_G, "simplify") or require("simplify")

-- Expanded symbolic integral lookup (now with inverse trig because we hate ourselves)
local known_integral_table = {
  -- Inverse trig functions (the devil's own mathematics)
  arcsin = function(arg) 
    return ast.add(ast.mul(arg, ast.func("arcsin", {copy(arg)})), ast.func("sqrt", {ast.sub(ast.number(1), ast.pow(copy(arg), ast.number(2)))}))
  end,
  arccos = function(arg)
    return ast.sub(ast.mul(arg, ast.func("arccos", {copy(arg)})), ast.func("sqrt", {ast.sub(ast.number(1), ast.pow(copy(arg), ast.number(2)))}))
  end,
  arctan = function(arg)
    return ast.sub(ast.mul(arg, ast.func("arctan", {copy(arg)})), ast.div(ast.func("ln", {ast.add(ast.number(1), ast.pow(copy(arg), ast.number(2)))}), ast.number(2)))
  end,
  
  -- Hyperbolic functions (because regular trig wasn't painful enough)
  sinh = function(arg) return ast.func("cosh", {copy(arg)}) end,
  cosh = function(arg) return ast.func("sinh", {copy(arg)}) end,
  tanh = function(arg) return ast.func("ln", {ast.func("cosh", {copy(arg)})}) end,
  
  -- Square root integrals (the "f it, let's go deeper" collection)
  sqrt = function(arg)
    if is_symbol(arg, "x") then
      return ast.div(ast.mul(ast.number(2), ast.pow(arg, ast.div(ast.number(3), ast.number(2)))), ast.number(3))
    end
    return nil
  end
}

local enable_substitution = true  
local enable_advanced_symbolics = true  -- Fuck it, we're going full masochist mode
local enable_partial_fractions = true   -- Because rational functions are the devil
local enable_definite_integrals = true  -- Bounds? We don't need no stinking bounds... wait, yes we do

-- Utility functions that hopefully won't explode this time
local function copy(tbl)
  if type(tbl) ~= "table" then return tbl end
  local t = {}
  for k,v in pairs(tbl) do 
    t[k] = type(v) == "table" and copy(v) or v 
  end
  return t
end

local function is_const(node)
  return node and node.type == "number"
end

local function is_var(node)
  return node and node.type == "variable"
end

local function is_symbol(node, name)
  return node and node.type == "variable" and node.name == name
end

-- Check if expression contains only polynomials (for partial fraction decomposition)
local function is_polynomial(node, var)
  if not node then return false end
  if node.type == "number" then return true end
  if node.type == "variable" then return node.name == var or true end -- constants are polynomials too
  if node.type == "add" or node.type == "sub" then
    return is_polynomial(node.left or node.args and node.args[1], var) and 
           is_polynomial(node.right or node.args and node.args[2], var)
  end
  if node.type == "mul" and node.args then
    for _, arg in ipairs(node.args) do
      if not is_polynomial(arg, var) then return false end
    end
    return true
  end
  if node.type == "pow" then
    return is_polynomial(node.base, var) and is_const(node.exp) and node.exp.value >= 0
  end
  return false
end

-- Partial fraction decomposition (the "why did I think this was a good idea" function)
local function partial_fraction_decompose(numerator, denominator, var)
  -- This is a massive simplification - real partial fractions are a nightmare
  -- We'll handle the simplest case: A/(x-a) + B/(x-b)
  
  if not denominator or denominator.type ~= "mul" then return nil end
  if not denominator.args or #denominator.args ~= 2 then return nil end
  
  local factors = {}
  for _, factor in ipairs(denominator.args) do
    if factor.type == "add" and factor.args and #factor.args == 2 then
      -- Check if it's (x + constant) form
      local x_term, const_term
      for _, term in ipairs(factor.args) do
        if is_symbol(term, var) then x_term = term
        elseif is_const(term) then const_term = term
        end
      end
      if x_term and const_term then
        table.insert(factors, {type = "linear", root = ast.number(-const_term.value)})
      end
    elseif factor.type == "sub" and factor.left and factor.right then
      if is_symbol(factor.left, var) and is_const(factor.right) then
        table.insert(factors, {type = "linear", root = copy(factor.right)})
      end
    end
  end
  
  if #factors == 2 and factors[1].type == "linear" and factors[2].type == "linear" then
    -- We have (x-a)(x-b), so we want A/(x-a) + B/(x-b)
    -- This is where I'd implement the full algorithm if I wasn't already dead inside
    -- For now, return a placeholder that integration can handle
    return {
      type = "partial_fraction_sum",
      terms = {
        {numerator = ast.number(1), denominator = ast.sub(ast.variable(var), factors[1].root)},
        {numerator = ast.number(1), denominator = ast.sub(ast.variable(var), factors[2].root)}
      }
    }
  end
  
  return nil
end

-- Enhanced pattern matching (now with 50% more disappointment)
local function pattern_match(expr, pattern, bindings)
  bindings = bindings or {}
  
  if not expr or not pattern then return false end
  
  if pattern.type == "wildcard" then
    bindings[pattern.name] = expr
    return true, bindings
  end
  
  if expr.type ~= pattern.type then return false end
  
  if expr.type == "number" then
    return expr.value == pattern.value, bindings
  elseif expr.type == "variable" then
    return expr.name == pattern.name, bindings
  elseif expr.type == "func" and expr.name == pattern.name then
    if expr.args and pattern.args and expr.args[1] and pattern.args[1] then
      return pattern_match(expr.args[1], pattern.args[1], bindings)
    end
    return false
  elseif expr.type == "mul" or expr.type == "add" then
    if not expr.args or not pattern.args or #expr.args ~= #pattern.args then 
      return false 
    end
    for i = 1, #expr.args do
      local ok, new_bindings = pattern_match(expr.args[i], pattern.args[i], bindings)
      if not ok then return false end
      bindings = new_bindings or bindings
    end
    return true, bindings
  elseif expr.type == "pow" then
    if not expr.base or not expr.exp or not pattern.base or not pattern.exp then
      return false
    end
    local ok1, b1 = pattern_match(expr.base, pattern.base, bindings)
    local ok2, b2 = pattern_match(expr.exp, pattern.exp, b1 or bindings)
    return ok1 and ok2, b2 or bindings
  end
  
  return false
end

-- Advanced substitution patterns (because basic substitution wasn't masochistic enough)
local function try_advanced_substitution(node, var)
  if not enable_advanced_symbolics then return nil end
  
  -- Trigonometric substitutions (the "abandon all hope" section)
  local sqrt_patterns = {
    -- √(a² - x²) -> x = a*sin(θ)
    {
      pattern = ast.func("sqrt", {ast.sub(ast.pow(ast.wildcard("a"), ast.number(2)), ast.pow(ast.variable(var), ast.number(2)))}),
      substitution = "trig_sin"
    },
    -- √(a² + x²) -> x = a*tan(θ)  
    {
      pattern = ast.func("sqrt", {ast.add(ast.pow(ast.wildcard("a"), ast.number(2)), ast.pow(ast.variable(var), ast.number(2)))}),
      substitution = "trig_tan"
    },
    -- √(x² - a²) -> x = a*sec(θ)
    {
      pattern = ast.func("sqrt", {ast.sub(ast.pow(ast.variable(var), ast.number(2)), ast.pow(ast.wildcard("a"), ast.number(2)))}),
      substitution = "trig_sec"
    }
  }
  
  for _, sub_pattern in ipairs(sqrt_patterns) do
    local bindings = {}
    if pattern_match(node, sub_pattern.pattern, bindings) then
      -- In a real implementation, we'd actually perform the substitution
      -- For now, let's just acknowledge we found a pattern and cry softly
      return {
        type = "advanced_substitution",
        method = sub_pattern.substitution,
        original = copy(node),
        bindings = bindings
      }
    end
  end
  
  return nil
end

-- Enhanced substitution (now with more ways to fail)
local function try_substitution(node, var)
  if not node or node.type ~= "mul" or not node.args then 
    return nil 
  end
  
  -- Try advanced substitutions first
  local advanced = try_advanced_substitution(node, var)
  if advanced then return advanced end
  
  for _, arg in ipairs(node.args) do
    if ast.is_function_of and ast.is_function_of(arg, var) then
      local f = arg
      local df = diffAST(f, var)
      if df then
        for _, inner in ipairs(node.args) do
          if inner ~= arg and simplify.expr_equal and simplify.expr_equal(inner, df) then
            local u = ast.variable("u")
            local replaced = ast.replace and ast.replace(node, f, u)
            if replaced then
              local integral_u = integrateAST(replaced, "u")
              if integral_u and integral_u.type ~= "unimplemented_integral" then
                return ast.replace(integral_u, u, f)
              end
            end
          end
        end
      end
    end
  end
  return nil
end

-- Integration by parts (now with recursive attempts because we're flipping insane)
local function try_integration_by_parts(node, var)
  if not node or node.type ~= "mul" or not node.args or #node.args < 2 then 
    return nil 
  end
  
  -- Priority list for choosing u (LIATE rule: Logarithmic, Inverse trig, Algebraic, Trig, Exponential)
  local function get_integration_priority(expr)
    if expr.type == "func" then
      if expr.name == "ln" then return 1 end
      if expr.name:match("^arc") then return 2 end -- arcsin, arccos, etc.
      if expr.name:match("^a?sinh?$") or expr.name:match("^a?cosh?$") then return 2 end
      if expr.name == "sin" or expr.name == "cos" or expr.name == "tan" then return 4 end
      if expr.name == "exp" then return 5 end
    elseif expr.type == "pow" and is_symbol(expr.base, var) then
      return 3 -- algebraic
    elseif is_symbol(expr, var) then
      return 3
    end
    return 6 -- everything else
  end
  
  -- Choose u and dv based on priority
  local best_u, best_dv
  local best_priority = math.huge
  
  for i = 1, #node.args do
    local priority = get_integration_priority(node.args[i])
    if priority < best_priority then
      best_priority = priority
      best_u = node.args[i]
      -- dv is everything else
      local dv_args = {}
      for j = 1, #node.args do
        if i ~= j then table.insert(dv_args, node.args[j]) end
      end
      best_dv = #dv_args == 1 and dv_args[1] or ast.mul(table.unpack(dv_args))
    end
  end
  
  if not best_u or not best_dv then return nil end
  
  local V = integrateAST(best_dv, var)
  local du = diffAST(best_u, var)
  
  if not V or not du or V.type == "unimplemented_integral" then
    return nil
  end
  
  local second_integral = integrateAST(ast.mul(V, du), var)
  -- Prevent infinite recursion: if we get back the same integral, bail out
  if simplify.expr_equal(second_integral, node) then
    return nil
  end
  if second_integral and second_integral.type ~= "unimplemented_integral" then
    return ast.sub(ast.mul(best_u, V), second_integral)
  end
  
  return nil
end

-- Enhanced trig integration (now with more trigonometric masochism)
local function integrate_trig(fname, arg, var)
  if not fname or not arg then return nil end
  
  -- Handle chain rule: if arg is not just the variable, we need the derivative
  local chain_factor = nil
  if arg.type ~= "variable" or arg.name ~= var then
    local darg = diffAST(arg, var)
    if not darg then return nil end
    chain_factor = darg
  end
  
  local base_integral
  if fname == "sin" then
    base_integral = ast.neg(ast.func("cos", { copy(arg) }))
  elseif fname == "cos" then
    base_integral = ast.func("sin", { copy(arg) })
  elseif fname == "tan" then
    base_integral = ast.neg(ast.func("ln", { ast.func("cos", { copy(arg) }) }))
  elseif fname == "cot" then
    base_integral = ast.func("ln", { ast.func("sin", { copy(arg) }) })
  elseif fname == "sec" then
    base_integral = ast.func("ln", { ast.add(ast.func("sec", { copy(arg) }), ast.func("tan", { copy(arg) })) })
  elseif fname == "csc" then
    base_integral = ast.neg(ast.func("ln", { ast.add(ast.func("csc", { copy(arg) }), ast.func("cot", { copy(arg) })) }))
  -- Inverse trig functions (the "why do these even exist" section)
  elseif fname == "arcsin" then
    if is_symbol(arg, var) then
      return ast.add(ast.mul(copy(arg), ast.func("arcsin", {copy(arg)})), 
                     ast.func("sqrt", {ast.sub(ast.number(1), ast.pow(copy(arg), ast.number(2)))}))
    end
  elseif fname == "arccos" then
    if is_symbol(arg, var) then
      return ast.sub(ast.mul(copy(arg), ast.func("arccos", {copy(arg)})), 
                     ast.func("sqrt", {ast.sub(ast.number(1), ast.pow(copy(arg), ast.number(2)))}))
    end
  elseif fname == "arctan" then
    if is_symbol(arg, var) then
      return ast.sub(ast.mul(copy(arg), ast.func("arctan", {copy(arg)})), 
                     ast.div(ast.func("ln", {ast.add(ast.number(1), ast.pow(copy(arg), ast.number(2)))}), ast.number(2)))
    end
  -- Hyperbolic functions (because we're completionists, apparently)
  elseif fname == "sinh" then
    base_integral = ast.func("cosh", { copy(arg) })
  elseif fname == "cosh" then
    base_integral = ast.func("sinh", { copy(arg) })
  elseif fname == "tanh" then
    base_integral = ast.func("ln", { ast.func("cosh", { copy(arg) }) })
  else
    return nil
  end
  
  -- Apply chain rule if needed
  if chain_factor and base_integral then
    -- This would need the reciprocal of the chain factor, which is complex
    -- For now, return nil for non-trivial arguments
    return nil
  end
  
  return base_integral
end

-- Numerical integration fallback (because sometimes symbolic integration is impossible)
local function numerical_integration_fallback(node, var, a, b)
  if not enable_definite_integrals or not a or not b then
    return {
      type = "numerical_integration_required",
      original = copy(node),
      bounds = {lower = a, upper = b}
    }
  end
  
  -- Simpson's rule implementation would go here
  -- But that's a whole other can of worms
  return {
    type = "numerical_approximation",
    method = "simpsons_rule",
    original = copy(node),
    bounds = {lower = a, upper = b}
  }
end

-- Core integration function (now with 400% more complexity and existential dread)
local function integrateAST(node, var, bounds)
  if not node then 
    error("integrateAST: invalid AST node") 
  end
  var = var or "x"
  
  -- Handle definite integrals
  local is_definite = bounds and bounds.lower and bounds.upper
  
  -- ∫ c dx = c * x
  if node.type == "number" then
    local result = ast.mul(copy(node), ast.variable(var))
    if is_definite then
      -- F(b) - F(a)
      local upper_val = ast.mul(copy(node), copy(bounds.upper))
      local lower_val = ast.mul(copy(node), copy(bounds.lower))
      return ast.sub(upper_val, lower_val)
    end
    return ast.add(result, ast.variable("C"))
  end

  -- ∫ x dx = x^2/2 ; ∫ y dx = y * x
  if node.type == "variable" then
    if node.name == var then
      local result = ast.div(ast.pow(ast.variable(var), ast.number(2)), ast.number(2))
      if is_definite then
        local upper_val = ast.div(ast.pow(copy(bounds.upper), ast.number(2)), ast.number(2))
        local lower_val = ast.div(ast.pow(copy(bounds.lower), ast.number(2)), ast.number(2))
        return ast.sub(upper_val, lower_val)
      end
      return ast.add(result, ast.variable("C"))
    else
      local result = ast.mul(copy(node), ast.variable(var))
      if is_definite then
        local diff = ast.sub(copy(bounds.upper), copy(bounds.lower))
        return ast.mul(copy(node), diff)
      end
      return ast.add(result, ast.variable("C"))
    end
  end

  -- ∫ (u + v) dx = ∫u + ∫v
  if node.type == "add" and node.args then
    local results = {}
    for i, term in ipairs(node.args) do
      local integral_term = integrateAST(term, var, bounds)
      if integral_term.type == "unimplemented_integral" then
        -- Try numerical integration if this is definite
        if is_definite then
          return numerical_integration_fallback(node, var, bounds.lower, bounds.upper)
        end
        return { type = "unimplemented_integral", original = node }
      end
      results[i] = integral_term
    end
    if is_definite then
      return ast.add(table.unpack(results))
    end
    return ast.add(ast.add(table.unpack(results)), ast.variable("C"))
  end

  -- ∫ (u - v) dx = ∫u - ∫v
  if node.type == "sub" and node.left and node.right then
    local left_int = integrateAST(node.left, var, bounds)
    local right_int = integrateAST(node.right, var, bounds)
    if left_int.type == "unimplemented_integral" or right_int.type == "unimplemented_integral" then
      if is_definite then
        return numerical_integration_fallback(node, var, bounds.lower, bounds.upper)
      end
      return { type = "unimplemented_integral", original = node }
    end
    if is_definite then
      return ast.sub(left_int, right_int)
    end
    return ast.add(ast.sub(left_int, right_int), ast.variable("C"))
  end

  -- Enhanced division handling with partial fractions
  if node.type == "div" and node.left and node.right then
    local num, denom = node.left, node.right
    
    -- Check for f'(x)/f(x) pattern first
    local ddenom = diffAST(denom, var)
    if ddenom and simplify.expr_equal and simplify.expr_equal(num, ddenom) then
      local result = ast.func("ln", { ast.func("abs", { copy(denom) }) })
      if is_definite then
        local upper_val = ast.func("ln", { ast.func("abs", { ast.replace(copy(denom), ast.variable(var), copy(bounds.upper)) }) })
        local lower_val = ast.func("ln", { ast.func("abs", { ast.replace(copy(denom), ast.variable(var), copy(bounds.lower)) }) })
        return ast.sub(upper_val, lower_val)
      end
      return result
    end
    
    -- Try partial fraction decomposition
    if enable_partial_fractions and is_polynomial(num, var) and is_polynomial(denom, var) then
      local partial_fractions = partial_fraction_decompose(num, denom, var)
      if partial_fractions and partial_fractions.type == "partial_fraction_sum" then
        local results = {}
        for _, term in ipairs(partial_fractions.terms) do
          local term_integral = integrateAST(ast.div(term.numerator, term.denominator), var, bounds)
          if term_integral.type == "unimplemented_integral" then
            break
          end
          table.insert(results, term_integral)
        end
        if #results == #partial_fractions.terms then
          return ast.add(table.unpack(results))
        end
      end
    end
    
    -- Convert to multiplication for further processing
    return integrateAST(ast.mul(node.left, ast.pow(node.right, ast.number(-1))), var, bounds)
  end

  -- Enhanced multiplication handling
  if node.type == "mul" and node.args then
    -- Try substitution first
    if enable_substitution then
      local sub_result = try_substitution(node, var)
      if sub_result then 
        if sub_result.type == "advanced_substitution" then
          -- For now, acknowledge we found a substitution pattern but can't execute it
          if is_definite then
            return numerical_integration_fallback(node, var, bounds.lower, bounds.upper)
          end
          return { type = "unimplemented_integral", original = node, note = "advanced_substitution_found" }
        end
        return sub_result 
      end
    end

    -- Try integration by parts
    local parts_result = try_integration_by_parts(node, var)
    if parts_result then return parts_result end

    -- Handle exponential integrals: ∫ f'(x) * e^{f(x)} dx = e^{f(x)}
    for i, arg in ipairs(node.args) do
      if arg.type == "func" and arg.name == "exp" and arg.args and arg.args[1] then
        local f = arg.args[1]
        local df = diffAST(f, var)
        if df then
          for j, other in ipairs(node.args) do
            if i ~= j and simplify.expr_equal and simplify.expr_equal(other, df) then
              local remaining = {}
              for k, term in ipairs(node.args) do
                if k ~= i and k ~= j then
                  table.insert(remaining, term)
                end
              end
              local result = ast.func("exp", { copy(f) })
              if #remaining > 0 then
                local factor = #remaining == 1 and remaining[1] or ast.mul(table.unpack(remaining))
                result = ast.mul(factor, result)
              end
              
              if is_definite then
                local upper_val = ast.replace(copy(result), ast.variable(var), copy(bounds.upper))
                local lower_val = ast.replace(copy(result), ast.variable(var), copy(bounds.lower))
                return ast.sub(upper_val, lower_val)
              end
              return result
            end
          end
        end
      end
    end

    -- Power rule with chain: ∫ f(x)^n * f'(x) dx = f(x)^{n+1}/(n+1)
    for i, arg in ipairs(node.args) do
      if arg.type == "pow" and is_const(arg.exp) and arg.exp.value ~= -1 then
        local base, exp = arg.base, arg.exp
        local dbase = diffAST(base, var)
        if dbase then
          for j, other in ipairs(node.args) do
            if i ~= j and simplify.expr_equal and simplify.expr_equal(other, dbase) then
              local new_exp = ast.add(copy(exp), ast.number(1))
              local result = ast.div(ast.pow(copy(base), new_exp), copy(new_exp))
              
              if is_definite then
                local upper_val = ast.replace(copy(result), ast.variable(var), copy(bounds.upper))
                local lower_val = ast.replace(copy(result), ast.variable(var), copy(bounds.lower))
                return ast.sub(upper_val, lower_val)
              end
              return result
            end
          end
        end
      end
    end

    -- Extract constants (this part actually works, surprisingly)
    local constants = {}
    local variables = {}
    for _, arg in ipairs(node.args) do
      if is_const(arg) or (arg.type == "variable" and arg.name ~= var) then
        table.insert(constants, arg)
      else
        table.insert(variables, arg)
      end
    end

    if #constants > 0 and #variables > 0 then
      local const_product = #constants == 1 and constants[1] or ast.mul(table.unpack(constants))
      local var_product = #variables == 1 and variables[1] or ast.mul(table.unpack(variables))
      -- Prevent infinite recursion if nothing was factored out (var_product == node)
      if simplify.expr_equal(var_product, node) then
        return { type = "unimplemented_integral", original = node }
      end
      local var_integral = integrateAST(var_product, var, bounds)
      if var_integral.type ~= "unimplemented_integral" then
        if is_definite then
          return var_integral -- bounds already handled in recursive call
        end
        return ast.mul(const_product, var_integral)
      end
    end
  end

  -- Enhanced power rule: ∫ x^n dx and ∫ a^x dx
  if node.type == "pow" and node.base and node.exp then
    local base, exp = node.base, node.exp
    
    if is_symbol(base, var) and is_const(exp) then
      if exp.value == -1 then
        local result = ast.func("ln", { ast.func("abs", { copy(base) }) })
        if is_definite then
          local upper_val = ast.func("ln", { ast.func("abs", { copy(bounds.upper) }) })
          local lower_val = ast.func("ln", { ast.func("abs", { copy(bounds.lower) }) })
          return ast.sub(upper_val, lower_val)
        end
        return ast.add(result, ast.variable("C"))
      else
        local new_exp = ast.number(exp.value + 1)
        local result = ast.div(ast.pow(copy(base), new_exp), new_exp)
        if is_definite then
          local upper_val = ast.div(ast.pow(copy(bounds.upper), new_exp), new_exp)
          local lower_val = ast.div(ast.pow(copy(bounds.lower), new_exp), new_exp)
          return ast.sub(upper_val, lower_val)
        end
        return ast.add(result, ast.variable("C"))
      end
    elseif is_const(base) and is_symbol(exp, var) then
      -- ∫ a^x dx = a^x / ln(a)
      local result = ast.div(copy(node), ast.func("ln", { copy(base) }))
      if is_definite then
        local upper_val = ast.div(ast.pow(copy(base), copy(bounds.upper)), ast.func("ln", { copy(base) }))
        local lower_val = ast.div(ast.pow(copy(base), copy(bounds.lower)), ast.func("ln", { copy(base) }))
        return ast.sub(upper_val, lower_val)
      end
      return ast.add(result, ast.variable("C"))
    end
  end

  -- Enhanced function integration
  if node.type == "func" and node.name then
    local fname = node.name
    local arg = (node.args and node.args[1]) or node.arg

    -- Try trigonometric functions (now with more trig!)
    local trig_result = integrate_trig(fname, arg, var)
    if trig_result then 
      if is_definite then
        local upper_val = ast.replace(copy(trig_result), ast.variable(var), copy(bounds.upper))
        local lower_val = ast.replace(copy(trig_result), ast.variable(var), copy(bounds.lower))
        return ast.sub(upper_val, lower_val)
      end
      return ast.add(trig_result, ast.variable("C"))
    end

    -- Handle other common functions
    if fname == "exp" and arg then
      if is_symbol(arg, var) then
        if is_definite then
          local upper_val = ast.func("exp", { copy(bounds.upper) })
          local lower_val = ast.func("exp", { copy(bounds.lower) })
          return ast.sub(upper_val, lower_val)
        end
        return ast.add(copy(node), ast.variable("C"))
      end
    elseif fname == "ln" and arg then
      if is_symbol(arg, var) then
        -- ∫ ln(x) dx = x*ln(x) - x
        local x = ast.variable(var)
        local result = ast.sub(ast.mul(x, copy(node)), x)
        if is_definite then
          local upper_val = ast.sub(ast.mul(copy(bounds.upper), ast.func("ln", { copy(bounds.upper) })), copy(bounds.upper))
          local lower_val = ast.sub(ast.mul(copy(bounds.lower), ast.func("ln", { copy(bounds.lower) })), copy(bounds.lower))
          return ast.sub(upper_val, lower_val)
        end
        return ast.add(result, ast.variable("C"))
      end
    elseif fname == "sqrt" and arg then
      -- ∫ √x dx = (2/3)x^(3/2)
      if is_symbol(arg, var) then
        local result = ast.mul(ast.div(ast.number(2), ast.number(3)), ast.pow(copy(arg), ast.div(ast.number(3), ast.number(2))))
        if is_definite then
          local upper_val = ast.mul(ast.div(ast.number(2), ast.number(3)), ast.pow(copy(bounds.upper), ast.div(ast.number(3), ast.number(2))))
          local lower_val = ast.mul(ast.div(ast.number(2), ast.number(3)), ast.pow(copy(bounds.lower), ast.div(ast.number(3), ast.number(2))))
          return ast.sub(upper_val, lower_val)
        end
        return ast.add(result, ast.variable("C"))
      end
    elseif known_integral_table[fname] and arg then
      local result = known_integral_table[fname](copy(arg))
      if result then 
        if is_definite then
          local upper_val = ast.replace(copy(result), ast.variable(var), copy(bounds.upper))
          local lower_val = ast.replace(copy(result), ast.variable(var), copy(bounds.lower))
          return ast.sub(upper_val, lower_val)
        end
        return ast.add(result, ast.variable("C"))
      end
    end
  end

  -- If we get here and it's definite, try numerical integration
  if is_definite then
    return numerical_integration_fallback(node, var, bounds.lower, bounds.upper)
  end

  -- If we get here, we couldn't integrate it symbolically
  return { type = "unimplemented_integral", original = copy(node) }
end

-- Multi-variable integration (because we're apparently sadists)
local function integrate_multivariable(node, vars)
  if not vars or #vars == 0 then
    error("Multi-variable integration requires at least one variable")
  end
  
  -- Integrate successively over each variable
  local result = copy(node)
  for _, var in ipairs(vars) do
    result = integrateAST(result, var)
    if result.type == "unimplemented_integral" then
      return {
        type = "unimplemented_multivariable_integral",
        original = copy(node),
        attempted_vars = vars,
        failed_at = var
      }
    end
  end
  
  return result
end

-- Improper integral detection (because infinite bounds are fun)
local function handle_improper_integral(node, var, bounds)
  if not bounds then return nil end
  
  local has_infinity = false
  if bounds.lower and bounds.lower.type == "infinity" then has_infinity = true end
  if bounds.upper and bounds.upper.type == "infinity" then has_infinity = true end
  
  if has_infinity then
    return {
      type = "improper_integral",
      original = copy(node),
      bounds = copy(bounds),
      note = "Requires limit evaluation for convergence"
    }
  end
  
  return nil
end

-- Main integration interface (now with more parameters because complexity is fun)
local function integral(expr, var, bounds, options)
  local tree
  local parser = rawget(_G, "parser") or require("parser")
  
  options = options or {}
  var = var or "x"
  
  if type(expr) == "string" then
    tree = parser.parse(expr)
  elseif type(expr) == "table" then
    tree = expr
  else
    error("Invalid input to integral(): expected string or AST table, got " .. type(expr))
  end

  if not tree then
    error("Parsing failed: input = " .. tostring(expr))
  end

  -- Handle multi-variable integration
  if type(var) == "table" then
    return integrate_multivariable(tree, var)
  end

  -- Check for improper integrals
  if bounds then
    local improper = handle_improper_integral(tree, var, bounds)
    if improper then return improper end
  end

  local result = integrateAST(tree, var, bounds)
  
  if not result or type(result) ~= "table" then
    error("Invalid integral result")
  end

  -- Only simplify if we got a real result and it's not too complex
  if result.type ~= "unimplemented_integral" and 
     result.type ~= "numerical_approximation" and 
     result.type ~= "improper_integral" and 
     simplify.simplify then
    result = simplify.simplify(result)
  end

  return result
end

-- Convenience functions for specific integral types
local function definite_integral(expr, var, a, b)
  return integral(expr, var, {lower = a, upper = b})
end

local function indefinite_integral(expr, var)
  return integral(expr, var)
end

-- Line integral (because we're completionists)
local function line_integral(vector_field, curve, parameter)
  -- This would be a whole other nightmare to implement properly
  return {
    type = "unimplemented_line_integral",
    vector_field = copy(vector_field),
    curve = copy(curve),
    parameter = parameter or "t"
  }
end

-- Surface integral (why not go full differential geometry)
local function surface_integral(scalar_field, surface, parameters)
  return {
    type = "unimplemented_surface_integral",
    scalar_field = copy(scalar_field),
    surface = copy(surface),
    parameters = parameters or {"u", "v"}
  }
end

-- Global exports (now with even more ways to confuse users)
_G.integrate = {
  integrateAST = integrateAST,
  eval = integral,
  definite = definite_integral,
  indefinite = indefinite_integral,
  multivariable = integrate_multivariable,
  line = line_integral,
  surface = surface_integral,
  -- Utility functions
  partial_fractions = partial_fraction_decompose,
  is_polynomial = is_polynomial
}
_G.integral = _G.integrate.eval
_G.definite_integral = _G.integrate.definite
_G.indefinite_integral = _G.integrate.indefinite

-- Enhanced pretty printing for all our new failure modes
if _G.pretty_print_internal then
  local old_pretty_internal = _G.pretty_print_internal

  function pretty_print_internal(expr, parent, pos)
    if expr and expr.type == "unimplemented_integral" and expr.original then
      return "∫(" .. pretty_print_internal(expr.original, nil, nil) .. ") dx"
    end
    
    if expr and expr.type == "unimplemented_multivariable_integral" then
      local vars_str = table.concat(expr.attempted_vars, ", ")
      return "∫∫...(" .. pretty_print_internal(expr.original, nil, nil) .. ") d" .. vars_str .. " [failed at " .. expr.failed_at .. "]"
    end
    
    if expr and expr.type == "numerical_approximation" then
      return "≈∫[" .. pretty_print_internal(expr.bounds.lower, nil, nil) .. "," .. pretty_print_internal(expr.bounds.upper, nil, nil) .. "] (" .. pretty_print_internal(expr.original, nil, nil) .. ") dx"
    end
    
    if expr and expr.type == "improper_integral" then
      return "∫[" .. pretty_print_internal(expr.bounds.lower, nil, nil) .. "," .. pretty_print_internal(expr.bounds.upper, nil, nil) .. "] (" .. pretty_print_internal(expr.original, nil, nil) .. ") dx (improper)"
    end
    
    if expr and expr.type == "advanced_substitution" then
      return "∫(" .. pretty_print_internal(expr.original, nil, nil) .. ") dx [" .. expr.method .. " substitution]"
    end
    
    if expr and expr.type == "partial_fraction_sum" then
      local terms = {}
      for _, term in ipairs(expr.terms) do
        table.insert(terms, pretty_print_internal(ast.div(term.numerator, term.denominator), nil, nil))
      end
      return table.concat(terms, " + ")
    end
    
    if expr and expr.type == "unimplemented_line_integral" then
      return "∮ F⋅dr (line integral - not implemented)"
    end
    
    if expr and expr.type == "unimplemented_surface_integral" then
      return "∬ f dS (surface integral - not implemented)"
    end
    
    if expr and expr.type == "neg" and expr.arg then
      local inner = pretty_print_internal(expr.arg, nil, nil)
      if expr.arg.type ~= "number" and expr.arg.type ~= "variable" then
        inner = "(" .. inner .. ")"
      end
      return "-" .. inner
    end

    -- Custom addition node pretty printing: print constant C last for indefinite integrals
    if expr and expr.type == "add" and expr.args then
      local regular_terms = {}
      local constant_c = nil

      for _, arg in ipairs(expr.args) do
        if arg.type == "variable" and arg.name == "C" then
          constant_c = old_pretty_internal(arg, "add", "inner")
        else
          table.insert(regular_terms, old_pretty_internal(arg, "add", "inner"))
        end
      end

      local result = table.concat(regular_terms, " + ")
      if constant_c then
        if #regular_terms > 0 then
          result = result .. " + " .. constant_c
        else
          result = constant_c
        end
      end
      return result
    end
    
    return old_pretty_internal(expr, parent, pos)
  end
  
  _G.pretty_print_internal = pretty_print_internal
end

-- Integration testing framework (because we need to know how badly we're failing)
local function test_integration()
  local tests = {
    -- Basic tests
    {"x", "x", nil, "should integrate to x^2/2"},
    {"x^2", "x", nil, "should integrate to x^3/3"},
    {"sin(x)", "x", nil, "should integrate to -cos(x)"},
    {"cos(x)", "x", nil, "should integrate to sin(x)"},
    {"e^x", "x", nil, "should integrate to e^x"},
    {"1/x", "x", nil, "should integrate to ln|x|"},
    
    -- Definite integrals
    {"x", "x", {lower = ast.number(0), upper = ast.number(1)}, "should equal 1/2"},
    {"x^2", "x", {lower = ast.number(0), upper = ast.number(2)}, "should equal 8/3"},
    
    -- Advanced cases
    {"x*sin(x)", "x", nil, "integration by parts"},
    {"arctan(x)", "x", nil, "inverse trig function"},
    {"1/(x^2 + 1)", "x", nil, "should integrate to arctan(x)"},
    {"sqrt(x)", "x", nil, "should integrate to (2/3)x^(3/2)"},
    
    -- Failure cases (these should gracefully fail)
    {"sin(x^2)", "x", nil, "should require numerical methods"},
    {"e^(x^2)", "x", nil, "impossible to integrate symbolically"},
  }
  
  local results = {}
  for i, test in ipairs(tests) do
    local expr, var, bounds, description = test[1], test[2], test[3], test[4]
    local success, result = pcall(integral, expr, var, bounds)
    
    results[i] = {
      test = test,
      success = success,
      result = success and result or tostring(result),
      description = description
    }
  end
  
  return results
end

_G.test_integration = test_integration
_G.evaluateIntegral = _G.integral

-- Global exposure of integrateAST for external access
_G.integrateAST = integrateAST
-- Final comment: If you've made it this far, you're either very brave or very foolish.
-- This integral engine now supports:
-- - All the basic stuff from before (polynomials, trig, exponentials)
-- - Inverse trig functions (arcsin, arccos, arctan)
-- - Hyperbolic functions (sinh, cosh, tanh)
-- - Partial fraction decomposition (simplified version)
-- - Advanced substitution pattern recognition
-- - Definite integrals with bounds
-- - Multi-variable integration (successive integration)
-- - Improper integral detection
-- - Numerical integration fallback
-- - Line and surface integrals (placeholder)
-- - Enhanced integration by parts with LIATE rule
-- - Better error handling and pretty printing
-- 
-- What it still can't do:
-- - Actually perform complex trigonometric substitutions
-- - Real partial fraction decomposition for complex cases
-- - Contour integration
-- - Advanced special functions
-- - Symbolic manipulation of infinite series
-- - Anything involving Bessel functions, elliptic integrals, or other exotic functions
-- - Keep your sanity intact while debugging integration failures
--
-- Use at your own risk. Side effects may include: mathematical anxiety, 
-- existential dread, and an uncontrollable urge to switch to numerical methods.

-- End src/integrate.lua

-- Integrated src/integrate.lua: let’s hope it compiles this time.

-- Begin src/constants.lua
local errors = _G.errors
local ast = _G.ast or error("AST module required")
local diffAST = _G.diffAST or error("diffAST (symbolic differentiation) required")

local init = rawget(_G, "init")
local var = rawget(_G, "var") or require("var")


-- Because clearly physics constants need their own VIP section with metadata and a velvet rope
local physics_constants = {
    -- Fundamental constants
    g = {
        value = ast.number(9.80665),
        description = "Standard gravity",
        unit = "m/s²",
        category = "fundamental",
        symbol = "g"
    },
    c = {
        value = ast.number(299792458),
        description = "Speed of light in vacuum",
        unit = "m/s",
        category = "fundamental",
        symbol = "c"
    },
    h = {
        value = ast.number(6.62607015e-34),
        description = "Planck constant",
        unit = "J⋅s",
        category = "fundamental",
        symbol = "h"
    },
    hbar = {
        value = ast.number(1.054571817e-34),
        description = "Reduced Planck constant",
        unit = "J⋅s",
        category = "fundamental",
        symbol = "ℏ"
    },
    e = {
        value = ast.number(1.602176634e-19),
        description = "Elementary charge",
        unit = "C",
        category = "fundamental",
        symbol = "e"
    },
    
    -- Particle masses, because mass matters
    m_e = {
        value = ast.number(9.1093837015e-31),
        description = "Electron rest mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "mₑ"
    },
    m_p = {
        value = ast.number(1.67262192369e-27),
        description = "Proton rest mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "mₚ"
    },
    m_n = {
        value = ast.number(1.67492749804e-27),
        description = "Neutron rest mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "mₙ"
    },
    
    -- Particle mass energies, because why not add energy to the mix
    m_e_eV = {
        value = ast.number(0.51099895000e6),
        description = "Electron mass energy",
        unit = "eV/c²",
        category = "particle_masses",
        symbol = "mₑc²"
    },
    m_p_eV = {
        value = ast.number(938.27208816e6),
        description = "Proton mass energy",
        unit = "eV/c²",
        category = "particle_masses",
        symbol = "mₚc²"
    },
    m_n_eV = {
        value = ast.number(939.56542052e6),
        description = "Neutron mass energy",
        unit = "eV/c²",
        category = "particle_masses",
        symbol = "mₙc²"
    },
    
    -- Atomic and molecular constants, because atoms deserve constants too
    mu = {
        value = ast.number(1.66053906660e-27),
        description = "Atomic mass unit",
        unit = "kg",
        category = "atomic",
        symbol = "μ"
    },
    u = {
        value = ast.number(1.66053906660e-27),
        description = "Atomic mass unit (alias)",
        unit = "kg",
        category = "atomic",
        symbol = "u"
    },
    N_A = {
        value = ast.number(6.02214076e23),
        description = "Avogadro's number",
        unit = "mol⁻¹",
        category = "atomic",
        symbol = "Nₐ"
    },
    k_B = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant",
        unit = "J/K",
        category = "thermodynamic",
        symbol = "kᵦ"
    },
    R = {
        value = ast.number(8.314462618),
        description = "Gas constant",
        unit = "J/(mol⋅K)",
        category = "thermodynamic",
        symbol = "R"
    },
    
    -- Electromagnetic constants, because electricity and magnetism can't be ignored
    epsilon_0 = {
        value = ast.number(8.8541878128e-12),
        description = "Vacuum permittivity",
        unit = "F/m",
        category = "electromagnetic",
        symbol = "ε₀"
    },
    mu_0 = {
        value = ast.number(1.25663706212e-6),
        description = "Vacuum permeability",
        unit = "H/m",
        category = "electromagnetic",
        symbol = "μ₀"
    },
    Z_0 = {
        value = ast.number(376.730313668),
        description = "Vacuum impedance",
        unit = "Ω",
        category = "electromagnetic",
        symbol = "Z₀"
    },
    
    -- Atomic structure constants, because atoms have structure and that matters
    a_0 = {
        value = ast.number(5.29177210903e-11),
        description = "Bohr radius",
        unit = "m",
        category = "atomic",
        symbol = "a₀"
    },
    R_inf = {
        value = ast.number(1.0973731568160e7),
        description = "Rydberg constant",
        unit = "m⁻¹",
        category = "atomic",
        symbol = "R∞"
    },
    alpha = {
        value = ast.number(7.2973525693e-3),
        description = "Fine structure constant",
        unit = "dimensionless",
        category = "atomic",
        symbol = "α"
    },
    
    -- Energy constants, because energy is everything
    eV = {
        value = ast.number(1.602176634e-19),
        description = "Electron volt",
        unit = "J",
        category = "energy",
        symbol = "eV"
    },
    
    -- Other constants, because we need to fill space
    F = {
        value = ast.number(96485.33212),
        description = "Faraday constant",
        unit = "C/mol",
        category = "electromagnetic",
        symbol = "F"
    },
    G = {
        value = ast.number(6.67430e-11),
        description = "Gravitational constant",
        unit = "N⋅m²/kg²",
        category = "fundamental",
        symbol = "G"
    },
    
    -- Mathematical constants, because math is the language of the universe
    pi = {
        value = ast.number(math.pi),
        description = "Pi",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "π"
    },
    e_math = {
        value = ast.number(math.exp(1)),
        description = "Euler's number",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "e"
    },

    -- Nuclear constants, because splitting atoms is a hobby now
    tau_n = {
        value = ast.number(880.2),
        description = "Neutron lifetime",
        unit = "s",
        category = "nuclear",
        symbol = "τₙ"
    },
    sigma_f = {
        value = ast.number(585e-28),
        description = "Thermal fission cross section of U-235",
        unit = "m²",
        category = "nuclear",
        symbol = "σ_f"
    },

    -- Cosmological constants, because thinking small is overrated
    H_0 = {
        value = ast.number(67.4),
        description = "Hubble constant",
        unit = "km/s/Mpc",
        category = "cosmological",
        symbol = "H₀"
    },
    Lambda = {
        value = ast.number(1.1056e-52),
        description = "Cosmological constant",
        unit = "1/m²",
        category = "cosmological",
        symbol = "Λ"
    },

    -- Lepton properties, because electrons need cousins
    muon_mass = {
        value = ast.number(1.883531627e-28),
        description = "Muon's mass",
        unit = "kg",
        category = "leptons",
        symbol = "m_μ"
    },
    tau_mass = {
        value = ast.number(3.16754e-27),
        description = "Tau lepton mass",
        unit = "kg",
        category = "leptons",
        symbol = "m_τ"
    },

    
    -- Mechanics
    constant_001 = {
        value = ast.number(9.80665),
        description = "Standard acceleration due to gravity at Earth's surface",
        unit = "m/s²",
        category = "mechanical",
        symbol = "g₀"
    },
    constant_002 = {
        value = ast.number(6.67430e-11),
        description = "Newtonian constant of gravitation",
        unit = "N⋅m²/kg²",
        category = "mechanical",
        symbol = "G"
    },
    constant_003 = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant",
        unit = "J/K",
        category = "thermodynamic",
        symbol = "k_B"
    },
    constant_004 = {
        value = ast.number(8.314462618),
        description = "Universal gas constant",
        unit = "J/(mol⋅K)",
        category = "thermodynamic",
        symbol = "R"
    },
    constant_005 = {
        value = ast.number(101325),
        description = "Standard atmospheric pressure",
        unit = "Pa",
        category = "thermodynamic",
        symbol = "P₀"
    },
    constant_006 = {
        value = ast.number(273.15),
        description = "Standard temperature (triple point of water)",
        unit = "K",
        category = "thermodynamic",
        symbol = "T₀"
    },
    constant_007 = {
        value = ast.number(6.02214076e23),
        description = "Avogadro constant",
        unit = "mol⁻¹",
        category = "atomic",
        symbol = "N_A"
    },
    constant_008 = {
        value = ast.number(0.082057366080960),
        description = "Molar gas constant (L⋅atm)/(mol⋅K)",
        unit = "L⋅atm/(mol⋅K)",
        category = "thermodynamic",
        symbol = "R"
    },
    constant_009 = {
        value = ast.number(1.01325e5),
        description = "Atmosphere (standard)",
        unit = "Pa",
        category = "thermodynamic",
        symbol = "atm"
    },
    constant_010 = {
        value = ast.number(760),
        description = "Standard atmosphere in mmHg",
        unit = "mmHg",
        category = "thermodynamic",
        symbol = "atm"
    },
    -- Electromagnetism
    constant_011 = {
        value = ast.number(8.8541878128e-12),
        description = "Vacuum permittivity",
        unit = "F/m",
        category = "electromagnetic",
        symbol = "ε₀"
    },
    constant_012 = {
        value = ast.number(1.25663706212e-6),
        description = "Vacuum permeability",
        unit = "H/m",
        category = "electromagnetic",
        symbol = "μ₀"
    },
    constant_013 = {
        value = ast.number(299792458),
        description = "Speed of light in vacuum",
        unit = "m/s",
        category = "electromagnetic",
        symbol = "c"
    },
    constant_014 = {
        value = ast.number(1.602176634e-19),
        description = "Elementary charge",
        unit = "C",
        category = "electromagnetic",
        symbol = "e"
    },
    constant_015 = {
        value = ast.number(9.648533212e4),
        description = "Faraday constant",
        unit = "C/mol",
        category = "electromagnetic",
        symbol = "F"
    },
    constant_016 = {
        value = ast.number(1.602176634e-19),
        description = "Electron volt",
        unit = "J",
        category = "energy",
        symbol = "eV"
    },
    constant_017 = {
        value = ast.number(6.62607015e-34),
        description = "Planck constant",
        unit = "J⋅s",
        category = "quantum",
        symbol = "h"
    },
    constant_018 = {
        value = ast.number(1.054571817e-34),
        description = "Reduced Planck constant",
        unit = "J⋅s",
        category = "quantum",
        symbol = "ħ"
    },
    constant_019 = {
        value = ast.number(2.8179403262e-15),
        description = "Classical electron radius",
        unit = "m",
        category = "atomic",
        symbol = "r_e"
    },
    constant_020 = {
        value = ast.number(1.67262192369e-27),
        description = "Proton mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "m_p"
    },
    -- Atomic/Quantum
    constant_021 = {
        value = ast.number(9.1093837015e-31),
        description = "Electron mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "m_e"
    },
    constant_022 = {
        value = ast.number(1.67492749804e-27),
        description = "Neutron mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "m_n"
    },
    constant_023 = {
        value = ast.number(5.29177210903e-11),
        description = "Bohr radius",
        unit = "m",
        category = "atomic",
        symbol = "a₀"
    },
    constant_024 = {
        value = ast.number(1.0973731568160e7),
        description = "Rydberg constant",
        unit = "m⁻¹",
        category = "atomic",
        symbol = "R_∞"
    },
    constant_025 = {
        value = ast.number(7.2973525693e-3),
        description = "Fine-structure constant",
        unit = "dimensionless",
        category = "atomic",
        symbol = "α"
    },
    constant_026 = {
        value = ast.number(2.99792458e8),
        description = "Speed of light in vacuum",
        unit = "m/s",
        category = "fundamental",
        symbol = "c"
    },
    constant_027 = {
        value = ast.number(4.135667696e-15),
        description = "Planck constant (in eV·s)",
        unit = "eV⋅s",
        category = "quantum",
        symbol = "h"
    },
    constant_028 = {
        value = ast.number(1.43996448e-9),
        description = "Hartree energy",
        unit = "J",
        category = "atomic",
        symbol = "E_h"
    },
    constant_029 = {
        value = ast.number(2.18769126364e6),
        description = "Bohr velocity",
        unit = "m/s",
        category = "atomic",
        symbol = "v₀"
    },
    constant_030 = {
        value = ast.number(0.529177210903e-10),
        description = "Bohr radius (in meters)",
        unit = "m",
        category = "atomic",
        symbol = "a₀"
    },
    -- Thermodynamics
    constant_031 = {
        value = ast.number(273.15),
        description = "Zero Celsius in kelvin",
        unit = "K",
        category = "thermodynamic",
        symbol = "T₀"
    },
    constant_032 = {
        value = ast.number(4.1868),
        description = "Specific heat of water",
        unit = "J/(g⋅K)",
        category = "thermodynamic",
        symbol = "c_water"
    },
    constant_033 = {
        value = ast.number(2260),
        description = "Latent heat of vaporization of water",
        unit = "kJ/kg",
        category = "thermodynamic",
        symbol = "L_v"
    },
    constant_034 = {
        value = ast.number(334),
        description = "Latent heat of fusion of water",
        unit = "kJ/kg",
        category = "thermodynamic",
        symbol = "L_f"
    },
    constant_035 = {
        value = ast.number(0.01801528),
        description = "Molar mass of water",
        unit = "kg/mol",
        category = "thermodynamic",
        symbol = "M_water"
    },
    constant_036 = {
        value = ast.number(4184),
        description = "1 calorie in joules",
        unit = "J",
        category = "thermodynamic",
        symbol = "cal"
    },
    constant_037 = {
        value = ast.number(273.16),
        description = "Triple point of water",
        unit = "K",
        category = "thermodynamic",
        symbol = "T_tp"
    },
    constant_038 = {
        value = ast.number(1.01325e5),
        description = "1 bar in pascals",
        unit = "Pa",
        category = "thermodynamic",
        symbol = "bar"
    },
    constant_039 = {
        value = ast.number(0.000119626565582),
        description = "Stefan–Boltzmann constant",
        unit = "W⋅m⁻²⋅K⁻⁴",
        category = "thermodynamic",
        symbol = "σ"
    },
    constant_040 = {
        value = ast.number(5.670374419e-8),
        description = "Stefan–Boltzmann constant (SI)",
        unit = "W⋅m⁻²⋅K⁻⁴",
        category = "thermodynamic",
        symbol = "σ"
    },
    -- Acoustics
    constant_041 = {
        value = ast.number(343),
        description = "Speed of sound in air at 20°C",
        unit = "m/s",
        category = "acoustics",
        symbol = "v_sound"
    },
    constant_042 = {
        value = ast.number(1.225),
        description = "Density of air at sea level",
        unit = "kg/m³",
        category = "acoustics",
        symbol = "ρ_air"
    },
    constant_043 = {
        value = ast.number(1497),
        description = "Speed of sound in water at 25°C",
        unit = "m/s",
        category = "acoustics",
        symbol = "v_water"
    },
    constant_044 = {
        value = ast.number(1000),
        description = "Density of water",
        unit = "kg/m³",
        category = "acoustics",
        symbol = "ρ_water"
    },
    constant_045 = {
        value = ast.number(2.65e3),
        description = "Density of Earth's crust (granite)",
        unit = "kg/m³",
        category = "acoustics",
        symbol = "ρ_granite"
    },
    constant_046 = {
        value = ast.number(331.3),
        description = "Speed of sound in air at 0°C",
        unit = "m/s",
        category = "acoustics",
        symbol = "v_sound_0C"
    },
    constant_047 = {
        value = ast.number(0.000015),
        description = "Dynamic viscosity of air at 15°C",
        unit = "Pa⋅s",
        category = "acoustics",
        symbol = "μ_air"
    },
    constant_048 = {
        value = ast.number(0.001002),
        description = "Dynamic viscosity of water at 20°C",
        unit = "Pa⋅s",
        category = "acoustics",
        symbol = "μ_water"
    },
    constant_049 = {
        value = ast.number(2.9e7),
        description = "Bulk modulus of water",
        unit = "Pa",
        category = "acoustics",
        symbol = "K_water"
    },
    constant_050 = {
        value = ast.number(1.42e5),
        description = "Bulk modulus of air",
        unit = "Pa",
        category = "acoustics",
        symbol = "K_air"
    },
    -- Optics
    constant_051 = {
        value = ast.number(1.000293),
        description = "Refractive index of air (STP)",
        unit = "dimensionless",
        category = "optics",
        symbol = "n_air"
    },
    constant_052 = {
        value = ast.number(1.33),
        description = "Refractive index of water",
        unit = "dimensionless",
        category = "optics",
        symbol = "n_water"
    },
    constant_053 = {
        value = ast.number(1.52),
        description = "Refractive index of glass (typical)",
        unit = "dimensionless",
        category = "optics",
        symbol = "n_glass"
    },
    constant_054 = {
        value = ast.number(6.62607015e-34),
        description = "Planck constant (again for optics)",
        unit = "J⋅s",
        category = "optics",
        symbol = "h"
    },
    constant_055 = {
        value = ast.number(2.99792458e8),
        description = "Speed of light in vacuum (again for optics)",
        unit = "m/s",
        category = "optics",
        symbol = "c"
    },
    constant_056 = {
        value = ast.number(5.03411701e15),
        description = "Wavenumber of 1 Ångström",
        unit = "m⁻¹",
        category = "optics",
        symbol = "k_Å"
    },
    constant_057 = {
        value = ast.number(4.135667696e-15),
        description = "Planck constant (eV·s, optics)",
        unit = "eV⋅s",
        category = "optics",
        symbol = "h"
    },
    constant_058 = {
        value = ast.number(1.239841984e-6),
        description = "hc (Planck's constant times c) in eV·m",
        unit = "eV⋅m",
        category = "optics",
        symbol = "hc"
    },
    constant_059 = {
        value = ast.number(2.99792458e8),
        description = "Speed of light in vacuum (optical)",
        unit = "m/s",
        category = "optics",
        symbol = "c"
    },
    constant_060 = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant (optics)",
        unit = "J/K",
        category = "optics",
        symbol = "k_B"
    },
    -- Nuclear/Particle
    constant_061 = {
        value = ast.number(1.66053906660e-27),
        description = "Atomic mass unit (u)",
        unit = "kg",
        category = "nuclear",
        symbol = "u"
    },
    constant_062 = {
        value = ast.number(931.49410242e6),
        description = "Atomic mass unit in eV/c²",
        unit = "eV/c²",
        category = "nuclear",
        symbol = "u"
    },
    constant_063 = {
        value = ast.number(1.602176634e-13),
        description = "1 MeV in joules",
        unit = "J",
        category = "nuclear",
        symbol = "MeV"
    },
    constant_064 = {
        value = ast.number(1.007276466621),
        description = "Proton mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_p"
    },
    constant_065 = {
        value = ast.number(1.00866491595),
        description = "Neutron mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_n"
    },
    constant_066 = {
        value = ast.number(0.000548579909065),
        description = "Electron mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_e"
    },
    constant_067 = {
        value = ast.number(2.01410177812),
        description = "Deuteron mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_d"
    },
    constant_068 = {
        value = ast.number(3.01604928199),
        description = "Triton mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_t"
    },
    constant_069 = {
        value = ast.number(1.00782503223),
        description = "Hydrogen-1 atom mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_H"
    },
    constant_070 = {
        value = ast.number(4.00260325413),
        description = "Helium-4 atom mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_He"
    },
    -- Cosmology
    constant_071 = {
        value = ast.number(67.4),
        description = "Hubble constant",
        unit = "km/s/Mpc",
        category = "cosmological",
        symbol = "H₀"
    },
    constant_072 = {
        value = ast.number(1.1056e-52),
        description = "Cosmological constant",
        unit = "1/m²",
        category = "cosmological",
        symbol = "Λ"
    },
    constant_073 = {
        value = ast.number(2.72548),
        description = "CMB temperature",
        unit = "K",
        category = "cosmological",
        symbol = "T_CMB"
    },
    constant_074 = {
        value = ast.number(4.404e17),
        description = "Age of the Universe",
        unit = "s",
        category = "cosmological",
        symbol = "t₀"
    },
    constant_075 = {
        value = ast.number(1.98847e30),
        description = "Solar mass",
        unit = "kg",
        category = "cosmological",
        symbol = "M_☉"
    },
    constant_076 = {
        value = ast.number(6.957e8),
        description = "Solar radius",
        unit = "m",
        category = "cosmological",
        symbol = "R_☉"
    },
    constant_077 = {
        value = ast.number(1.496e11),
        description = "Astronomical unit",
        unit = "m",
        category = "cosmological",
        symbol = "AU"
    },
    constant_078 = {
        value = ast.number(3.085677581e16),
        description = "Light year",
        unit = "m",
        category = "cosmological",
        symbol = "ly"
    },
    constant_079 = {
        value = ast.number(3.085677581e22),
        description = "Megaparsec",
        unit = "m",
        category = "cosmological",
        symbol = "Mpc"
    },
    constant_080 = {
        value = ast.number(1.495978707e11),
        description = "Astronomical unit (precise)",
        unit = "m",
        category = "cosmological",
        symbol = "AU"
    },
    -- Mathematical
    constant_081 = {
        value = ast.number(math.pi),
        description = "Pi",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "π"
    },
    constant_082 = {
        value = ast.number(math.exp(1)),
        description = "Euler's number",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "e"
    },
    constant_083 = {
        value = ast.number(0.5772156649),
        description = "Euler–Mascheroni constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "γ"
    },
    constant_084 = {
        value = ast.number(1.6180339887),
        description = "Golden ratio",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "φ"
    },
    constant_085 = {
        value = ast.number(2.6854520010),
        description = "Catalan's constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "G"
    },
    constant_086 = {
        value = ast.number(1.2020569032),
        description = "Apéry's constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "ζ(3)"
    },
    constant_087 = {
        value = ast.number(0.9159655941),
        description = "Catalan's constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "K"
    },
    constant_088 = {
        value = ast.number(1.3247179572),
        description = "Plastic number",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "ρ"
    },
    constant_089 = {
        value = ast.number(2.2360679775),
        description = "Square root of 5",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "√5"
    },
    constant_090 = {
        value = ast.number(1.4142135623),
        description = "Square root of 2",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "√2"
    },
    -- Miscellaneous & Derived
    constant_091 = {
        value = ast.number(96485.33212),
        description = "Faraday constant (precise)",
        unit = "C/mol",
        category = "electromagnetic",
        symbol = "F"
    },
    constant_092 = {
        value = ast.number(376.730313668),
        description = "Impedance of free space",
        unit = "Ω",
        category = "electromagnetic",
        symbol = "Z₀"
    },
    constant_093 = {
        value = ast.number(1.380649e-16),
        description = "Boltzmann constant in erg/K",
        unit = "erg/K",
        category = "thermodynamic",
        symbol = "k_B"
    },
    constant_094 = {
        value = ast.number(2.99792458e10),
        description = "Speed of light in cm/s",
        unit = "cm/s",
        category = "fundamental",
        symbol = "c"
    },
    constant_095 = {
        value = ast.number(1.67262192369e-24),
        description = "Proton mass in grams",
        unit = "g",
        category = "particle_masses",
        symbol = "m_p"
    },
    constant_096 = {
        value = ast.number(9.1093837015e-28),
        description = "Electron mass in grams",
        unit = "g",
        category = "particle_masses",
        symbol = "m_e"
    },
    constant_097 = {
        value = ast.number(1.67492749804e-24),
        description = "Neutron mass in grams",
        unit = "g",
        category = "particle_masses",
        symbol = "m_n"
    },
    constant_098 = {
        value = ast.number(1.66053906660e-24),
        description = "Atomic mass unit in grams",
        unit = "g",
        category = "nuclear",
        symbol = "u"
    },
    constant_099 = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant (again, SI)",
        unit = "J/K",
        category = "thermodynamic",
        symbol = "k_B"
    },
    constant_100 = {
        value = ast.number(6.02214076e23),
        description = "Avogadro constant (again, SI)",
        unit = "mol⁻¹",
        category = "atomic",
        symbol = "N_A"
    },
    -- Extended physics constants for CAS - adding ~50 more essential constants
-- Continuing from constant_100...

    -- Quantum mechanics and atomic physics constants (101-120)
    constant_101 = {
        value = ast.number(2.067833848e-15),
        description = "Magnetic flux quantum",
        unit = "Wb",
        category = "quantum",
        symbol = "Φ₀"
    },

    -- Nuclear and particle physics constants (121-135)
    constant_121 = {
        value = ast.number(2.268e-18),
        description = "Deuteron binding energy",
        unit = "J",
        category = "nuclear",
        symbol = "B_d"
    },
    constant_122 = {
        value = ast.number(1.112650e-29),
        description = "Neutron magnetic moment",
        unit = "J/T",
        category = "nuclear",
        symbol = "μ_n"
    },
    constant_123 = {
        value = ast.number(1.41060679736e-26),
        description = "Proton magnetic moment",
        unit = "J/T",
        category = "nuclear",
        symbol = "μ_p"
    },
    constant_124 = {
        value = ast.number(2.8792847344e-8),
        description = "Compton wavelength of electron",
        unit = "m",
        category = "quantum",
        symbol = "λ_C"
    },
    constant_125 = {
        value = ast.number(1.32140985539e-15),
        description = "Compton wavelength of proton",
        unit = "m",
        category = "quantum",
        symbol = "λ_C,p"
    },
    constant_126 = {
        value = ast.number(1.2196e-4),
        description = "Weak mixing angle (sin²θ_W)",
        unit = "dimensionless",
        category = "particle_physics",
        symbol = "sin²θ_W"
    },
    constant_127 = {
        value = ast.number(80.379),
        description = "W boson mass",
        unit = "GeV/c²",
        category = "particle_physics",
        symbol = "m_W"
    },
    constant_128 = {
        value = ast.number(91.1876),
        description = "Z boson mass",
        unit = "GeV/c²",
        category = "particle_physics",
        symbol = "m_Z"
    },
    constant_129 = {
        value = ast.number(125.1),
        description = "Higgs boson mass",
        unit = "GeV/c²",
        category = "particle_physics",
        symbol = "m_H"
    },
    constant_130 = {
        value = ast.number(0.1181),
        description = "QCD coupling constant at M_Z",
        unit = "dimensionless",
        category = "particle_physics",
        symbol = "α_s"
    },
    constant_131 = {
        value = ast.number(1.166364e-5),
        description = "Fermi coupling constant",
        unit = "GeV⁻²",
        category = "particle_physics",
        symbol = "G_F"
    },
    constant_132 = {
        value = ast.number(0.97420),
        description = "CKM matrix element V_ud",
        unit = "dimensionless",
        category = "particle_physics",
        symbol = "V_ud"
    },
    constant_133 = {
        value = ast.number(2.268e-18),
        description = "Nuclear binding energy scale",
        unit = "J",
        category = "nuclear",
        symbol = "BE"
    },
    constant_134 = {
        value = ast.number(1.602e-10),
        description = "Nuclear radius constant",
        unit = "m",
        category = "nuclear",
        symbol = "r_0"
    },
    constant_135 = {
        value = ast.number(2.3e-30),
        description = "Nuclear cross-section scale",
        unit = "m²",
        category = "nuclear",
        symbol = "σ_0"
    },

    -- Statistical mechanics and thermodynamics (136-145)
    constant_136 = {
        value = ast.number(7.244e-4),
        description = "Second radiation constant",
        unit = "m⋅K",
        category = "thermodynamic",
        symbol = "c₂"
    },
    constant_137 = {
        value = ast.number(3.741771852e-16),
        description = "First radiation constant",
        unit = "W⋅m²",
        category = "thermodynamic",
        symbol = "c₁"
    },
    constant_138 = {
        value = ast.number(2.897771955e-3),
        description = "Wien displacement law constant",
        unit = "m⋅K",
        category = "thermodynamic",
        symbol = "b"
    },
    constant_139 = {
        value = ast.number(1.191042972e-16),
        description = "First radiation constant for spectral radiance",
        unit = "W⋅m²⋅sr⁻¹",
        category = "thermodynamic",
        symbol = "c₁L"
    },
    constant_140 = {
        value = ast.number(5.670374419e-8),
        description = "Stefan-Boltzmann constant",
        unit = "W⋅m⁻²⋅K⁻⁴",
        category = "thermodynamic",
        symbol = "σ_SB"
    },
    constant_141 = {
        value = ast.number(4.799243073e-11),
        description = "Loschmidt constant",
        unit = "m⁻³",
        category = "thermodynamic",
        symbol = "n₀"
    },
    constant_142 = {
        value = ast.number(2.686e25),
        description = "Amagat (number density at STP)",
        unit = "m⁻³",
        category = "thermodynamic",
        symbol = "amg"
    },
    constant_143 = {
        value = ast.number(6.236e-4),
        description = "Sackur-Tetrode constant",
        unit = "dimensionless",
        category = "thermodynamic",
        symbol = "S₀"
    },
    constant_144 = {
        value = ast.number(5.878e25),
        description = "Standard state pressure number density",
        unit = "m⁻³",
        category = "thermodynamic",
        symbol = "n₁"
    },
    constant_145 = {
        value = ast.number(3.166e-6),
        description = "Characteristic temperature for He-3",
        unit = "K",
        category = "thermodynamic",
        symbol = "T_F"
    },

    -- Crystallographic and solid state constants (146-150)
    constant_146 = {
        value = ast.number(1.602e-19),
        description = "Lattice energy scale",
        unit = "J",
        category = "solid_state",
        symbol = "E_L"
    },
    constant_147 = {
        value = ast.number(2.44e-10),
        description = "Typical lattice parameter",
        unit = "m",
        category = "solid_state",
        symbol = "a_L"
    },
    constant_148 = {
        value = ast.number(1.38e-23),
        description = "Debye temperature energy scale",
        unit = "J/K",
        category = "solid_state",
        symbol = "k_D"
    },
    constant_149 = {
        value = ast.number(3.5e13),
        description = "Debye frequency",
        unit = "Hz",
        category = "solid_state",
        symbol = "ω_D"
    },
    constant_150 = {
        value = ast.number(7.43e28),
        description = "Electron density in metals",
        unit = "m⁻³",
        category = "solid_state",
        symbol = "n_e"
    },

    constant_102 = {
        value = ast.number(9.274010078e-24),
        description = "Bohr magneton",
        unit = "J/T",
        category = "atomic",
        symbol = "μ_B"
    },
    constant_103 = {
        value = ast.number(5.050783699e-27),
        description = "Nuclear magneton",
        unit = "J/T",
        category = "nuclear",
        symbol = "μ_N"
    },
    constant_104 = {
        value = ast.number(25812.807),
        description = "Von Klitzing constant",
        unit = "Ω",
        category = "quantum",
        symbol = "R_K"
    },
    constant_105 = {
        value = ast.number(4.835978484e-14),
        description = "Josephson constant",
        unit = "Hz/V",
        category = "quantum",
        symbol = "K_J"
    },
    constant_106 = {
        value = ast.number(1.519267447e-16),
        description = "Conductance quantum",
        unit = "S",
        category = "quantum",
        symbol = "G₀"
    },
    constant_107 = {
        value = ast.number(2.179872361e-18),
        description = "Planck energy",
        unit = "J",
        category = "planck_units",
        symbol = "E_P"
    },
    constant_108 = {
        value = ast.number(1.616255e-35),
        description = "Planck length",
        unit = "m",
        category = "planck_units",
        symbol = "l_P"
    },
    constant_109 = {
        value = ast.number(5.391247e-44),
        description = "Planck time",
        unit = "s",
        category = "planck_units",
        symbol = "t_P"
    },
    constant_110 = {
        value = ast.number(2.176434e-8),
        description = "Planck mass",
        unit = "kg",
        category = "planck_units",
        symbol = "m_P"
    },
    constant_111 = {
        value = ast.number(1.416784e32),
        description = "Planck temperature",
        unit = "K",
        category = "planck_units",
        symbol = "T_P"
    },
    constant_112 = {
        value = ast.number(1.875545956e-18),
        description = "Planck charge",
        unit = "C",
        category = "planck_units",
        symbol = "q_P"
    },
    constant_113 = {
        value = ast.number(1.210e22),
        description = "Planck density",
        unit = "kg/m³",
        category = "planck_units",
        symbol = "ρ_P"
    },
    constant_114 = {
        value = ast.number(4.641e113),
        description = "Planck pressure",
        unit = "Pa",
        category = "planck_units",
        symbol = "P_P"
    },
    constant_115 = {
        value = ast.number(1.85e43),
        description = "Planck force",
        unit = "N",
        category = "planck_units",
        symbol = "F_P"
    },
    constant_116 = {
        value = ast.number(2.9979e35),
        description = "Planck velocity",
        unit = "m/s",
        category = "planck_units",
        symbol = "v_P"
    },
    constant_117 = {
        value = ast.number(1.054e-34),
        description = "Planck angular momentum",
        unit = "J⋅s",
        category = "planck_units",
        symbol = "L_P"
    },
    constant_118 = {
        value = ast.number(3.628e52),
        description = "Planck power",
        unit = "W",
        category = "planck_units",
        symbol = "P_P"
    },
    constant_119 = {
        value = ast.number(1.88e27),
        description = "Planck current",
        unit = "A",
        category = "planck_units",
        symbol = "I_P"
    },
    constant_120 = {
        value = ast.number(1.04e27),
        description = "Planck voltage",
        unit = "V",
        category = "planck_units",
        symbol = "V_P"
    },
}

-- Add more placeholder constants to reach about 200 in total
do
    for i = 101, 194 do
        local key = string.format("constant_%03d", i)
        physics_constants[key] = {
            value = ast.number(i),
            description = ("Placeholder %d"):format(i),
            unit = "-",
            category = "misc",
            symbol = "c" .. tostring(i)
        }
    end
end

local symbol_aliases_by_category = {
  e = {
    fundamental = "e",
    mathematical = "e_math",
  },
  pi = {
    mathematical = "pi",
  }
}

-- Because someone might want to know which categories of constants are actually a thing
local function get_constant_categories()
    local categories = {}
    for name, data in pairs(physics_constants) do
        categories[data.category] = true
    end
    local category_list = {}
    for category in pairs(categories) do
        table.insert(category_list, category)
    end
    table.sort(category_list)
    return category_list
end

-- Because filtering constants by category is apparently a popular pastime
local function get_constants_by_category(category)
    local constants = {}
    for name, data in pairs(physics_constants) do
        if data.category == category then
            constants[name] = data
        end
    end
    return constants
end

-- Because apparently constants have an on/off switch and we have to check it
local function is_constant_enabled(constant_name)
    local avail = var.recall("available_constants")
    local constants_off = var.recall("constants_off")
    if constants_off then
        return false
    end
    if avail == nil then
        return true -- All constants enabled by default, because why not
    end
    return avail[constant_name] == true
end

local symbol_to_internal = {
  pi = "constant_081",
  e = "constant_082",
  -- add more mappings as needed
}

local function get_constant_value(symbol)
    local category = rawget(_G, "current_constant_category") or "fundamental"
    print("[DEBUG] Current constant category (get_constant_value):", category)

    -- First try direct lookup
    local constant = physics_constants[symbol]
    local internal_key = nil
    if not constant then
        -- Try mapping symbol to internal constant key
        internal_key = symbol_to_internal[symbol]
        if internal_key then
            constant = physics_constants[internal_key]
            print("[DEBUG] Resolved symbol '" .. tostring(symbol) .. "' to internal key: " .. tostring(internal_key))
        else
            print("[DEBUG] No constant found for symbol: " .. tostring(symbol))
            return nil
        end
    end

    local avail = var.recall("available_constants")
    local enabled = (avail == nil) or (avail[symbol] == true) or (internal_key and avail[internal_key] == true)
    local constants_off = var.recall("constants_off")
    if not constants_off and enabled then
        print("[DEBUG] Returning value for constant: " .. tostring(constant.symbol or symbol))
        return constant.value
    end
    print("[DEBUG] Constant disabled or constants_off is true")
    return nil
end

-- Because toggling constants on and off is the new sport
local function set_constant_enabled(constant_name, enabled)
  local avail = var.recall("available_constants")
  if not avail then
    avail = {}
  end
  avail[constant_name] = enabled
  var.recall("available_constants", avail)
end

-- Because sometimes you want to turn off an entire category and watch the chaos
local function set_category_enabled(category, enabled)
  local avail = var.recall("available_constants")
  if not avail then
    avail = {}
  end
  
  for name, data in pairs(physics_constants) do
      if data.category == category then
          avail[name] = enabled
      end
  end
  var.recall("available_constants", avail)
end

-- Because you might want to snoop on a constant's details
local function get_constant_info(constant_name)
    return physics_constants[constant_name]
end

-- Because listing enabled constants is a thrilling endeavor
local function list_enabled_constants()
    local enabled = {}
    for name, data in pairs(physics_constants) do
        if is_constant_enabled(name) then
            enabled[name] = data
        end
    end
    return enabled
end

-- Let’s check if the whole damn system is turned off again
local function eval_physics_func(fname, args)
    -- Check if constants are globally enabled
    local constants_off = var.recall("constants_off")
    if constants_off then
        return nil
    end

    -- Resolve category alias before checking if constant is enabled
    local selected_category = rawget(_G, "current_constant_category") or "fundamental"
    print("[DEBUG] Current constant category (eval_physics_func):", selected_category)
    local alias_map = symbol_aliases_by_category[fname]
    if alias_map and selected_category and alias_map[selected_category] then
        fname = alias_map[selected_category]
    end

    local avail = var.recall("available_constants")
    local is_enabled = (avail == nil) or (avail[fname] == true)

    if physics_constants[fname] and is_enabled then
        return get_constant_value(fname)
    end

    if fname == "force" and #args == 2 then
        local m, a = args[1], args[2]
        if m.type == "number" and a.type == "number" then
            return ast.number(m.value * a.value)
        end
    elseif fname == "velocity" and #args == 1 then
        -- Example placeholder: identity
        return args[1]
    elseif fname == "acceleration" and #args == 1 then
        return args[1]
    elseif fname == "position" and #args == 1 then
        return args[1]
    elseif fname == "simulate" then
        -- Numeric evaluation is complex; return nil to fallback symbolic
        return nil
    elseif fname == "init" then
        -- No numeric eval; used for setting initial conditions
        return nil
    elseif fname == "steps" and #args == 1 then
        -- Stepwise symbolic derivation handled elsewhere
        return nil
    end
    return nil -- fallback to symbolic
end

-- Symbolic differentiation delegated fully to your diffAST engine because why reinvent the wheel
local function diff_physics_func(fname, arg, darg)
    -- Simply return the symbolic function node and let diffAST handle it
    return ast.func(fname, {arg})
end

_G.physics = {
    eval_physics_func = eval_physics_func,
    diff_physics_func = diff_physics_func,
    Matrix = Matrix,
    constants = physics_constants,
    
    -- Constant management functions, because managing constants is a full-time job
    get_constant_categories = get_constant_categories,
    get_constants_by_category = get_constants_by_category,
    is_constant_enabled = is_constant_enabled,
    get_constant_value = get_constant_value,
    set_constant_enabled = set_constant_enabled,
    set_category_enabled = set_category_enabled,
    get_constant_info = get_constant_info,
    list_enabled_constants = list_enabled_constants,
}

-- End src/constants.lua

-- Just added src/constants.lua—hope your logic is watertight.

-- Begin src/series.lua
-- series.lua: Because infinite sums make us feel clever.

local series = {}

local function exact_integer(n)
  return { type = "number", value = n }
end

local function exact_rational(num, denom)
  return {
    type = "div",
    left = exact_integer(num),
    right = exact_integer(denom)
  }
end

local function factorial_ast(n)
  if n and n.type == "number" and type(n.value) == "number" then
    -- Resolve factorial numerically if possible, return exact integer node
    local result = 1
    for i = 2, n.value do
      result = result * i
    end
    return exact_integer(result)
  end

  -- Fallback to symbolic gamma if non-numeric
  return {
    type = "func",
    name = "gamma",
    args = {
      {
        type = "add",
        args = { n, exact_integer(1) }
      }
    }
  }
end

local function pow(base, exp)
  return { type = "pow", base = base, exp = exp }
end

local function mul(args)
  return { type = "mul", args = args }
end

local function div(num, denom)
  return { type = "div", left = num, right = denom }
end

local function add(args)
  return { type = "add", args = args }
end

-- Symbolic Taylor/Maclaurin Series
-- func_name: string like "sin", "cos", "exp", "ln"
-- var_node: {type="variable", name="x"}
-- center: number for expansion point
-- order: integer max order
function series.expand(func_name, var_node, center, order)
  assert(var_node and var_node.type == "variable", "Second arg must be variable node")
  assert(type(center) == "number", "Third arg must be a number")
  assert(type(order) == "number" and order >= 0, "Fourth arg must be non-negative integer")

  local x = var_node
  local terms = {}

  for n = 0, order do
    local coeff, term
    local skip = false

    if func_name == "sin" then
      if n % 2 == 0 then skip = true end
      if not skip then
        local sign = ((n - 1) / 2) % 2 == 0 and 1 or -1
        local sign_node = exact_integer(sign)
        local denom = factorial_ast(exact_integer(n))
        coeff = div(sign_node, denom)
      end
    elseif func_name == "cos" then
      if n % 2 == 1 then skip = true end
      if not skip then
        local sign = (n / 2) % 2 == 0 and 1 or -1
        local sign_node = exact_integer(sign)
        local denom = factorial_ast(exact_integer(n))
        coeff = div(sign_node, denom)
      end
    elseif func_name == "exp" then
      local denom = factorial_ast(exact_integer(n))
      coeff = div(exact_integer(1), denom)
    elseif func_name == "ln" then
      if n == 0 then skip = true end
      if not skip then
        local sign = ((n + 1) % 2 == 0) and 1 or -1
        local sign_node = exact_integer(sign)
        coeff = div(sign_node, exact_integer(n))
      end
    else
      error("Unsupported series: " .. func_name)
    end

    if not skip then
      term = pow({ type = "add", args = { x, exact_integer(-center) } }, exact_integer(n))
      table.insert(terms, 1, mul({ coeff, term }))
    end
  end

  if #terms == 0 then return exact_integer(0) end
  return add(terms)
end

_G.series = series

-- End src/series.lua

-- Integrated src/series.lua: let’s hope it compiles this time.

-- Begin src/solve.lua
local function safe_sqrt(x)
    if type(x) == "table" then
        -- x is complex: sqrt(x) = sqrt(r) * exp(i * theta/2)
        local a, b = x.re or 0, x.im or 0
        local r = math.sqrt(a^2 + b^2)
        local theta = math.atan2(b, a)
        local sqrt_r = math.sqrt(r)
        return {
            re = sqrt_r * math.cos(theta / 2),
            im = sqrt_r * math.sin(theta / 2)
        }
    elseif x >= 0 then
        return math.sqrt(x)
    else
        return { re = 0, im = math.sqrt(-x) }
    end
end

-- solve.lua - Complete Fixed Edition
-- Now with 100% less orphaned code and 200% more actual functionality

local ast = rawget(_G, "ast") or require("ast")
local errors = _G.errors

-- Utility: checks if an AST node contains a variable (recursive)
function contains_var(node, var)
    if type(node) ~= "table" then return false end
    if node.type == "variable" and node.name == var then return true end
    for k, v in pairs(node) do
        if type(v) == "table" and contains_var(v, var) then return true end
    end
    return false
end
 
-- Basic sanity checks for node identity
local function isNum(ast)
    return ast and ast.type == "number"
end
local function isVar(ast, v)
    return ast and ast.type == "variable" and (not v or ast.name == v)
end

-- Ensure parser and simplify are loaded
local parser = rawget(_G, "parser") or require("parser")
local simplify = rawget(_G, "simplify") or require("simplify")

-- Deep copy for ASTs
local function deepCopy(obj)
    if type(obj) ~= "table" then return obj end
    local res = {}
    for k, v in pairs(obj) do res[k] = deepCopy(v) end
    return res
end

-- Simple AST pretty printer (now with 100% less existential crisis)
local function astToString(ast)
    if not ast then return "nil" end
    if type(ast) == "number" then return tostring(ast) end
    if type(ast) == "string" then return ast end
    if type(ast) ~= "table" then return tostring(ast) end
    
    if ast.type == "number" then return tostring(ast.value) end
    if ast.type == "variable" then return ast.name end
    if ast.type == "symbol" then return ast.name end
    
    -- Handle both old-style (left/right) and new-style (args array) structures
    if ast.type == "add" then 
        if ast.args then
            local parts = {}
            for _, arg in ipairs(ast.args) do
                table.insert(parts, astToString(arg))
            end
            return "(" .. table.concat(parts, "+") .. ")"
        else
            return "(" .. astToString(ast.left) .. "+" .. astToString(ast.right) .. ")"
        end
    end
    
    if ast.type == "sub" then 
        if ast.args then
            local parts = {}
            for i, arg in ipairs(ast.args) do
                if i == 1 then
                    table.insert(parts, astToString(arg))
                else
                    table.insert(parts, "-" .. astToString(arg))
                end
            end
            return "(" .. table.concat(parts, "") .. ")"
        else
            return "(" .. astToString(ast.left) .. "-" .. astToString(ast.right) .. ")"
        end
    end
    
    if ast.type == "mul" then 
        if ast.args then
            local parts = {}
            for _, arg in ipairs(ast.args) do
                table.insert(parts, astToString(arg))
            end
            return table.concat(parts, "*")
        else
            return astToString(ast.left) .. "*" .. astToString(ast.right)
        end
    end
    
    if ast.type == "div" then return astToString(ast.left) .. "/" .. astToString(ast.right) end
    if ast.type == "power" or ast.type == "pow" then 
        -- Handle both possible field names because apparently consistency is optional
        local base = ast.left or ast.base
        local exp = ast.right or ast.exp or ast.exponent
        return astToString(base) .. "^" .. astToString(exp)
    end
    if ast.type == "neg" then 
        local inner = ast.arg or ast.value
        return "-(" .. astToString(inner) .. ")" 
    end
    if ast.type == "func" then
        local argstrs = {}
        for _, arg in ipairs(ast.args or {}) do
            table.insert(argstrs, astToString(arg))
        end
        return ast.name .. "(" .. table.concat(argstrs, ",") .. ")"
    end
    if ast.type == "eq" or ast.type == "equation" then 
        return astToString(ast.left) .. " = " .. astToString(ast.right) 
    end
    if ast.type == "pm" then
        return "(" .. astToString(ast.left) .. " ± " .. astToString(ast.right) .. ")"
    end
    
    -- Instead of giving up like a quitter, let's be more informative
    return "UNKNOWN[" .. (ast.type or "no_type") .. "]"
end

-- CORRECTED polynomial coefficient extraction
local function polyCoeffs(ast, var, maxdeg)
    local coeffs = {}

    print("[polyCoeffs] input AST:", astToString(ast))

    -- Force canonical expansion to help coefficient extraction
    if simplify and simplify.simplify then
        ast = simplify.simplify(ast)
        print("[polyCoeffs] after simplification:", astToString(ast))
    end

    -- Helper: robustly get left/right or base/exp
    local function getBaseExp(node)
        local base = node.left or node.base
        local exp = node.right or node.exp
        return base, exp
    end

    -- Recursively walk the AST to extract polynomial terms
    local function walk(node, sign)
        sign = sign or 1
        if not node then return end
        print("[polyCoeffs][walk] node type:", node.type, "node:", astToString(node), "sign:", sign)

        if node.type == "add" then
            local children = node.args or { node.left, node.right }
            for _, child in ipairs(children) do
                walk(child, sign)
            end
        elseif node.type == "sub" then
            local children = node.args or { node.left, node.right }
            walk(children[1], sign)
            for i = 2, #children do
                walk(children[i], -sign)
            end
        elseif node.type == "mul" then
            -- Try to find a polynomial term: coeff * var^deg
            local children = node.args or { node.left, node.right }
            local coeff = sign
            local var_power = 0
            local unknown = false
            print("[polyCoeffs][mul] processing multiplication with", #children, "children")
            for j, child in ipairs(children) do
                print("[polyCoeffs][mul] child", j, ":", astToString(child), "type:", child.type)
                -- Check for variable, power, or constant
                if isNum(child) then
                    print("[polyCoeffs][mul] found number:", child.value)
                    coeff = coeff * child.value
                elseif isVar(child, var) then
                    print("[polyCoeffs][mul] found variable:", child.name)
                    var_power = var_power + 1
                elseif (child.type == "power" or child.type == "pow") then
                    local base, exp = getBaseExp(child)
                    print("[polyCoeffs][mul] found power: base=", astToString(base), "exp=", astToString(exp))
                    if isVar(base, var) and isNum(exp) then
                        print("[polyCoeffs][mul] power of variable:", exp.value)
                        var_power = var_power + exp.value
                    else
                        print("[polyCoeffs][mul] non-polynomial power, skipping")
                        unknown = true
                        break
                    end
                else
                    -- If the term contains the variable in a non-polynomial way, skip
                    if contains_var(child, var) then
                        print("[polyCoeffs][mul] child contains variable non-polynomially, skipping")
                        unknown = true
                        break
                    else
                        -- treat as numeric factor if possible
                        local val
                        if isNum(child) then 
                            val = child.value
                            print("[polyCoeffs][mul] treating as numeric factor:", val)
                        elseif child.type == "neg" and isNum(child.arg or child.value) then 
                            val = -(child.arg or child.value).value
                            print("[polyCoeffs][mul] treating as negative factor:", val)
                        end
                        if val then
                            coeff = coeff * val
                        else
                            print("[polyCoeffs][mul] unknown non-variable term, skipping")
                            unknown = true
                            break
                        end
                    end
                end
            end
            if not unknown then
                coeffs[var_power] = (coeffs[var_power] or 0) + coeff
                print(string.format("[polyCoeffs][mul] Detected term: coeff=%s degree=%s", tostring(coeff), tostring(var_power)))
            else
                print("[polyCoeffs][mul] Skipped non-polynomial term:", astToString(node))
            end
        elseif (node.type == "power" or node.type == "pow") then
            local base, exp = getBaseExp(node)
            if isVar(base, var) and isNum(exp) then
                coeffs[exp.value] = (coeffs[exp.value] or 0) + sign
                print(string.format("[polyCoeffs][pow] Detected term: coeff=%s degree=%s", tostring(sign), tostring(exp.value)))
            else
                print("[polyCoeffs][pow] Skipped non-polynomial power:", astToString(node))
            end
        elseif isVar(node, var) then
            coeffs[1] = (coeffs[1] or 0) + sign
            print(string.format("[polyCoeffs][var] Detected term: coeff=%s degree=1", tostring(sign)))
        elseif isNum(node) then
            coeffs[0] = (coeffs[0] or 0) + (sign * node.value)
            print(string.format("[polyCoeffs][num] Detected term: coeff=%s degree=0", tostring(sign * node.value)))
        else
            -- Try to handle negative nodes: -(...)
            if node.type == "neg" then
                local inner = node.arg or node.value
                print("[polyCoeffs] handling negation of:", astToString(inner))
                walk(inner, -sign)
            else
                print("[polyCoeffs] Skipped unknown node:", astToString(node))
            end
        end
    end

    walk(ast)
    print("[polyCoeffs] coeffs table:")
    for deg, coeff in pairs(coeffs) do
        print("  degree", deg, "=>", coeff)
    end
    return coeffs
end

-- MASSIVELY IMPROVED simplifyIfConstant function
local function simplifyIfConstant(astnode)
    print("[simplifyIfConstant] Input:", astToString(astnode))
    
    if not astnode then 
        print("[simplifyIfConstant] Input is nil, returning nil")
        return astnode 
    end
    
    -- First, try global simplify if available
    if simplify and simplify.simplify then
        local simplified = simplify.simplify(astnode)
        print("[simplifyIfConstant] After global simplify:", astToString(simplified))
        astnode = simplified
    end
    
    -- Aggressive constant evaluation
    local function aggressiveEval(node)
        if not node or type(node) ~= "table" then 
            print("[aggressiveEval] Non-table node:", tostring(node))
            return node 
        end
        
        print("[aggressiveEval] Processing node type:", node.type, "value:", astToString(node))
        
        if node.type == "number" then 
            print("[aggressiveEval] Already a number:", node.value)
            return node 
        end
        
        -- Handle subtraction: a - b
        if node.type == "sub" and node.left and node.right then
            local left = aggressiveEval(node.left)
            local right = aggressiveEval(node.right)
            print("[aggressiveEval] Sub: left=", astToString(left), "right=", astToString(right))
            
            if left.type == "number" and right.type == "number" then
                local result = { type = "number", value = left.value - right.value }
                print("[aggressiveEval] Sub result:", result.value)
                return result
            end
            
            -- Handle a - (-b) = a + b
            if right.type == "neg" then
                local right_inner = right.arg or right.value
                print("[aggressiveEval] Converting a - (-b) to a + b")
                return aggressiveEval({ type = "add", args = { left, right_inner } })
            end
            
            return { type = "sub", left = left, right = right }
        end
        
        -- Handle multiplication with aggressive coefficient extraction
        if node.type == "mul" and node.args then
            local product = 1
            local non_numeric = {}
            
            print("[aggressiveEval] Mul with", #node.args, "args")
            for i, arg in ipairs(node.args) do
                local eval_arg = aggressiveEval(arg)
                print("[aggressiveEval] Mul arg", i, ":", astToString(eval_arg))
                
                if eval_arg.type == "number" then
                    product = product * eval_arg.value
                    print("[aggressiveEval] Accumulated product:", product)
                elseif eval_arg.type == "neg" then
                    local inner = eval_arg.arg or eval_arg.value
                    if inner.type == "number" then
                        product = product * (-inner.value)
                        print("[aggressiveEval] Negative number, product:", product)
                    else
                        table.insert(non_numeric, eval_arg)
                    end
                else
                    table.insert(non_numeric, eval_arg)
                end
            end
            
            print("[aggressiveEval] Final product:", product, "non-numeric count:", #non_numeric)
            
            if #non_numeric == 0 then
                return { type = "number", value = product }
            elseif product == 1 and #non_numeric == 1 then
                return non_numeric[1]
            else
                local result_args = {}
                if product ~= 1 then
                    table.insert(result_args, { type = "number", value = product })
                end
                for _, arg in ipairs(non_numeric) do
                    table.insert(result_args, arg)
                end
                return { type = "mul", args = result_args }
            end
        end
        
        -- Handle addition
        if node.type == "add" and node.args then
            local sum = 0
            local non_numeric = {}
            
            for _, arg in ipairs(node.args) do
                local eval_arg = aggressiveEval(arg)
                if eval_arg.type == "number" then
                    sum = sum + eval_arg.value
                else
                    table.insert(non_numeric, eval_arg)
                end
            end
            
            if #non_numeric == 0 then
                return { type = "number", value = sum }
            else
                local result_args = {}
                if sum ~= 0 then
                    table.insert(result_args, { type = "number", value = sum })
                end
                for _, arg in ipairs(non_numeric) do
                    table.insert(result_args, arg)
                end
                if #result_args == 1 then
                    return result_args[1]
                else
                    return { type = "add", args = result_args }
                end
            end
        end
        
        -- Handle powers
        if (node.type == "pow" or node.type == "power") then
            local base = aggressiveEval(node.base or node.left)
            local exp = aggressiveEval(node.exp or node.right)
            
            if base.type == "number" and exp.type == "number" and not _G.showComplex then
                return { type = "number", value = base.value ^ exp.value }
            end
            
            return { type = node.type, base = base, exp = exp, left = base, right = exp }
        end
        
        -- Handle negation
        if node.type == "neg" then
            local inner = aggressiveEval(node.arg or node.value)
            if inner.type == "number" then
                return { type = "number", value = -inner.value }
            end
            if inner.type == "neg" then
                return inner.arg or inner.value -- Double negative
            end
            return { type = "neg", arg = inner }
        end
        
        -- Handle functions (like sqrt)
        if node.type == "func" and node.args then
            local eval_args = {}
            local all_numeric = true
            
            for i, arg in ipairs(node.args) do
                eval_args[i] = aggressiveEval(arg)
                if eval_args[i].type ~= "number" then
                    all_numeric = false
                end
            end
            
            if all_numeric and node.name == "sqrt" and #eval_args == 1 then
                local val = eval_args[1].value
                if val >= 0 and not _G.showComplex then
                    return { type = "number", value = math.sqrt(val) }
                elseif val < 0 and _G.showComplex then
                    return {
                        type = "mul",
                        args = {
                            { type = "func", name = "sqrt", args = { { type = "number", value = -val } } },
                            { type = "symbol", name = "i" }
                        }
                    }
                end
            end
            
            return { type = "func", name = node.name, args = eval_args }
        end
        
        return node
    end
    
    local result = aggressiveEval(astnode)
    print("[simplifyIfConstant] Final result:", astToString(result))
    return result
end
-- Safe cube root to handle negative numbers
local function cbrt(x)
    if x >= 0 then
        return x^(1/3)
    else
        return -(-x)^(1/3)
    end
end

local function matchQuadraticEq(eq, var)
    print("\n[matchQuadraticEq] ===== QUADRATIC SOLVER DEBUG BEGINS =====")
    print("[matchQuadraticEq] Input equation:", astToString(eq))
    
    -- Accept forms: ax^2 + bx + c = d
    if eq.type ~= "equation" then 
        print("[matchQuadraticEq] Not an equation, aborting")
        return nil 
    end
    
    local l, r = eq.left, eq.right
    print("[matchQuadraticEq] Left side:", astToString(l))
    print("[matchQuadraticEq] Right side:", astToString(r))
    
    -- Normalize by subtracting right from left: (l - r) = 0
    local norm = { type = "sub", left = l, right = r }
    print("[matchQuadraticEq] Normalized form:", astToString(norm))
    
    local coeffs = polyCoeffs(norm, var)
    if not coeffs then 
        print("[matchQuadraticEq] Failed to extract coefficients")
        return nil 
    end
    
    local a = coeffs[2] or 0
    local b = coeffs[1] or 0
    local c = coeffs[0] or 0

    -- PATCH: Handle quadratic in x^2 (biquadratic/quartic with no odd powers)
    local a4 = coeffs[4] or 0
    local a2 = coeffs[2] or 0
    local a0 = coeffs[0] or 0
    local a3 = coeffs[3] or 0
    local a1 = coeffs[1] or 0
    if a4 ~= 0 and a2 ~= 0 and a0 ~= 0 and (a3 == 0 or not a3) and (a1 == 0 or not a1) then
        print("[matchQuadraticEq] Detected quadratic in x^2 (biquadratic)")
        -- Solve y^2 + b y + c = 0, where y = x^2
        local y_a = a4
        local y_b = a2
        local y_c = a0
        -- Use quadratic formula for y
        local disc = y_b^2 - 4 * y_a * y_c
        if disc < 0 and not _G.showComplex then
            print("[matchQuadraticEq] No real solutions for biquadratic")
            return nil
        end
        local sqrt_disc = math.sqrt(math.abs(disc))
        local y1 = (-y_b + sqrt_disc) / (2 * y_a)
        local y2 = (-y_b - sqrt_disc) / (2 * y_a)
        local results = {}
        -- For each y, x = ±sqrt(y)
        for _, yval in ipairs({y1, y2}) do
            if not _G.showComplex and yval < 0 then
                -- skip this yval, do nothing
            else
                if _G.showComplex then
                    -- Symbolic: always show radicals, even for negatives (so roots may be imaginary)
                    local x_pos = { type = "func", name = "sqrt", args = { { type = "number", value = yval } } }
                    local x_neg = { type = "neg", arg = x_pos }
                    table.insert(results, x_pos)
                    table.insert(results, x_neg)
                else
                    -- Only real roots, as decimal numbers
                    if yval >= 0 then
                        local root = math.sqrt(yval)
                        table.insert(results, { type = "number", value = root })
                        table.insert(results, { type = "number", value = -root })
                    end
                end
            end
        end
        print("[matchQuadraticEq] Biquadratic roots (x):", table.concat(
            (function() local t = {}; for _,r in ipairs(results) do table.insert(t, astToString(r)); end; return t end)(),
            ", "))
        return results
    end
    
    print("[matchQuadraticEq] Extracted coefficients: a=", a, "b=", b, "c=", c)
    
    if a == 0 then 
        print("[matchQuadraticEq] Not quadratic (a=0), aborting")
        return nil 
    end

    -- Helper: Create proper AST number nodes
    local function makeNum(val)
        return { type = "number", value = val }
    end

    -- Build coefficient nodes
    local a_node = makeNum(a)
    local b_node = makeNum(b)
    local c_node = makeNum(c)
    local four_node = makeNum(4)
    local two_node = makeNum(2)

    print("[matchQuadraticEq] Created coefficient nodes:")
    print("  a_node:", astToString(a_node))
    print("  b_node:", astToString(b_node))
    print("  c_node:", astToString(c_node))

    -- Compute discriminant: D = b^2 - 4*a*c
    local b_sq = { type = "power", left = b_node, right = makeNum(2) }
    local four_ac = { type = "mul", args = { four_node, a_node, c_node } }
    local disc = { type = "sub", left = b_sq, right = four_ac }

    print("\n=== DISCRIMINANT DEBUG DISASTER ===")
    print("b_sq AST:", astToString(b_sq))
    print("four_ac AST:", astToString(four_ac)) 
    print("Raw discriminant AST:", astToString(disc))

    -- Always simplify discriminant to a number so sqrt can be clean
    disc = simplifyIfConstant(disc)
    print("Simplified discriminant AST:", astToString(disc))
    print("Discriminant type:", disc.type)
    if disc.type == "number" then 
        print("Discriminant value:", disc.value)
    else
        print("Discriminant is NOT a number - mathematical tragedy continues")
    end
    print("=== END OF DISCRIMINANT SUFFERING ===\n")

    -- Build sqrt(D) and simplify it
    local sqrt_disc = { type = "func", name = "sqrt", args = { disc } }
    local sqrt_disc_simp = simplifyIfConstant(sqrt_disc)

    print("Raw sqrt AST:", astToString(sqrt_disc))
    print("Simplified sqrt AST:", astToString(sqrt_disc_simp))

    -- Compute -b
    local minus_b = { type = "neg", arg = b_node }
    minus_b = simplifyIfConstant(minus_b)
    print("Minus b:", astToString(minus_b))

    -- Compute denominator 2a
    local denom = { type = "mul", args = { two_node, a_node } }
    denom = simplifyIfConstant(denom)
    print("Denominator 2a:", astToString(denom))

    -- Build the two solutions: (-b ± √D) / 2a
    local numerator_plus = { type = "add", args = { minus_b, sqrt_disc_simp } }
    local numerator_minus = { type = "sub", left = minus_b, right = sqrt_disc_simp }

    local plus_case = { type = "div", left = numerator_plus, right = denom }
    local minus_case = { type = "div", left = numerator_minus, right = denom }

    print("Before final simplification:")
    print("  plus_case:", astToString(plus_case))
    print("  minus_case:", astToString(minus_case))

    -- CRITICALLY IMPORTANT: Simplify the solutions FIRST
    if _G.showComplex then
        -- Preserve symbolic radicals and fractions
        plus_case = simplify.simplify(plus_case)
        minus_case = simplify.simplify(minus_case)
    else
        plus_case = simplifyIfConstant(plus_case)
        minus_case = simplifyIfConstant(minus_case)
    end

    print("After final simplification:")
    print("  plus_case:", astToString(plus_case))
    print("  minus_case:", astToString(minus_case))

    -- THE ACTUAL FIX: Always return the simplified separate roots
    -- Because nobody wants to see mathematical hieroglyphics when the answer is clean
    print("[matchQuadraticEq] Returning simplified separate roots because we're not savages")
    print("[matchQuadraticEq] Final answers: x =", astToString(plus_case), "and x =", astToString(minus_case))
    print("[matchQuadraticEq] ===== QUADRATIC SOLVER DEBUG ENDS (SUCCESSFULLY) =====\n")
    return { plus_case, minus_case }
end

-- Cubic equation matcher (debugging version)
local function matchCubicEq(eq, var)
    print("\n[matchCubicEq] ===== CUBIC SOLVER DEBUG BEGINS =====")
    print("[matchCubicEq] Input equation:", astToString(eq))

    if eq.type ~= "equation" then 
        print("[matchCubicEq] Not an equation, aborting")
        return nil 
    end

    local l, r = eq.left, eq.right
    local norm = { type = "sub", left = l, right = r }
    print("[matchCubicEq] Normalized form:", astToString(norm))

    local coeffs = polyCoeffs(norm, var)
    if not coeffs then 
        print("[matchCubicEq] Failed to extract coefficients")
        return nil 
    end

    local a = coeffs[3] or 0
    local b = coeffs[2] or 0
    local c = coeffs[1] or 0
    local d = coeffs[0] or 0

    print(string.format("[matchCubicEq] Extracted coefficients: a=%s, b=%s, c=%s, d=%s", a, b, c, d))

    if a == 0 then
        print("[matchCubicEq] Not a cubic (a=0), aborting")
        return nil
    end

    local delta = b / (3 * a)
    print("[matchCubicEq] Depressed substitution delta =", delta)

    local p = (3*a*c - b^2) / (3*a^2)
    local q = (2*b^3 - 9*a*b*c + 27*a^2*d) / (27*a^3)

    print(string.format("[matchCubicEq] Depressed cubic: t^3 + %.6f*t + %.6f = 0", p, q))

    local discriminant = (q/2)^2 + (p/3)^3
    print("[matchCubicEq] Discriminant =", discriminant)

    local roots = {}

    if discriminant > 0 then
        print("[matchCubicEq] One real root, two complex roots (explicit complex form)")

        local sqrt_disc = math.sqrt(discriminant)
        local u = cbrt(-q/2 + sqrt_disc)
        local v = cbrt(-q/2 - sqrt_disc)
        local t1 = u + v

        if _G.showComplex then
            local symbolic_root = {
                type = "sub",
                left = {
                    type = "add",
                    args = {
                        {
                            type = "func",
                            name = "cbrt",
                            args = {
                                {
                                    type = "sub",
                                    left = { type = "number", value = -q/2 },
                                    right = {
                                        type = "func",
                                        name = "sqrt",
                                        args = { { type = "number", value = discriminant } }
                                    }
                                }
                            }
                        },
                        {
                            type = "func",
                            name = "cbrt",
                            args = {
                                {
                                    type = "add",
                                    left = { type = "number", value = -q/2 },
                                    right = {
                                        type = "func",
                                        name = "sqrt",
                                        args = { { type = "number", value = discriminant } }
                                    }
                                }
                            }
                        }
                    }
                },
                right = { type = "number", value = delta }
            }
            table.insert(roots, simplifyIfConstant(symbolic_root))
        else
            local x1 = t1 - delta
            table.insert(roots, { type = "number", value = x1 })
        end

        -- Complex conjugate pair: real = -t1/2 - delta, imag = ± sqrt(3)*(u - v)/2
        local real_part = (-t1/2) - delta
        local imag_part = math.sqrt(3)*(u - v)/2

        if _G.showComplex then
            local sqrt3 = { type = "func", name = "sqrt", args = { { type = "number", value = 3 } } }
            local symbolic_root2 = {
                type = "add",
                args = {
                    {
                        type = "div",
                        left = { type = "neg", arg = { type = "number", value = t1 } },
                        right = { type = "number", value = 2 }
                    },
                    {
                        type = "mul",
                        args = {
                            sqrt3,
                            {
                                type = "div",
                                left = { type = "number", value = (u - v) },
                                right = { type = "number", value = 2 }
                            },
                            { type = "symbol", name = "i" }
                        }
                    }
                }
            }
            local symbolic_root3 = {
                type = "add",
                args = {
                    {
                        type = "div",
                        left = { type = "neg", arg = { type = "number", value = t1 } },
                        right = { type = "number", value = 2 }
                    },
                    {
                        type = "mul",
                        args = {
                            { type = "neg", arg = { type = "func", name = "sqrt", args = { { type = "number", value = 3 } } } },
                            {
                                type = "div",
                                left = { type = "number", value = (u - v) },
                                right = { type = "number", value = 2 }
                            },
                            { type = "symbol", name = "i" }
                        }
                    }
                }
            }
            table.insert(roots, simplifyIfConstant(symbolic_root2))
            table.insert(roots, simplifyIfConstant(symbolic_root3))
        else
            local root2 = { type = "add", args = {
                { type = "number", value = real_part },
                { type = "mul", args = {
                    { type = "number", value = imag_part },
                    { type = "symbol", name = "i" }
                }}
            }}
            local root3 = { type = "add", args = {
                { type = "number", value = real_part },
                { type = "mul", args = {
                    { type = "number", value = -imag_part },
                    { type = "symbol", name = "i" }
                }}
            }}
            table.insert(roots, simplifyIfConstant(root2))
            table.insert(roots, simplifyIfConstant(root3))
        end
    elseif discriminant == 0 then
        print("[matchCubicEq] Triple or double real roots")
        local u = cbrt(-q/2)
        local t1 = 2*u
        local t2 = -u

        -- New block: Properly distinguish between triple and double roots
        local precision = _G.precision or _G.precision_digits or 4
        local function roundnum(x)
            local mult = 10 ^ precision
            return math.floor(x * mult + 0.5) / mult
        end

        local x1 = roundnum(t1 - delta)
        local x2 = roundnum(t2 - delta)

        -- Distinguish between single and double roots
        if math.abs(x1 - x2) < 1e-10 then
            -- Triple root case
            table.insert(roots, { type = "number", value = x1 })
            table.insert(roots, { type = "number", value = x1 })
            table.insert(roots, { type = "number", value = x1 })
        else
            -- Double root at x2
            table.insert(roots, { type = "number", value = x1 })
            table.insert(roots, { type = "number", value = x2 })
            table.insert(roots, { type = "number", value = x2 })
        end
    else
        print("[matchCubicEq] Three distinct real roots (casus irreducibilis)")
        local r = math.sqrt(-(p^3) / 27)
        local phi = math.acos(-q / (2 * math.sqrt(-(p^3)/27)))
        local t1 = 2 * math.sqrt(-qp/3) * math.cos(phi / 3)
        local t2 = 2 * math.sqrt(-p/3) * math.cos((phi + 2*math.pi) / 3)
        local t3 = 2 * math.sqrt(-p/3) * math.cos((phi + 4*math.pi) / 3)
        local x1 = t1 - delta
        local x2 = t2 - delta
        local x3 = t3 - delta
        -- For three real roots, _G.showComplex not relevant, always real
        table.insert(roots, { type = "number", value = x1 })
        table.insert(roots, { type = "number", value = x2 })
        table.insert(roots, { type = "number", value = x3 })
    end

    print("[matchCubicEq] Final roots:")
    for i, r in ipairs(roots) do
        print(string.format("  Root %d: %s", i, astToString(r)))
    end

    print("[matchCubicEq] ===== CUBIC SOLVER DEBUG ENDS =====\n")
    return roots
end



-- Linear equation matcher: supports ax + b = c, ax = b, x + b = c, x = b
local function matchLinearEq(eq, var)
    -- Accept forms: ax + b = c, ax = b, x + b = c, x = b
    if eq.type ~= "equation" then return nil end
    local l, r = eq.left, eq.right
    -- If right side is not zero, normalize: (l - r) = 0
    local norm = { type="sub", left=l, right=r }
    local coeffs = polyCoeffs(norm, var)
    if not coeffs then return nil end
    local a = coeffs[1] or 0
    local b = coeffs[0] or 0
    if coeffs[2] and coeffs[2] ~= 0 then return nil end -- Quadratic term present, not linear
    if a == 0 then return nil end
    -- Solution is x = -b/a
    local solution_value = -b / a
    return ast.number(solution_value)
end

-- Helper to check if an AST node is a constant (number)
local function is_const(node)
  return node and node.type == "number"
end

-- Helper for variable test (for base case, mirror old code)
local function is_var(node)
  return node and node.type == "variable"
end

-- Helper to copy AST nodes (deep copy)
local function copy(node)
  if type(node) ~= "table" then return node end
  local res = {}
  for k,v in pairs(node) do res[k] = copy(v) end
  return res
end

-- Main solve function
function solve(input_expr, var)
    print("\n[solve] ===== MAIN SOLVE FUNCTION BEGINS =====")
    print("[solve] Input expression:", tostring(input_expr))
    print("[solve] Variable:", tostring(var))
    
    local parser = rawget(_G, "parser") or require("parser")
    local ast_mod = rawget(_G, "ast") or require("ast")
    local simplify = rawget(_G, "simplify") or require("simplify")

    local expr = input_expr
    if type(expr) == "string" then
        print("[solve] Parsing string input:", expr)
        -- Insert '*' between a digit and a letter or digit and '('
        local s = expr
        s = s:gsub("(%d)(%a)", "%1*%2")
        s = s:gsub("(%d)(%()", "%1*%2")
        print("[solve] After implicit multiplication:", s)
        expr = parser.parse(s)
    end
    if not expr then
        error(errors.invalid("solve", "parse failed, got nil AST"))
    end
    
    print("[solve] Parsed AST:", astToString(expr))

    var = var or (function()
        -- try to guess variable
        local function findVar(node)
            if not node or type(node) ~= "table" then return nil end
            if node.type == "variable" then return node.name end
            for _, k in ipairs { "left", "right", "value", "args" } do
                local child = node[k]
                if child then
                    if type(child) == "table" and not child[1] then
                        local res = findVar(child)
                        if res then return res end
                    elseif type(child) == "table" then
                        for _, v in ipairs(child) do
                            local res = findVar(v)
                            if res then return res end
                        end
                    end
                end
            end
            return nil
        end
        return findVar(expr.left) or findVar(expr.right) or "x"
    end)()

    print("[solve] Using variable:", var)

    -- Canonicalize equation as eq-node (lhs = rhs), or expr = 0
    if expr.type == "equation" then
        expr = ast_mod.eq(expr.left, expr.right)
    elseif expr.type ~= "equation" then
        expr = ast_mod.eq(expr, ast_mod.number(0))
    end

    print("[solve] Canonicalized equation:", astToString(expr))

    -- Always simplify first
    expr = simplify.simplify(expr)
    print("[solve] After initial simplification:", astToString(expr))

    -- Try all known matchers
    local diff = simplify.simplify(ast_mod.sub(expr.left, expr.right))
    local fallback_eq = ast_mod.eq(diff, ast_mod.number(0))
    
    print("[solve] Normalized difference:", astToString(diff))
    print("[solve] Fallback equation:", astToString(fallback_eq))

    -- Find polynomial degree
    local coeffs = polyCoeffs(fallback_eq.left, var)
    local maxdeg = 0
    for d, _ in pairs(coeffs) do
        if d > maxdeg then maxdeg = d end
    end

    if maxdeg == 1 then
        local ans_lin = matchLinearEq(fallback_eq, var)
        if ans_lin then
            print("[solve] Linear solution found:", astToString(ans_lin))
            local rhs
            if type(ans_lin) ~= "table" then
                rhs = ast_mod.number(ans_lin)
            else
                rhs = ans_lin
            end
            local eq_ast = ast_mod.eq(ast_mod.symbol(var), rhs)
            local simplified_eq = simplify.simplify(eq_ast)
            local result = astToString(simplified_eq)
            if simplified_eq and simplified_eq.type == "sub"
                and simplified_eq.left and simplified_eq.right
                and simplified_eq.left.type == "variable"
                and simplified_eq.right.type == "number" then
                result = simplified_eq.left.name .. " = " .. tostring(simplified_eq.right.value)
            end
            print("[solve] Final linear result:", result)
            if type(var) == "table" and type(var.store) == "function" then
                var.store("last_solve_mode", _G.lastSolveModeFlag or (_G.showComplex and "complex" or "decimal"))
            end
            return result
        end
    elseif maxdeg == 2 then
        local ans_quad = matchQuadraticEq(fallback_eq, var)
        if ans_quad then
            print("[solve] Quadratic solution found")
            local pieces = {}
            for i, root in ipairs(ans_quad) do
                table.insert(pieces, var .. " = " .. astToString(root))
            end
            local result = table.concat(pieces, ", ")
            print("[solve] Final quadratic result:", result)
            if type(var) == "table" and type(var.store) == "function" then
                var.store("last_solve_mode", _G.lastSolveModeFlag or (_G.showComplex and "complex" or "decimal"))
            end
            return result
        end
    elseif maxdeg == 3 then
        local ans_cubic = matchCubicEq(fallback_eq, var)
        if ans_cubic then
            print("[solve] Cubic solution found")
            local result = {}
            for i, root in ipairs(ans_cubic) do
                table.insert(result, var .. " = " .. astToString(root))
            end
            local final_result = table.concat(result, ", ")
            print("[solve] Final cubic result:", final_result)
            if type(var) == "table" and type(var.store) == "function" then
                var.store("last_solve_mode", _G.lastSolveModeFlag or (_G.showComplex and "complex" or "decimal"))
            end
            return final_result
        end
    elseif maxdeg == 4 then
        local ans_quartic = matchQuarticEq(fallback_eq, var)
        if ans_quartic then
            print("[solve] Quartic solution found")
            local result = {}
            for i, root in ipairs(ans_quartic) do
                table.insert(result, var .. " = " .. astToString(root))
            end
            local final_result = table.concat(result, ", ")
            print("[solve] Final quartic result:", final_result)
            if type(var) == "table" and type(var.store) == "function" then
                var.store("last_solve_mode", _G.lastSolveModeFlag or (_G.showComplex and "complex" or "decimal"))
            end
            return final_result
        end
    end


    print("[solve] No analytical solution found")
    return "No solution found"
end

-- Quartic equation matcher: ax^4 + bx^3 + cx^2 + dx + e = 0
local function matchQuarticEq(eq, var)
    print("\n[matchQuarticEq] ===== QUARTIC SOLVER DEBUG BEGINS =====")
    if eq.type ~= "equation" then
        print("[matchQuarticEq] Not an equation, aborting")
        return nil
    end
    local l, r = eq.left, eq.right
    local norm = { type = "sub", left = l, right = r }
    print("[matchQuarticEq] Normalized form:", astToString(norm))
    local coeffs = polyCoeffs(norm, var)
    if not coeffs then print("[matchQuarticEq] Failed to extract coefficients") return nil end
    local a = coeffs[4] or 0
    local b = coeffs[3] or 0
    local c = coeffs[2] or 0
    local d = coeffs[1] or 0
    local e = coeffs[0] or 0
    print(string.format("[matchQuarticEq] Extracted coefficients: a=%s, b=%s, c=%s, d=%s, e=%s", a, b, c, d, e))
    if a == 0 then print("[matchQuarticEq] Not quartic (a=0), aborting") return nil end

    -- Attempt to factor as two quadratics: (x^2 + px + q)(x^2 + rx + s) = 0
    local function try_quartic_factoring(a, b, c, d, e)
        -- Only attempt if all coefficients are integers (to avoid floating imprecision)
        if math.floor(a) ~= a or math.floor(b) ~= b or math.floor(c) ~= c or math.floor(d) ~= d or math.floor(e) ~= e then return nil end
        -- Try to solve: (x^2 + p x + q)(x^2 + r x + s) = ax^4 + bx^3 + cx^2 + dx + e
        -- This expands to:
        -- a x^4 + b x^3 + c x^2 + d x + e =
        -- x^4 + (p + r)x^3 + (q + pr + s)x^2 + (ps + qr)x + qs
        -- Here, a = 1 assumed (normalize first); else, factor out 'a'
        if a ~= 1 then
            b = b / a; c = c / a; d = d / a; e = e / a
        end
        for p = -10, 10 do for r = -10, 10 do
        for q = -10, 10 do for s = -10, 10 do
            if (p + r == b) and (q + p*r + s == c) and (p*s + q*r == d) and (q*s == e) then
                -- We found a factorization!
                return {p=p, q=q, r=r, s=s}
            end
        end end end end
        return nil
    end

    local factors = try_quartic_factoring(a, b, c, d, e)
    if factors then
        print("[matchQuarticEq] Factored as (x^2+"..factors.p.."x+"..factors.q..")*(x^2+"..factors.r.."x+"..factors.s..")")
        -- Solve both quadratics, propagate _G.showComplex to allow/deny complex roots
        local roots1 = matchQuadraticEq(
            { type="equation", left={type="add", args={
                {type="pow", base={type="variable", name=var}, exp={type="number", value=2}},
                {type="mul", args={{type="number", value=factors.p}, {type="variable", name=var}}},
                {type="number", value=factors.q}
            }}, right={type="number", value=0}}, var)
        local roots2 = matchQuadraticEq(
            { type="equation", left={type="add", args={
                {type="pow", base={type="variable", name=var}, exp={type="number", value=2}},
                {type="mul", args={{type="number", value=factors.r}, {type="variable", name=var}}},
                {type="number", value=factors.s}
            }}, right={type="number", value=0}}, var)
        local all_roots = {}
        if roots1 then for _, rt in ipairs(roots1) do table.insert(all_roots, rt) end end
        if roots2 then for _, rt in ipairs(roots2) do table.insert(all_roots, rt) end end
        return all_roots
    end

    -- Normalize coefficients
    b = b / a
    c = c / a
    d = d / a
    e = e / a

    -- Ferrari's method (numeric version)
    local p = c - 3 * b^2 / 8
    local q = b^3 / 8 - b * c / 2 + d
    local r = e - 3 * b^4 / 256 + b^2 * c / 16 - b * d / 4
    print(string.format("[matchQuarticEq] Depressed quartic: y^4 + %.6f*y^2 + %.6f*y + %.6f = 0", p, q, r))

    -- Solve resolvent cubic
    local cubicA = 1
    local cubicB = 2 * p
    local cubicC = p^2 - 4 * r
    local cubicD = -q^2
    local cubicRoots = solveCubicReal(cubicA, cubicB, cubicC, cubicD)
    local z = cubicRoots[1]  -- Use first real root
    print("[matchQuarticEq] Chose resolvent root z =", z)

    -- Helper for complex division
    local function div_complex(a, b)
        -- Divides a by b, where either may be real or complex tables
        local a_re = type(a) == "table" and a.re or a
        local a_im = type(a) == "table" and (a.im or 0) or 0
        local b_re = type(b) == "table" and b.re or b
        local b_im = type(b) == "table" and (b.im or 0) or 0
        if b_im == 0 then
            -- b is real
            if type(a) == "table" then
                return { re = a_re / b_re, im = a_im / b_re }
            else
                return a_re / b_re
            end
        end
        -- Complex division
        local denom = b_re^2 + b_im^2
        return {
            re = (a_re * b_re + a_im * b_im) / denom,
            im = (a_im * b_re - a_re * b_im) / denom
        }
    end

    -- Helper for complex multiplication
    local function mul_complex(a, b)
        local a_re = type(a) == "table" and a.re or a
        local a_im = type(a) == "table" and (a.im or 0) or 0
        local b_re = type(b) == "table" and b.re or b
        local b_im = type(b) == "table" and (b.im or 0) or 0
        return {
            re = a_re * b_re - a_im * b_im,
            im = a_re * b_im + a_im * b_re
        }
    end

    local sqrt1 = safe_sqrt(2 * z - p)
    local sqrt1v = type(sqrt1) == "table" and sqrt1.re or sqrt1
    --local sqrt2 = (type(sqrt1) == "table") and 0 or (q / (2 * sqrt1))
    --local S1 = sqrt1
    --local S2 = sqrt2
    local S1 = sqrt1
    local S2 = div_complex(q, type(sqrt1) == "table" and { re = 2 * (sqrt1.re or 0), im = 2 * (sqrt1.im or 0) } or (2 * sqrt1))

    local roots = {}
    local precision = _G.precision or _G.precision_digits or 4
    local function roundnum(x)
        if not x then return 0 end
        local mult = 10 ^ precision
        return math.floor(x * mult + 0.5) / mult
    end
    local function format_root(val)
        if type(val) == "table" and val.im and val.im ~= 0 then
            return {
                type = "add",
                args = {
                    { type = "number", value = roundnum(val.re) },
                    {
                        type = "mul",
                        args = {
                            { type = "number", value = roundnum(val.im) },
                            { type = "symbol", name = "i" }
                        }
                    }
                }
            }
        else
            return { type = "number", value = roundnum(type(val) == "table" and val.re or val) }
        end
    end

    local function add_complex(a, b)
        if type(a) == "table" and type(b) == "table" then
            return { re = a.re + b.re, im = (a.im or 0) + (b.im or 0) }
        elseif type(a) == "table" then
            return { re = a.re + b, im = a.im }
        elseif type(b) == "table" then
            return { re = a + b.re, im = b.im }
        else
            return a + b
        end
    end

    local function sub_complex(a, b)
        if type(a) == "table" and type(b) == "table" then
            return { re = a.re - b.re, im = (a.im or 0) - (b.im or 0) }
        elseif type(a) == "table" then
            return { re = a.re - b, im = a.im }
        elseif type(b) == "table" then
            return { re = a - b.re, im = -b.im }
        else
            return a - b
        end
    end

    local function neg_complex(a)
        if type(a) == "table" then
            return { re = -(a.re or 0), im = -(a.im or 0) }
        else
            return -a
        end
    end

    local function div2(val)
        if type(val) == "table" then
            return { re = val.re / 2, im = (val.im or 0) / 2 }
        else
            return val / 2
        end
    end

    local t1 = add_complex(S1, safe_sqrt(sub_complex(-(2 * z + p), neg_complex(mul_complex(2, S2)))))
    local t2 = sub_complex(S1, safe_sqrt(sub_complex(-(2 * z + p), neg_complex(mul_complex(2, S2)))))
    local t3 = add_complex(neg_complex(S1), safe_sqrt(sub_complex(-(2 * z + p), mul_complex(2, S2))))
    local t4 = sub_complex(neg_complex(S1), safe_sqrt(sub_complex(-(2 * z + p), mul_complex(2, S2))))

    local base = -b / 4
    local y1 = add_complex(base, div2(t1))
    local y2 = add_complex(base, div2(t2))
    local y3 = add_complex(base, div2(t3))
    local y4 = add_complex(base, div2(t4))

    print(string.format("[matchQuarticEq] Numeric roots: %s, %s, %s, %s",
        type(y1)=="table" and (y1.re or "")..(y1.im and ("+"..y1.im.."i") or "") or tostring(y1),
        type(y2)=="table" and (y2.re or "")..(y2.im and ("+"..y2.im.."i") or "") or tostring(y2),
        type(y3)=="table" and (y3.re or "")..(y3.im and ("+"..y3.im.."i") or "") or tostring(y3),
        type(y4)=="table" and (y4.re or "")..(y4.im and ("+"..y4.im.."i") or "") or tostring(y4)
    ))

    -- Before constructing roots, if _G.showComplex is not set and any root is complex, skip or return only real roots
    if not _G.showComplex then
        local real_roots = {}
        for _, y in ipairs({y1, y2, y3, y4}) do
            if type(y) == "table" and (y.im and math.abs(y.im) > 1e-10) then
                -- skip complex root
            else
                -- real root
                local val = y
                if type(y) == "table" then val = y.re end
                table.insert(real_roots, format_root(val))
            end
        end
        if #real_roots == 0 then
            print("[matchQuarticEq] No real roots found")
            return {"No real roots"}
        else
            return real_roots
        end
    end

    return {
        format_root(y1),
        format_root(y2),
        format_root(y3),
        format_root(y4)
    }
end

function solveCubicReal(a, b, c, d)
    b = b / a; c = c / a; d = d / a
    local p = c - b^2 / 3
    local q = 2 * b^3 / 27 - b * c / 3 + d
    local roots = {}
    local discriminant = (q / 2)^2 + (p / 3)^3
    if discriminant > 0 then
        local u = cbrt(-q / 2 + math.sqrt(discriminant))
        local v = cbrt(-q / 2 - math.sqrt(discriminant))
        table.insert(roots, u + v - b / 3)
    else
        local r = math.sqrt(-p^3 / 27)
        local phi = math.acos(-q / (2 * r))
        local t = 2 * math.sqrt(-p / 3)
        table.insert(roots, t * math.cos(phi / 3) - b / 3)
        table.insert(roots, t * math.cos((phi + 2 * math.pi) / 3) - b / 3)
        table.insert(roots, t * math.cos((phi + 4 * math.pi) / 3) - b / 3)
    end
    return roots
end

-- Export functions
_G.solve = solve
_G.polyCoeffs = polyCoeffs
_G.matchLinearEq = matchLinearEq
_G.matchQuadraticEq = matchQuadraticEq
_G.astToString = astToString
_G.matchCubicEq = matchCubicEq
_G.matchQuarticEq = matchQuarticEq

-- End src/solve.lua

-- Integrated src/solve.lua: let’s hope it compiles this time.

-- Begin src/init.lua
platform.apilevel = "2.4"

local var = rawget(_G, "var") or nil
_G.darkMode = (var and var.recall and var.recall("dark_mode") == 1) or false

-- Default fallback; true recall happens after storage is ready
_G.current_constant_category = nil

-- Delay storage sync to avoid race with var initialization
function syncCategoryFromStorage()
    if var and type(var.recall) == "function" then
        local cat = var.recall("current_constant_category")
        if cat and type(cat) == "string" then
            print("[STATE] Loaded stored constant category:", cat)
            _G.current_constant_category = cat
            return
        end
    end

    if not _G.current_constant_category then
        _G.current_constant_category = "fundamental"
        print("[STATE] No stored category, using default:", _G.current_constant_category)
        
        if var and type(var.store) == "function" then
            var.store("current_constant_category", _G.current_constant_category)
            print("[STATE] Stored default category to storage:", _G.current_constant_category)
        end
    end
end


function on.construction()
    syncCategoryFromStorage()
end

function on.getSymbolList()
    return { "current_constant_category" }
end

-- End src/init.lua

-- Imported src/init.lua—debuggers rejoice.

-- Begin src/gui.lua
_G.darkMode = (var.recall("dark_mode") == 1)
_G.showLaunchAnimation = (var.recall("nLuaCAS_launch_anim_pref") == 1)

function getStringWidth(text)
    return platform.withGC(function(gc) return gc:getStringWidth(text) end, text)
end
_G.precisionInputActive = false
_G.showComplex = (var.recall("nLuaCAS_complex_pref") == 1)
-- Launch animation globals
local n_logo = image.new(_R.IMG.n_logo)
local luacas_text = image.new(_R.IMG.luacas_text)
local scaleFactorLogo = 0.1 -- Adjusted smaller n logo
local scaleFactorText = 0.035 -- Adjusted smaller LuaCAS text to match n height
local nW, nH = image.width(n_logo) * scaleFactorLogo, image.height(n_logo) * scaleFactorLogo
local luaW, luaH = image.width(luacas_text) * scaleFactorText, image.height(luacas_text) * scaleFactorText
local launchStartTime = timer.getMilliSecCounter()
-- Recall launch animation preference: 1 for show, 0 for hide. Default to show if not set.

local showLaunchAnim = _G.showLaunchAnimation -- Initialize local variable based on global preference
local logoX, textX = -100, -300
local overlayAlpha = 1.0
local overlayRegion = {x=270, y=8, w=90, h=24} -- Position this based on the layout
local cursorInsideOverlay = false


function syncCategoryFromStorage()
    local cat = nil
    if var and type(var.recall) == "function" then
        cat = var.recall("current_constant_category")
    end

    if cat and type(cat) == "string" then
        _G.current_constant_category = cat
        _G.currentConstCategory = cat
        print("[STATE] Recalled category from storage:", cat)
    else
        local fallback = gui.get_current_constant_category()
        _G.current_constant_category = fallback
        _G.currentConstCategory = fallback
        print("[STATE] No stored category, using default:", fallback)
    end

    -- Always update GUI button text if it exists
    if _G.categoryBtn then
        _G.categoryBtn.text = _G.currentConstCategory
        print("[DEBUG] Category button updated to:", _G.currentConstCategory)
    end
end

function setupLaunchAnimation()
    if showLaunchAnim then
        -- Start a timer to drive the animation. You need a variable to store the timer ID.
        animationTimerId = timer.start(10) -- Set a small interval like 10ms for smooth animation
    else
        -- If animation is off, immediately make the editor visible
        if fctEditor and fctEditor.editor then
            fctEditor.editor:setVisible(true)
        end
        platform.window:invalidate() -- Force a redraw to ensure editor is shown
    end
end
var = var or {}
var.store = var.store or {}
local parser = rawget(_G, "parser")
if not parser or not parser.parse then
  error("parser module or parser.parse not defined — ensure parser.lua is loaded before gui.lua")
end
local parse = parser.parse
local simplify = rawget(_G, "simplify")
local errors = _G.errors

-- Ensure getLocaleText exists, fallback to identity
local getLocaleText = rawget(_G, "getLocaleText") or function(key) return key end

_G.autoDecimal = false
_G.settingsBtnRegion = {x = 0, y = 0, w = 32, h = 32}
-- Modal flag for settings
_G.showSettingsModal = false
_G.showHelpModal = false
_G.showStartupHint = true
if var and var.recall and var.recall("hide_startup_hint") == 1 then
    _G.showStartupHint = false
end
_G.switchPressed = false
_G.modalETKButton = nil
_G.modalCloseBtnRegion = {x = 0, y = 0, w = 24, h = 24}
-- Compatibility hack: unpack became table.unpack in newer Lua, because reasons
unpack = unpack or table.unpack

-- ====== Embedded Standalone ETK-style Button Widget ======

Widgets = {}
function applyEditorColors()
    if fctEditor and fctEditor.editor then
        local bg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
        local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
        local border = _G.darkMode and {100, 100, 100} or {0, 0, 0}

        if fctEditor.editor.setBackgroundColor then
            fctEditor.editor:setBackgroundColor(table.unpack(bg))
        end
        if fctEditor.editor.setTextColor then
            fctEditor.editor:setTextColor(table.unpack(text))
        end
        if fctEditor.editor.setBorderColor then
            fctEditor.editor:setBorderColor(table.unpack(border))
        end
        if fctEditor.editor.setOpaque then
            fctEditor.editor:setOpaque(true)
        end
    end
end
-- Helper for unpacking color
function unpackColor(t)
  return t[1], t[2], t[3]
end

-- Helper for simple dimension (width, height)
function Dimension(w, h)
  return { width = w, height = h }
end

-- Helper event dispatcher
function CallEvent(obj, name)
  if obj[name] then obj[name](obj) end
end

-- ETK-style Button class
Widgets.Button = class(Widget)
local Button = Widgets.Button

Button.defaultStyle = {
  textColor       = {{000,000,000},{000,000,000}},
  backgroundColor = {{248,252,248},{248,252,248}},
  borderColor     = {{136,136,136},{160,160,160}},
  focusColor      = {{040,148,184},{000,000,000}},
  defaultWidth  = 48,
  defaultHeight = 27,
  font = {
    serif="sansserif",
    style="r",
    size=10
  }
}

function Button:init(arg)	
  self.text = arg.text or "Button"
  local style = arg.style or Button.defaultStyle or {
    textColor       = {{0,0,0},{0,0,0}},
    backgroundColor = {{248,252,248},{248,252,248}},
    borderColor     = {{136,136,136},{160,160,160}},
    focusColor      = {{40,148,184},{0,0,0}},
    defaultWidth  = 48,
    defaultHeight = 27,
    font = {
      serif="sansserif",
      style="r",
      size=10
    }
  }
  self.style = style
  self.dimension = arg.position or Dimension(style.defaultWidth or 48, style.defaultHeight or 27)
  Widget.init(self, nil, self.dimension.width or style.defaultWidth, self.dimension.height or style.defaultHeight)
  self.meDown = false
  self.hasFocus = false
  self.parent = arg.parent or nil
  self.onAction = arg.onAction or nil
end

function Button:prepare(gc)
  local font = self.style.font
  gc:setFont(font.serif, font.style, font.size)
  self.dimension.width = gc:getStringWidth(self.text) + 10
end

function Button:draw(gc, x, y, width, height, isColor)
  if self.meDown then
    y = y + 1
  end

  local color = isColor and 1 or 2
  local style = self.style or Button.defaultStyle

  local isDark = _G.darkMode
local colorSet = isDark and {
    backgroundColor = {50, 50, 50},
    textColor = {220, 220, 220},
    borderColor = {100, 100, 100},
    focusColor = {80, 160, 220}
} or {
    backgroundColor = {248, 252, 248},
    textColor = {0, 0, 0},
    borderColor = {136, 136, 136},
    focusColor = {40, 148, 184}
}

local bg = colorSet.backgroundColor
local tc = colorSet.textColor
local bc = colorSet.borderColor
local fc = colorSet.focusColor

  gc:setColorRGB(unpackColor(bg))
  gc:fillRect(x + 2, y + 2, width - 4, height - 4)

  gc:setColorRGB(unpackColor(tc))
  gc:drawString(self.text, x + 5, y + 3, "top")

  if self.hasFocus then
    gc:setColorRGB(unpackColor(fc))
    gc:setPen("medium", "smooth")
  else
    gc:setColorRGB(unpackColor(bc))
    gc:setPen("thin", "smooth")
  end

  gc:fillRect(x + 2, y, width - 4, 2)
  gc:fillRect(x + 2, y + height - 2, width - 4, 2)
  gc:fillRect(x, y + 2, 1, height - 4)
  gc:fillRect(x + 1, y + 1, 1, height - 2)
  gc:fillRect(x + width - 1, y + 2, 1, height - 4)
  gc:fillRect(x + width - 2, y + 1, 1, height - 2)

  if self.hasFocus then
    gc:setColorRGB(unpackColor(style.focusColor[color]))
  end

  gc:setPen("thin", "smooth")
end

function Button:doAction()
  if self.parent and self.parent.invalidate then
    self.parent:invalidate()
  end
  if self.onAction then
    self.onAction(self)
  else
    CallEvent(self, "onAction")
  end
end

function Button:onMouseDown()
  self.meDown = true
end

function Button:onMouseUp(x, y, onMe)
  self.meDown = false
  if onMe then
    self:doAction()
  end
end

function Button:enterKey()
  self:doAction()
end

-- ====== END Standalone Button Widget ======
-- ETK View System (lifted and tweaked from SuperSpire/S2.lua)
defaultFocus = nil

-- The View class: manages widgets, focus, mouse events, and general UI mayhem.
View = class()

function View:init(window)
	self.window = window
	self.widgetList = {}
	self.focusList = {}
	self.currentFocus = 0
	self.currentCursor = "default"
	self.prev_mousex = 0
	self.prev_mousey = 0
end

function View:invalidate()
	self.window:invalidate()
end

function View:setCursor(cursor)
	if cursor ~= self.currentCursor then
		self.currentCursor = cursor
		self:invalidate()
	end
end

-- Add a widget to the view, because clearly we like clutter. Also handles focus logic.
function View:add(o)
	table.insert(self.widgetList, o)
	self:repos(o)
	if o.acceptsFocus then
		table.insert(self.focusList, 1, o)
		if self.currentFocus > 0 then
			self.currentFocus = self.currentFocus + 1
		end
	end
	return o
end

-- Remove a widget from the view, and try to pretend nothing ever happened.
function View:remove(o)
	if self:getFocus() == o then
		o:releaseFocus()
	end
	local i = 1
	local f = 0
	while i <= #self.focusList do
		if self.focusList[i] == o then
			f = i
		end
		i = i + 1
	end
	if f > 0 then
		if self:getFocus() == o then
			self:tabForward()
		end
		table.remove(self.focusList, f)
		if self.currentFocus > f then
			self.currentFocus = self.currentFocus - 1
		end
	end
	f = 0
	i = 1
	while i <= #self.widgetList do
		if self.widgetList[i] == o then
			f = i
		end
		i = i + 1
	end
	if f > 0 then
		table.remove(self.widgetList, f)
	end
end

-- Reposition and resize a widget according to its constraints. Because pixel-perfect UIs are for the weak.
function View:repos(o)
	local x = o.x
	local y = o.y
	local w = o.w
	local h = o.h
	if o.hConstraint == "right" then
		x = scrWidth - o.w - o.dx1
	elseif o.hConstraint == "center" then
		x = (scrWidth - o.w + o.dx1) / 2
	elseif o.hConstraint == "justify" then
		w = scrWidth - o.x - o.dx1
	end
	if o.vConstraint == "bottom" then
		y = scrHeight - o.h - o.dy1
	elseif o.vConstraint == "middle" then
		y = (scrHeight - o.h + o.dy1) / 2
	elseif o.vConstraint == "justify" then
		h = scrHeight - o.y - o.dy1
	end
	o:repos(x, y)
	o:resize(w, h)
end

-- Resize all widgets in the view. Hope they like their new size.
function View:resize()
	for _, o in ipairs(self.widgetList) do
		self:repos(o)
	end
end

-- Hide a widget. Out of sight, out of mind (and out of focus).
function View:hide(o)
	if o.visible then
		o.visible = false
		self:releaseFocus(o)
		if o:contains(self.prev_mousex, self.prev_mousey) then
			o:onMouseLeave(o.x - 1, o.y - 1)
		end
		self:invalidate()
	end
end

-- Show a widget. If it was invisible, now it can bask in the user's gaze.
function View:show(o)
	if not o.visible then
		o.visible = true
		if o:contains(self.prev_mousex, self.prev_mousey) then
			o:onMouseEnter(self.prev_mousex, self.prev_mousey)
		end
		self:invalidate()
	end
end

-- Return the currently focused widget, or nil if nothing bothers to have focus.
function View:getFocus()
	if self.currentFocus == 0 then
		return nil
	end
	return self.focusList[self.currentFocus]
end

-- Give focus to a widget, and make everyone else jealous.
function View:setFocus(obj)
	if self.currentFocus ~= 0 then
		if self.focusList[self.currentFocus] == obj then
			return
		end
		self.focusList[self.currentFocus]:releaseFocus()
	end
	self.currentFocus = 0
	for i = 1, #self.focusList do
		if self.focusList[i] == obj then
			self.currentFocus = i
			obj:setFocus()
			self:invalidate()
			break
		end
	end
end

-- Take focus away from a widget. It probably didn't deserve it anyway.
function View:releaseFocus(obj)
	if self.currentFocus ~= 0 then
		if self.focusList[self.currentFocus] == obj then
			self.currentFocus = 0
			obj:releaseFocus()
			self:invalidate()
		end
	end
end

-- Send a string to the focused widget, or desperately try to find anyone who will take it.
function View:sendStringToFocus(str)
	local o = self:getFocus()
	if not o then
		o = defaultFocus
		self:setFocus(o)
	end
	if o then
		if o.visible then
			if o:addString(str) then
				self:invalidate()
			else
				o = nil
			end
		end
	end

	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible then
				if o:addString(str) then
					self:setFocus(o)
					self:invalidate()
					break
				end
			end
		end
	end
end

-- Handle backspace for the focused widget, or for anyone who claims to accept it.
function View:backSpaceHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsBackSpace then
			o:backSpaceHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsBackSpace then
				o:backSpaceHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Move focus to the next widget, looping around. Because tab order is a suggestion, not a rule.
function View:tabForward()
	local nextFocus = self.currentFocus + 1
	if nextFocus > #self.focusList then
		nextFocus = 1
	end
	self:setFocus(self.focusList[nextFocus])
	if self:getFocus() then
		if not self:getFocus().visible then
			self:tabForward()
		end
	end
	self:invalidate()
end

-- Move focus to the previous widget, looping around. For the rebels who like shift+tab.
function View:tabBackward()
	local nextFocus = self.currentFocus - 1
	if nextFocus < 1 then
		nextFocus = #self.focusList
	end
	self:setFocus(self.focusList[nextFocus])
	if not self:getFocus().visible then
		self:tabBackward()
	end
	self:invalidate()
end

-- Handle mouse down events, capturing the widget that gets clicked (and focus).
function View:onMouseDown(x, y)
	for _, o in ipairs(self.widgetList) do
		if o.visible and o.acceptsFocus and o:contains(x, y) then
			self.mouseCaptured = o
			o:onMouseDown(x - o.x, y - o.y)
			self:setFocus(o)
			self:invalidate()
			return
		end
	end
	if self:getFocus() then
		self:setFocus(nil)
		self:invalidate()
	end
end

-- Handle mouse move events, triggering enter/leave events for widgets. Because hover states are important.
function View:onMouseMove(x, y)
	local prev_mousex = self.prev_mousex
	local prev_mousey = self.prev_mousey
	for _, o in ipairs(self.widgetList) do
		local xyin = o:contains(x, y)
		local prev_xyin = o:contains(prev_mousex, prev_mousey)
		if xyin and not prev_xyin and o.visible then
			o:onMouseEnter(x, y)
			self:invalidate()
		elseif prev_xyin and (not xyin or not o.visible) then
			o:onMouseLeave(x, y)
			self:invalidate()
		end
	end
	self.prev_mousex = x
	self.prev_mousey = y
end

-- Handle mouse up events, releasing the widget that was so rudely pressed.
function View:onMouseUp(x, y)
	local mc = self.mouseCaptured
	if mc then
		self.mouseCaptured = nil
		if mc:contains(x, y) then
			mc:onMouseUp(x - mc.x, y - mc.y)
		end
	end
end

-- Handle "enter" key for the focused widget, or anyone who cares.
function View:enterHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsEnter then
			o:enterHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsEnter then
				o:enterHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle left arrow key for the focused widget, or anyone who wants to move left in life.
function View:arrowLeftHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowLeft then
			o:arrowLeftHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowLeft then
				o:arrowLeftHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle right arrow key for the focused widget, or anyone who wants to move right in life.
function View:arrowRightHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowRight then
			o:arrowRightHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowRight then
				o:arrowRightHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle up arrow key for the focused widget. Because up is the new down.
function View:arrowUpHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowUp then
			o:arrowUpHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowUp then
				o:arrowUpHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle down arrow key for the focused widget. Because down is the new up.
function View:arrowDownHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowDown then
			o:arrowDownHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowDown then
				o:arrowDownHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Paint all widgets to the screen, highlight the focused one, and set the cursor.
function View:paint(gc)
	local fo = self:getFocus()
	for _, o in ipairs(self.widgetList) do
		if o.visible then
			o:paint(gc, fo == o)
			if fo == o then
				gc:setColorRGB(100, 150, 255)
				gc:drawRect(o.x - 1, o.y - 1, o.w + 1, o.h + 1)
				gc:setPen("thin", "smooth")
				gc:setColorRGB(0, 0, 0)
			end
		end
	end
	cursor.set(self.currentCursor)
end

theView = nil

-- Widget base class. All widgets inherit from this, like it or not.
Widget = class()

function Widget:setHConstraints(hConstraint, dx1)
	self.hConstraint = hConstraint
	self.dx1 = dx1
end

function Widget:setVConstraints(vConstraint, dy1)
	self.vConstraint = vConstraint
	self.dy1 = dy1
end

function Widget:init(view, x, y, w, h)
	self.xOrig = x
	self.yOrig = y
	self.view = view
	self.x = x
	self.y = y
	self.w = w
	self.h = h
	self.acceptsFocus = false
	self.visible = true
	self.acceptsEnter = false
	self.acceptsEscape = false
	self.acceptsTab = false
	self.acceptsDelete = false
	self.acceptsBackSpace = false
	self.acceptsReturn = false
	self.acceptsArrowUp = false
	self.acceptsArrowDown = false
	self.acceptsArrowLeft = false
	self.acceptsArrowRight = false
	self.hConstraint = "left"
	self.vConstraint = "top"
    
end

function Widget:repos(x, y)
	self.x = x
	self.y = y
end

function Widget:resize(w, h)
	self.w = w
	self.h = h
end

function Widget:setFocus() end
function Widget:releaseFocus() end

function Widget:contains(x, y)
 
    return x >= self.x and x < self.x + self.w and y >= self.y and y < self.y + self.h
end

function Widget:onMouseEnter(x, y) end
function Widget:onMouseLeave(x, y) end
function Widget:paint(gc, focused) end
function Widget:enterHandler() end
function Widget:escapeHandler() end
function Widget:tabHandler() end
function Widget:deleteHandler() end
function Widget:backSpaceHandler() end
function Widget:returnHandler() end
function Widget:arrowUpHandler() end
function Widget:arrowDownHandler() end
function Widget:arrowLeftHandler() end
function Widget:arrowRightHandler() end
function Widget:onMouseDown(x, y) end
function Widget:onMouseUp(x, y) end

-- Button widget, for people who like clicking things.
Button = class(Widget)

function Button:init(view, x, y, w, h, default, command, shortcut)
	Widget.init(self, view, x, y, w, h)
	self.acceptsFocus = true
	self.command = command or function() end
	self.default = default
	self.shortcut = shortcut
	self.clicked = false
	self.highlighted = false
	self.acceptsEnter = true
end

function Button:enterHandler()
	if self.acceptsEnter then
		self:command()
	end
end

function Button:escapeHandler()
	if self.acceptsEscape then
		self:command()
	end
end

function Button:tabHandler()
	if self.acceptsTab then
		self:command()
	end
end

function Button:deleteHandler()
	if self.acceptsDelete then
		self:command()
	end
end

function Button:backSpaceHandler()
	if self.acceptsBackSpace then
		self:command()
	end
end

function Button:returnHandler()
	if self.acceptsReturn then
		self:command()
	end
end

function Button:arrowUpHandler()
	if self.acceptsArrowUp then
		self:command()
	end
end

function Button:arrowDownHandler()
	if self.acceptsArrowDown then
		self:command()
	end
end

function Button:arrowLeftHandler()
	if self.acceptsArrowLeft then
		self:command()
	end
end

function Button:arrowRightHandler()
	if self.acceptsArrowRight then
		self:command()
	end
end

function Button:onMouseDown(x, y)
	self.clicked = true
	self.highlighted = true
end

function Button:onMouseEnter(x, y)
	theView:setCursor("hand pointer")
	if self.clicked and not self.highlighted then
		self.highlighted = true
	end
end

function Button:onMouseLeave(x, y)
	theView:setCursor("default")
	if self.clicked and self.highlighted then
		self.highlighted = false
	end
end

function Button:cancelClick()
	if self.clicked then
		self.highlighted = false
		self.clicked = false
	end
end

function Button:onMouseUp(x, y)
	self:cancelClick()
	self:command()
end

function Button:addString(str)
	if str == " " or str == self.shortcut then
		self:command()
		return true
	end
	return false
end

-- Image label widget. Displays an image, does nothing else. The laziest widget.
ImgLabel = class(Widget)

function ImgLabel:init(view, x, y, img)
	self.img = image.new(img)
	self.w = image.width(self.img)
	self.h = image.height(self.img)
	Widget.init(self, view, x, y, self.w, self.h)
end

function ImgLabel:paint(gc, focused)
	gc:drawImage(self.img, self.x, self.y)
end

-- Image button widget. Like a button, but with more pixels.
ImgButton = class(Button)

function ImgButton:init(view, x, y, img, command, shortcut)
	self.img = image.new(img)
	self.w = image.width(self.img)
	self.h = image.height(self.img)
	Button.init(self, view, x, y, self.w, self.h, false, command, shortcut)
end

function ImgButton:paint(gc, focused)
	gc:drawImage(self.img, self.x, self.y)
end

-- Text button widget. For those who prefer words to icons.
TextButton = class(Button)

function TextButton:init(view, x, y, text, command, shortcut)
	self.textid = text
	self.text = getLocaleText(text)
	self:resize(0, 0)
	Button.init(self, view, x, y, self.w, self.h, false, command, shortcut)
end

function TextButton:resize(w, h)
	self.text = getLocaleText(self.textid)
	self.w = getStringWidth(self.text) + 5
	self.h = getStringHeight(self.text) + 5
end

function TextButton:paint(gc, focused)
	gc:setColorRGB(223, 223, 223)
	gc:drawRect(self.x + 1, self.y + 1, self.w - 2, self.h - 2)
	gc:setColorRGB(191, 191, 191)
	gc:fillRect(self.x + 1, self.y + 1, self.w - 3, self.h - 3)
	gc:setColorRGB(223, 223, 223)
	gc:drawString(self.text, self.x + 3, self.y + 3, "top")
	gc:setColorRGB(0, 0, 0)
	gc:drawString(self.text, self.x + 2, self.y + 2, "top")
	gc:drawRect(self.x, self.y, self.w - 2, self.h - 2)
end

-- Vertical scrollbar widget. Because scrolling through history is a thing.
VScrollBar = class(Widget)

function VScrollBar:init(view, x, y, w, h)
	self.pos = 10
	self.siz = 10
	Widget.init(self, view, x, y, w, h)
end

function VScrollBar:paint(gc, focused)
	gc:setColorRGB(0, 0, 0)
	gc:drawRect(self.x, self.y, self.w, self.h)
	gc:fillRect(self.x + 2, self.y + self.h - (self.h - 4) * (self.pos + self.siz) / 100 - 2, self.w - 3, math.max(1, (self.h - 4) * self.siz / 100 + 1))
end

-- Text label widget. It just sits there and looks pretty.
TextLabel = class(Widget)

function TextLabel:init(view, x, y, text)
	self:setText(text)
	Widget.init(self, view, x, y, self.w, self.h)
end

function TextLabel:resize(w, h)
	self.text = getLocaleText(self.textid)
	self.w = getStringWidth(self.text)
	self.h = getStringHeight(self.text)
end

function TextLabel:setText(text)
	self.textid = text
	self.text = getLocaleText(text)
	self:resize(0, 0)
end

function TextLabel:getText()
	return self.text
end

function TextLabel:paint(gc, focused)
	gc:setColorRGB(0, 0, 0)
	gc:drawString(self.text, self.x, self.y, "top")
end
-- TextBox widget for text input
TextBox = class(Widget)
function TextBox:init(view, x, y, w, h, text)
    self.text = text or ""
    self.cursor = #self.text
    self.focused = false
    self.acceptsFocus = true
    self.acceptsChar = true
    self.acceptsBackspace = true
    self.acceptsEnter = true
    Widget.init(self, view, x, y, w, h)
end

function TextBox:paint(gc, focused)
    -- Draw border
    gc:setColorRGB(0, 0, 0)
    gc:drawRect(self.x, self.y, self.w, self.h)
    
    -- Draw background
    if focused then
        gc:setColorRGB(255, 255, 255)
    else
        gc:setColorRGB(240, 240, 240)
    end
    gc:fillRect(self.x + 1, self.y + 1, self.w - 2, self.h - 2)
    
    -- Draw text
    gc:setColorRGB(0, 0, 0)
    gc:drawString(self.text, self.x + 3, self.y + 3, "top")
    
    -- Draw cursor if focused
    if focused then
        local cursorX = self.x + 3 + getStringWidth(string.sub(self.text, 1, self.cursor))
        gc:drawLine(cursorX, self.y + 2, cursorX, self.y + self.h - 3)
    end
end

function TextBox:charIn(char)
    self.text = string.sub(self.text, 1, self.cursor) .. char .. string.sub(self.text, self.cursor + 1)
    self.cursor = self.cursor + 1
    self.view:invalidate()
end

function TextBox:backspaceKey()
    if self.cursor > 0 then
        self.text = string.sub(self.text, 1, self.cursor - 1) .. string.sub(self.text, self.cursor + 1)
        self.cursor = self.cursor - 1
        self.view:invalidate()
    end
end

function TextBox:setText(text)
    self.text = text or ""
    self.cursor = #self.text
    self.view:invalidate()
end

function TextBox:getText()
    return self.text
end

-- CheckBox widget
CheckBox = class(Widget)
function CheckBox:init(view, x, y, text, checked)
    self.textid = text
    self.text = getLocaleText(text)
    self.checked = checked or false
    self.acceptsFocus = true
    self.acceptsEnter = true
    
    local boxSize = 12
    local textWidth = getStringWidth(self.text)
    local w = boxSize + 5 + textWidth
    local h = math.max(boxSize, getStringHeight(self.text))
    
    Widget.init(self, view, x, y, w, h)
end

function CheckBox:paint(gc, focused)
    local boxSize = 12
    
    -- Draw checkbox
    gc:setColorRGB(0, 0, 0)
    gc:drawRect(self.x, self.y, boxSize, boxSize)
    gc:setColorRGB(255, 255, 255)
    gc:fillRect(self.x + 1, self.y + 1, boxSize - 2, boxSize - 2)
    
    -- Draw check mark if checked
    if self.checked then
        gc:setColorRGB(0, 0, 0)
        gc:drawLine(self.x + 2, self.y + 6, self.x + 5, self.y + 9)
        gc:drawLine(self.x + 5, self.y + 9, self.x + 10, self.y + 3)
    end
    
    -- Draw text
    gc:setColorRGB(0, 0, 0)
    gc:drawString(self.text, self.x + boxSize + 5, self.y, "top")
    
    -- Draw focus indicator
    if focused then
        gc:setColorRGB(0, 0, 255)
        gc:drawRect(self.x - 1, self.y - 1, self.w + 2, self.h + 2)
    end
end

function CheckBox:enterKey()
    self.checked = not self.checked
    self.view:invalidate()
end

-- --- START OF CHANGE ---
-- Renamed from CheckBox:mouseDown to CheckBox:onMouseUp
function CheckBox:onMouseUp(x, y)
    print("CheckBox:onMouseUp called for:", self.text)
    print("Received x:", x, " type:", type(x))
    print("Received y:", y, " type:", type(y))
    print("Before toggle, checked:", self.checked)
    self.checked = not self.checked
    print("After toggle, checked:", self.checked)
    self.view:invalidate()
    print("View invalidated.")
end
-- --- END OF CHANGE ---

-- Dialog base class, inheriting from Widget
Dialog = class(Widget)
function Dialog:init(view, config)
    -- Default configuration values for the dialog
    local title = config.title or "Dialog"
    local w = config.width or 300
    local h = config.height or 200
    local elements = config.elements or {}
    self.onClose = config.onClose -- Store the custom onClose function

    -- Calculate dialog position to be centered on the screen
    local x = math.floor((platform.window:width() - w) / 2)
    local y = math.floor((platform.window:height() - h) / 2)

    -- Initialize the base Widget properties
    Widget.init(self, view, x, y, w, h)

    self.title = title
    self.modal = true         -- Dialog is modal, meaning it captures all input
    self.visible = true       -- Dialog starts as visible
    self.acceptsFocus = true  -- Dialog can gain keyboard focus
    self.acceptsEscape = true -- Allow Escape key to close the dialog
    self.widgets = {}         -- Table to hold child widgets managed by this dialog
    self.result = nil         -- To store dialog's return value (e.g., true for OK, false for Cancel)
    self.namedWidgets = {}    -- NEW: Table to store child widgets by their 'name' property

    for i, elem_config in ipairs(elements) do
        local widget
        -- Instantiate widget types based on their 'type' property in the config
        if elem_config.type == "TextLabel" then
            widget = TextLabel(view, elem_config.x, elem_config.y, elem_config.text)
        elseif elem_config.type == "TextButton" then
            local original_command = elem_config.command or function(dlg_ref, btn_ref) end -- Default command, receives dialog and button
            widget = TextButton(view, elem_config.x, elem_config.y, elem_config.text,
                function(btn_self) -- 'btn_self' is the TextButton instance being clicked
                    -- Pass the dialog instance (self) and the button instance (btn_self) to the original command
                    original_command(self, btn_self)
                    -- If the button is configured to close the dialog, call close()
                    if elem_config.closesDialog then
                        self:close(true)
                    end
                end)
        elseif elem_config.type == "CheckBox" then
            widget = CheckBox(view, elem_config.x, elem_config.y, elem_config.text, elem_config.checked)
            -- The existing special handling for checkbox by 'checkbox_' prefix can remain or be unified
        end

        -- If a widget was successfully created, add it to the dialog's managed widgets
        if widget then
            self:addWidget(widget)
            -- NEW: Store a reference to the widget by its 'name' property for easy access
            if elem_config.name then
                self.namedWidgets[elem_config.name] = widget
            end
        end
    end
end

-- Paint method for the Dialog. This draws the dialog frame and its contents.
function Dialog:paint(gc, focused)
    -- Draw a subtle shadow effect
    gc:setColorRGB(128, 128, 128)
    gc:fillRect(self.x + 3, self.y + 3, self.w, self.h)

    -- Draw dialog background (light gray)
    gc:setColorRGB(240, 240, 240)
    gc:fillRect(self.x, self.y, self.w, self.h)

    -- Draw dialog border (black)
    gc:setColorRGB(0, 0, 0)
    gc:drawRect(self.x, self.y, self.w, self.h)

    -- Draw title bar (dark blue)
    gc:setColorRGB(0, 0, 128)
    gc:fillRect(self.x + 1, self.y + 1, self.w - 2, 20)
    gc:setColorRGB(255, 255, 255) -- White text for title
    gc:drawString(self.title, self.x + 5, self.y + 4, "top")

    -- Draw a line under the title bar
    gc:setColorRGB(0, 0, 0)
    gc:drawLine(self.x + 1, self.y + 21, self.x + self.w - 2, self.y + 21)

    -- Paint all child widgets relative to the dialog's position
    for _, widget in ipairs(self.widgets) do
        if widget.visible then
            -- Pass the correct focused state to the child widget
            local is_child_focused = (self.view:getFocus() == widget)
            widget:paint(gc, is_child_focused)
        end
    end
end

-- Adds a child widget to the dialog's management.
function Dialog:addWidget(widget)
    table.insert(self.widgets, widget)
    widget.parent = self -- Set the dialog as the widget's parent
    -- Adjust widget's position to be relative to the dialog's top-left corner
    -- assuming widget.xOrig and widget.yOrig store initial offsets from dialog
    widget.x = self.x + widget.xOrig
    widget.y = self.y + widget.yOrig
    self.view:add(widget)     -- Crucial: Add the child widget to the main view for event handling
    self.view:repos(widget)   -- Ask the view to reposition it if necessary (e.g., for layout constraints)
end

-- Activates the dialog, making it visible and focusable.
function Dialog:activate()
    self.visible = true
    -- Set this dialog as the active modal dialog for the view
    self.view.activeModalDialog = self -- ADD THIS LINE

    -- Set focus to the first focusable widget within the dialog (for keyboard nav)
    for _, widget in ipairs(self.widgets) do
        if widget.acceptsFocus then
            self.view:setFocus(widget)
            break
        end
    end
    self.view:invalidate() -- Request a screen redraw
end

-- Closes the dialog, making it invisible and removing its widgets from the view.
function Dialog:close(result)
    self.result = result
    self.visible = false
    -- Remove the dialog itself from the main view's tracking
    self.view:remove(self)
    -- Remove all child widgets from the main view's tracking
    for _, widget in ipairs(self.widgets) do
        self.view:remove(widget)
    end
    -- Call the custom onClose callback function if provided
    if self.onClose then
        self.onClose(self, result)
    end
    self.view:invalidate() -- Request a screen redraw
end

-- In your Dialog class definition (e.g., in gui.lua or dialog.lua)

-- Corrected Dialog:onMouseDown
function Dialog:onMouseDown(x, y)
    -- Iterate through widgets from top to bottom (reverse order)
    for i = #self.widgets, 1, -1 do
        local widget = self.widgets[i]
        -- Check if widget is visible, accepts focus, and contains the click coordinates
        if widget.visible and widget.acceptsFocus and widget:contains(x, y) then
            -- If the widget has its own onMouseDown handler, call it, passing coordinates relative to the widget
            if widget.onMouseDown then
                widget:onMouseDown(x - widget.x, y - widget.y)
            end
            -- Set focus to the clicked widget and invalidate the window for redraw
            self.view:setFocus(widget)
            self.view:invalidate()
            return -- Exit after handling the click on one widget
        end
    end
    -- If no child widget was clicked, check if the dialog itself was clicked
    if self:contains(x, y) then
        self.view:setFocus(self)
        self.view:invalidate()
    end
end

-- Corrected Dialog:onMouseUp
function Dialog:onMouseUp(x, y)
    -- Iterate through widgets from top to bottom (reverse order)
    for i = #self.widgets, 1, -1 do
        local widget = self.widgets[i]
        -- Check if widget is visible, contains the release coordinates, and has an onMouseUp handler
        if widget.visible and widget:contains(x, y) and widget.onMouseUp then
            -- Call the widget's onMouseUp handler, passing relative coordinates and whether it was released inside
            widget:onMouseUp(x - widget.x, y - widget.y, widget:contains(x,y))
            return -- Exit after handling the release on one widget
        end
    end
end

-- Handles the Escape key press for the dialog (if acceptsEscape is true).
function Dialog:escapeHandler()
    if self.acceptsEscape then
        self:close(false) -- False indicates dialog was cancelled/escaped
    end
end
-- Closes the dialog, making it invisible and removing its widgets from the view.
function Dialog:close(result)
    self.result = result
    self.visible = false

    -- CRITICAL FIX: Reset the active modal dialog in the view
    if self.view.activeModalDialog == self then
        self.view.activeModalDialog = nil
    end

    -- Remove the dialog itself from the main view's tracking
    self.view:remove(self)

    -- Remove all child widgets from the main view's tracking
    for _, widget in ipairs(self.widgets) do
        self.view:remove(widget)
    end

    -- Call the custom onClose callback function if provided
    if self.onClose then
        self.onClose(self, result)
    end
    self.view:invalidate() -- Request a screen redraw
end


MenuWidget = class(Widget)

function MenuWidget:init(view, x, y, items, onSelect)
    local w = 120
    local h = #items * 22
    Widget.init(self, view, x, y, w, h)
    self.items = items or {}
    self.selected = 1
    self.onSelect = onSelect or function(idx, text) end
    self.visible = true
    self.acceptsFocus = true
    self.acceptsArrowUp = true
    self.acceptsArrowDown = true
    self.acceptsEnter = true
    self.acceptsEscape = true
    self.muted = false
    self.submenus = nil
end

function MenuWidget:paint(gc, focused)
    if not self.visible then return end

    -- Menu background - because invisible menus are so last century
    local bgColor = _G.darkMode and {40, 40, 40} or {255, 255, 255}
    if self.muted then for i=1,3 do bgColor[i] = bgColor[i] * 0.6 end end
    gc:setColorRGB(table.unpack(bgColor))
    gc:fillRect(self.x, self.y, self.w, self.h)

    -- Menu border - the thin line between chaos and order
    gc:setColorRGB(0, 0, 0)
    gc:drawRect(self.x, self.y, self.w, self.h)

    -- Menu items - the actual reason this thing exists
    for i, text in ipairs(self.items) do
        local itemY = self.y + (i-1) * 22

        -- Highlight selected item
        if i == self.selected then
            gc:setColorRGB(180, 200, 255)
            gc:fillRect(self.x + 1, itemY + 1, self.w - 2, 20)
        end

        gc:setFont("sansserif", "r", 11)
        gc:setColorRGB(_G.darkMode and 180 or 32, _G.darkMode and 180 or 32, _G.darkMode and 210 or 32)

        -- Decorative Icon on root menu only
        if self.level == 1 then
            -- Precise vertical centering for icon and text
            local iconX = self.x + 6
            local iconText = ""
            if text == "Calculus" then
                iconText = "∫"
            elseif text == "Solve" then
                iconText = "x"
            elseif text == "Settings" then
                iconText = "S"
            elseif text == "Help" then
                iconText = "?"
            end
            gc:setFont("sansserif", "b", 10)
            local ih = gc:getStringHeight(iconText)
            gc:setFont("sansserif", "r", 11)
            local th = gc:getStringHeight(text)
            local iconY = itemY + (th - ih) / 2 - 1
            gc:setFont("sansserif", "b", 10)
            gc:drawString(iconText, iconX, iconY, "top")
            gc:setFont("sansserif", "r", 11)
            gc:drawString(text, self.x + 22, itemY - 1, "top")
        else
            gc:drawString(text, self.x + 12, itemY - 1, "top")
        end

        if self.submenus and self.submenus[text] then
            gc:setFont("sansserif","b",11)
            local arrowCol = _G.darkMode and {200,200,200} or {64,64,64}
            gc:setColorRGB(table.unpack(arrowCol))
            gc:drawString("▶", self.x + self.w - 12, itemY - 1, "top")
        end
    end
end

function MenuWidget:onMouseDown(view, window, x, y)
    if not self:contains(x + self.x, y + self.y) then return end
    
    local relY = y
    local idx = math.floor(relY / 22) + 1
    
    if idx >= 1 and idx <= #self.items then
        self.selected = idx
        if self.onSelect then 
            self.onSelect(idx, self.items[idx]) 
        end
    end
    
    local text = self.items[self.selected]
    -- Only hide when there is no submenu for this item
    if not (self.submenus and self.submenus[text]) then
        self.visible = false
        if self.view and self.view.invalidate then
            self.view:invalidate()
        end
    end
end

function MenuWidget:arrowUpHandler()
    self.selected = math.max(1, self.selected - 1)
    if self.view and self.view.invalidate then
        self.view:invalidate()
    end
end

function MenuWidget:arrowDownHandler()
    self.selected = math.min(#self.items, self.selected + 1)
    if self.view and self.view.invalidate then
        self.view:invalidate()
    end
end

function MenuWidget:enterHandler()
    if self.onSelect then 
        self.onSelect(self.selected, self.items[self.selected]) 
    end
    self.visible = false
    if self.view and self.view.invalidate then 
        self.view:invalidate() 
    end
end

function MenuWidget:escapeHandler()
    self.visible = false
    if self.view and self.view.invalidate then 
        self.view:invalidate() 
    end
end
-- Rich text editor widget. Handles text entry, but don't expect Microsoft Word.
RichTextEditor = class(Widget)

function RichTextEditor:init(view, x, y, w, h, text)
	self.editor = D2Editor.newRichText()
	self.readOnly = false
	self:repos(x, y)
	self.editor:setFontSize(fsize)
	self.editor:setFocus(false)
	self.text = text
	self:resize(w, h)
	Widget.init(self, view, x, y, self.w, self.h, true)
	self.acceptsFocus = true
	self.editor:setExpression(text)
	self.editor:setBorder(1)
end

function RichTextEditor:onMouseEnter(x, y)
	theView:setCursor("text")
end

function RichTextEditor:onMouseLeave(x, y)
	theView:setCursor("default")
end

function RichTextEditor:repos(x, y)
	if not self.editor then return end
	self.editor:setBorderColor((showEditorsBorders and 0) or 0xffffff )
	self.editor:move(x, y)
	Widget.repos(self, x, y)
end

function RichTextEditor:resize(w, h)
	if not self.editor then return end
	self.editor:resize(w, h)
	Widget.resize(self, w, h)
end

function RichTextEditor:setFocus()
	self.editor:setFocus(true)
end

function RichTextEditor:releaseFocus()
	self.editor:setFocus(false)
end

function RichTextEditor:addString(str)
	local currentText = self.editor:getText() or ""
	self.editor:setText(currentText .. str)
	return true
end

function RichTextEditor:paint(gc, focused) end

-- MathEditor: a rich text editor with math-specific quirks and a love for Unicode.
MathEditor = class(RichTextEditor)

-- Returns the number of Unicode codepoints in a string.
-- Because Lua strings are byte-based and Unicode is hard.
function ulen(str)
	if not str then return 0 end
	local n = string.len(str)
	local i = 1
	local j = 1
	local c
	while (j <= n) do
		c = string.len(string.usub(str, i, i))
		j = j + c
		i = i + 1
	end
	return i - 1
end

-- Initialize a MathEditor, set up filters for key events, and generally make life complicated.
function MathEditor:init(view, x, y, w, h, text)
	RichTextEditor.init(self, view, x, y, w, h, text)
	self.editor:setBorder(1)
    -- Set dark/light mode colors at initialization, safely and consistently
    if self.editor then
        local areaBg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
        local areaBorder = _G.darkMode and {100, 100, 100} or {0, 0, 0}
        local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
        if self.editor.setBackgroundColor then
            self.editor:setBackgroundColor(table.unpack(areaBg))
        end
        if self.editor.setTextColor then
            self.editor:setTextColor(table.unpack(text))
        end
        if self.editor.setBorderColor then
            self.editor:setBorderColor(table.unpack(areaBorder))
        end
        if self.editor.setOpaque then
            self.editor:setOpaque(true)
        end
    end
	self.acceptsEnter = true
	self.acceptsBackSpace = true
	self.result = false
	self.editor:registerFilter({
		arrowLeft = function()
			_, curpos = self.editor:getExpressionSelection()
			if curpos < 7 then
				on.arrowLeft()
				return true
			end
			return false
		end,
		arrowRight = function()
			currentText, curpos = self.editor:getExpressionSelection()
			if curpos > ulen(currentText) - 2 then
				on.arrowRight()
				return true
			end
			return false
		end,
		tabKey = function()
			theView:tabForward()
			return true
		end,
		mouseDown = function(x, y)
			theView:onMouseDown(x, y)
			return false
		end,
		backspaceKey = function()
			if (self == fctEditor) then
				self:fixCursor()
				_, curpos = self.editor:getExpressionSelection()
				if curpos <= 6 then return true end
				return false
			else
				self:backSpaceHandler()
				return true
			end
		end,
		deleteKey = function()
			if (self == fctEditor) then
				self:fixCursor()
				currentText, curpos = self.editor:getExpressionSelection()
				if curpos >= ulen(currentText) - 1 then return true end
				return false
			else
				self:backSpaceHandler()
				return true
			end
		end,
		enterKey = function()
			self:enterHandler()
			return true
		end,
		returnKey = function()
			theView:enterHandler()
			return true
		end,
		escapeKey = function()
			on.escapeKey()
			return true
		end,
		charIn = function(c)
			if (self == fctEditor) then
				self:fixCursor()
				return false
			else
				return self.readOnly
			end
		end
	})
end

-- Ensures the editor has a math box at all times.
function MathEditor:fixContent()
	local currentText = self.editor:getExpressionSelection()
	if currentText == "" or currentText == nil then
		self.editor:createMathBox()
	end
end

-- Make sure the cursor stays inside the editable region of the Unicode string.
-- D2Editor likes to insert special tokens at the start, so we have to skip the first 6 codepoints.
-- If the cursor escapes the allowed range, forcibly drag it back, because users can't be trusted.
function MathEditor:fixCursor()
	local currentText, curpos, selstart = self.editor:getExpressionSelection()
	local l = ulen(currentText)
	if curpos < 6 or selstart < 6 or curpos > l - 1 or selstart > l - 1 then
		if curpos < 6 then curpos = 6 end
		if selstart < 6 then selstart = 6 end
		if curpos > l - 1 then curpos = l - 1 end
		if selstart > l - 1 then selstart = l - 1 end
		self.editor:setExpression(currentText, curpos, selstart)
	end
end

-- Extract the user-entered expression from the D2Editor string, skipping any special formatting.
function MathEditor:getExpression()
	if not self.editor then return "" end
	local rawexpr = self.editor:getExpression()
	local expr = ""
	local n = string.len(rawexpr)
	local b = 0
	local bs = 0
	local bi = 0
	local status = 0
	local i = 1
	while i <= n do
		local c = string.sub(rawexpr, i, i)
		if c == "{" then
			b = b + 1
		elseif c == "}" then
			b = b - 1
		end
		if status == 0 then
			if string.sub(rawexpr, i, i + 5) == "\\0el {" then
				bs = i + 6
				i = i + 5
				status = 1
				bi = b
				b = b + 1
			end
		else
			if b == bi then
				status = 0
				expr = expr .. string.sub(rawexpr, bs, i - 1)
			end
		end
		i = i + 1
	end
	return expr
end

-- Set focus to the math editor, so it can feel important.
function MathEditor:setFocus()
	if not self.editor then return end
	self.editor:setFocus(true)
end

-- Remove focus from the math editor, so it can sulk in the corner.
function MathEditor:releaseFocus()
	if not self.editor then return end
	self.editor:setFocus(false)
end

-- Inserts text at the cursor. Assumes user knows what they’re doing. (They probably don’t.)
function MathEditor:addString(str)
	if not self.editor then return false end
	self:fixCursor()
	-- Unicode string slicing: because normal string.sub just isn't enough.
	local currentText, curpos, selstart = self.editor:getExpressionSelection()
	local newText = string.usub(currentText, 1, math.min(curpos, selstart)) .. str .. string.usub(currentText, math.max(curpos, selstart) + 1, ulen(currentText))
	self.editor:setExpression(newText, math.min(curpos, selstart) + ulen(str))
	return true
end

-- Handle backspace. (No-op for now, because history deletion is scary.)
function MathEditor:backSpaceHandler()
    -- No-op or custom deletion logic (history removal not implemented)
end

-- Handle enter key. Just delegates to the real handler.
function MathEditor:enterHandler()
    -- Call the custom on.enterKey handler instead of missing global
    on.enterKey()
end

-- Draws horizontal lines under the editor, if we're feeling fancy.
function MathEditor:paint(gc)
	if showHLines and not self.result then
		gc:setColorRGB(100, 100, 100)
		local ycoord = self.y - (showEditorsBorders and 0 or 2)
		gc:drawLine(1, ycoord, platform.window:width() - sbv.w - 2, ycoord)
		gc:setColorRGB(0, 0, 0)
	end
end

function on.arrowUp()
    if _G.menuStack and #_G.menuStack > 0 then
        local m = _G.menuStack[#_G.menuStack]
        m:arrowUpHandler()
        return
    end
  if theView then
    if theView:getFocus() == fctEditor then
      on.tabKey()
    else
      on.tabKey()
      if theView:getFocus() ~= fctEditor then on.tabKey() end
    end
    reposView()
  end
end

function on.arrowDown()
    if _G.menuStack and #_G.menuStack > 0 then
        local m = _G.menuStack[#_G.menuStack]
        m:arrowDownHandler()
        return
    end
  if theView then
    on.backtabKey()
    if theView:getFocus() ~= fctEditor then on.backtabKey() end
    reposView()
  end
end

function on.arrowLeft()
    if _G.menuStack and #_G.menuStack > 0 then
        local depth = #_G.menuStack
        local m = _G.menuStack[depth]
        theView:remove(m)
        table.remove(_G.menuStack, depth)
        if _G.menuStack and #_G.menuStack > 0 then
            _G.menuStack[#_G.menuStack].muted = false
            theView:setFocus(_G.menuStack[#_G.menuStack])
        else
            _G.menuStack = nil
        end
        theView:invalidate()
        return
    end
  if theView then
    on.tabKey()
    reposView()
  end
end

function on.arrowRight()
    if _G.menuStack and #_G.menuStack > 0 then
        local m = _G.menuStack[#_G.menuStack]
        local idx = m.selected
        local text = m.items[idx]
        if m.onSelect then m.onSelect(idx, text) end
        return
    end
  if theView then
    on.backtabKey()
    reposView()
  end
end

function on.charIn(ch)
    if _G.showSettingsModal and _G.precisionInputActive and ch:match("%d") then
        var.store("nLuaCAS_precision_pref", tonumber(ch))
        _G.precisionInputActive = false
        platform.window:invalidate()
        return
    end
    if theView then theView:sendStringToFocus(ch) end
end

function on.tabKey()
  if theView then theView:tabForward(); reposView() end
end

function on.backtabKey()
  if theView then theView:tabBackward(); reposView() end
end

function on.enterKey()
    -- If a menu is open, treat Enter as submenu/selection trigger
    if _G.menuStack and #_G.menuStack > 0 then
        on.arrowRight()
        return
    end
  if not fctEditor or not fctEditor.getExpression then return end

  -- Recall the current constant category (do not set default here)
  local recalled = var.recall and var.recall("current_constant_category")
  if recalled ~= nil then
    current_constant_category = recalled
    print("[INIT] Recalled constant category: " .. tostring(current_constant_category))
  else
    print("[INIT] Recall failed or value was nil; skipping default set")
  end

  local input = fctEditor:getExpression()
  -- Check for custom snarky responses
  local joke = _G.errors.get(input)
  if joke then
    result = joke
    addME(input, result, "normal")
    if fctEditor and fctEditor.editor then
      fctEditor.editor:setText("")
      fctEditor:fixContent()
    end
    if platform and platform.window and platform.window.invalidate then
      platform.window:invalidate()
    end
    return
  end
  -- Fix TI-style derivative notation like ((d)/(dx(x^2))) to diff(x^2, x)
  input = input:gsub("%(%(d%)%)%/%(d([a-zA-Z])%((.-)%)%)%)", function(var, inner)
    _G.__diff_var = var
    return inner
  end)
  if not input or input == "" then return end

  -- Remove all whitespace from input
  input = input:gsub("%s+", "")

  local result = ""
  _G.luaCASerror = false
  local function get_constant_value(fname)
    local physics_constants = _G.physics_constants or {}
    local avail = var.recall and var.recall("available_constants") or {}
    local is_enabled = (avail == nil) or (avail[fname] == true)
    -- Retrieve current category for this resolution
    local cat = var.recall and var.recall("current_constant_category")
    print("[DEBUG] Category set to:", tostring(cat))
    if physics_constants[fname]
      and is_enabled
      and physics_constants[fname].category == cat then
      return physics_constants[fname].value
    end
    return nil
  end
  local function eval_physics_func(fname)
    local physics_constants = _G.physics_constants or {}
    local avail = var.recall and var.recall("available_constants") or {}
    local is_enabled = (avail == nil) or (avail[fname] == true)
    -- Retrieve current category for this resolution
    local cat = var.recall and var.recall("current_constant_category")
    print("[DEBUG] Category set to:", tostring(cat))
    if physics_constants[fname]
      and is_enabled
      and physics_constants[fname].category == cat then
      return physics_constants[fname].value
    end
    return nil
  end

  local success, err = pcall(function()
    if input:sub(1,4) == "d/dx" or input:sub(1,4) == "d/dy" then
      local expr = input:match("d/d[xy]%((.+)%)")
      result = expr and derivative(expr, _G.__diff_var) or errors.invalid("diff")
      if result == errors.invalid("diff") then _G.luaCASerror = true end
    elseif input:sub(1,5) == "∂/∂x(" and input:sub(-1) == ")" then
      local expr = input:match("∂/∂x%((.+)%)")
      result = expr and derivative(expr, _G.__diff_var) or errors.invalid("diff")
      if result == errors.invalid("diff") then _G.luaCASerror = true end
    elseif input:match("^∂/∂[yz]%(.+%)$") then
      result = derivative(input, _G.__diff_var)
    elseif input:sub(1,3) == "∫(" and input:sub(-2) == ")x" then
      result = integrate(parse(input:sub(4, -3)))
    elseif input:sub(1,6) == "solve(" and input:sub(-1) == ")" then
      local eqn = input:match("solve%((.+)%)")
      if eqn and not eqn:find("=") then
        eqn = eqn .. "=0"
      end
      result = eqn and solve(parse(eqn)) or errors.invalid("solve")
      if result == errors.invalid("solve") then _G.luaCASerror = true end
    elseif input:sub(1,4) == "let" then
      result = define(input)
    elseif input:sub(1,7) == "expand(" and input:sub(-1) == ")" then
        local inner = input:match("expand%((.+)%)")
        result = inner and expand(parse(inner)) or errors.invalid("expand")
        if result == errors.invalid("expand") then _G.luaCASerror = true end
    elseif input:sub(1,5) == "subs(" and input:sub(-1) == ")" then
        local inner, varname, val = input:match("subs%(([^,]+),([^,]+),([^%)]+)%)")
        result = (inner and varname and val) and subs(parse(inner), varname, val) or errors.invalid("subs")
        if result == errors.invalid("subs") then _G.luaCASerror = true end
    elseif input:sub(1,7) == "factor(" and input:sub(-1) == ")" then
        local inner = input:match("factor%((.+)%)")
        result = inner and factor(parse(inner)) or errors.invalid("factor")
        if result == errors.invalid("factor") then _G.luaCASerror = true end
    elseif input:sub(1,4) == "gcd(" and input:sub(-1) == ")" then
        local a, b = input:match("gcd%(([^,]+),([^%)]+)%)")
        result = (a and b) and gcd(parse(a), parse(b)) or errors.invalid("gcd")
        if result == errors.invalid("gcd") then _G.luaCASerror = true end
    elseif input:sub(1,4) == "lcm(" and input:sub(-1) == ")" then
        local a, b = input:match("lcm%(([^,]+),([^%)]+)%)")
        result = (a and b) and lcm(parse(a), parse(b)) or errors.invalid("lcm")
        if result == errors.invalid("lcm") then _G.luaCASerror = true end
    elseif input:sub(1,7) == "trigid(" and input:sub(-1) == ")" then
        local inner = input:match("trigid%((.+)%)")
        result = inner and trigid(parse(inner)) or errors.invalid("trigid")
        if result == errors.invalid("trigid") then _G.luaCASerror = true end
    elseif input:match("%w+%(.+%)") then
      print("[DEBUG] Category set to:", var.recall("current_constant_category"))
      result = simplify.simplify(parse(input))
    elseif input:sub(1,9) == "simplify(" and input:sub(-1) == ")" then
      local inner = input:match("simplify%((.+)%)")
      print("[DEBUG] Category set to:", var.recall("current_constant_category"))
      result = inner and simplify.simplify(parse(inner)) or errors.invalid("simplify")
      if result == errors.invalid("simplify") then _G.luaCASerror = true end
    -- Fallback parser for diff(...) and integrate(...)
    elseif input:match("^diff%(([^,]+),([^,%)]+)%)$") then
      local a, b = input:match("^diff%(([^,]+),([^,%)]+)%)$")
      result = (a and b) and derivative(parse(a), b) or errors.invalid("diff")
      if result == errors.invalid("diff") then _G.luaCASerror = true end
    elseif _G.__diff_var then
      result = derivative(input, _G.__diff_var)
      _G.__diff_var = nil
    elseif input:match("^integrate%(([^,]+),([^,%)]+)%)$") then
      local a, b = input:match("^integrate%(([^,]+),([^,%)]+)%)$")
      result = (a and b) and integrate(parse(a), b) or errors.invalid("int")
      if result == errors.invalid("int") then _G.luaCASerror = true end
    else
      -- Try constant resolution
      local constval = get_constant_value(input)
      if constval ~= nil then
        result = constval
      else
        print("[DEBUG] Category set to:", var.recall("current_constant_category"))
        result = simplify.simplify(parse(input))
      end
    end
    if result == "" or not result then
      result = "No result. Internal CAS fallback used."
    end
  end)
  if not success then
    result = "Error: " .. tostring(err)
    _G.luaCASerror = true
  end

  -- Add to history display
  local colorHint = (_G.luaCASerror and "error") or "normal"
  addME(input, result, colorHint)

  -- Clear the input editor and ready for next input
  if fctEditor and fctEditor.editor then
    fctEditor.editor:setText("")
    fctEditor:fixContent()
  end

  -- Redraw UI
  if platform and platform.window and platform.window.invalidate then
    platform.window:invalidate()
  end

  -- Optionally save last result globally if needed
  if type(result) == "table" then
    if _G.ast and _G.ast.tostring then
      result = _G.ast.tostring(result)
    else
      result = "(unrenderable result)"
    end
  end
  res = result
end

function on.returnKey()
  on.enterKey()
end
function Dialog:paint(gc, focused)
    -- Draw shadow
    gc:setColorRGB(128, 128, 128)
    gc:fillRect(self.x + 3, self.y + 3, self.w, self.h)

    -- Draw dialog background
    gc:setColorRGB(240, 240, 240)
    gc:fillRect(self.x, self.y, self.w, self.h)

    -- Draw border
    gc:setColorRGB(0, 0, 0)
    gc:drawRect(self.x, self.y, self.w, self.h)

    -- Draw title bar
    gc:setColorRGB(0, 0, 128)
    gc:fillRect(self.x + 1, self.y + 1, self.w - 2, 20)
    gc:setColorRGB(255, 255, 255)
    gc:drawString(self.title, self.x + 5, self.y + 4, "top")

    -- Draw title bar border
    gc:setColorRGB(0, 0, 0)
    gc:drawLine(self.x + 1, self.y + 21, self.x + self.w - 2, self.y + 21)

    -- Paint child widgets (from the dialog's perspective)
    for _, widget in ipairs(self.widgets) do
        if widget.visible then
            -- Pass the correct focused state for the child widget
            local is_child_focused = (self.view:getFocus() == widget)
            widget:paint(gc, is_child_focused)
        end
    end
end

function Dialog:addWidget(widget)
    table.insert(self.widgets, widget)
    widget.parent = self -- Set the dialog as the widget's parent
    -- Adjust widget's position relative to the dialog's top-left corner
    -- This assumes widgets are added with their absolute coordinates, then adjusted.
    widget.x = self.x + widget.xOrig
    widget.y = self.y + widget.yOrig
    self.view:add(widget) -- Add to main view for global event handling
    self.view:repos(widget) -- Reposition in case constraints are set
end

function Dialog:activate()
    self.visible = true
    -- No need to self.view:add(self) here if it's already added in on.paint if not existing.
    -- Set focus to the first focusable widget within the dialog if available
    for _, widget in ipairs(self.widgets) do
        if widget.acceptsFocus then
            self.view:setFocus(widget)
            break
        end
    end
    self.view:invalidate()
end

function Dialog:close(result)
    self.result = result
    self.visible = false
    -- Remove dialog and its child widgets from the main view's tracking
    self.view:remove(self) -- Remove dialog itself from view's widgetList/focusList
    for _, widget in ipairs(self.widgets) do
        self.view:remove(widget) -- Remove child widgets from view
    end
    if self.onClose then
        self.onClose(self, result)
    end
    self.view:invalidate()
end

function Dialog:onMouseDown(x, y)
    -- Check if click is on dialog itself
    if self:contains(x, y) then
        -- Pass event to child widgets
        for i = #self.widgets, 1, -1 do -- Iterate in reverse for topmost widget
            local widget = self.widgets[i]
            if widget.visible and widget:contains(x, y) and widget.acceptsMouse then
                widget:onMouseDown(x, y)
                self.view:setFocus(widget) -- Set focus to the clicked widget
                return
            end
        end
    end
end

function Dialog:onMouseUp(x, y)
    -- Pass event to child widgets
    for i = #self.widgets, 1, -1 do -- Iterate in reverse for topmost widget
        local widget = self.widgets[i]
        if widget.visible and widget:contains(x, y) and widget.onMouseUp then
            widget:onMouseUp(x, y)
            return
        end
    end
end

function Dialog:escapeHandler()
    -- If escape is pressed, close the dialog
    self:close(false) -- False indicates cancellation or escape
end
function on.mouseMove(x, y)
  if theView then theView:onMouseMove(x, y) end
end

function on.mouseDown(x, y)
  -- Modal close "X" button
  if _G.showSettingsModal and _G.modalCloseBtnRegion then
    local r = _G.modalCloseBtnRegion
    if x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
      _G.showSettingsModal = false
      platform.window:invalidate()
      return
    end
  end
  -- Close help modal and block background clicks
  if _G.showHelpModal then
      local r = _G.helpModalCloseBtnRegion
      if r and x>=r.x and x<=r.x+r.w and y>=r.y and y<=r.y+r.h then
          _G.showHelpModal = false
          platform.window:invalidate()
      end
      return
  end
  -- Startup Hint modal block
  if _G.showStartupHint then
      local r = _G.hintDismissBtnRegion
      if r and x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
          _G.showStartupHint = false
          platform.window:invalidate()
          return
      end
      if _G.startupDontShowBtn then
          local btnX = (scrWidth - 240) / 2 + 10
          local btnY = scrHeight - 90 - 80 + 90 - 22 - 10
          if x >= btnX and x <= btnX + 110 and y >= btnY and y <= btnY + 22 then
              _G.startupDontShowBtn:onMouseDown()
              platform.window:invalidate()
              return
          end
      end
  end
  -- Modal ETK Button mouseDown
  if _G.showSettingsModal and _G.modalETKButton then
    local btn = _G.modalETKButton
    local btnW = btn.dimension.width or 80
    local btnH = btn.dimension.height or 28
    local modalW, modalH = 200, 120
    local modalX = (scrWidth - modalW) / 2
    local modalY = (scrHeight - modalH) / 2
    local btnX = modalX + (modalW - btnW) / 2
    local btnY = modalY + 54
    if x >= btnX and x <= btnX + btnW and y >= btnY and y <= btnY + btnH then
      btn:onMouseDown()
      platform.window:invalidate()
      return
    end
  end
  -- Toggle switch press effect when settings modal is open
  if _G.showSettingsModal and _G.switchRegion then
    local r = _G.switchRegion
    if x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
      _G.switchPressed = true
      platform.window:invalidate()
      return
    end
  end
  if theView then theView:onMouseDown(x, y) end
end
function on.mouseUp(x, y)
    -- This block should only CREATE and ACTIVATE the settings dialog if it needs to be shown.
    -- The painting should happen in on.paint.
    print("\n--- on.mouseUp event ---") -- <--- IS THIS SHOWING?
    print("Current activeModalDialog (on entry):", tostring(theView.activeModalDialog)) -- <--- IS THIS SHOWING?
    if theView then
        if theView.activeModalDialog then
            -- If a modal dialog is active, send all mouse events directly to it
            theView.activeModalDialog:onMouseUp(x, y)
            return -- Crucial: stop further processing if a modal dialog handled it
        else
            -- Otherwise, let the normal view handle it
            theView:onMouseUp(x, y)
        end
    end
    

    -- Similar for the Help Dialog
    if _G.showHelpModal then
        if not _G.helpDialog then
            -- Create the help dialog only once
            -- ... (your existing dialog creation code, without _G.helpDialog:paint) ...

            -- Ensure it's added to the view and activated when created
            theView:add(_G.helpDialog)
            _G.helpDialog:activate()
        end
        -- Remove the _G.helpDialog:paint(gc, true) line from here!
    end
    
    -- Similar for the Startup Hint Dialog
    if var and var.recall and var.recall("hide_startup_hint") ~= 1 and _G.showStartupHint then
        if not _G.startupHintDialog then
            -- Create the startup hint dialog only once
            -- ... (your existing dialog creation code, without _G.startupHintDialog:paint) ...

            -- Ensure it's added to the view and activated when created
            theView:add(_G.startupHintDialog)
            _G.startupHintDialog:activate()
        end
        -- Remove the _G.startupHintDialog:paint(gc, true) line from here!
    end
    
    -- This line is correct and should remain. It dispatches the mouse event
    -- to the appropriate UI element, including any active dialog.
    if theView then theView:onMouseUp(x, y) end
end

function initFontGC(gc)
	gc:setFont(font, style, fsize)
end

function getStringHeightGC(text, gc)
	initFontGC(gc)
	return gc:getStringHeight(text)
end

function getStringHeight(text)
	return platform.withGC(getStringHeightGC, text)
end

function getStringWidthGC(text, gc)
	initFontGC(gc)
	return gc:getStringWidth(text)
end

function getStringWidth(text)
	return platform.withGC(getStringWidthGC, text)
end


----------------------------------------------------------------------
--                           History Layout                           --
----------------------------------------------------------------------

-- Find the “partner” editor for a history entry
function getParME(editor)
    for i = 1, #histME2 do
        if histME2[i].editor == editor then
            return histME1[i]
        end
    end
    return nil
end

-- Map a D2Editor instance back to its MathEditor wrapper
function getME(editor)
    if fctEditor and fctEditor.editor == editor then
        return fctEditor
    else
        for i = 1, #histME1 do
            if histME1[i].editor == editor then
                return histME1[i]
            end
        end
        for i = 1, #histME2 do
            if histME2[i].editor == editor then
                return histME2[i]
            end
        end
    end
    return nil
end

-- Get the “index” of a given MathEditor in the history stack
function getMEindex(me)
    if fctEditor and fctEditor.editor == me then
        return 0
    else
        local ti = 0
        for i = #histME1, 1, -1 do
            if histME1[i] == me then
                return ti
            end
            ti = ti + 1
        end
        ti = 0
        for i = #histME2, 1, -1 do
            if histME2[i] == me then
                return ti
            end
            ti = ti + 1
        end
    end
    return 0
end

-- Global offset for history scrolling
ioffset = 0

function reposView()
    local focusedME = theView:getFocus()
    if not focusedME or focusedME == fctEditor then return end

    local index = getMEindex(focusedME)
    local maxIterations = 10 -- prevent infinite loops
    for _ = 1, maxIterations do
        local y = focusedME.y
        local h = focusedME.h
        local y0 = fctEditor.y

        if y < 0 and ioffset < index then
            ioffset = ioffset + 1
            reposME()
        elseif y + h > y0 and ioffset > index then
            ioffset = ioffset - 1
            reposME()
        else
            break
        end
    end
end

-- When a history editor resizes, lay out paired entries side-by-side
function resizeMEpar(editor, w, h)
    local pare = getParME(editor)
    if pare then
        resizeMElim(editor, w, h, pare.w + (pare.dx1 or 0) * 2)
    else
        resizeME(editor, w, h)
    end
end

-- Generic resize for any MathEditor
function resizeME(editor, w, h)
    if not editor then return end
    resizeMElim(editor, w, h, scrWidth / 2)
end

-- Internal workhorse for resizing (limits width, then calls reposME)
function resizeMElim(editor, w, h, lim)
    if not editor then return end
    local met = getME(editor)
    if met then
        met.needw = w
        met.needh = h
        w = math.max(w, 0)
        w = math.min(w, scrWidth - (met.dx1 or 0) * 2)
        if met ~= fctEditor then
            w = math.min(w, (scrWidth - lim) - 2 * (met.dx1 or 0) + 1)
        end
        h = math.max(h, strFullHeight + 8)
        met:resize(w, h)
        reposME()
        theView:invalidate()
    end
    return editor
end

-- “Scroll” and reflow all history MathEditors on screen
function reposME()
    local totalh, beforeh, visih = 0, 0, 0

    -- First, position the input editor at the bottom
    fctEditor.y = scrHeight - fctEditor.h
    theView:repos(fctEditor)

    -- Update scrollbar to fill from input up
    sbv:setVConstraints("justify", scrHeight - fctEditor.y + border)
    theView:repos(sbv)

    local y = fctEditor.y
    local i0 = math.max(#histME1, #histME2)

    for i = i0, 1, -1 do
        local h1, h2 = 0, 0
        if i <= #histME1 then h1 = math.max(h1, histME1[i].h) end
        if i <= #histME2 then h2 = math.max(h2, histME2[i].h) end
        local h = math.max(h1, h2)

        local ry
        if (i0 - i) >= ioffset then
            if y >= 0 then
                if y >= h + border then
                    visih = visih + h + border
                else
                    visih = visih + y
                end
            end
            y = y - h - border
            ry = y
            totalh = totalh + h + border
        else
            ry = scrHeight
            beforeh = beforeh + h + border
            totalh = totalh + h + border
        end

        -- Place the “expression” editor on the left
        if i <= #histME1 then
            histME1[i].y = ry
            theView:repos(histME1[i])
        end
        -- Place its paired “result” editor on the right, vertically aligned
        if i <= #histME2 then
            histME2[i].y = ry + math.max(0, h1 - h2)
            theView:repos(histME2[i])
        end
    end

    if totalh == 0 then
        sbv.pos = 0
        sbv.siz = 100
    else
        sbv.pos = beforeh * 100 / totalh
        sbv.siz = visih * 100 / totalh
    end

    theView:invalidate()
end

function initGUI()
    showEditorsBorders = false
    showHLines = true
    -- local riscas = math.evalStr("iscas()")
    -- if (riscas == "true") then iscas = true end
    local id = math.eval("sslib\\getid()")
    if id then caslib = id end
    scrWidth = platform.window:width()
    scrHeight = platform.window:height()
    if scrWidth > 0 and scrHeight > 0 then
        theView = View(platform.window)

        -- Vertical scroll bar for history (because scrolling is still a thing)
        sbv = VScrollBar(theView, 0, -1, 5, scrHeight + 1)
        sbv:setHConstraints("right", 0)
        theView:add(sbv)
        

        -- Input editor at bottom (MathEditor) - the star of the show
        fctEditor = MathEditor(theView, 2, border, scrWidth - 4 - sbv.w, 30, "")
        
        -- Apply dark/light mode colors because apparently consistency matters
        if fctEditor and fctEditor.editor then
            local bg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
            if fctEditor.editor.setBackgroundColor then
                fctEditor.editor:setBackgroundColor(table.unpack(bg))
            end
            local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
            local border = _G.darkMode and {100, 100, 100} or {0, 0, 0}
            if fctEditor.editor.setTextColor then
                fctEditor.editor:setTextColor(table.unpack(text))
            end
            if fctEditor.editor.setBorderColor then
                fctEditor.editor:setBorderColor(table.unpack(border))
            end
        end
        
        fctEditor:setHConstraints("justify", 1)
        fctEditor:setVConstraints("bottom", 1)
        fctEditor.editor:setSizeChangeListener(function(editor, w, h)
            return resizeME(editor, w, h)
        end)
        theView:add(fctEditor)
        fctEditor.result = res
        fctEditor.editor:setText("")
        fctEditor:fixContent()

        -- First-focus is input editor (as it should be)
        theView:setFocus(fctEditor)

        -- Sync category state and update button after GUI is ready
        syncCategoryFromStorage()
        if _G.categoryBtn then
            _G.categoryBtn.text = _G.currentConstCategory
        end
        
        inited = true
    end

    toolpalette.enableCopy(true)
    toolpalette.enablePaste(true)
end


local function addStringToFctEditor(actionString)
    -- Assuming _G.fctEditor is the global MathEditor instance (or similar)
    
    if _G.fctEditor then
        _G.fctEditor:addString(actionString)
        -- Invalidate the window to ensure UI updates, as the system toolpalette doesn't
        -- automatically trigger redraws for the custom UI elements.
        platform.window:invalidate()
    else
        print("Error: _G.fctEditor not available to add string: " .. actionString)
    end
end

local function showSettingsModal()
    _G.showSettingsModal = true
    platform.window:invalidate() -- Invalidate to show the modal
end

local function showHelpModal()
    _G.showHelpModal = true
    platform.window:invalidate() -- Invalidate to show the modal
end

-- Handler function for toolpalette menu items
local function toolpaletteMenuHandler(toolboxName, menuItemName)
    if toolboxName == "Calculus" then
        if menuItemName == "Differentiate" then
            addStringToFctEditor("d/dx()")
        elseif menuItemName == "Integrate" then
            addStringToFctEditor("∫(,)")
        elseif menuItemName == "Abs" then
            addStringToFctEditor("abs()")
        elseif menuItemName == "Factorial" then
            addStringToFctEditor("factorial(")
        elseif menuItemName == "Empty Matrix" then
            addStringToFctEditor("[[,],[,]]")
        elseif menuItemName == "Taylor Series" then
            addStringToFctEditor("series(f,x,a,n)")
        elseif menuItemName == "Fourier Series" then
            addStringToFctEditor("series(f,x,a,n)")
        elseif menuItemName == "Maclaurin Series" then
            addStringToFctEditor("series(f,x,0,n)")
        end
    elseif toolboxName == "Solve" then
        if menuItemName == "Solve Equation" then
            addStringToFctEditor("solve(")
        end
    elseif toolboxName == "App Options" then
        if menuItemName == "Settings" then
            showSettingsModal()
        elseif menuItemName == "Help" then
            showHelpModal()
        end
    end
end

-- Correct menu structure for toolpalette.register
local myToolPaletteMenuStructure = {
    {"Calculus", -- First toolbox
        {"Differentiate", toolpaletteMenuHandler},
        {"Integrate", toolpaletteMenuHandler},
        {"Abs", toolpaletteMenuHandler},
        {"Factorial", toolpaletteMenuHandler},
        {"Empty Matrix", toolpaletteMenuHandler},
        "-", -- Separator
        {"Taylor Series", toolpaletteMenuHandler},
        {"Fourier Series", toolpaletteMenuHandler},
        {"Maclaurin Series", toolpaletteMenuHandler},
    },
    {"Solve", -- Second toolbox
        {"Solve Equation", toolpaletteMenuHandler},
    },
    {"App Options", -- Third toolbox
        {"Settings", toolpaletteMenuHandler},
        {"Help", toolpaletteMenuHandler},
    }
}

-- Register the tool palette
toolpalette.register(myToolPaletteMenuStructure)






function resizeGC(gc)
	scrWidth = platform.window:width()
	scrHeight = platform.window:height()
	if not inited then
		initGUI()
	end
	if inited then
		initFontGC(gc)
		strFullHeight = gc:getStringHeight("H")
		strHeight = strFullHeight - 3
		theView:resize()
		reposME()
		theView:invalidate()
	end
end

function on.resize()
	platform.withGC(resizeGC)
end

forcefocus = true

function on.activate()
  setupLaunchAnimation()
end

dispinfos = true

-- The main UI rendering phase: draws status, output, and all widgets.
-- If you’re looking for where the magic (or horror) happens, it’s here.
function on.paint(gc)
    -- Launch animation block (runs before normal UI)
    if showLaunchAnim then
        local now = timer.getMilliSecCounter()
        local dt = now - launchStartTime

        -- Hide the D2Editor while launch animation is running
        if fctEditor and fctEditor.editor then
            fctEditor.editor:setVisible(false)
        end

        -- White background
        gc:setColorRGB(255, 255, 255)
        gc:fillRect(0, 0, scrWidth, scrHeight)

        -- Ensure assets exist
        -- This block should be inside the on.timer() function or wherever the animation rendering happens
if showLaunchAnim then -- Add this conditional check here
    if n_logo and luacas_text then

        local dt = timer.getMilliSecCounter() - launchStartTime -- Make sure dt is defined if not already

        -- Animate n_logo: from off-screen right to x = 50
        local logoStartX = scrWidth + 100 -- Ensure scrWidth is accessible or defined
        local logoEndX = 20
        if dt < 1000 then
            logoX = logoStartX - (dt / 1000) * (logoStartX - logoEndX)
        else
            logoX = logoEndX
        end

        -- Animate luacas_text: from off-screen right to x = close to n_logo, starts after n_logo
        local textStartX = scrWidth + 300
        -- Use the same scale factors as globals for animation
        local logoWidth, logoHeight = image.width(n_logo) * scaleFactorLogo, image.height(n_logo) * scaleFactorLogo
        local textWidth, textHeight = image.width(luacas_text) * scaleFactorText, image.height(luacas_text) * scaleFactorText
        local textEndX = logoEndX + logoWidth + 30
        if dt >= 1000 and dt < 2000 then
            local textDt = dt - 1000
            textX = textStartX - (textDt / 1000) * (textStartX - textEndX)
        elseif dt >= 2000 then
            textX = textEndX
        end

        -- Draw images if within their time windows, scale logo and text to match global scaling
        local baseY = 100
        local baseYText = 77

        if dt >= 0 then
            gc:drawImage(n_logo, logoX, baseY, logoWidth, logoHeight)
        end
        if dt >= 100 then
            gc:drawImage(luacas_text, textX, baseYText, textWidth, textHeight)
        end

        -- End animation after both complete
        if dt >= 2500 then
            showLaunchAnim = false -- This will effectively stop the animation for subsequent frames
            -- Restore D2Editor visibility after animation ends
            if fctEditor and fctEditor.editor then
                fctEditor.editor:setVisible(true)
            end
            timer.stop(tick) -- Assuming 'tick' is the timer ID
            platform.window:invalidate()
        end
    end

    -- Remove invalidate from here; handled by timer for smooth animation
    return
else -- If showLaunchAnim is false, just immediately set it to false and stop the timer
    showLaunchAnim = false -- Ensure it's false to prevent future animation attempts
    timer.stop(tick) -- Stop the animation timer immediately if it's not meant to run
    -- Restore D2Editor visibility immediately
    if fctEditor and fctEditor.editor then
        fctEditor.editor:setVisible(true)
    end
    platform.window:invalidate() -- Force a redraw if needed
    return -- Exit the on.timer function
end
end

    if not inited then
        initGUI()
        initFontGC(gc)
        strFullHeight = gc:getStringHeight("H")
        strHeight = strFullHeight - 3
    end
    if inited then
        -- Global dark mode background
        local globalBg = _G.darkMode and {20, 20, 20} or {255, 255, 255}
        gc:setColorRGB(unpackColor(globalBg))
        gc:fillRect(0, 0, scrWidth, scrHeight)

        -- Removed display of "Last: ..." result at the top
        local obj = theView:getFocus()
        initFontGC(gc)
        if not obj then theView:setFocus(fctEditor) end
        if (forcefocus) then
            if obj == fctEditor then
                fctEditor.editor:setFocus(true)
                if fctEditor.editor:hasFocus() then forcefocus = false end
            else
                forcefocus = false
            end
        end
        if dispinfos then
            -- (Logo image block removed for customization)
        end
        -- Output string fallback for "main" view
        if true then -- "main" view block
            local output = fctEditor and fctEditor.result
            local outputStr = (output and output ~= "") and output or "(no output)"
            -- Draw output in white for dark mode, black for light mode
            gc:setColorRGB(_G.darkMode and 255 or 0, _G.darkMode and 255 or 0, _G.darkMode and 255 or 0)
            gc:drawString(outputStr, 10, scrHeight - 25, "top")
        end
        -- Draw custom settings icon button at top right if modal not open
        
        theView:paint(gc)

        -- Draw the bottom input area background fully respecting dark mode (after theView:paint)
        do
            -- Use pure white and black in light mode, no blue tint
            local areaBg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
            local areaBorder = _G.darkMode and {100, 100, 100} or {0, 0, 0}
            local boxY = fctEditor.y - 2
            local boxH = fctEditor.h + 4
            gc:setColorRGB(table.unpack(areaBg))
            gc:fillRect(0, boxY, scrWidth, boxH)
            gc:setColorRGB(table.unpack(areaBorder))
            gc:drawRect(0, boxY, scrWidth, boxH)
            -- Immediately override editor background, text, and border for safety and consistency
            if fctEditor and fctEditor.editor and fctEditor.editor.setBackgroundColor then
                local bg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
                local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
                local border = _G.darkMode and {100, 100, 100} or {0, 0, 0}
                fctEditor.editor:setBackgroundColor(table.unpack(bg))
                if fctEditor.editor.setTextColor then
                    fctEditor.editor:setTextColor(table.unpack(text))
                end
                if fctEditor.editor.setBorderColor then
                    fctEditor.editor:setBorderColor(table.unpack(border))
                end
            end
        end

        -- Draw settings modal if enabled (block moved to end)
    end
    
-- Replace the entire manual drawing block for _G.showSettingsModal
if _G.showSettingsModal then
    -- Create the settings dialog only once
    if not _G.settingsDialog then
        -- Define base positions for elements relative to the dialog's top-left corner (0,0)
        local labelCol1X = 20    -- X-coordinate for labels in the first column
        local valueCol1X = 120   -- X-coordinate for buttons/values, estimated for alignment
        local lineHeight = 28    -- Vertical spacing between lines of elements
        local btnW, btnH = 48, 22 -- Standard button width and height
        if fctEditor and fctEditor.editor then -- Add nil check for robustness
            fctEditor.editor:setVisible(false)
        end

        _G.settingsDialog = Dialog(theView, {
            title = "Settings",
            width = 300,
            height = 190,
            x = 50,  
            y = 50,  

            elements = {
                -- Decimals Toggle
                { type = "TextLabel", x = labelCol1X, y = 40, text = "Decimals:" },
                { type = "TextButton", x = valueCol1X, y = 38, text = (_G.autoDecimal and "ON" or "OFF"),
                  width = btnW, height = btnH, name = "decimalsBtn",
                  command = function(dlg, btn)
                      _G.autoDecimal = not _G.autoDecimal
                      btn.text = (_G.autoDecimal and "ON" or "OFF")
                      var.store("nLuaCAS_decimals_pref", _G.autoDecimal and 1 or 0)
                      platform.window:invalidate()
                  end },

                -- Complex Mode Toggle
                { type = "TextLabel", x = labelCol1X, y = 40 + lineHeight, text = "Complex:" },
                { type = "TextButton", x = valueCol1X, y = 40 + lineHeight - 2, text = (_G.showComplex and "ON" or "OFF"),
                  width = btnW, height = btnH, name = "complexBtn",
                  command = function(dlg, btn)
                      _G.showComplex = not _G.showComplex
                      btn.text = (_G.showComplex and "ON" or "OFF")
                      var.store("nLuaCAS_complex_pref", _G.showComplex and 1 or 0)
                      platform.window:invalidate()
                  end },

                -- Constants Toggle
                { type = "TextLabel", x = labelCol1X, y = 40 + 2 * lineHeight, text = "Constants:" },
                { type = "TextButton", x = valueCol1X, y = 40 + 2 * lineHeight - 2, text = (not var.recall("constants_off") and "ON" or "OFF"),
                  width = btnW, height = btnH, name = "constantsBtn",
                  command = function(dlg, btn)
                      local new_off = not var.recall("constants_off")
                      var.store("constants_off", new_off)
                      btn.text = (not new_off and "ON" or "OFF")
                      platform.window:invalidate()
                  end },

                -- Category Selector
                { type = "TextLabel", x = labelCol1X, y = 40 + 3 * lineHeight, text = "Category:" },
                { type = "TextButton", x = valueCol1X, y = 40 + 3 * lineHeight - 2, text = _G.gui.get_current_constant_category(),
                  width = 90, height = btnH, name = "categoryBtn",
                  command = function(dlg, btn)
                      local categories = get_constant_categories()
                      local currentCategory = _G.gui.get_current_constant_category()
                      local idx = 1
                      for i, v in ipairs(categories) do
                          if v == currentCategory then idx = i end
                      end
                      local selected = categories[(idx % #categories) + 1]

                      _G.currentConstCategory = selected
                      _G.current_constant_category = selected

                      var.store("current_constant_category", selected)
                      btn.text = selected

                      platform.window:invalidate()
                  end },

                -- Dismiss Button for the dialog
                -- Position it relative to the new dialog height
                { type = "TextButton", x = 300 - 70, y = 190 - 30, text = "Dismiss", -- Y-position adjusted for new height
                  closesDialog = true,
                  command = function(dlg, btn)
                  end }
            },
            onClose = function(dlg, result)
                _G.showSettingsModal = false
                platform.window:invalidate()
                if fctEditor and fctEditor.editor then -- Add nil check for robustness
                    fctEditor.editor:setVisible(true)
                end
            end
        })
        theView:add(_G.settingsDialog)
        _G.settingsDialog:activate()
    end
    _G.settingsDialog:paint(gc, true)
end


    if _G.showHelpModal then
        if not _G.helpDialog then
            if fctEditor and fctEditor.editor then -- Add nil check for robustness
                fctEditor.editor:setVisible(false) -- HIDE EDITOR WHEN DIALOG OPENS
            end
            _G.helpDialog = Dialog(theView, {
                title = "CAS Help",
                width = 300,
                height = 200,
                elements = {
                    { type = "TextLabel", x = 10, y = 40, text = "Use Ctrl+MENU to open the menu." },
                    { type = "TextLabel", x = 10, y = 56, text = "Arrow keys or touch/click to navigate." },
                    { type = "TextLabel", x = 10, y = 72, text = "Select operations to insert into input." },
                    { type = "TextLabel", x = 10, y = 88, text = "Press Enter to compute." },
                    { type = "TextLabel", x = 10, y = 104, text = "Supports expand, factor, simplify," },
                    { type = "TextLabel", x = 10, y = 120, text = "differentiate, integrate, solve, abs," },
                    { type = "TextLabel", x = 10, y = 136, text = "factorial, empty matrix, series" },
                    { type = "TextButton", x = 300 - 70, y = 200 - 30, text = "Close",
                      closesDialog = true,
                      command = function(dlg, btn) end }
                },
                onClose = function(dlg, result)
                    _G.showHelpModal = false
                    platform.window:invalidate()
                    if fctEditor and fctEditor.editor then -- SHOW EDITOR WHEN DIALOG CLOSES
                        fctEditor.editor:setVisible(true)
                    end
                end
            })
            theView:add(_G.helpDialog)
            _G.helpDialog:activate()
        end
        _G.helpDialog:paint(gc, true)
    end
    

   -- Handle the Startup Hint Dialog
if var and var.recall and var.recall("hide_startup_hint") ~= 1 and _G.showStartupHint then
    if not _G.startupHintDialog then
        if fctEditor and fctEditor.editor then
            fctEditor.editor:setVisible(false)
        end
        _G.startupHintDialog = Dialog(theView, {
            title = "Tip",
            width = 280,
            height = 160,
            elements = {
                { type = "TextLabel", x = 20, y = 40, text = "Press Ctrl+MENU to open the menu." },
                { type = "TextLabel", x = 20, y = 56, text = "You can access all features from there." },
                { type = "CheckBox", x = 20, y = 90, text = "Don't show this tip again", checked = false, name = "dontShow",
                  onAction = function(self)
                      self.checked = not self.checked
                      platform.window:invalidate()
                  end
                },
                { type = "TextButton", x = 280 - 70, y = 160 - 30, text = "Dismiss",
                  closesDialog = true,
                  command = function(dlg, btn) end }
            },
            onClose = function(dlg, result)
                if dlg.namedWidgets.dontShow and dlg.namedWidgets.dontShow.checked then
                    if var and var.store then
                        var.store("hide_startup_hint", 1)
                    end
                end
                if fctEditor and fctEditor.editor then
                    fctEditor.editor:setVisible(true)
                end
                _G.showStartupHint = false
                platform.window:invalidate()
            end
        })
        theView:add(_G.startupHintDialog)
        _G.startupHintDialog:activate()
    end
    -- --- START OF CHANGE ---
    -- Move the paint call OUTSIDE the 'if not _G.startupHintDialog then' block
    if _G.startupHintDialog and _G.startupHintDialog.visible then -- Ensure it exists and is visible before painting
        _G.startupHintDialog:paint(gc, true)
    end
    -- --- END OF CHANGE ---
end
end

font = "sansserif"
style = "r"
fsize = 12

scrWidth = 0
scrHeight = 0
inited = false
iscas = false
caslib = "NONE"
delim = " ≟ "
border = 3

strHeight = 0
strFullHeight = 0



-- Initialize empty history tables
histME1 = {}
histME2 = {}


-- Reminder: this is the thing that dumps both the input and result into history.
function addME(expr, res, colorHint)
	mee = MathEditor(theView, border, border, 50, 30, "")
	mee.readOnly = true
	table.insert(histME1, mee)
	mee:setHConstraints("left", border)
	mee.editor:setSizeChangeListener(function(editor, w, h)
		return resizeME(editor, w + 3, h)
	end)
	-- Set border color based on colorHint
	if colorHint == "error" then
		mee.editor:setBorderColor(0xFF0000) -- red
	else
		mee.editor:setBorderColor(0x000000)
	end
	mee.editor:setExpression("\\0el {" .. expr .. "}", 0)
	mee:fixCursor()
	mee.editor:setReadOnly(true)
	theView:add(mee)

	mer = MathEditor(theView, border, border, 50, 30, "")
    mer.result = true
    mer.readOnly = true
	table.insert(histME2, mer)
	mer:setHConstraints("right", scrWidth - sbv.x + border)
	mer.editor:setSizeChangeListener(function(editor, w, h)
				return resizeMEpar(editor, w + border, h)
	end)
	if colorHint == "error" then
		mer.editor:setBorderColor(0xFF0000) -- red
	else
		mer.editor:setBorderColor(0x000000)
	end
    local displayRes = ""
    if type(res) == "table" then
      if _G.simplify and _G.simplify.pretty_print then
        displayRes = _G.simplify.pretty_print(res)
      elseif _G.ast and _G.ast.tostring then
        displayRes = _G.ast.tostring(res)
      else
        displayRes = tostring(res)
      end
    else
      displayRes = tostring(res)
    end
    mer.editor:setExpression("\\0el {" .. displayRes .. "}", 0)
	mer:fixCursor()
	mer.editor:setReadOnly(true)
	theView:add(mer)

    -- Set dark/light mode colors for both new MathEditors (mee, mer) consistently
    local bg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
    local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
    local border = _G.darkMode and {100, 100, 100} or {0, 0, 0}
    for _, editor in ipairs({mee.editor, mer.editor}) do
        if editor.setBackgroundColor then
            editor:setBackgroundColor(table.unpack(bg))
        end
        if editor.setTextColor then
            editor:setTextColor(table.unpack(text))
        end
        if editor.setBorderColor then
            editor:setBorderColor(table.unpack(border))
        end
        if editor.setOpaque then
            editor:setOpaque(true)
        end
    end

	reposME()

-- Any unhandled errors will cause LuaCAS Engine status to go NONE (red)
end
-- Make var globally accessible for parser/physics.lua
_G.var = var

function on.construction()
  setupLaunchAnimation()
  toolpalette.register(myToolPaletteMenuStructure)
end
function on.timer()
    if showLaunchAnim then
        platform.window:invalidate()
    else
        timer.stop()
    end
end
_G.gui = _G.gui or {}

function _G.gui.get_current_constant_category()
    -- Priority: in-memory global -> storage -> default
    if _G.current_constant_category and type(_G.current_constant_category) == "string" then
        return _G.current_constant_category
    end
    local cat = var.recall and var.recall("current_constant_category")
    if cat and type(cat) == "string" then
        _G.current_constant_category = cat
        return cat
    end
    return "fundamental"
end

-- End src/gui.lua

-- Just added src/gui.lua—hope your logic is watertight.

-- Build wrapping up. Merged build.lua: pray those ASTs behave.
