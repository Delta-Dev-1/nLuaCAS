-- Autogenerated build. If you’re reading this, something probably broke upstream.

-- Begin src/init.lua
platform.apilevel = "2.4"

local var = rawget(_G, "var") or nil
_G.darkMode = (var and var.recall and var.recall("dark_mode") == 1) or false

-- Default fallback; true recall happens after storage is ready
_G.current_constant_category = nil

-- Delay storage sync to avoid race with var initialization
function syncCategoryFromStorage()
    if var and type(var.recall) == "function" then
        local cat = var.recall("current_constant_category")
        if cat and type(cat) == "string" then
            print("[STATE] Loaded stored constant category:", cat)
            _G.current_constant_category = cat
            return
        end
    end

    if not _G.current_constant_category then
        _G.current_constant_category = "fundamental"
        print("[STATE] No stored category, using default:", _G.current_constant_category)
        
        if var and type(var.store) == "function" then
            var.store("current_constant_category", _G.current_constant_category)
            print("[STATE] Stored default category to storage:", _G.current_constant_category)
        end
    end
end


function on.construction()
    syncCategoryFromStorage()
end

function on.getSymbolList()
    return { "current_constant_category" }
end

-- End src/init.lua

-- Imported src/init.lua—debuggers rejoice.

-- Begin src/ast.lua

-- Abstract Syntax Tree (AST) library for symbolic math
-- Defines constructors, utilities, transformation tools for symbolic expressions.
-- Built to be cold, deterministic, and unreasonably explicit.

table.unpack = unpack

-- Use simplify.pretty_print for all string conversion of ASTs
local ok, simplify = pcall(require, "simplify")
if ok and simplify and simplify.pretty_print then
  function ast_tostring(ast)
    return simplify.pretty_print(ast)
  end
  ast.tostring = ast_tostring
end

-- Recursively print AST structure with optional indentation
-- For when you want to debug something by yelling at trees
function ast_debug_print(ast, indent)
    indent = indent or ""
    if type(ast) ~= "table" then
        print(indent .. tostring(ast))
        return
    end
    if ast.type then
        local desc = ast.type
        if ast.name then desc = desc .. " (" .. tostring(ast.name) .. ")" end
        print(indent .. desc)
        if ast.value ~= nil then print(indent .. "  value: " .. tostring(ast.value)) end
        if ast.name ~= nil and ast.type ~= "variable" then print(indent .. "  name: " .. tostring(ast.name)) end
        if ast.args then
            print(indent .. "  args:")
            for i, arg in ipairs(ast.args) do
                ast_debug_print(arg, indent .. "    ")
            end
        end
        -- Print left/right for binary nodes
        if ast.left then
            print(indent .. "  left:")
            ast_debug_print(ast.left, indent .. "    ")
        end
        if ast.right then
            print(indent .. "  right:")
            ast_debug_print(ast.right, indent .. "    ")
        end
    else
        for k, v in pairs(ast) do
            print(indent .. tostring(k) .. ":")
            ast_debug_print(v, indent .. "  ")
        end
    end
end

-- If you're not using these, you're probably doing something wrong
-- Node constructors (convenience)
function ast_number(val) return { type = "number", value = val } end
function ast_symbol(name) return { type = "variable", name = name } end
function ast_func(name, args) return { type = "func", name = name, args = args or {} } end
function ast_binop(op, left, right) return { type = op, left = left, right = right } end
function ast_neg(val) return { type = "neg", arg = val } end
function ast_pow(base, exp) return { type = "pow", base = base, exp = exp } end
function ast_raw(str) return { type = "raw", value = str } end


-- Patch all AST node constructors to auto-set tostring metamethod
-- So you can print them and pretend you understand the output
-- Make all AST nodes print pretty with print(ast)
local ast_mt = {
  __tostring = function(self)
    if _G.ast_tostring then
      return _G.ast_tostring(self)
    elseif _G.simplify and _G.simplify.pretty_print then
      return _G.simplify.pretty_print(self)
    else
      return "[AST]"
    end
  end
}
-- Patch constructors to set metatable for all AST nodes
local function set_ast_mt(node)
  if type(node) == "table" and node.type and getmetatable(node) ~= ast_mt then
    setmetatable(node, ast_mt)
    -- Recursively set for children
    if node.args then
      for _, v in ipairs(node.args) do set_ast_mt(v) end
    end
    if node.left then set_ast_mt(node.left) end
    if node.right then set_ast_mt(node.right) end
    if node.base then set_ast_mt(node.base) end
    if node.exp then set_ast_mt(node.exp) end
    if node.value and type(node.value) == "table" then set_ast_mt(node.value) end
    -- Patch matrix rows if present
    if node.rows then
      for _, row in ipairs(node.rows) do
        for i, cell in ipairs(row) do
          row[i] = set_ast_mt(cell)
        end
      end
    end
  end
  return node
end

function ast_matrix(rows)
  return set_ast_mt({ type = "matrix", rows = rows })
end

-- Deep copy an AST — because shallow regret isn't enough
function ast_deepcopy(obj)
    if type(obj) ~= "table" then return obj end
    local res = {}
    for k, v in pairs(obj) do
        res[k] = ast_deepcopy(v)
    end
    return res
end

-- Structural equality check for ASTs
-- Tests whether two expressions are indistinguishably boring
function ast_equal(a, b)
    if type(a) ~= type(b) then return false end
    if type(a) ~= "table" then return a == b end
    for k, v in pairs(a) do
        if not ast_equal(v, b[k]) then return false end
    end
    for k, v in pairs(b) do
        if not ast_equal(v, a[k]) then return false end
    end
    return true
end

-- Depth-first traversal of the AST
-- Applies a function to every node, top-down
function ast_traverse(ast, fn)
    fn(ast)
    if type(ast) == "table" then
        if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
            for _, v in ipairs(ast.args) do
                ast_traverse(v, fn)
            end
        else
            for k, v in pairs(ast) do
                if type(v) == "table" then ast_traverse(v, fn) end
            end
        end
    end
end

-- Like traverse, but returns a new AST
-- Good for transformations and bad ideas
function ast_map(ast, fn)
    if type(ast) ~= "table" then return fn(ast) end
    local mapped = {}
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        mapped.type = ast.type
        mapped.args = {}
        if ast.name then mapped.name = ast.name end
        for i, v in ipairs(ast.args) do
            mapped.args[i] = ast_map(v, fn)
        end
    else
        for k, v in pairs(ast) do
            mapped[k] = ast_map(v, fn)
        end
    end
    return fn(mapped)
end

-- Replace all occurrences of a subtree with another
-- Think copy/paste but with slightly more guilt
function ast_substitute(ast, target, replacement)
    if ast_equal(ast, target) then return ast_deepcopy(replacement) end
    if type(ast) ~= "table" then return ast end
    local res = {}
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        res.type = ast.type
        if ast.name then res.name = ast.name end
        res.args = {}
        for i, v in ipairs(ast.args) do
            res.args[i] = ast_substitute(v, target, replacement)
        end
    else
        for k, v in pairs(ast) do
            res[k] = ast_substitute(v, target, replacement)
        end
    end
    return res
end

-- Collect all variable symbols in the AST
-- Returns a set-like table of every symbol that dares to show up
function ast_vars(ast, found)
    found = found or {}
    if type(ast) ~= "table" then return found end
    if ast.type == "variable" then found[ast.name] = true end
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        for _, v in ipairs(ast.args) do
            ast_vars(v, found)
        end
    else
        for k, v in pairs(ast) do
            ast_vars(v, found)
        end
    end
    return found
end

-- Count the total number of nodes in an AST
-- Like measuring code size, but with more branches
function ast_size(ast)
    if type(ast) ~= "table" then return 1 end
    local sum = 1
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        for _, v in ipairs(ast.args) do sum = sum + ast_size(v) end
    else
        for k, v in pairs(ast) do sum = sum + ast_size(v) end
    end
    return sum
end

-- Computes the maximum depth of the AST
-- Deep code is not necessarily smart code
function ast_depth(ast)
    if type(ast) ~= "table" then return 0 end
    local maxd = 0
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        for _, v in ipairs(ast.args) do
            local d = ast_depth(v)
            if d > maxd then maxd = d end
        end
    else
        for k, v in pairs(ast) do
            local d = ast_depth(v)
            if d > maxd then maxd = d end
        end
    end
    return 1 + maxd
end


-- Original AST to string printer (for debugging)
function ast_tostring_raw(ast)
    if type(ast) ~= "table" then return tostring(ast) end
    if ast.type == "number" then return tostring(ast.value) end
    if ast.type == "variable" then return ast.name end
    if ast.type == "func" then
        local args = {}
        for i, v in ipairs(ast.args) do args[i] = ast_tostring_raw(v) end
        return ast.name .. "(" .. table.concat(args, ",") .. ")"
    end
    if ast.type == "neg" then
        return "-(" .. ast_tostring_raw(ast.arg) .. ")"
    end
    if ast.type == "pow" then
        return "(" .. ast_tostring_raw(ast.base) .. ")^(" .. ast_tostring_raw(ast.exp) .. ")"
    end
    if ast.type == "add" then
        local parts = {}
        for i, v in ipairs(ast.args) do
            parts[i] = ast_tostring_raw(v)
        end
        return "(" .. table.concat(parts, " + ") .. ")"
    end
    if ast.type == "sub" then
        return "(" .. ast_tostring_raw(ast.left) .. ") - (" .. ast_tostring_raw(ast.right) .. ")"
    end
    if ast.type == "mul" then
        local parts = {}
        for i, v in ipairs(ast.args) do
            parts[i] = ast_tostring_raw(v)
        end
        -- Nice form: 2x, x2 for two args, otherwise with *
        if #parts == 2 then
            local a, b = ast.args[1], ast.args[2]
            if ast_is_number(a) and ast_is_variable(b) then
                return tostring(a.value) .. parts[2]
            elseif ast_is_variable(a) and ast_is_number(b) then
                return parts[1] .. tostring(b.value)
            end
        end
        return table.concat(parts, "*")
    end
    if ast.type == "div" then
        return "(" .. ast_tostring_raw(ast.left) .. ")/(" .. ast_tostring_raw(ast.right) .. ")"
    end
    if ast.type == "raw" then
        return "[RAW:" .. tostring(ast.value) .. "]"
    end
    -- fallback
    local str = "{" .. (ast.type or "?")
    for k, v in pairs(ast) do
        if k ~= "type" then str = str .. "," .. k .. "=" .. ast_tostring_raw(v) end
    end
    return str .. "}"
end

-- AST node type test helpers
function ast_is_number(node)
    return type(node) == "table" and node.type == "number"
end
function ast_is_variable(node)
    return type(node) == "table" and node.type == "variable"
end
function ast_is_func(node, fname)
    return type(node) == "table" and node.type == "func" and (not fname or node.name == fname)
end
function ast_is_op(node, op)
    return type(node) == "table" and node.type == op
end


-- Evaluate the AST numerically if it's purely numeric
-- Warning: does not handle symbolic stupidity
function ast_eval_numeric(ast, env)
    env = env or {}
    if ast.type == "number" then return ast.value end
    if ast.type == "variable" then
        return env[ast.name] or error("Unbound variable: " .. tostring(ast.name))
    end
    if ast.type == "func" then
        local argv = {}
        for i, v in ipairs(ast.args) do
            argv[i] = ast_eval_numeric(v, env)
        end
        if math[ast.name] then
            return math[ast.name](table.unpack(argv))
        elseif ast.name == "ln" then
            return math.log(argv[1])
        elseif ast.name == "log" then
            return math.log10(argv[1])
        elseif ast.name == "gamma" then
            local n = argv[1]
            if n > 0 and math.floor(n) == n then
                local factorial = 1
                for i = 1, n - 1 do
                    factorial = factorial * i
                end
                return factorial
            elseif n == 0.5 then
                return math.sqrt(math.pi)
            else
                error("Gamma function not implemented for value: " .. tostring(n))
            end
        else
            error("Unknown function: " .. ast.name)
        end
    end
    if ast.type == "add" then
        local sum = 0
        for _, v in ipairs(ast.args) do
            sum = sum + ast_eval_numeric(v, env)
        end
        return sum
    end
    if ast.type == "sub" then
        return ast_eval_numeric(ast.left, env) - ast_eval_numeric(ast.right, env)
    end
    if ast.type == "mul" then
        local prod = 1
        for _, v in ipairs(ast.args) do
            prod = prod * ast_eval_numeric(v, env)
        end
        return prod
    end
    if ast.type == "div" then
        return ast_eval_numeric(ast.left, env) / ast_eval_numeric(ast.right, env)
    end
    if ast.type == "pow" then
        return ast_eval_numeric(ast.base, env) ^ ast_eval_numeric(ast.exp, env)
    end
    if ast.type == "neg" then
        return -ast_eval_numeric(ast.arg, env)
    end
    error("Unsupported node in ast_eval_numeric: " .. tostring(ast.type))
end

-- Pattern match against an AST using a pattern
-- Binds variables, fails if it sees something it doesn’t like
function ast_match(pattern, ast, bindings)
    bindings = bindings or {}
    if type(pattern) ~= "table" then
        if pattern == ast then return bindings else return nil end
    end
    if pattern.var then
        if bindings[pattern.var] then
            return ast_equal(bindings[pattern.var], ast) and bindings or nil
        else
            bindings[pattern.var] = ast
            return bindings
        end
    end
    if type(ast) ~= "table" then return nil end
    if pattern.type and pattern.type ~= ast.type then return nil end
    if (pattern.type == "add" or pattern.type == "mul" or pattern.type == "func") and pattern.args then
        if #pattern.args ~= #ast.args then return nil end
        for i = 1, #pattern.args do
            local sub = ast_match(pattern.args[i], ast.args[i], bindings)
            if not sub then return nil end
            bindings = sub
        end
    else
        for k, v in pairs(pattern) do
            if k ~= "var" and k ~= "args" then
                local sub = ast_match(v, ast[k], bindings)
                if not sub then return nil end
                bindings = sub
            end
        end
    end
    return bindings
end

-- Export all as ast.*
ast = {
    number = ast_number,
    symbol = ast_symbol,
    variable = ast_symbol,
    func = ast_func,
    binop = ast_binop,
    neg = ast_neg,
    pow = ast_pow,
    raw = ast_raw,
    matrix = ast_matrix,

    -- Shorthand binary operation constructors
    add = function(...) return { type = "add", args = {...} } end,
    sub = function(l, r) return ast_binop("sub", l, r) end,
    mul = function(...) return { type = "mul", args = {...} } end,
    div = function(l, r) return ast_binop("div", l, r) end,
    pow = function(l, r) return ast_pow(l, r) end,
    neg = ast_neg,
    eq = function(left, right) return { type = "equation", left = left, right = right } end,

    deepcopy = ast_deepcopy,
    equal = ast_equal,
    traverse = ast_traverse,
    map = ast_map,
    substitute = ast_substitute,
    vars = ast_vars,
    size = ast_size,
    depth = ast_depth,
    tostring = ast_tostring,

    is_number = ast_is_number,
    is_variable = ast_is_variable,
    is_func = ast_is_func,
    is_op = ast_is_op,

    eval_numeric = ast_eval_numeric,
    match = ast_match,
    debug_print = ast_debug_print,
}

-- Flattens nested additive/multiplicative trees
-- Useful for canonicalization, sorting, or general misuse
function ast_flatten_add(node)
    if not ast_is_op(node, "add") then return { node } end
    local parts = {}
    local function collect(n)
        if ast_is_op(n, "add") then
            for _, v in ipairs(n.args) do
                collect(v)
            end
        else
            table.insert(parts, n)
        end
    end
    collect(node)
    table.sort(parts, function(a, b) return ast_tostring(a) < ast_tostring(b) end)
    return parts
end

-- Flattens nested additive/multiplicative trees
-- Useful for canonicalization, sorting, or general misuse
function ast_flatten_mul(node)
    if not ast_is_op(node, "mul") then return { node } end
    local parts = {}
    local function collect(n)
        if ast_is_op(n, "mul") then
            for _, v in ipairs(n.args) do
                collect(v)
            end
        else
            table.insert(parts, n)
        end
    end
    collect(node)
    table.sort(parts, function(a, b) return ast_tostring(a) < ast_tostring(b) end)
    return parts
end

ast.flatten_add = ast_flatten_add
ast.flatten_mul = ast_flatten_mul

-- Generic AST node constructor
function ast_node(typ, opts)
    local node = { type = typ }
    for k, v in pairs(opts or {}) do
        node[k] = v
    end
    return node
end
ast.node = ast_node
_G.ast_node = ast.node
_G.ast = ast




_G.ast_debug_print = ast_debug_print


-- Patch ast.eval_numeric to support physics functions without cyclic load errors
do
  local old_eval_numeric = ast.eval_numeric

  function ast.eval_numeric(node, env)
    env = env or {}
    -- Lazy-load physics module to break cyclic dependency
    local physics = _G.physics or require("physics")

    if node.type == "func" then
      local args_eval = {}
      for i, arg in ipairs(node.args) do
        args_eval[i] = ast.eval_numeric(arg, env)
      end

      if math[node.name] then
        return math[node.name](table.unpack(args_eval))
      end

      if node.name == "ln" then return math.log(args_eval[1]) end
      if node.name == "log" then return math.log10(args_eval[1]) end
      if node.name == "gamma" then
        local n = args_eval[1]
        if n > 0 and math.floor(n) == n then
          local fact = 1
          for i = 1, n - 1 do fact = fact * i end
          return fact
        elseif n == 0.5 then
          return math.sqrt(math.pi)
        else
          error("Gamma function not implemented for value: " .. tostring(n))
        end
      end

      -- Delegate to physics evaluation if available
      local phys_val = physics.eval_physics_func(node.name, node.args)
      if phys_val ~= nil then
        return ast.eval_numeric(phys_val, env)
      end

      error("Unknown function: " .. tostring(node.name))
    else
      return old_eval_numeric(node, env)
    end
  end

  ast.eval_numeric = ast.eval_numeric
end

-- End src/ast.lua

-- Just added src/ast.lua—hope your logic is watertight.

-- Begin src/errors.lua
-- errors.lua: handles sarcastic diagnostics for the criminally wrong

_G.errors = {}

_G.errors.custom = {
  ["simplify(human_emotion)"] = {
  "simplify(human_emotion): undefined behavior. Try numbing instead.",
  "expression too irrational. Can't simplify that.",
  "simplify(): emotions do not cancel out algebraically."
},

["solve(economy)"] = {
  "solution too volatile. Try again next fiscal cycle.",
  "solve(economy): infinite variables, zero stability.",
  "output is imaginary. So is the value of your currency."
},

["int(motivation)"] = {
  "area under the curve is... flat. Burnout detected.",
  "integrated result: exhaustion + C",
  "int(motivation): indefinite. Like your deadlines."
},

["diff(common_sense)"] = {
  "∂/∂x(common_sense) = 0. It’s a constant…ly missing.",
  "derivative undefined. Assumed extinct.",
  "diff(): nothing to differentiate. It was never there."
},

["subs(truth, society, propaganda)"] = {
  "truth replaced with propaganda. Output looks familiar.",
  "subs(): societal override complete. Result: fiction.",
  "did you mean: rationalize(disaster)?"
},

["solve(existence = absurdity)"] = {
  "solve(): contradiction detected. Camus would approve.",
  "equation tautological. Output is void.",
  "solution: undefined. Please consult your local philosopher."
},

["tokenize(entropy)"] = {
  "tokenize(): too much randomness. Try less chaos.",
  "failed to classify: input appears stochastic.",
  "token stream is melting. So is reality."
},

["parse(hope)"] = {
  "parser found optimism. Immediately rejected.",
  "hope is not a valid token.",
  "parse(): unexpected symbol. Are you dreaming again?"
},
  ["simplify(existence)"] = {
    "undefined. Like your weekend plans.",
    "simplify(existence): returns 'absurd'. Camus approves.",
    "Trying to simplify existence? Good luck with that."
  },
  ["solve(life)"] = {
    "solution not found. Try philosophy().",
    "solve(life): result is complex. No real solutions.",
    "solve(life): nice try. Meaning remains undefined."
  },
  ["diff(nothing)"] = {
    "finally, something you can't screw up.",
    "∂/∂nothing = nothing. Revolutionary.",
    "You differentiated nothing. Ambitious."
  },
  ["d/dx(nothing))"] = {
    "d/dx(nothing): you're trying too hard and also failing.",
    "diff(expr, var): both required. Unlike your faith in syntax.",
    "You wrote a fraction that looks like math. But isn't."
  },
  ["int(hopelessness)"] = {
    "integrated result: depression + C",
    "area under the curve? it's flatlining.",
    "hope cancelled. integration complete."
  },
  ["subs(sanity, reality, chaos)"] = {
    "sanity → chaos applied. welcome to symbolic algebra.",
    "substitution complete. your mind is now unstable.",
    "why did you do that? too late now."
  },
  ["gcd(404, not_found)"] = {
    "Missing operand. Or file.",
    "gcd error: inputs not located.",
    "check your gcd privileges."
  }
}

function _G.errors.get(key)
  local val = _G.errors.custom and _G.errors.custom[key]
  if type(val) == "table" then
    return val[math.random(#val)]
  else
    return val
  end
end

function _G.errors.invalid(fn, hint)
  local base = {
    simplify = {
      default = "simplify() expects an expression. Yours was... questionable.",
      type = "simplify(): expected expression, got a math-themed prank."
    },
    solve = {
      default = "solve() needs an equation. Not interpretive math dance.",
      missing_eq = "solve(): that’s not an equation. It’s a suggestion.",
      empty = "solve(): nothing to solve. Existential, huh?"
    },
    subs = {
      default = "subs(expr, var, val): you're missing something. Probably 'val'.",
      args = "subs(): three arguments please. This isn’t blackjack.",
      type = "subs(): expected AST, got a philosophical void."
    },
    int = {
      default = "int(expr) wants an integrand. You gave hope.",
      type = "int(): we can’t integrate that. Not even symbolically."
    },
    diff = {
      default = "diff(expr, var): both required. Unlike your faith in syntax.",
      args = "diff(): expression and variable are not optional accessories.",
      type = "diff(): we differentiate functions, not vibes."
    },
    factor = {
      default = "factor(expr): we can’t factor air.",
      type = "factor(): expected expression. Got nihilism instead."
    },
    gcd = {
      default = "gcd(a, b): you forgot one. Math is a duet.",
      args = "gcd(): needs two numbers. This isn’t solo algebra.",
      type = "gcd(): expected integers. Got chaos."
    },
    lcm = {
      default = "lcm(a, b): needs two arguments. Try harder.",
      type = "lcm(): expected numeric inputs. Yours are... mysterious."
    },
    trigid = {
      default = "trigid(expr): not just for trig dreams.",
      arg = "trigid(): you forgot the trig part. Again."
    },
    parse = {
      default = "parse(): failed to understand your expression. Again.",
      unexpected = "parse(): unexpected token. Are you freestyling?"
    },
    tokenize = {
      default = "tokenize(): found something it couldn't classify. Like your handwriting.",
      badchar = "tokenize(): unknown character. Probably cursed."
    },
    compile = { default = "compile(): could not compile. You should feel bad." },
    eval = { default = "eval(): tried. Failed. Retrying won’t help." },
    ast = { default = "AST error: malformed tree. Roots missing." },
    gui = { default = "GUI error: screen logic borked. Blame the OS. Or you." },
    input = { default = "Input error: at least *pretend* to enter valid math." },
    runtime = { default = "Runtime error: no, seriously, what did you expect?" },
    default = { default = "Something broke. Again. This is why we can’t have nice things." }
  }

  local fnBlock = base[fn] or base["default"]
  if type(fnBlock) == "table" then
    return (hint and fnBlock[hint]) or fnBlock.default or base["default"].default
  else
    return fnBlock
  end
end

-- intentionally not returning anything because this file is concatenated

-- End src/errors.lua

-- src/errors.lua has arrived. Prepare to blame someone.

-- Begin src/parser.lua
-- parser.lua: Because writing your own parser is the best way to avoid happiness.
--
-- For those who care about "compatibility": yes, the API is still the same.
--   tokenize(expr) => {tokens} -- like anyone remembers the output.
--   buildAST(tokens) => ast    -- because trees are the only way to understand math.
--   parseExpr(tokens, idx) => ast, nextIdx -- because recursion is fun until it isn't.
--
-- Now with more "features" you didn't ask for: error nagging, big numbers, functions, brackets, sneaky multiplication, negative numbers, and, because why not, matrix parsing.

local parser = {}
local init = rawget(_G, "init")
local errors = rawget(_G, "errors") or {
  invalid = function(fn, hint)
    return "parse(" .. (fn or "?") .. "): " .. (hint or "unknown error. also: _G.errors was nil.")
  end
}

-- Because seeing your AST in tree form is the only joy you'll get today.
local function print_ast(ast, indent)
  indent = indent or ""
  if type(ast) ~= "table" then
    print(indent .. tostring(ast))
    return
  end
  if ast.type then
    local desc = ast.type
    if ast.name then desc = desc .. " (" .. tostring(ast.name) .. ")" end
    print(indent .. desc)
    if ast.value ~= nil then print(indent .. "  value: " .. tostring(ast.value)) end
    if ast.name ~= nil and ast.type ~= "variable" then print(indent .. "  name: " .. tostring(ast.name)) end
    if ast.args then
      print(indent .. "  args:")
      for i, arg in ipairs(ast.args) do
        print_ast(arg, indent .. "    ")
      end
    end
    if ast.rows then
      print(indent .. "  rows:")
      for i, row in ipairs(ast.rows) do
        print(indent .. "    row " .. i .. ":")
        for j, elem in ipairs(row) do
          print_ast(elem, indent .. "      ")
        end
      end
    end
    if ast.base then
      print(indent .. "  base:")
      print_ast(ast.base, indent .. "    ")
    end
    if ast.exp then
      print(indent .. "  exp:")
      print_ast(ast.exp, indent .. "    ")
    end
    if ast.left then
      print(indent .. "  left:")
      print_ast(ast.left, indent .. "    ")
    end
    if ast.right then
      print(indent .. "  right:")
      print_ast(ast.right, indent .. "    ")
    end
  else
    for k, v in pairs(ast) do
      print(indent .. tostring(k) .. ":")
      print_ast(v, indent .. "  ")
    end
  end
end
parser.print_ast = print_ast
_G.print_ast = print_ast

-- Tokenizer: Because parsing math without slicing it into tiny pieces would be too easy.

local function utf8char(str, i)
  local b1 = str:byte(i)
  if not b1 then return nil, 0 end
  if b1 < 0x80 then
    return str:sub(i, i), 1
  elseif b1 < 0xE0 and #str >= i + 1 then
    return str:sub(i, i + 1), 2
  elseif b1 < 0xF0 and #str >= i + 2 then
    return str:sub(i, i + 2), 3
  elseif b1 < 0xF8 and #str >= i + 3 then
    return str:sub(i, i + 3), 4
  else
    -- Invalid start byte or incomplete sequence, treat as one byte to avoid infinite loop
    return str:sub(i, i), 1
  end
end

-- Adjust is_alpha to recognize ascii letters and greek utf8 letters (add more if needed)
local function is_alpha(c)
  -- ASCII letters
  if c:match("^[%a_]$") then return true end
  -- Common Greek letters and others can be added here
  -- For demo, accept anything with byte length > 1 (non-ASCII)
  if #c > 1 then return true end
  return false
end

function parser.tokenize(expr)
  local tokens = {}
  local i = 1
  local len = #expr
  while i <= len do
    local c, clen = utf8char(expr, i)
    if not c or clen == 0 then break end

    if c:match('%s') then
      -- whitespace
      i = i + clen
    -- Improved special handling for (d/dx) derivative pattern
    elseif expr:sub(i, i+4) == "(d/dx" and expr:sub(i+5, i+5) == ")" then
      table.insert(tokens, {type="derivative"})
      i = i + 6 -- skip full "(d/dx)"
    elseif c:match('%d') or (c == '.' and (i+clen <= len) and expr:sub(i+clen,i+clen):match('%d')) then
      -- number, read full numeric token
      local num = c
      i = i + clen
      while i <= len do
        local nc, nclen = utf8char(expr, i)
        if not nc or not (nc:match('%d') or nc == '.') then break end
        num = num .. nc
        i = i + nclen
      end
      table.insert(tokens, {type="number", value=tonumber(num)})
      print(string.format("Token: [number] %s", num))
    elseif c == '∫' then
      table.insert(tokens, {type="integral", value=c})
      print(string.format("Token: [integral] %s", c))
      i = i + clen
    elseif is_alpha(c) then
      -- identifier/function
      local ident = c
      i = i + clen
      while i <= len do
        local nc, nclen = utf8char(expr, i)
        if not nc then break end
        if is_alpha(nc) or nc:match('%d') then
          ident = ident .. nc
          i = i + nclen
        else
          break
        end
      end
      table.insert(tokens, {type="ident", value=ident})
      print(string.format("Token: [ident] %s", ident))
    elseif c == '"' or c == "'" then
      -- string literal
      local quote = c
      local j = i + clen
      local str = ''
      while j <= len do
        local cc, cclen = utf8char(expr, j)
        if not cc then break end
        if cc == quote then break end
        str = str .. cc
        j = j + cclen
      end
      if j > len then
        error(errors.invalid('tokenize', 'unterminated string literal'))
      end
      table.insert(tokens, {type='string', value=str})
      print(string.format("Token: [string] %s", str))
      i = j + clen -- skip closing quote
    elseif c == ')' then
      -- Special handling for closing parenthesis after (d/dx
      if #tokens > 0 and tokens[#tokens].type == "derivative_start" then
        tokens[#tokens].type = "derivative"
      else
        table.insert(tokens, {type=c, value=c})
      end
      i = i + clen
    elseif c == ',' or c == '(' or c == '[' or c == ']' or
           c == '+' or c == '-' or c == '*' or c == '/' or c == '^' or
           c == '!' or c == '=' or c == '∫' then
      local ttype
      if c == ',' then ttype = ','
      elseif c == '(' then ttype = c
      elseif c == '[' or c == ']' then ttype = c
      elseif c == '=' then ttype = "equals"
      elseif c == '∫' then ttype = "integral"
      elseif c == '+' or c == '-' or c == '*' or c == '/' or c == '^' or c == '!' then ttype = "op"
      else ttype = "unknown" end
      table.insert(tokens, {type=ttype, value=c})
      print(string.format("Token: [%s] %s", ttype, c))
      i = i + clen
    else
      error(errors.invalid("tokenize", "unknown character: " .. c))
    end
  end

  -- Insert implicit multiplication tokens as before
  local j = 2
  while j <= #tokens do
    local t1, t2 = tokens[j-1], tokens[j]
    if (t1.type == 'number' or t1.type == ')' ) and
       (t2.type == 'ident' or t2.type == '(' or t2.type == '[') then
      table.insert(tokens, j, {type="op", value="*"})
      j = j + 1
    end
    j = j + 1
  end

  print("Final token list:")
  for _, tok in ipairs(tokens) do
    print(string.format("  %s : %s", tok.type, tostring(tok.value)))
  end
  return tokens
end

-- Parser: Because recursion is the only way to feel alive.
--   Now with precedence, unary minus, function calls, and, of course, matrices.

-- Matrix parsing: because spreadsheets weren't enough.
local function parse_matrix(tokens, idx)
  -- Expect '[' to start, because obviously that's how math works now.
  assert(tokens[idx] and tokens[idx].type == '[', 
         errors.invalid("parse_matrix", "expected '[' to start matrix (did you mean to type something else?)"))
  
  local i = idx + 1
  
  -- Handle empty matrix case, because someone just loves empty brackets.
  if tokens[i] and tokens[i].type == ']' then
    return {type="matrix", rows={}}, i + 1
  end
  
  -- Decide if it's a 1D vector or a 2D matrix, because ambiguity is fun.
  -- Look ahead to see if first element is '['
  if tokens[i] and tokens[i].type == '[' then
    -- This is a 2D matrix [[...], [...]] -- because 1D was too boring.
    local rows = {}
    
    -- Parse first row, because why not nest things more.
    i = i + 1 -- skip '['
    local current_row = {}
    
    -- Parse elements in first row, because commas are the new semicolons.
    if tokens[i] and tokens[i].type ~= ']' then
      local elem, ni = parser.parseExpr(tokens, i)
      table.insert(current_row, elem)
      i = ni
      
      while tokens[i] and tokens[i].type == ',' do
        local next_elem
        next_elem, i = parser.parseExpr(tokens, i + 1)
        table.insert(current_row, next_elem)
      end
    end
    
    -- Expect ']' to end first row (because matching brackets is a core life skill).
    assert(tokens[i] and tokens[i].type == ']', 
           errors.invalid("parse_matrix", "expected ']' to end matrix row (or maybe just give up?)"))
    i = i + 1
    
    table.insert(rows, current_row)
    local expected_cols = #current_row
    
    -- Parse remaining rows, because you thought one row was enough? Ha.
    while tokens[i] and tokens[i].type == ',' do
      i = i + 1 -- skip comma
      
      -- Parse next row, because every matrix needs more rows.
      assert(tokens[i] and tokens[i].type == '[', 
             errors.invalid("parse_matrix", "expected '[' to start matrix row (you broke the symmetry)"))
      i = i + 1
      
      local row = {}
      
      -- Parse elements in this row, because repetition is the spice of life.
      if tokens[i] and tokens[i].type ~= ']' then
        local elem, ni = parser.parseExpr(tokens, i)
        table.insert(row, elem)
        i = ni
        
        while tokens[i] and tokens[i].type == ',' do
          local next_elem
          next_elem, i = parser.parseExpr(tokens, i + 1)
          table.insert(row, next_elem)
        end
      end
      
      -- Expect ']' to end this row (because brackets are your new best friend).
      assert(tokens[i] and tokens[i].type == ']', 
             errors.invalid("parse_matrix", "expected ']' to end matrix row (math is hard)"))
      i = i + 1
      
      -- Check row length consistency, because apparently rectangular matrices are a thing.
      assert(#row == expected_cols, 
             errors.invalid("parse_matrix", "matrix rows must have same number of columns (nice try)"))
      
      table.insert(rows, row)
    end
    
    -- Expect ']' to end matrix, because you love counting brackets.
    assert(tokens[i] and tokens[i].type == ']', 
           errors.invalid("parse_matrix", "expected ']' to end matrix (you almost made it)"))
    
    return {type="matrix", rows=rows}, i + 1
  else
    -- This is a 1D vector [a,b,c] - because 2D was too much work.
    local row = {}
    
    -- Parse elements, because lists are just sad matrices.
    if tokens[i] and tokens[i].type ~= ']' then
      local elem, ni = parser.parseExpr(tokens, i)
      table.insert(row, elem)
      i = ni
      
      while tokens[i] and tokens[i].type == ',' do
        local next_elem
        next_elem, i = parser.parseExpr(tokens, i + 1)
        table.insert(row, next_elem)
      end
    end
    
    -- Expect ']' to end vector (don't forget your closing bracket, rebel).
    assert(tokens[i] and tokens[i].type == ']', 
           errors.invalid("parse_matrix", "expected ']' to end vector (you just had to forget, didn't you?)"))
    
    return {type="matrix", rows={row}}, i + 1
  end
end

-- Handles literals, variables, function calls, parentheses, matrices, and unary minus.
-- Also wraps things in factorials if someone thought 'x!' was a good idea. Because, why not.
local function make_var(x) return {type="variable", name=x} end -- Because variables need love too.

-- Integral parsing: parses ∫(expression, variable)
local function parse_integral(tokens, idx)
  -- ∫(expression, variable) format
  local tok = tokens[idx]
  assert(tok and tok.type == "integral", "expected ∫ symbol")

  assert(tokens[idx + 1] and tokens[idx + 1].type == "(", "expected '(' after ∫")

  local expr, i = parser.parseExpr(tokens, idx + 2)
  assert(tokens[i] and tokens[i].type == ",", "expected ',' after integral expression")

  local var_token = tokens[i + 1]
  assert(var_token and var_token.type == "ident", "expected variable name after ',' in integral")

  assert(tokens[i + 2] and tokens[i + 2].type == ")", "expected ')' to close integral")

  return {
    type = "func",
    name = "int",
    args = { expr, { type = "variable", name = var_token.value } }
  }, i + 3
end

local function parse_primary(tokens, idx)
  local tok = tokens[idx]
  if not tok then return nil, idx end

  local function wrap_factorial(node, i)
    if tokens[i] and tokens[i].type == "op" and tokens[i].value == "!" then
      return {
        type = "func",
        name = "factorial",
        args = { node }
      }, i + 1
    end
    return node, i
  end

  -- Derivative node: (d/dx)(expr) pattern
  if tok.type == "derivative" then
    local expr, ni = parser.parseExpr(tokens, idx + 1)
    return {type="derivative", respect_to="x", expr=expr}, ni
  end

  if tok.type == "integral" then
    return parse_integral(tokens, idx)
  elseif tok.type == "number" then
    return wrap_factorial({type="number", value=tok.value}, idx+1)
  elseif tok.type == "ident" then
    if tokens[idx + 1] and tokens[idx + 1].type == "(" then
      -- Special handling for series(func, var, center, order)
      if tok.value == "series" then
        local i = idx + 2
        local func_expr, ni = parser.parseExpr(tokens, i)
        assert(tokens[ni] and tokens[ni].type == ",", "expected ',' after function expression in series()")
        local var_node, ni2 = parser.parseExpr(tokens, ni + 1)
        assert(tokens[ni2] and tokens[ni2].type == ",", "expected ',' after variable in series()")
        local center_node, ni3 = parser.parseExpr(tokens, ni2 + 1)
        assert(tokens[ni3] and tokens[ni3].type == ",", "expected ',' after center in series()")
        local order_node, ni4 = parser.parseExpr(tokens, ni3 + 1)
        assert(tokens[ni4] and tokens[ni4].type == ")", "expected ')' to close series()")
        return {
          type = "series",
          func = func_expr,
          var = var_node,
          center = center_node,
          order = order_node
        }, ni4 + 1
      end
      -- Function call detected (non-series)
      local args = {}
      local i = idx + 2
      if tokens[i] and tokens[i].type ~= ")" then
        local arg_node
        arg_node, i = parser.parseExpr(tokens, i)
        table.insert(args, arg_node)
        while tokens[i] and tokens[i].type == "," do
          local next_arg
          next_arg, i = parser.parseExpr(tokens, i + 1)
          table.insert(args, next_arg)
        end
      end
      assert(tokens[i] and tokens[i].type == ")", "expected ')' after function arguments")
      return wrap_factorial({ type="func", name=tok.value, args=args }, i + 1)
    else
      local physics_constants = _G.physics and _G.physics.constants or nil
      if physics_constants and physics_constants[tok.value] then
        -- Use deepcopy to avoid shared state for constant value nodes
        local deepcopy = rawget(_G, "deepcopy") or function(tbl)
          if type(tbl) ~= "table" then return tbl end
          local t2 = {}
          for k, v in pairs(tbl) do
            t2[k] = type(v) == "table" and deepcopy(v) or v
          end
          return t2
        end
        local constant_entry = physics_constants[tok.value]
        local val_node = deepcopy(constant_entry.value)
        local node = {type="constant", name=tok.value, value=val_node}
        return wrap_factorial(node, idx + 1)
      else
        return wrap_factorial({type="variable", name=tok.value}, idx + 1)
      end
    end
  elseif tok.type == '(' then
    -- Detect general derivative notation (d)/(dx)(expr)
    if tokens[idx+1] and tokens[idx+1].type == 'ident' and tokens[idx+1].value == 'd' then
      if tokens[idx+2] and tokens[idx+2].type == ')' and
   tokens[idx+3] and tokens[idx+3].type == 'op' and tokens[idx+3].value == '/' and
   tokens[idx+4] and tokens[idx+4].type == '(' and
   tokens[idx+5] and tokens[idx+5].type == 'ident' and tokens[idx+5].value == 'dx' and
   tokens[idx+6] and tokens[idx+6].type == ')' then
        local expr, ni = parser.parseExpr(tokens, idx + 7)
        return {
            type = "derivative",
            respect_to = "x",
            expr = expr
        }, ni
      end
    end
    local node, ni = parser.parseExpr(tokens, idx+1)
    assert(tokens[ni] and tokens[ni].type == ')', "expected ')'")
    return wrap_factorial(node, ni+1)
  elseif tok.type == '[' then
    local matrix, ni = parse_matrix(tokens, idx)
    return wrap_factorial(matrix, ni)
  elseif tok.type == 'string' then
    return {type='string', value=tok.value}, idx + 1
  elseif tok.type == "op" and tok.value == '-' then
    local expr, ni = parser.parseExpr(tokens, idx+1)
    return wrap_factorial({type="neg", value=expr}, ni)
  else
    error("unexpected token at parse_primary: " .. (tok.type or '?'))
  end
end

-- Parses exponentiation. Right-associative, because math teachers said so.
local function parse_power(tokens, idx)
  local left, i = parse_primary(tokens, idx)
  while tokens[i] and tokens[i].type == "op" and tokens[i].value == '^' do
    local right
    right, i = parse_primary(tokens, i+1)
    left = {type="pow", base=left, exp=right}
  end
  return left, i
end

-- Handles multiplication, division, and reciprocal logic.
-- Because a/b is really just a*1/b, right? (Sure, let's pretend.)
local function parse_term(tokens, idx)
  -- Parse the first factor, because you have to start somewhere.
  local factors = {}
  local i = idx
  local node, ni = parse_power(tokens, i)
  table.insert(factors, node)
  i = ni
  while tokens[i] and tokens[i].type == "op" and (tokens[i].value == '*' or tokens[i].value == '/') do
    local op = tokens[i].value
    local right
    right, i = parse_power(tokens, i+1)
    if op == '*' then
      table.insert(factors, right)
    else
      -- Division: because why not multiply by the reciprocal and confuse everyone.
      table.insert(factors, {type="pow", base=right, exp={type="number", value=-1}})
    end
  end
  if #factors == 1 then
    return factors[1], i
  else
    return {type="mul", args=factors}, i
  end
end

-- The real entry point for expressions. Supports + and -, but mostly supports your suffering.
-- Folds everything into a single add tree so simplify() doesn't go on strike.
function parser.parseExpr(tokens, idx)
  idx = idx or 1
  local terms = {}
  local signs = {}
  local node, i = parse_term(tokens, idx)
  table.insert(terms, node)
  table.insert(signs, 1)
  while tokens[i] and tokens[i].type == "op" and (tokens[i].value == '+' or tokens[i].value == '-') do
    local op = tokens[i].value
    local right
    right, i = parse_term(tokens, i+1)
    if op == '+' then
      table.insert(terms, right)
      table.insert(signs, 1)
    else
      -- Instead of wrapping just numbers in neg, wrap the whole right term
      table.insert(terms, right)
      table.insert(signs, -1)
    end
  end
  -- Flatten into n-ary add, handling subtraction as add of negative (because why not make it harder?)
  if #terms == 1 then
    if tokens[i] and tokens[i].type == "equals" then
      local rhs, next_i = parser.parseExpr(tokens, i + 1)
      return {type = "equation", left = node, right = rhs}, next_i -- Because equations make everything more complicated.
    end
    return node, i
  else
    local args = {}
    for j = 1, #terms do
      if signs[j] == 1 then
        table.insert(args, terms[j])
      else
        table.insert(args, {type="neg", value=terms[j]})
      end
    end
    local add_node = {type="add", args=args}
    if tokens[i] and tokens[i].type == "equals" then
      local rhs, next_i = parser.parseExpr(tokens, i + 1)
      return {type = "equation", left = add_node, right = rhs}, next_i -- Because why stop at arithmetic when you can do algebra?
    end
    return add_node, i
  end
end

-- Wraps parseExpr and checks for leftovers.
-- If you forgot a bracket, this will find it and yell at you.
function parser.buildAST(tokens)
  local ast, idx = parser.parseExpr(tokens, 1)
  if idx <= #tokens then
    error(errors.invalid("parse", "unexpected " .. tostring(tokens[idx].type or "?") .. " (you left something behind)"))
  end
  return ast
end

function parser.parse(expr)
  -- Get physics constants table and category from global
  local constants = _G.physics and _G.physics.constants or nil
  local constants_off = _G.var and _G.var.recall and _G.var.recall("constants_off")
  local current_category = _G.current_constant_category or "fundamental"

  -- Tokenize first, then replace identifier tokens with constants if appropriate
  local tokens = parser.tokenize(expr)

  -- Replace identifiers matching constant symbols after tokenizing
  if constants and not constants_off then
      for _, tok in ipairs(tokens) do
          if tok.type == "ident" and constants[tok.value] then
              if _G.physics.is_constant_enabled(tok.value) and
                 (not current_category or constants[tok.value].category == current_category or constants[tok.value].category == nil) then
                  -- Replace identifier with constant name if symbol matches
                  tok.type = "constant"
                  tok.name = tok.value
                  tok.value = nil
              end
          end
      end
  end

  -- Proceed with building AST etc...
  local ok, ast_or_err = pcall(parser.buildAST, tokens)
  if not ok then
    error(errors.invalid("parse", tostring(ast_or_err)))
  end
  return ast_or_err
end

_G.parser = parser
_G.parse = parser.parse

_G.parser = parser

-- Expose a direct solve_equation interface for global use, because everyone wants to solve everything.
if _G.solve_equation then
  _G.solve = function(expr)
    local ast = parser.parse(expr)
    return _G.solve_equation(ast)
  end
end

-- Wraps two arguments in a 'sub' node, because subtraction isn't just minus.
function parser.make_sub(left, right)
  return {type = "sub", left = left, right = right}
end

-- Wraps two arguments in a 'div' node, because division is just misunderstood multiplication.
function parser.make_div(num, denom)
  return {type = "div", left = num, right = denom}
end


-- Greek letter aliases (UTF-8 mapped to standard names)
-- Greek letter aliases for physics constants (assumes Constants table exists)
if _G.Constants then
    -- Basic Greek alphabet
    Constants[utf8(945)] = Constants["alpha"] or Constants[utf8(945)]  -- α (fine structure already exists)
Constants[utf8(946)] = Constants["beta"]                           -- β  
Constants[utf8(947)] = Constants["gamma"]                          -- γ
Constants[utf8(948)] = Constants["delta"]                          -- δ
Constants[utf8(949)] = Constants["epsilon"] or Constants[utf8(949).."0"] -- ε (permittivity already exists)
Constants[utf8(950)] = Constants["zeta"]                           -- ζ
Constants[utf8(951)] = Constants["eta"]                            -- η
Constants[utf8(952)] = Constants["theta"]                          -- θ
Constants[utf8(953)] = Constants["iota"]                           -- ι
Constants[utf8(954)] = Constants["kappa"]                          -- κ
Constants[utf8(955)] = Constants["lambda"]                         -- λ
Constants[utf8(956)] = Constants["mu"] or Constants[utf8(956).."0"] -- μ (permeability already exists)
Constants[utf8(957)] = Constants["nu"]                             -- ν
Constants[utf8(958)] = Constants["xi"]                             -- ξ
Constants[utf8(959)] = Constants["omicron"]                        -- ο
Constants[utf8(960)] = Constants["pi"]                             -- π (already exists)
Constants[utf8(961)] = Constants["rho"]                            -- ρ
Constants[utf8(962)] = Constants["sigma_final"]                    -- ς (final sigma)
Constants[utf8(963)] = Constants["sigma"]                          -- σ
Constants[utf8(964)] = Constants["tau"]                            -- τ
Constants[utf8(965)] = Constants["upsilon"]                        -- υ
Constants[utf8(966)] = Constants["phi"]                            -- φ
Constants[utf8(967)] = Constants["chi"]                            -- χ
Constants[utf8(968)] = Constants["psi"]                            -- ψ
Constants[utf8(969)] = Constants["omega"]                          -- ω

-- Greek letters (uppercase)
Constants[utf8(913)] = Constants["Alpha"]                          -- Α
Constants[utf8(914)] = Constants["Beta"]                           -- Β
Constants[utf8(915)] = Constants["Gamma"]                          -- Γ
Constants[utf8(916)] = Constants["Delta"]                          -- Δ
Constants[utf8(917)] = Constants["Epsilon"]                        -- Ε
Constants[utf8(918)] = Constants["Zeta"]                           -- Ζ
Constants[utf8(919)] = Constants["Eta"]                            -- Η
Constants[utf8(920)] = Constants["Theta"]                          -- Θ
Constants[utf8(921)] = Constants["Iota"]                           -- Ι
Constants[utf8(922)] = Constants["Kappa"]                          -- Κ
Constants[utf8(923)] = Constants["Lambda"]                         -- Λ
Constants[utf8(924)] = Constants["Mu"]                             -- Μ
Constants[utf8(925)] = Constants["Nu"]                             -- Ν
Constants[utf8(926)] = Constants["Xi"]                             -- Ξ
Constants[utf8(927)] = Constants["Omicron"]                        -- Ο
Constants[utf8(928)] = Constants["Pi"]                             -- Π
Constants[utf8(929)] = Constants["Rho"]                            -- Ρ
Constants[utf8(931)] = Constants["Sigma"]                          -- Σ
Constants[utf8(932)] = Constants["Tau"]                            -- Τ
Constants[utf8(933)] = Constants["Upsilon"]                        -- Υ
Constants[utf8(934)] = Constants["Phi"]                            -- Φ
Constants[utf8(935)] = Constants["Chi"]                            -- Χ
Constants[utf8(936)] = Constants["Psi"]                            -- Ψ
Constants[utf8(937)] = Constants["Omega"]                          -- Ω

-- PHYSICS-SPECIFIC CONSTANTS AND ALIASES

-- Common physics symbols
Constants[utf8(8463)] = Constants["h"] or Constants["planck"]      -- ℏ (reduced Planck)
Constants["hbar"] = Constants[utf8(8463)]

-- Mass-energy relations
Constants[utf8(956).."e"] = Constants["me"]                        -- μe (electron mass)
Constants[utf8(956).."p"] = Constants["mp"]                        -- μp (proton mass) 
Constants[utf8(956).."n"] = Constants["mn"]                        -- μn (neutron mass)

-- Coupling constants
Constants[utf8(945).."s"] = Constants["strong_coupling"]           -- αs (strong coupling)
Constants[utf8(945).."em"] = Constants[utf8(945)]                  -- αem (electromagnetic, same as fine structure)

-- Particle physics masses (if you add them)
Constants[utf8(956).."_e"] = Constants["electron_mass"]            -- μ_e
Constants[utf8(956).."_"..utf8(956)] = Constants["muon_mass"]      -- μ_μ (muon)
Constants[utf8(956).."_"..utf8(964)] = Constants["tau_mass"]       -- μ_τ (tau)
Constants["m_W"] = Constants["w_boson_mass"]                       -- W boson
Constants["m_Z"] = Constants["z_boson_mass"]                       -- Z boson
Constants["m_H"] = Constants["higgs_mass"]                         -- Higgs
Constants["m_t"] = Constants["top_mass"]                          -- top quark
Constants["m_b"] = Constants["bottom_mass"]                       -- bottom quark
Constants["m_c"] = Constants["charm_mass"]                        -- charm quark
Constants["m_s"] = Constants["strange_mass"]                      -- strange quark
Constants["m_u"] = Constants["up_mass"]                           -- up quark
Constants["m_d"] = Constants["down_mass"]                         -- down quark

-- QCD scale
Constants[utf8(923).."_QCD"] = Constants["lambda_qcd"]            -- Λ_QCD
Constants[utf8(952).."_QCD"] = Constants["theta_qcd"]             -- θ_QCD

-- Weinberg angle
Constants[utf8(952).."_W"] = Constants["weinberg_angle"]          -- θ_W
Constants["sin2"..utf8(952).."_W"] = Constants["sin2_theta_w"]    -- sin²θ_W

-- Cosmological constants
Constants[utf8(923)] = Constants["cosmological_constant"]         -- Λ
Constants[utf8(937).."_m"] = Constants["matter_density"]          -- Ω_m
Constants[utf8(937).."_"..utf8(923)] = Constants["dark_energy"]  -- Ω_Λ
Constants[utf8(937).."_b"] = Constants["baryon_density"]          -- Ω_b
Constants["H_0"] = Constants["hubble_constant"]                   -- H₀

-- Thermodynamic
Constants[utf8(946)] = Constants["inverse_temperature"]           -- β = 1/(kT)
Constants[utf8(963).."_SB"] = Constants["stefan_boltzmann"]       -- σ_SB

-- CKM matrix elements (quark mixing)
Constants["V_ud"] = Constants["ckm_ud"]
Constants["V_us"] = Constants["ckm_us"] 
Constants["V_ub"] = Constants["ckm_ub"]
Constants["V_cd"] = Constants["ckm_cd"]
Constants["V_cs"] = Constants["ckm_cs"]
Constants["V_cb"] = Constants["ckm_cb"]
Constants["V_td"] = Constants["ckm_td"]
Constants["V_ts"] = Constants["ckm_ts"]
Constants["V_tb"] = Constants["ckm_tb"]

-- PMNS matrix elements (neutrino mixing)
Constants[utf8(952).."_12"] = Constants["solar_angle"]           -- θ₁₂
Constants[utf8(952).."_23"] = Constants["atmospheric_angle"]     -- θ₂₃  
Constants[utf8(952).."_13"] = Constants["reactor_angle"]         -- θ₁₃
Constants[utf8(948).."_CP"] = Constants["cp_phase"]              -- δ_CP

-- Neutrino mass differences
Constants[utf8(916).."m2_21"] = Constants["delta_m21_squared"]   -- Δm²₂₁
Constants[utf8(916).."m2_31"] = Constants["delta_m31_squared"]   -- Δm²₃₁

-- Running couplings (scale dependent)
Constants[utf8(945).."("..utf8(956)..")"] = Constants["running_alpha"]     -- α(μ)
Constants[utf8(945).."s("..utf8(956)..")"] = Constants["running_alphas"]   -- αs(μ)

-- Renormalization scales  
Constants[utf8(956).."_R"] = Constants["renormalization_scale"]  -- μ_R
Constants[utf8(956).."_F"] = Constants["factorization_scale"]    -- μ_F

-- Effective field theory cutoffs
Constants[utf8(923).."_UV"] = Constants["uv_cutoff"]             -- Λ_UV
Constants[utf8(923).."_IR"] = Constants["ir_cutoff"]             -- Λ_IR

-- Supersymmetry parameters
Constants["M_SUSY"] = Constants["susy_scale"]
Constants["tan"..utf8(946)] = Constants["tan_beta"]              -- tan β
Constants[utf8(956).."_SUSY"] = Constants["susy_mu"]             -- μ_SUSY

-- Axion physics
Constants["f_a"] = Constants["axion_decay_constant"]             -- f_a
Constants[utf8(952).."_strong"] = Constants["strong_cp_angle"]   -- θ_strong

-- Dark matter
Constants[utf8(963).."_SI"] = Constants["dm_si_cross_section"]   -- σ_SI
Constants[utf8(963).."_SD"] = Constants["dm_sd_cross_section"]   -- σ_SD
Constants["<"..utf8(963).."v>"] = Constants["dm_annihilation"]   -- ⟨σv⟩

-- Extra dimensions
Constants["M_D"] = Constants["extra_dim_scale"]
Constants["R_extra"] = Constants["extra_dim_radius"]

-- String theory scale
Constants["M_string"] = Constants["string_scale"]
Constants["M_Pl"] = Constants["planck_mass"]

-- AdS/CFT
Constants["L_AdS"] = Constants["ads_radius"]
Constants["c_central"] = Constants["central_charge"]

-- Instantons and topology
Constants[utf8(952)] = Constants["theta_angle"]                  -- θ
Constants["w"] = Constants["winding_number"]
end

-- End src/parser.lua

-- Imported src/parser.lua—debuggers rejoice.

-- Begin src/factorial.lua
-- factorial.lua
-- Converts symbolic factorial calls to Gamma-based equivalents
-- Works even when you feed it algebra instead of numbers, which is both useful and terrifying

-- Numerical fallback (not actually used in AST transforms)
-- Just here for completeness, or when someone evaluates factorial(5) directly
-- Lanczos approximation for Gamma function, accurate for most real numbers
local lanczos_coef = {
  676.5203681218851, -1259.1392167224028, 771.32342877765313,
  -176.61502916214059, 12.507343278686905, -0.13857109526572012,
  9.9843695780195716e-6, 1.5056327351493116e-7
}

local function gamma(z)
  if z < 0.5 then
    -- Reflection formula for negative arguments
    return math.pi / (math.sin(math.pi * z) * gamma(1 - z))
  else
    z = z - 1
    local x = 0.99999999999980993
    for i = 1, #lanczos_coef do
      x = x + lanczos_coef[i] / (z + i)
    end
    local t = z + #lanczos_coef - 0.5
    return math.sqrt(2 * math.pi) * t^(z + 0.5) * math.exp(-t) * x
  end
end

-- General factorial using Gamma, valid for real/complex domain
local function factorial(n)
  return gamma(n + 1)
end

-- Matches factorial(x) and returns gamma(x + 1)
-- Strictly cosmetic — lets us pretend we know how to differentiate factorials
local function matchFactorial(ast)
  if ast.type == "func" and ast.name == "factorial" and ast.args and #ast.args == 1 then
    local arg = ast.args[1]
    -- Convert factorial(n) to gamma(n+1)
    return {
      type = "func",
      name = "gamma",
      args = {
        {
          type = "add",
          args = { arg, { type = "number", value = 1 } }  -- ← Fixed: Use args array
        }
      }
    }
  end
  return ast
end

-- Walks the AST and replaces every factorial(...) with gamma(... + 1)
-- Recursively rewrites child nodes as well, whether they like it or not
function transformFactorial(ast)
  if type(ast) ~= "table" then return ast end
  
  -- Transform factorial(n) → gamma(n+1)
  if ast.type == "func" and ast.name == "factorial" and ast.args and #ast.args == 1 then
    local arg = transformFactorial(ast.args[1])
    return {
      type = "func",
      name = "gamma",
      args = {
        {
          type = "add",
          args = { arg, { type = "number", value = 1 } }  -- ← Fixed: Use args array
        }
      }
    }
  end
  
  local out = {}
  for k, v in pairs(ast) do
    if type(v) == "table" then
      if #v > 0 then
        out[k] = {}
        for i = 1, #v do
          out[k][i] = transformFactorial(v[i])
        end
      else
        out[k] = transformFactorial(v)
      end
    else
      out[k] = v
    end
  end
  return out
end

-- Evaluate the Gamma function numerically using the Lanczos approximation
local function evaluateGamma(z)
  return gamma(z)
end

-- Evaluate the factorial numerically using the Gamma function
local function evaluateFactorial(n)
  return factorial(n)
end

_G.transformFactorial = transformFactorial
_G.evaluateGamma = evaluateGamma  -- Expose evaluateGamma globally
_G.evaluateFactorial = evaluateFactorial  -- Expose evaluateFactorial globally

-- End src/factorial.lua

-- Just added src/factorial.lua—hope your logic is watertight.

-- Begin src/simplify.lua
local simplify = {}
local ast = rawget(_G, "ast") or require("ast")
local parser = rawget(_G, "parser") or require("parser")

-- ===== UTILITY FUNCTIONS (The Boring But Essential Shit) =====

local function num(n) return {type="number", value=n} end
local function var(name) return {type="variable", name=name} end

local function is_num(e) return e and e.type == "number" end
local function is_var(e) return e and e.type == "variable" end
local function is_pow(e) return e and e.type == "pow" end
local function is_add(e) return e and e.type == "add" end
local function is_mul(e) return e and e.type == "mul" end
local function is_sin(e) return e and e.type == "sin" end
local function is_cos(e) return e and e.type == "cos" end
local function is_ln(e) return e and e.type == "ln" end
local function is_exp(e) return e and e.type == "exp" end

local function deepcopy(t)
    if type(t) ~= "table" then return t end
    local c = {}
    for k,v in pairs(t) do c[k] = deepcopy(v) end
    return c
end

-- Simple hash for expression comparison
local function expr_hash(expr)
    if type(expr) ~= "table" then return tostring(expr) end
    
    local parts = {expr.type}
    if expr.type == "number" then
        table.insert(parts, tostring(expr.value))
    elseif expr.type == "variable" then
        table.insert(parts, expr.name)
    elseif expr.type == "pow" then
        table.insert(parts, expr_hash(expr.base))
        table.insert(parts, expr_hash(expr.exp))
    elseif expr.type == "sin" or expr.type == "cos" or expr.type == "ln" or expr.type == "exp" then
        table.insert(parts, expr_hash(expr.arg))
    elseif (expr.type == "add" or expr.type == "mul") and expr.args then
        local arg_hashes = {}
        for _, arg in ipairs(expr.args) do
            table.insert(arg_hashes, expr_hash(arg))
        end
        table.sort(arg_hashes) -- Commutative operations
        for _, hash in ipairs(arg_hashes) do
            table.insert(parts, hash)
        end
    end
    
    return table.concat(parts, "|")
end

local function expr_equal(a, b)
    return expr_hash(a) == expr_hash(b)
end

-- ===== STEP 1: FLATTEN ASSOCIATIVE OPERATIONS =====
-- Because nested additions/multiplications are the devil

local function flatten(expr)
    if not (is_add(expr) or is_mul(expr)) or not expr.args then return expr end
    
    local flattened = {}
    local op_type = expr.type
    
    local function collect_args(e)
        if e.type == op_type and e.args then
            for _, arg in ipairs(e.args) do
                collect_args(arg)
            end
        else
            table.insert(flattened, e)
        end
    end
    
    for _, arg in ipairs(expr.args) do
        collect_args(arg)
    end
    
    return {type = op_type, args = flattened}
end

-- ===== STEP 2: SORT ARGUMENTS FOR COMMUTATIVITY =====
-- Because order matters for consistency, not math

local function get_power_of_var(expr, var_name)
    -- Return exponent if expr is base^exp where base is var_name
    if expr.type == "pow" and expr.base.type == "variable" and expr.base.name == var_name then
        if expr.exp.type == "number" then
            return expr.exp.value
        end
    elseif expr.type == "variable" and expr.name == var_name then
        return 1
    elseif expr.type == "number" then
        return 0
    end
    return nil -- Cannot determine power
end

local function sort_args(expr)
    if not ((expr.type == "add" or expr.type == "mul") and expr.args) then return expr end
    
    local sorted_args = deepcopy(expr.args)
    -- If addition, try to sort by power of x ascending
    if expr.type == "add" then
        table.sort(sorted_args, function(a, b)
            local a_pow = get_power_of_var(a, "x")
            local b_pow = get_power_of_var(b, "x")
            if a_pow and b_pow then
                return a_pow < b_pow
            elseif a_pow then
                return true
            elseif b_pow then
                return false
            else
                return expr_hash(a) < expr_hash(b)
            end
        end)
    else
        -- For multiplication, keep original expr_hash sorting
        table.sort(sorted_args, function(a, b)
            return expr_hash(a) < expr_hash(b)
        end)
    end
    
    return {type = expr.type, args = sorted_args}
end

-- ===== STEP 3: CONSTANT FOLDING (The Easy Wins) =====

local function fold_constants(expr)
    if is_num(expr) then return expr end
    
    if is_add(expr) and expr.args then
        local sum = 0
        local non_numbers = {}
        
        for _, arg in ipairs(expr.args) do
            if is_num(arg) then
                sum = sum + arg.value
            else
                table.insert(non_numbers, arg)
            end
        end
        
        local result_args = {}
        if sum ~= 0 then
            table.insert(result_args, num(sum))
        end
        for _, arg in ipairs(non_numbers) do
            table.insert(result_args, arg)
        end
        
        if #result_args == 0 then return num(0) end
        if #result_args == 1 then return result_args[1] end
        return {type = "add", args = result_args}
    end
    
    if is_mul(expr) and expr.args then
        local product = 1
        local non_numbers = {}

        for _, arg in ipairs(expr.args) do
            if is_num(arg) then
                product = product * arg.value
            else
                table.insert(non_numbers, arg)
            end
        end

        -- Zero kills everything
        if product == 0 then return num(0) end

        local result_args = {}
        -- Only include the 1 if there are no non-numeric factors
        if product ~= 1 or #non_numbers == 0 then
            table.insert(result_args, num(product))
        end
        for _, arg in ipairs(non_numbers) do
            table.insert(result_args, arg)
        end

        if #result_args == 0 then return num(1) end
        if #result_args == 1 then return result_args[1] end
        return {type = "mul", args = result_args}
    end
    
    if is_pow(expr) then
        if is_num(expr.base) and is_num(expr.exp) then
            return num(expr.base.value ^ expr.exp.value)
        end
    end

    -- Gamma function constant folding using _G.evaluateGamma if available
    if expr.type == "func" and expr.name == "gamma" and expr.args and #expr.args == 1 then
        local arg = expr.args[1]
        if is_num(arg) and _G.evaluateGamma then
            return num(_G.evaluateGamma(arg.value))
        end
    end

    -- Factorial constant folding using _G.evaluateFactorial if available, else fallback to transform
    if expr.type == "func" and expr.name == "factorial" and expr.args and #expr.args == 1 then
        local arg = expr.args[1]
        if is_num(arg) and _G.evaluateFactorial then
            return num(_G.evaluateFactorial(arg.value))
        else
            local transformed = _G.transformFactorial(expr)
            return transformed
        end
    end
    
    return expr
end

-- ===== STEP 4: COLLECT LIKE TERMS (The Real Work) =====

local function extract_coefficient_and_base(expr)
    if is_num(expr) then
        return expr.value, num(1)
    end
    
    if is_mul(expr) and expr.args then
        local coeff = 1
        local base_parts = {}
        
        for _, arg in ipairs(expr.args) do
            if is_num(arg) then
                coeff = coeff * arg.value
            else
                table.insert(base_parts, arg)
            end
        end
        
        local base
        if #base_parts == 0 then
            base = num(1)
        elseif #base_parts == 1 then
            base = base_parts[1]
        else
            base = {type = "mul", args = base_parts}
        end
        
        return coeff, base
    end
    
    return 1, expr
end

local function collect_like_terms(expr)
    if not (is_add(expr) and expr.args) then return expr end
    
    local groups = {}
    
    for _, term in ipairs(expr.args) do
        local coeff, base = extract_coefficient_and_base(term)
        local base_key = expr_hash(base)
        
        if groups[base_key] then
            groups[base_key].coeff = groups[base_key].coeff + coeff
        else
            groups[base_key] = {coeff = coeff, base = base}
        end
    end
    
    local result_terms = {}
    for _, group in pairs(groups) do
        if math.abs(group.coeff) > 1e-10 then -- Handle floating point errors
            if math.abs(group.coeff - 1) < 1e-10 and not expr_equal(group.base, num(1)) then
                -- Coefficient is 1, just use base
                table.insert(result_terms, group.base)
            elseif expr_equal(group.base, num(1)) then
                -- Base is 1, just use coefficient
                table.insert(result_terms, num(group.coeff))
            else
                -- Both matter
                table.insert(result_terms, {type = "mul", args = {num(group.coeff), group.base}})
            end
        end
    end
    
    if #result_terms == 0 then return num(0) end
    if #result_terms == 1 then return result_terms[1] end
    return {type = "add", args = result_terms}
end

-- ===== STEP 5: POWER SIMPLIFICATION =====

local function simplify_powers(expr)
    -- x^0 = 1
    if is_pow(expr) and is_num(expr.exp) and expr.exp.value == 0 then
        return num(1)
    end
    
    -- x^1 = x
    if is_pow(expr) and is_num(expr.exp) and expr.exp.value == 1 then
        return expr.base
    end
    
    -- (x^a)^b = x^(a*b)
    if is_pow(expr) and is_pow(expr.base) then
        local new_exp = {type = "mul", args = {expr.base.exp, expr.exp}}
        return {type = "pow", base = expr.base.base, exp = new_exp}
    end
    
    return expr
end

-- ===== STEP 6: COMBINE LIKE POWERS IN MULTIPLICATION =====

local function combine_powers(expr)
    if not (is_mul(expr) and expr.args) then return expr end
    
    local base_groups = {}
    local other_factors = {}
    
    for _, factor in ipairs(expr.args) do
        local base, exp
        if is_pow(factor) then
            base, exp = factor.base, factor.exp
        else
            base, exp = factor, num(1)
        end
        
        local base_key = expr_hash(base)
        if base_groups[base_key] then
            -- Combine exponents: x^a * x^b = x^(a+b)
            base_groups[base_key].exponents = base_groups[base_key].exponents or {}
            table.insert(base_groups[base_key].exponents, exp)
        else
            base_groups[base_key] = {base = base, exponents = {exp}}
        end
    end
    
    local result_factors = {}
    
    for _, group in pairs(base_groups) do
        if #group.exponents == 1 then
            if expr_equal(group.exponents[1], num(1)) then
                table.insert(result_factors, group.base)
            else
                table.insert(result_factors, {type = "pow", base = group.base, exp = group.exponents[1]})
            end
        else
            local combined_exp = {type = "add", args = group.exponents}
            table.insert(result_factors, {type = "pow", base = group.base, exp = combined_exp})
        end
    end
    
    if #result_factors == 0 then return num(1) end
    if #result_factors == 1 then return result_factors[1] end
    return {type = "mul", args = result_factors}
end

-- ===== STEP 7: BASIC DISTRIBUTION =====

local function distribute_simple(expr)
    if not (is_mul(expr) and expr.args) then return expr end
    
    -- Look for a(b + c) pattern
    local additions = {}
    local other_factors = {}
    
    for _, factor in ipairs(expr.args) do
        if is_add(factor) and factor.args then
            table.insert(additions, factor)
        else
            table.insert(other_factors, factor)
        end
    end
    
    if #additions == 0 then return expr end
    
    -- Take first addition and distribute other factors into it
    local first_add = additions[1]
    local remaining_adds = {}
    for i = 2, #additions do
        table.insert(remaining_adds, additions[i])
    end
    
    local all_other_factors = {}
    for _, f in ipairs(other_factors) do
        table.insert(all_other_factors, f)
    end
    for _, f in ipairs(remaining_adds) do
        table.insert(all_other_factors, f)
    end
    
    local distributed_terms = {}
    for _, addend in ipairs(first_add.args) do
        local new_factors = {addend}
        for _, factor in ipairs(all_other_factors) do
            table.insert(new_factors, factor)
        end
        
        if #new_factors == 1 then
            table.insert(distributed_terms, new_factors[1])
        else
            table.insert(distributed_terms, {type = "mul", args = new_factors})
        end
    end
    
    return {type = "add", args = distributed_terms}
end

-- ===== STEP 8: SPECIAL EXPANSIONS =====

local function expand_special_cases(expr)
    -- (a + b)^2 = a^2 + 2ab + b^2
    if is_pow(expr) and is_num(expr.exp) and expr.exp.value == 2 then
        if is_add(expr.base) and expr.base.args and #expr.base.args == 2 then
            local a, b = expr.base.args[1], expr.base.args[2]
            return {
                type = "add",
                args = {
                    {type = "pow", base = a, exp = num(2)},
                    {type = "mul", args = {num(2), a, b}},
                    {type = "pow", base = b, exp = num(2)}
                }
            }
        end
    end
    
    return expr
end

-- ===== STEP 9: TRIGONOMETRIC IDENTITIES =====

local function apply_trig_identities(expr)
    -- sin^2(x) + cos^2(x) = 1
    if is_add(expr) and expr.args and #expr.args == 2 then
        local term1, term2 = expr.args[1], expr.args[2]
        
        -- Check if we have sin^2(x) and cos^2(x)
        if is_pow(term1) and is_pow(term2) and 
           is_num(term1.exp) and is_num(term2.exp) and
           term1.exp.value == 2 and term2.exp.value == 2 then
            
            if is_sin(term1.base) and is_cos(term2.base) and
               expr_equal(term1.base.arg, term2.base.arg) then
                return num(1)
            elseif is_cos(term1.base) and is_sin(term2.base) and
                   expr_equal(term1.base.arg, term2.base.arg) then
                return num(1)
            end
        end
    end
    
    return expr
end

-- ===== STEP 10: LOGARITHM IDENTITIES =====

local function apply_log_identities(expr)
    -- ln(e^x) = x
    if is_ln(expr) and is_exp(expr.arg) then
        return expr.arg.arg
    end
    
    -- e^(ln(x)) = x
    if is_exp(expr) and is_ln(expr.arg) then
        return expr.arg.arg
    end
    
    return expr
end

-- ===== MAIN SIMPLIFICATION ENGINE =====

-- Helper function to serialize AST nodes for debugging
local function ast_to_string(node, visited, depth)
    visited = visited or {}
    depth = depth or 0
    local indent = string.rep("  ", depth)
    if type(node) ~= "table" then
        return tostring(node)
    end
    if visited[node] then
        return indent .. "<cycle>"
    end
    visited[node] = true
    local parts = {}
    table.insert(parts, indent .. "{")
    for k, v in pairs(node) do
        local keystr = tostring(k)
        if type(v) == "table" then
            table.insert(parts, indent .. "  " .. keystr .. " = " .. ast_to_string(v, visited, depth + 1))
        else
            table.insert(parts, indent .. "  " .. keystr .. " = " .. tostring(v))
        end
    end
    table.insert(parts, indent .. "}")
    return table.concat(parts, "\n")
end

local function simplify_step(expr)
    if type(expr) ~= "table" then return expr end

    -- Recursively simplify children first
    local new_expr = deepcopy(expr)

    -- Debug print for all nodes at entry (full AST node)
    print("DEBUG: AST node received by simplify_step:\n" .. ast_to_string(new_expr))

    -- Only simplify known types; preserve unknown types (e.g. unimplemented_integral)
    local known_types = {
        number = true, variable = true, constant = true, pow = true, add = true, mul = true,
        sin = true, cos = true, ln = true, exp = true, integral = true, func = true, neg = true,
        series = true
    }
    if not known_types[new_expr.type] then
        return new_expr -- Preserve unknown node types like unimplemented_integral
    end

    if new_expr.type == "pow" then
        new_expr.base = simplify_step(new_expr.base)
        new_expr.exp = simplify_step(new_expr.exp)
    elseif new_expr.type == "sin" or new_expr.type == "cos" or new_expr.type == "ln" or new_expr.type == "exp" then
        new_expr.arg = simplify_step(new_expr.arg)
    elseif (new_expr.type == "add" or new_expr.type == "mul") and new_expr.args then
        for i = 1, #new_expr.args do
            new_expr.args[i] = simplify_step(new_expr.args[i])
        end
    elseif new_expr.type == "neg" and new_expr.arg then
        new_expr.arg = simplify_step(new_expr.arg)
        -- Double negation elimination: -(-expr) => expr
        if new_expr.arg and new_expr.arg.type == "neg" then
            return simplify_step(new_expr.arg.arg)
        end
    elseif new_expr.type == "constant" then
        -- Recursively simplify the value of the constant
        new_expr.value = simplify_step(new_expr.value)
        return new_expr.value
    end

    -- Integration logic using the integration engine
    if new_expr.type == "integral" then
        local integrand = simplify_step(new_expr.integrand)
        local respect_to = new_expr.respect_to

        if _G.integrate and _G.integrate.integrateAST then
            local integrated = _G.integrate.integrateAST(integrand, respect_to)
            if integrated then
                return simplify_step(integrated)
            end
        end

        -- Fallback symbolic node if integration fails
        return { type = "integral", integrand = integrand, respect_to = respect_to }
    end

    -- Handle func("int", {expr, var}) as symbolic integral, with debug tracing
    if new_expr.type == "func" and new_expr.name == "int" and new_expr.args then
        local integrand = simplify_step(new_expr.args[1])
        local respect_to = "x"
        if new_expr.args[2] and new_expr.args[2].type == "variable" then
            respect_to = new_expr.args[2].name
        end

        print("Integrating func int with integrand:", simplify.pretty_print(integrand), "respect_to:", respect_to)

        local integrated = nil
        if _G.integrate and _G.integrate.integrateAST then
            integrated = _G.integrate.integrateAST(integrand, respect_to)
        else
            print("Warning: _G.integrate.integrateAST missing")
        end

        print("Integration result:", integrated and simplify.pretty_print(integrated) or "nil")

        if integrated then
            return simplify_step(integrated)
        else
            print("Integration failed, returning symbolic int node")
            return {
                type = "func",
                name = "int",
                args = { integrand, { type = "variable", name = respect_to } }
            }
        end
    end

    -- Debug: print each stage
    print("Original:", simplify.pretty_print(new_expr))

    new_expr = flatten(new_expr)
    print("After flatten:", simplify.pretty_print(new_expr))

    new_expr = sort_args(new_expr)
    print("After sort_args:", simplify.pretty_print(new_expr))

    new_expr = fold_constants(new_expr)
    print("After fold_constants:", simplify.pretty_print(new_expr))

    new_expr = collect_like_terms(new_expr)
    print("After collect_like_terms:", simplify.pretty_print(new_expr))

    new_expr = simplify_powers(new_expr)
    print("After simplify_powers:", simplify.pretty_print(new_expr))

    new_expr = combine_powers(new_expr)
    print("After combine_powers:", simplify.pretty_print(new_expr))

    new_expr = distribute_simple(new_expr)
    print("After distribute_simple:", simplify.pretty_print(new_expr))

    new_expr = expand_special_cases(new_expr)
    print("After expand_special_cases:", simplify.pretty_print(new_expr))

    new_expr = apply_trig_identities(new_expr)
    print("After apply_trig_identities:", simplify.pretty_print(new_expr))

    new_expr = apply_log_identities(new_expr)
    print("After apply_log_identities:", simplify.pretty_print(new_expr))

    -- Series expansion handling
    if new_expr.type == "series" and _G.series and _G.series.expand then
        local func = simplify_step(new_expr.func)
        local var = simplify_step(new_expr.var)
        local center = simplify_step(new_expr.center)
        local order = simplify_step(new_expr.order)

        assert(var.type == "variable", "series var must be a variable")

        -- Expand the series using the series module
        local expanded = _G.series.expand(func.name, var, center.value, order.value)

        -- Fully simplify the expanded series recursively
        local simplified_expanded = simplify_step(expanded)

        -- Fold constants to clean up factorial/gamma evaluations
        simplified_expanded = fold_constants(simplified_expanded)

        -- Collect like terms and simplify powers for neatness
        simplified_expanded = collect_like_terms(simplified_expanded)
        simplified_expanded = simplify_powers(simplified_expanded)
        simplified_expanded = combine_powers(simplified_expanded)
        simplified_expanded = fold_constants(simplified_expanded) -- again fold any new constants

        return simplified_expanded
    end

    return new_expr
end

local function simplify_until_stable(expr, max_iterations)
    max_iterations = max_iterations or 20
    local iteration = 0
    local prev_hash = nil
    
    while iteration < max_iterations do
        expr = simplify_step(expr)
        local current_hash = expr_hash(expr)
        
        if current_hash == prev_hash then
            break -- Converged
        end
        
        prev_hash = current_hash
        iteration = iteration + 1
    end
    
    return expr
end

-- ===== PRETTY PRINTER =====

-- Improved precedence-aware parentheses logic
local function needs_parens(expr, parent_op, position)
    -- Precedence: higher number = binds tighter
    local precedence = {
        add = 1,
        sub = 1,
        mul = 2,
        div = 2,
        pow = 3,
        neg = 4,
        func = 5,
        sin = 5,
        cos = 5,
        ln = 5,
        exp = 5,
        sqrt = 5,
    }
    local expr_prec = precedence[expr.type] or 6
    local parent_prec = precedence[parent_op] or 0
    if not parent_op then return false end
    if expr_prec > parent_prec then return false end
    if expr_prec < parent_prec then return true end
    -- When precedence is equal, only pow is right-associative
    if parent_op == "pow" and position == "right" then return true end
    -- For subtraction and division, left and right children may need parens for clarity
    if (parent_op == "sub" or parent_op == "div") and position == "right" then return true end
    return false
end

-- Helper: should multiplication be shown as explicit * ?
local function should_show_multiplication(left, right)
    -- Omit * when: number followed by variable/power, variable by variable/power, power by variable/power, sqrt by variable/number/etc.
    local function is_sqrt(e)
        return e and (e.type == "sqrt" or (is_pow(e) and is_num(e.exp) and e.exp.value == 0.5))
    end
    if is_num(left) and (is_var(right) or is_pow(right) or is_sqrt(right)) then return false end
    if is_var(left) and (is_var(right) or is_pow(right) or is_sqrt(right)) then return false end
    if is_pow(left) and (is_var(right) or is_pow(right) or is_sqrt(right)) then return false end
    if is_sqrt(left) and (is_var(right) or is_num(right) or is_pow(right) or is_sqrt(right)) then return false end
    -- Omit * between closing paren and variable/number
    if left.type == "constant" and (is_var(right) or is_num(right)) then return false end
    return true
end

-- Helper: is a simple factor (number, variable, constant, or function call)
local function is_simple_factor(expr)
    return is_num(expr) or is_var(expr) or expr.type == "constant"
        or expr.type == "sin" or expr.type == "cos" or expr.type == "ln" or expr.type == "exp"
        or expr.type == "sqrt"
        or (expr.type == "func" and expr.name and expr.args)
end

local function pretty_print_internal(expr, parent_op, position)
    -- Numbers
    if is_num(expr) then
        if expr.value >= 0 then
            return tostring(expr.value)
        else
            return "(" .. tostring(expr.value) .. ")"
        end
    end
    -- Variable
    if is_var(expr) then
        return expr.name
    end
    -- Constants
    if expr.type == "constant" then
        return expr.name
    end
    -- Negation
    if expr.type == "neg" and expr.arg then
        local inner = pretty_print_internal(expr.arg, "neg", "right")
        if not is_simple_factor(expr.arg) then
            inner = "(" .. inner .. ")"
        end
        return "-" .. inner
    end
    -- Power: x^y, also handle sqrt
    if is_pow(expr) then
        -- Square root pretty print
        if is_num(expr.exp) and expr.exp.value == 0.5 then
            local arg_str = pretty_print_internal(expr.base, "sqrt", "arg")
            -- Avoid excessive parentheses around simple factors or powers (like x^2)
            if not (is_simple_factor(expr.base) or is_pow(expr.base)) then
                arg_str = "(" .. arg_str .. ")"
            end
            return "√" .. arg_str
        end
        local base_str = pretty_print_internal(expr.base, "pow", "left")
        local exp_str = pretty_print_internal(expr.exp, "pow", "right")
        if needs_parens(expr.base, "pow", "left") then
            base_str = "(" .. base_str .. ")"
        end
        if needs_parens(expr.exp, "pow", "right") then
            exp_str = "(" .. exp_str .. ")"
        end
        return base_str .. "^" .. exp_str
    end
    -- Functions: sin, cos, ln, exp, sqrt, and custom
    if expr.type == "sin" or expr.type == "cos" or expr.type == "ln" or expr.type == "exp" then
        local fname = expr.type
        return fname .. "(" .. pretty_print_internal(expr.arg, nil, nil) .. ")"
    end
    if expr.type == "sqrt" then
        local arg_str = pretty_print_internal(expr.arg, "sqrt", "arg")
        -- Avoid excessive parentheses around simple factors or powers (like x^2)
        if not (is_simple_factor(expr.arg) or is_pow(expr.arg)) then
            arg_str = "(" .. arg_str .. ")"
        end
        return "√" .. arg_str
    end
    -- Pretty print for func("int", ...): display as integral
    if expr.type == "func" and expr.name == "int" and expr.args then
        local arg_str = pretty_print_internal(expr.args[1], nil, nil)
        local respect_to = "x"
        if expr.args[2] and expr.args[2].type == "variable" then
            respect_to = expr.args[2].name
        end
        return "∫" .. arg_str .. " d" .. respect_to
    end
    -- Pretty print for inverse trig: arcsin, arccos, arctan, etc.
    if expr.type == "func" and expr.name and expr.args and (
        expr.name == "arcsin" or expr.name == "arccos" or expr.name == "arctan" or expr.name == "arccot"
        or expr.name == "arccsc" or expr.name == "arcsec"
    ) then
        local arg_strs = {}
        for i, arg in ipairs(expr.args) do
            table.insert(arg_strs, pretty_print_internal(arg, nil, nil))
        end
        return expr.name .. "(" .. table.concat(arg_strs, ", ") .. ")"
    end
    -- Handle generic function nodes: func(name, args)
    if expr.type == "func" and expr.name and expr.args then
        local arg_strs = {}
        for i, arg in ipairs(expr.args) do
            table.insert(arg_strs, pretty_print_internal(arg, nil, nil))
        end
        return expr.name .. "(" .. table.concat(arg_strs, ", ") .. ")"
    end
    -- Addition with forced + C at the end
    if is_add(expr) and expr.args then
        local regular_terms = {}
        local constant_c = nil

        for _, arg in ipairs(expr.args) do
            if arg.type == "variable" and arg.name == "C" then
                constant_c = pretty_print_internal(arg, "add", "inner")
            else
                local s = pretty_print_internal(arg, "add", "inner")
                -- Parenthesize negative terms for clarity
                if is_num(arg) and arg.value < 0 then
                    s = "(" .. s .. ")"
                elseif arg.type == "neg" then
                    s = "(" .. s .. ")"
                end
                table.insert(regular_terms, s)
            end
        end

        local result = table.concat(regular_terms, " + ")
        if constant_c then
            if #regular_terms > 0 then
                result = result .. " + " .. constant_c
            else
                result = constant_c
            end
        end

        if needs_parens(expr, parent_op, position) then
            return "(" .. result .. ")"
        end
        return result
    end
    -- Multiplication (improved implicit multiplication logic, always print 2x not x*2)
    if is_mul(expr) and expr.args then
        local parts = {}
        local function is_simple_func(e)
            return e and (e.type == "sin" or e.type == "cos" or e.type == "ln" or e.type == "exp" or (e.type == "func"))
        end
        -- Sort: numbers first, then variables, then powers, then functions, then others
        local sorted_args = {}
        for i, arg in ipairs(expr.args) do sorted_args[i] = arg end
        table.sort(sorted_args, function(a, b)
            local function sort_key(e)
                if is_num(e) then return 1
                elseif is_var(e) then return 2
                elseif is_pow(e) then return 3
                elseif is_simple_func(e) then return 4
                else return 5 end
            end
            local ka, kb = sort_key(a), sort_key(b)
            if ka ~= kb then return ka < kb end
            -- If same type, keep original order for stability
            return false
        end)
        -- Suppress leading 1 * expr, unless it's the only argument
        if is_num(sorted_args[1]) and sorted_args[1].value == 1 and #sorted_args > 1 then
            table.remove(sorted_args, 1)
        end
        -- Now build pretty print from sorted_args
        for i, arg in ipairs(sorted_args) do
            local s = pretty_print_internal(arg, "mul", "inner")
            if i == 1 then
                table.insert(parts, s)
            else
                local prev = sorted_args[i-1]
                local prev_is_num = is_num(prev)
                local prev_is_var = is_var(prev)
                local prev_is_pow = is_pow(prev)
                local prev_is_func = is_simple_func(prev)
                local curr_is_num = is_num(arg)
                local curr_is_var = is_var(arg)
                local curr_is_pow = is_pow(arg)
                local curr_is_func = is_simple_func(arg)

                -- Implicit multiplication rules:
                -- 2x, 3sin(x), xy, x^2y, x^2sin(x), sin(x)y, etc.
                -- But: x*6, sin(x)*5, etc. should be explicit
                local implicit = false
                -- Number before variable/power/function: 2x, 3sin(x), 4x^2
                if prev_is_num and (curr_is_var or curr_is_pow or curr_is_func) then
                    implicit = true
                    table.insert(parts, s)
                -- Variable before variable/power/function: xy, xsin(x), x^2y, x^2sin(x)
                elseif prev_is_var and (curr_is_var or curr_is_pow or curr_is_func) then
                    -- Special: if variable before inverse trig function, add space
                    if curr_is_func and arg.type == "func"
                        and (arg.name == "arcsin" or arg.name == "arccos" or arg.name == "arctan"
                             or arg.name == "arccot" or arg.name == "arccsc" or arg.name == "arcsec")
                    then
                        implicit = true
                        table.insert(parts, " " .. s)
                    else
                        implicit = true
                        table.insert(parts, s)
                    end
                -- Power before variable/power/function: x^2y, x^2sin(x), (x^2)(y^3)
                elseif prev_is_pow and (curr_is_var or curr_is_pow or curr_is_func) then
                    implicit = true
                    table.insert(parts, s)
                -- Function before variable/power/function: sin(x)y, sin(x)x^2
                elseif prev_is_func and (curr_is_var or curr_is_pow) then
                    implicit = true
                    table.insert(parts, s)
                else
                    table.insert(parts, " * " .. s)
                end
            end
        end
        local result = table.concat(parts)
        if needs_parens(expr, parent_op, position) then
            return "(" .. result .. ")"
        end
        return result
    end
    -- Division
    if expr.type == "div" and expr.left and expr.right then
        local left_str = pretty_print_internal(expr.left, "div", "left")
        local right_str = pretty_print_internal(expr.right, "div", "right")
        if not is_simple_factor(expr.left) then
            left_str = "(" .. left_str .. ")"
        end
        if not is_simple_factor(expr.right) then
            right_str = "(" .. right_str .. ")"
        end
        return left_str .. "/" .. right_str
    end
    -- Subtraction
    if expr.type == "sub" and expr.left and expr.right then
        local left_str = pretty_print_internal(expr.left, "sub", "left")
        local right_str = pretty_print_internal(expr.right, "sub", "right")
        if not is_simple_factor(expr.left) then
            left_str = "(" .. left_str .. ")"
        end
        if not is_simple_factor(expr.right) then
            right_str = "(" .. right_str .. ")"
        end
        return left_str .. " - " .. right_str
    end
    -- Pretty print for integral nodes
    if expr.type == "integral" and expr.integrand and expr.respect_to then
        return "∫" .. pretty_print_internal(expr.integrand, nil, nil) .. " d" .. expr.respect_to
    end

    -- Pretty print for limit nodes
    if expr.type == "lim" and expr.expr and expr.var and expr.to then
        local expr_str = pretty_print_internal(expr.expr, nil, nil)
        local to_str = pretty_print_internal(expr.to, nil, nil)
        return "lim_(" .. expr.var .. "→" .. to_str .. ") " .. expr_str
    end
    -- Pretty print for series node
if expr.type == "series" and expr.func and expr.var and expr.center and expr.order then
    local func_str = pretty_print_internal(expr.func, nil, nil)
    local var_str = pretty_print_internal(expr.var, nil, nil)
    local center_str = pretty_print_internal(expr.center, nil, nil)
    local order_str = pretty_print_internal(expr.order, nil, nil)
    return "series(" .. func_str .. ", " .. var_str .. ", " .. center_str .. ", " .. order_str .. ")"
end
    return "<unknown>"
end

-- ===== PUBLIC API =====

function simplify.simplify(expr)
    return simplify_until_stable(expr)
end

function simplify.pretty_print(expr)
    return pretty_print_internal(expr, nil, nil)
end

function simplify.canonicalize(expr)
    -- Just normalize structure without aggressive simplification
    local normalized = deepcopy(expr)
    if (is_add(normalized) or is_mul(normalized)) and normalized.args then
        normalized = flatten(normalized)
        normalized = sort_args(normalized)
    end
    return normalized
end

function simplify.simplify_with_stats(expr)
    local max_iterations = 20
    local iteration = 0
    local prev_hash = nil
    
    while iteration < max_iterations do
        expr = simplify_step(expr)
        local current_hash = expr_hash(expr)
        
        if current_hash == prev_hash then
            break -- Converged
        end
        
        prev_hash = current_hash
        iteration = iteration + 1
    end
    
    return expr, {
        passes = iteration,
        converged = iteration < max_iterations
    }
end

-- Export to global if needed (keeping compatibility)
_G.simplify = simplify


-- End src/simplify.lua

-- You included src/simplify.lua—brace for unexpected side effects.

-- Begin src/matrix.lua
local ast = _G.ast or error("AST module required")

local Matrix = {}
Matrix.__index = Matrix

function Matrix:eval_numeric(env)
  local result = {}
  for i = 1, self.rows do
    result[i] = {}
    for j = 1, self.cols do
      result[i][j] = ast.eval_numeric(self.data[i][j], env)
    end
  end
  return result
end

function Matrix.new(data)
  assert(type(data) == "table", "Matrix must be constructed from a table")
  local rows = #data
  local cols = #data[1]
  for i = 2, rows do
    assert(#data[i] == cols, "Matrix rows must be same length")
  end
  return setmetatable({ type = "matrix", data = data, rows = rows, cols = cols }, Matrix)
end

function Matrix:tostring()
  local out = {}
  for i = 1, self.rows do
    local row = {}
    for j = 1, self.cols do
      table.insert(row, tostring(self.data[i][j]))
    end
    table.insert(out, "{" .. table.concat(row, ", ") .. "}")
  end
  return "[" .. table.concat(out, ",\n ") .. "]"
end

function Matrix:add(B)
  assert(self.rows == B.rows and self.cols == B.cols, "Shape mismatch")
  local result = {}
  for i = 1, self.rows do
    result[i] = {}
    for j = 1, self.cols do
      result[i][j] = ast.add(self.data[i][j], B.data[i][j])
    end
  end
  return Matrix.new(result)
end

function Matrix:mul(B)
  assert(self.cols == B.rows, "Incompatible dimensions")
  local result = {}
  for i = 1, self.rows do
    result[i] = {}
    for j = 1, B.cols do
      local sum = ast.number(0)
      for k = 1, self.cols do
        sum = ast.add(sum, ast.mul(self.data[i][k], B.data[k][j]))
      end
      result[i][j] = sum
    end
  end
  return Matrix.new(result)
end

function Matrix:transpose()
  local result = {}
  for i = 1, self.cols do
    result[i] = {}
    for j = 1, self.rows do
      result[i][j] = self.data[j][i]
    end
  end
  return Matrix.new(result)
end

function Matrix:determinant()
  assert(self.rows == 2 and self.cols == 2, "Only 2x2 determinant supported")
  local a, b = self.data[1][1], self.data[1][2]
  local c, d = self.data[2][1], self.data[2][2]
  return ast.sub(ast.mul(a, d), ast.mul(b, c))
end

function Matrix:inverse()
  local det = self:determinant()
  local a, b = self.data[1][1], self.data[1][2]
  local c, d = self.data[2][1], self.data[2][2]
  local inv = {
    {d, ast.mul(ast.number(-1), b)},
    {ast.mul(ast.number(-1), c), a}
  }
  local det_inv = ast.pow(det, ast.number(-1))
  for i = 1, 2 do
    for j = 1, 2 do
      inv[i][j] = ast.mul(inv[i][j], det_inv)
    end
  end
  return Matrix.new(inv)
end

_G.Matrix = Matrix

-- End src/matrix.lua

-- Integrated src/matrix.lua: let’s hope it compiles this time.

-- Begin src/derivative.lua
-- Derivative Engine (WIP)
-- Tries to symbolically differentiate expressions.
-- Some parts work. Some parts pretend to work.
-- Expect broken edge cases, unimplemented branches, and fallback logic.

local ast = rawget(_G, "ast") or require("ast")
local trig = rawget(_G, "trig")

-- Utility: shallow copy of a table
local function copy(tbl)
  if type(tbl) ~= "table" then return tbl end
  local t = {}
  for k,v in pairs(tbl) do t[k]=v end
  return t
end
-- Utility: check if AST is a constant (number)
local function is_const(ast)
  return ast.type == "number"
end

-- Utility: check if AST is a variable (symbol)
local function is_var(ast)
  return ast.type == "variable"
end

-- Utility: check if AST is a specific symbol
local function is_symbol(ast, name)
  return ast.type == "variable" and ast.name == name
end

-- Utility: limit AST node
local function lim(expr, var, to)
  return { type = 'lim', expr = expr, var = var, to = to }
end

-- Symbolic differentiation core. Tries to pretend it understands your math.
-- Falls back to limit definitions when it gives up.
local function diffAST(ast_node, var)
  if not ast_node then
    error("diffAST: invalid AST node passed in")
  end
  if type(ast_node) ~= "table" then
    error("diffAST: encountered non-AST node of type " .. type(ast_node))
  end
  var = var or "x"
  -- Numbers don't change. That's kind of the point.
  if ast_node.type == "number" then
    -- x → 1, everything else → 0. Classic.
    return ast.number(0)
  end
  -- x → 1, everything else → 0. Classic.
  if ast_node.type == "variable" then
    if ast_node.name == var then
      return ast.number(1)
    else
      return ast.number(0)
    end
  end
  -- Negation: signs flip, but rules stay the same.
  if ast_node.type == "neg" then
    return ast.neg(diffAST(ast_node.value, var))
  end
  -- Addition: term-wise differentiation. Nothing surprising.
  if ast_node.type == "add" then
    local deriv_args = {}
    for i, term in ipairs(ast_node.args) do
      deriv_args[i] = diffAST(term, var)
    end
    return ast.add(table.unpack(deriv_args))
  end
  -- Subtraction: just addition's grumpy cousin.
  if ast_node.type == "sub" then
    return ast.sub(diffAST(ast_node.left, var), diffAST(ast_node.right, var))
  end
  -- Multiplication: full product rule. Brace yourself.
  if ast_node.type == "mul" then
    local n = #ast_node.args
    local terms = {}
    for k = 1, n do
      local prod_args = {}
      for i = 1, n do
        if i == k then
          prod_args[i] = diffAST(ast_node.args[i], var)
        else
          prod_args[i] = copy(ast_node.args[i])
        end
      end
      terms[k] = ast.mul(table.unpack(prod_args))
    end
    return ast.add(table.unpack(terms))
  end
  -- Quotient rule. Surprisingly tidy, even here.
  if ast_node.type == "div" then
    local u = ast_node.left
    local v = ast_node.right
    local du = diffAST(u, var)
    local dv = diffAST(v, var)

    local numerator = ast.sub(
      ast.mul(du, copy(v)),
      ast.mul(copy(u), dv)
    )

    local denominator = ast.pow(copy(v), ast.number(2))

    return ast.div(numerator, denominator)
  end
  -- Powers: handles constants, variables, and full u^v chains.
  -- Tries to be clever with logs if needed.
  if ast_node.type == "pow" then
    local u, n = ast_node.base, ast_node.exp
    -- Case: u^c, c constant
    if is_const(n) then
      -- d/dx(u^c) = c*u^(c-1) * du/dx
      return ast.mul(
        ast.mul(copy(n), ast.pow(copy(u), ast.number(n.value - 1))),
        diffAST(u, var)
      )
    -- Case: c^v, c constant
    elseif is_const(u) then
      -- d/dx(c^v) = ln(c) * c^v * dv/dx
      return ast.mul(
        ast.mul(ast.func("ln", { copy(u) }), ast.pow(copy(u), copy(n))),
        diffAST(n, var)
      )
    else
      -- General case: d/dx(u^v) = u^v * (v' * ln(u) + v * u'/u)
      -- (by logarithmic differentiation)
      return ast.mul(
        ast.pow(copy(u), copy(n)),
        ast.add(
          ast.mul(diffAST(n, var), ast.func("ln", { copy(u) })),
          ast.mul(copy(n), ast.div(diffAST(u, var), copy(u)))
        )
      )
    end
  end
  -- Function differentiation: sin, exp, ln, etc.
  -- Tries trig.lua first. Falls back to hardcoded rules.
  -- Anything unknown? It gets the limit treatment.
  if ast_node.type == "func" then
    local fname = ast_node.name
    -- Support both .arg (single) and .args (list) notation
    local u = ast_node.arg or (ast_node.args and ast_node.args[1])
    local du = diffAST(u, var)
    -- Handle standard trig derivatives directly
    if fname == "sin" then
        return ast.mul(ast.func("cos", { copy(u) }), du)
    elseif fname == "cos" then
        return ast.neg(ast.mul(ast.func("sin", { copy(u) }), du))
    elseif fname == "tan" then
        return ast.mul(ast.pow(ast.func("sec", { copy(u) }), ast.number(2)), du)
    elseif fname == "sec" then
        return ast.mul(ast.mul(ast.func("sec", { copy(u) }), ast.func("tan", { copy(u) })), du)
    elseif fname == "csc" then
        return ast.neg(ast.mul(ast.func("csc", { copy(u) }), ast.func("cot", { copy(u) }), du))
    elseif fname == "cot" then
        return ast.neg(ast.mul(ast.pow(ast.func("csc", { copy(u) }), ast.number(2)), du))
    elseif fname == "arcsin" then
        return ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2))) })), du)
    elseif fname == "arccos" then
        return ast.neg(ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2))) })), du))
    elseif fname == "arctan" then
        return ast.mul(ast.div(ast.number(1), ast.add(ast.number(1), ast.pow(copy(u), ast.number(2)))), du)
    elseif fname == "arccsc" then
        return ast.neg(ast.mul(ast.div(ast.number(1), ast.mul(ast.func("abs", { copy(u) }), ast.func("sqrt", { ast.sub(ast.pow(copy(u), ast.number(2)), ast.number(1)) }))), du))
    elseif fname == "arcsec" then
        return ast.mul(ast.div(ast.number(1), ast.mul(ast.func("abs", { copy(u) }), ast.func("sqrt", { ast.sub(ast.pow(copy(u), ast.number(2)), ast.number(1)) }))), du)
    elseif fname == "arccot" then
        return ast.neg(ast.mul(ast.div(ast.number(1), ast.add(ast.number(1), ast.pow(copy(u), ast.number(2)))), du))
    end
    -- Use trig.lua for trigonometric differentiation if available
    if trig and trig.diff_trig_func then
      local trig_result = trig.diff_trig_func(fname, copy(u), du)
      if trig_result then return trig_result end
    end
    if fname == "exp" then
      return ast.mul(ast.func("exp", { copy(u) }), du)
    elseif fname == "ln" then
      return ast.mul(ast.div(ast.number(1), copy(u)), du)
    elseif fname == "log" then
      -- log(x) = ln(x) / ln(10), so derivative is 1/(x ln(10))
      return ast.mul(ast.div(ast.number(1), ast.mul(copy(u), ast.func("ln", { ast.number(10) }))), du)
    elseif fname == "sqrt" then
      -- d/dx sqrt(u) = 1/(2*sqrt(u)) * du/dx
      return ast.mul(ast.div(ast.number(1), ast.mul(ast.number(2), ast.func("sqrt", { copy(u) }))), du)
    elseif fname == "asin" then
      -- d/dx asin(u) = 1/sqrt(1-u^2) * du/dx
      return ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2))) })), du)
    elseif fname == "acos" then
      -- d/dx acos(u) = -1/sqrt(1-u^2) * du/dx
      return ast.mul(ast.neg(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2))) }))), du)
    elseif fname == "atan" then
      -- d/dx atan(u) = 1/(1+u^2) * du/dx
      return ast.mul(ast.div(ast.number(1), ast.add(ast.number(1), ast.pow(copy(u), ast.number(2)))), du)
    elseif fname == "sinh" then
      return ast.mul(ast.func("cosh", { copy(u) }), du)
    elseif fname == "cosh" then
      return ast.mul(ast.func("sinh", { copy(u) }), du)
    elseif fname == "tanh" then
      return ast.mul(ast.sub(ast.number(1), ast.pow(ast.func("tanh", { copy(u) }), ast.number(2))), du)
    elseif fname == "asinh" then
      return ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.add(ast.pow(copy(u), ast.number(2)), ast.number(1)) })), du)
    elseif fname == "acosh" then
      return ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.pow(copy(u), ast.number(2)), ast.number(1)) })), du)
    elseif fname == "atanh" then
      return ast.mul(ast.div(ast.number(1), ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2)))), du)
    elseif fname == "log10" then
      return ast.mul(ast.div(ast.number(1), ast.mul(copy(u), ast.func("ln", { ast.number(10) }))), du)
    elseif fname == "log2" then
      return ast.mul(ast.div(ast.number(1), ast.mul(copy(u), ast.func("ln", { ast.number(2) }))), du)
    elseif fname == "abs" then
      return ast.mul(ast.div(copy(u), ast.func("abs", { copy(u) })), du)
    elseif fname == "sign" then
      return ast.number(0)
    elseif fname == "floor" or fname == "ceil" or fname == "round" then
      -- Derivative is zero except at discontinuity
      return ast.number(0)
    elseif fname == "erf" then
      -- d/dx erf(u) = 2/sqrt(pi) * exp(-u^2) * du/dx
      return ast.mul(ast.mul(ast.div(ast.number(2), ast.func("sqrt", { ast.number(math.pi) })), ast.func("exp", { ast.neg(ast.pow(copy(u), ast.number(2))) })), du)
    elseif fname == "gamma" then
      -- d/dx gamma(u) = gamma(u) * digamma(u) * du/dx (digamma not implemented, fallback)
      return { type = "unimplemented_derivative", func = fname, arg = copy(u) }
    elseif fname == "digamma" then
      -- d/dx digamma(u) = trigamma(u) * du/dx
      return ast.mul(ast.func("trigamma", { copy(u) }), du)
    elseif fname == "trigamma" then
      -- d/dx trigamma(u) = polygamma(2, u) * du/dx
      return ast.mul(ast.func("polygamma", { ast.number(2), copy(u) }), du)
    else
      -- Fallback: Use limit definition for unknown function
      -- f'(x) = lim_{h->0} [f(x+h)-f(x)]/h
      local h = ast.symbol("__h__")
      local u_ph = ast.add(copy(u), h)
      local fxh = ast.func(fname, { u_ph })
      local fx = ast.func(fname, { copy(u) })
      local nume = ast.sub(fxh, fx)
      local denom = copy(h)
      if not denom or denom.type ~= "variable" then
          denom = ast.symbol("__h__")
      end
      local quot = ast.div(nume, denom)
      return lim(quot, "__h__", ast.number(0))
    end
  end
  -- No clue what this is. Marked for manual inspection later.
  -- As a safety fallback, return an unknown node
  local result = { type = "unhandled_node", original = ast_node }
  if type(result) ~= "table" or not result.type then
    error("diffAST: returned invalid AST node structure")
  end
  return result
end


-- Public interface: takes string input, returns simplified derivative AST.
-- If it doesn't break, it probably worked.
local function derivative(expr, var)
  -- Load parser
  local parser = rawget(_G, "parser") or require("parser")
  -- Input validation and debug print
  if type(expr) ~= "string" then
    error("Invalid input to derivative(): expected string, got " .. type(expr))
  end
  print("DEBUG: input to parser.parse =", expr)
  -- Parse expr string to AST
  local tree = parser.parse(expr)
  if not tree then
    error("Parsing failed: input = " .. expr)
  end
  local result = diffAST(tree, var)
  if type(result) ~= "table" or not result.type then
    error("Invalid derivative AST structure")
  end
  return (rawget(_G, "simplify") or require("simplify")).simplify(result)
end
_G.derivative = derivative
_G.diffAST = diffAST

-- End src/derivative.lua

-- You included src/derivative.lua—brace for unexpected side effects.

-- Begin src/trig.lua
-- trig.lua
-- Trig evaluation and symbolic helpers for nLuaCAS
-- Mostly here to pretend we remember SOHCAHTOA and the chain rule

local errors = _G.errors

-- Handles numeric evaluation of trig functions
-- Assumes degrees because radians scare most calculator users
-- Falls back to symbolic if it smells like algebra
-- Numeric trig evaluation (angle in degrees if constant input)
local function eval_trig_func(fname, arg)
  if type(arg) == "table" and arg.type == "number" then
    local val = arg.value
    -- Assume degrees for simple numbers (can adapt for radians)
    local rad = math.rad(val)
    if fname == "sin" then return ast.number(math.sin(rad)) end
    if fname == "cos" then return ast.number(math.cos(rad)) end
    if fname == "tan" then return ast.number(math.tan(rad)) end
    if fname == "cot" then return ast.number(1 / math.tan(rad)) end
    if fname == "sec" then return ast.number(1 / math.cos(rad)) end
    if fname == "csc" then return ast.number(1 / math.sin(rad)) end
  end
  -- Not a numeric constant: return nil, fall back to symbolic
  return nil -- fallback to symbolic; not a number
end

-- Applies the chain rule without asking for permission
-- Sins become cosines, cosines become negative sins, and so on
-- Symbolic differentiation of all trig functions (chain rule applied)
local function diff_trig_func(fname, arg, darg)
  if fname == "sin" then
    return ast.mul(ast.func("cos", {arg}), darg)
  elseif fname == "cos" then
    return ast.mul(ast.neg(ast.func("sin", {arg})), darg)
  elseif fname == "tan" then
    return ast.mul(ast.add(ast.number(1), ast.pow(ast.func("tan", {arg}), ast.number(2))), darg)
  elseif fname == "cot" then
    return ast.mul(ast.neg(ast.add(ast.number(1), ast.pow(ast.func("cot", {arg}), ast.number(2)))), darg)
  elseif fname == "sec" then
    return ast.mul(ast.mul(ast.func("sec", {arg}), ast.func("tan", {arg})), darg)
  elseif fname == "csc" then
    return ast.mul(ast.neg(ast.mul(ast.func("csc", {arg}), ast.func("cot", {arg}))), darg)
  end
  return error(errors.invalid("diff", "unknown trig function: " .. tostring(fname)))
end

-- Symbolic integration of trig functions
local function integrate_trig_func(fname, arg)
  if fname == "sin" then
    return ast.neg(ast.func("cos", {arg}))
  elseif fname == "cos" then
    return ast.func("sin", {arg})
  elseif fname == "tan" then
    return ast.neg(ast.func("ln", {ast.func("cos", {arg})}))
  elseif fname == "cot" then
    return ast.func("ln", {ast.func("sin", {arg})})
  elseif fname == "sec" then
    return ast.func("ln", {ast.add(ast.func("sec", {arg}), ast.func("tan", {arg}))})
  elseif fname == "csc" then
    return ast.neg(ast.func("ln", {ast.add(ast.func("csc", {arg}), ast.func("cot", {arg}))}))
  end
  return nil -- unknown trig function, fallback to unhandled
end

-- Bundle it up for the global namespace
-- Hopefully avoids circular dependency chaos
_G.trig = {
  eval_trig_func = eval_trig_func,
  diff_trig_func = diff_trig_func,
  integrate_trig_func = integrate_trig_func,
}

-- End src/trig.lua

-- src/trig.lua has arrived. Prepare to blame someone.

-- Begin src/integrate.lua
-- Integral Engine (Enhanced Edition - Because Apparently We're Gluttons for Punishment)
-- Now with 300% more ways to fail spectacularly at symbolic integration
-- Features: Inverse trig functions, partial fractions, and other mathematical nightmares

local ast = rawget(_G, "ast") or require("ast")
local diffAST = rawget(_G, "diffAST") or error("diffAST: differentiation function required for integration by parts")
local trig = rawget(_G, "trig")
local simplify = rawget(_G, "simplify") or require("simplify")

-- Expanded symbolic integral lookup (now with inverse trig because we hate ourselves)
local known_integral_table = {
  -- Inverse trig functions (the devil's own mathematics)
  arcsin = function(arg) 
    return ast.add(ast.mul(arg, ast.func("arcsin", {copy(arg)})), ast.func("sqrt", {ast.sub(ast.number(1), ast.pow(copy(arg), ast.number(2)))}))
  end,
  arccos = function(arg)
    return ast.sub(ast.mul(arg, ast.func("arccos", {copy(arg)})), ast.func("sqrt", {ast.sub(ast.number(1), ast.pow(copy(arg), ast.number(2)))}))
  end,
  arctan = function(arg)
    return ast.sub(ast.mul(arg, ast.func("arctan", {copy(arg)})), ast.div(ast.func("ln", {ast.add(ast.number(1), ast.pow(copy(arg), ast.number(2)))}), ast.number(2)))
  end,
  
  -- Hyperbolic functions (because regular trig wasn't painful enough)
  sinh = function(arg) return ast.func("cosh", {copy(arg)}) end,
  cosh = function(arg) return ast.func("sinh", {copy(arg)}) end,
  tanh = function(arg) return ast.func("ln", {ast.func("cosh", {copy(arg)})}) end,
  
  -- Square root integrals (the "fuck it, let's go deeper" collection)
  sqrt = function(arg)
    if is_symbol(arg, "x") then
      return ast.div(ast.mul(ast.number(2), ast.pow(arg, ast.div(ast.number(3), ast.number(2)))), ast.number(3))
    end
    return nil
  end
}

local enable_substitution = true  
local enable_advanced_symbolics = true  -- Fuck it, we're going full masochist mode
local enable_partial_fractions = true   -- Because rational functions are the devil
local enable_definite_integrals = true  -- Bounds? We don't need no stinking bounds... wait, yes we do

-- Utility functions that hopefully won't explode this time
local function copy(tbl)
  if type(tbl) ~= "table" then return tbl end
  local t = {}
  for k,v in pairs(tbl) do 
    t[k] = type(v) == "table" and copy(v) or v 
  end
  return t
end

local function is_const(node)
  return node and node.type == "number"
end

local function is_var(node)
  return node and node.type == "variable"
end

local function is_symbol(node, name)
  return node and node.type == "variable" and node.name == name
end

-- Check if expression contains only polynomials (for partial fraction decomposition)
local function is_polynomial(node, var)
  if not node then return false end
  if node.type == "number" then return true end
  if node.type == "variable" then return node.name == var or true end -- constants are polynomials too
  if node.type == "add" or node.type == "sub" then
    return is_polynomial(node.left or node.args and node.args[1], var) and 
           is_polynomial(node.right or node.args and node.args[2], var)
  end
  if node.type == "mul" and node.args then
    for _, arg in ipairs(node.args) do
      if not is_polynomial(arg, var) then return false end
    end
    return true
  end
  if node.type == "pow" then
    return is_polynomial(node.base, var) and is_const(node.exp) and node.exp.value >= 0
  end
  return false
end

-- Partial fraction decomposition (the "why did I think this was a good idea" function)
local function partial_fraction_decompose(numerator, denominator, var)
  -- This is a massive simplification - real partial fractions are a nightmare
  -- We'll handle the simplest case: A/(x-a) + B/(x-b)
  
  if not denominator or denominator.type ~= "mul" then return nil end
  if not denominator.args or #denominator.args ~= 2 then return nil end
  
  local factors = {}
  for _, factor in ipairs(denominator.args) do
    if factor.type == "add" and factor.args and #factor.args == 2 then
      -- Check if it's (x + constant) form
      local x_term, const_term
      for _, term in ipairs(factor.args) do
        if is_symbol(term, var) then x_term = term
        elseif is_const(term) then const_term = term
        end
      end
      if x_term and const_term then
        table.insert(factors, {type = "linear", root = ast.number(-const_term.value)})
      end
    elseif factor.type == "sub" and factor.left and factor.right then
      if is_symbol(factor.left, var) and is_const(factor.right) then
        table.insert(factors, {type = "linear", root = copy(factor.right)})
      end
    end
  end
  
  if #factors == 2 and factors[1].type == "linear" and factors[2].type == "linear" then
    -- We have (x-a)(x-b), so we want A/(x-a) + B/(x-b)
    -- This is where I'd implement the full algorithm if I wasn't already dead inside
    -- For now, return a placeholder that integration can handle
    return {
      type = "partial_fraction_sum",
      terms = {
        {numerator = ast.number(1), denominator = ast.sub(ast.variable(var), factors[1].root)},
        {numerator = ast.number(1), denominator = ast.sub(ast.variable(var), factors[2].root)}
      }
    }
  end
  
  return nil
end

-- Enhanced pattern matching (now with 50% more disappointment)
local function pattern_match(expr, pattern, bindings)
  bindings = bindings or {}
  
  if not expr or not pattern then return false end
  
  if pattern.type == "wildcard" then
    bindings[pattern.name] = expr
    return true, bindings
  end
  
  if expr.type ~= pattern.type then return false end
  
  if expr.type == "number" then
    return expr.value == pattern.value, bindings
  elseif expr.type == "variable" then
    return expr.name == pattern.name, bindings
  elseif expr.type == "func" and expr.name == pattern.name then
    if expr.args and pattern.args and expr.args[1] and pattern.args[1] then
      return pattern_match(expr.args[1], pattern.args[1], bindings)
    end
    return false
  elseif expr.type == "mul" or expr.type == "add" then
    if not expr.args or not pattern.args or #expr.args ~= #pattern.args then 
      return false 
    end
    for i = 1, #expr.args do
      local ok, new_bindings = pattern_match(expr.args[i], pattern.args[i], bindings)
      if not ok then return false end
      bindings = new_bindings or bindings
    end
    return true, bindings
  elseif expr.type == "pow" then
    if not expr.base or not expr.exp or not pattern.base or not pattern.exp then
      return false
    end
    local ok1, b1 = pattern_match(expr.base, pattern.base, bindings)
    local ok2, b2 = pattern_match(expr.exp, pattern.exp, b1 or bindings)
    return ok1 and ok2, b2 or bindings
  end
  
  return false
end

-- Advanced substitution patterns (because basic substitution wasn't masochistic enough)
local function try_advanced_substitution(node, var)
  if not enable_advanced_symbolics then return nil end
  
  -- Trigonometric substitutions (the "abandon all hope" section)
  local sqrt_patterns = {
    -- √(a² - x²) -> x = a*sin(θ)
    {
      pattern = ast.func("sqrt", {ast.sub(ast.pow(ast.wildcard("a"), ast.number(2)), ast.pow(ast.variable(var), ast.number(2)))}),
      substitution = "trig_sin"
    },
    -- √(a² + x²) -> x = a*tan(θ)  
    {
      pattern = ast.func("sqrt", {ast.add(ast.pow(ast.wildcard("a"), ast.number(2)), ast.pow(ast.variable(var), ast.number(2)))}),
      substitution = "trig_tan"
    },
    -- √(x² - a²) -> x = a*sec(θ)
    {
      pattern = ast.func("sqrt", {ast.sub(ast.pow(ast.variable(var), ast.number(2)), ast.pow(ast.wildcard("a"), ast.number(2)))}),
      substitution = "trig_sec"
    }
  }
  
  for _, sub_pattern in ipairs(sqrt_patterns) do
    local bindings = {}
    if pattern_match(node, sub_pattern.pattern, bindings) then
      -- In a real implementation, we'd actually perform the substitution
      -- For now, let's just acknowledge we found a pattern and cry softly
      return {
        type = "advanced_substitution",
        method = sub_pattern.substitution,
        original = copy(node),
        bindings = bindings
      }
    end
  end
  
  return nil
end

-- Enhanced substitution (now with more ways to fail)
local function try_substitution(node, var)
  if not node or node.type ~= "mul" or not node.args then 
    return nil 
  end
  
  -- Try advanced substitutions first
  local advanced = try_advanced_substitution(node, var)
  if advanced then return advanced end
  
  for _, arg in ipairs(node.args) do
    if ast.is_function_of and ast.is_function_of(arg, var) then
      local f = arg
      local df = diffAST(f, var)
      if df then
        for _, inner in ipairs(node.args) do
          if inner ~= arg and simplify.expr_equal and simplify.expr_equal(inner, df) then
            local u = ast.variable("u")
            local replaced = ast.replace and ast.replace(node, f, u)
            if replaced then
              local integral_u = integrateAST(replaced, "u")
              if integral_u and integral_u.type ~= "unimplemented_integral" then
                return ast.replace(integral_u, u, f)
              end
            end
          end
        end
      end
    end
  end
  return nil
end

-- Integration by parts (now with recursive attempts because we're fucking insane)
local function try_integration_by_parts(node, var)
  if not node or node.type ~= "mul" or not node.args or #node.args < 2 then 
    return nil 
  end
  
  -- Priority list for choosing u (LIATE rule: Logarithmic, Inverse trig, Algebraic, Trig, Exponential)
  local function get_integration_priority(expr)
    if expr.type == "func" then
      if expr.name == "ln" then return 1 end
      if expr.name:match("^arc") then return 2 end -- arcsin, arccos, etc.
      if expr.name:match("^a?sinh?$") or expr.name:match("^a?cosh?$") then return 2 end
      if expr.name == "sin" or expr.name == "cos" or expr.name == "tan" then return 4 end
      if expr.name == "exp" then return 5 end
    elseif expr.type == "pow" and is_symbol(expr.base, var) then
      return 3 -- algebraic
    elseif is_symbol(expr, var) then
      return 3
    end
    return 6 -- everything else
  end
  
  -- Choose u and dv based on priority
  local best_u, best_dv
  local best_priority = math.huge
  
  for i = 1, #node.args do
    local priority = get_integration_priority(node.args[i])
    if priority < best_priority then
      best_priority = priority
      best_u = node.args[i]
      -- dv is everything else
      local dv_args = {}
      for j = 1, #node.args do
        if i ~= j then table.insert(dv_args, node.args[j]) end
      end
      best_dv = #dv_args == 1 and dv_args[1] or ast.mul(table.unpack(dv_args))
    end
  end
  
  if not best_u or not best_dv then return nil end
  
  local V = integrateAST(best_dv, var)
  local du = diffAST(best_u, var)
  
  if not V or not du or V.type == "unimplemented_integral" then
    return nil
  end
  
  local second_integral = integrateAST(ast.mul(V, du), var)
  if second_integral and second_integral.type ~= "unimplemented_integral" then
    return ast.sub(ast.mul(best_u, V), second_integral)
  end
  
  return nil
end

-- Enhanced trig integration (now with more trigonometric masochism)
local function integrate_trig(fname, arg, var)
  if not fname or not arg then return nil end
  
  -- Handle chain rule: if arg is not just the variable, we need the derivative
  local chain_factor = nil
  if arg.type ~= "variable" or arg.name ~= var then
    local darg = diffAST(arg, var)
    if not darg then return nil end
    chain_factor = darg
  end
  
  local base_integral
  if fname == "sin" then
    base_integral = ast.neg(ast.func("cos", { copy(arg) }))
  elseif fname == "cos" then
    base_integral = ast.func("sin", { copy(arg) })
  elseif fname == "tan" then
    base_integral = ast.neg(ast.func("ln", { ast.func("cos", { copy(arg) }) }))
  elseif fname == "cot" then
    base_integral = ast.func("ln", { ast.func("sin", { copy(arg) }) })
  elseif fname == "sec" then
    base_integral = ast.func("ln", { ast.add(ast.func("sec", { copy(arg) }), ast.func("tan", { copy(arg) })) })
  elseif fname == "csc" then
    base_integral = ast.neg(ast.func("ln", { ast.add(ast.func("csc", { copy(arg) }), ast.func("cot", { copy(arg) })) }))
  -- Inverse trig functions (the "why do these even exist" section)
  elseif fname == "arcsin" then
    if is_symbol(arg, var) then
      return ast.add(ast.mul(copy(arg), ast.func("arcsin", {copy(arg)})), 
                     ast.func("sqrt", {ast.sub(ast.number(1), ast.pow(copy(arg), ast.number(2)))}))
    end
  elseif fname == "arccos" then
    if is_symbol(arg, var) then
      return ast.sub(ast.mul(copy(arg), ast.func("arccos", {copy(arg)})), 
                     ast.func("sqrt", {ast.sub(ast.number(1), ast.pow(copy(arg), ast.number(2)))}))
    end
  elseif fname == "arctan" then
    if is_symbol(arg, var) then
      return ast.sub(ast.mul(copy(arg), ast.func("arctan", {copy(arg)})), 
                     ast.div(ast.func("ln", {ast.add(ast.number(1), ast.pow(copy(arg), ast.number(2)))}), ast.number(2)))
    end
  -- Hyperbolic functions (because we're completionists, apparently)
  elseif fname == "sinh" then
    base_integral = ast.func("cosh", { copy(arg) })
  elseif fname == "cosh" then
    base_integral = ast.func("sinh", { copy(arg) })
  elseif fname == "tanh" then
    base_integral = ast.func("ln", { ast.func("cosh", { copy(arg) }) })
  else
    return nil
  end
  
  -- Apply chain rule if needed
  if chain_factor and base_integral then
    -- This would need the reciprocal of the chain factor, which is complex
    -- For now, return nil for non-trivial arguments
    return nil
  end
  
  return base_integral
end

-- Numerical integration fallback (because sometimes symbolic integration is impossible)
local function numerical_integration_fallback(node, var, a, b)
  if not enable_definite_integrals or not a or not b then
    return {
      type = "numerical_integration_required",
      original = copy(node),
      bounds = {lower = a, upper = b}
    }
  end
  
  -- Simpson's rule implementation would go here
  -- But that's a whole other can of worms
  return {
    type = "numerical_approximation",
    method = "simpsons_rule",
    original = copy(node),
    bounds = {lower = a, upper = b}
  }
end

-- Core integration function (now with 400% more complexity and existential dread)
local function integrateAST(node, var, bounds)
  if not node then 
    error("integrateAST: invalid AST node") 
  end
  var = var or "x"
  
  -- Handle definite integrals
  local is_definite = bounds and bounds.lower and bounds.upper
  
  -- ∫ c dx = c * x
  if node.type == "number" then
    local result = ast.mul(copy(node), ast.variable(var))
    if is_definite then
      -- F(b) - F(a)
      local upper_val = ast.mul(copy(node), copy(bounds.upper))
      local lower_val = ast.mul(copy(node), copy(bounds.lower))
      return ast.sub(upper_val, lower_val)
    end
    return ast.add(result, ast.variable("C"))
  end

  -- ∫ x dx = x^2/2 ; ∫ y dx = y * x
  if node.type == "variable" then
    if node.name == var then
      local result = ast.div(ast.pow(ast.variable(var), ast.number(2)), ast.number(2))
      if is_definite then
        local upper_val = ast.div(ast.pow(copy(bounds.upper), ast.number(2)), ast.number(2))
        local lower_val = ast.div(ast.pow(copy(bounds.lower), ast.number(2)), ast.number(2))
        return ast.sub(upper_val, lower_val)
      end
      return ast.add(result, ast.variable("C"))
    else
      local result = ast.mul(copy(node), ast.variable(var))
      if is_definite then
        local diff = ast.sub(copy(bounds.upper), copy(bounds.lower))
        return ast.mul(copy(node), diff)
      end
      return ast.add(result, ast.variable("C"))
    end
  end

  -- ∫ (u + v) dx = ∫u + ∫v
  if node.type == "add" and node.args then
    local results = {}
    for i, term in ipairs(node.args) do
      local integral_term = integrateAST(term, var, bounds)
      if integral_term.type == "unimplemented_integral" then
        -- Try numerical integration if this is definite
        if is_definite then
          return numerical_integration_fallback(node, var, bounds.lower, bounds.upper)
        end
        return { type = "unimplemented_integral", original = node }
      end
      results[i] = integral_term
    end
    if is_definite then
      return ast.add(table.unpack(results))
    end
    return ast.add(ast.add(table.unpack(results)), ast.variable("C"))
  end

  -- ∫ (u - v) dx = ∫u - ∫v
  if node.type == "sub" and node.left and node.right then
    local left_int = integrateAST(node.left, var, bounds)
    local right_int = integrateAST(node.right, var, bounds)
    if left_int.type == "unimplemented_integral" or right_int.type == "unimplemented_integral" then
      if is_definite then
        return numerical_integration_fallback(node, var, bounds.lower, bounds.upper)
      end
      return { type = "unimplemented_integral", original = node }
    end
    if is_definite then
      return ast.sub(left_int, right_int)
    end
    return ast.add(ast.sub(left_int, right_int), ast.variable("C"))
  end

  -- Enhanced division handling with partial fractions
  if node.type == "div" and node.left and node.right then
    local num, denom = node.left, node.right
    
    -- Check for f'(x)/f(x) pattern first
    local ddenom = diffAST(denom, var)
    if ddenom and simplify.expr_equal and simplify.expr_equal(num, ddenom) then
      local result = ast.func("ln", { ast.func("abs", { copy(denom) }) })
      if is_definite then
        local upper_val = ast.func("ln", { ast.func("abs", { ast.replace(copy(denom), ast.variable(var), copy(bounds.upper)) }) })
        local lower_val = ast.func("ln", { ast.func("abs", { ast.replace(copy(denom), ast.variable(var), copy(bounds.lower)) }) })
        return ast.sub(upper_val, lower_val)
      end
      return result
    end
    
    -- Try partial fraction decomposition
    if enable_partial_fractions and is_polynomial(num, var) and is_polynomial(denom, var) then
      local partial_fractions = partial_fraction_decompose(num, denom, var)
      if partial_fractions and partial_fractions.type == "partial_fraction_sum" then
        local results = {}
        for _, term in ipairs(partial_fractions.terms) do
          local term_integral = integrateAST(ast.div(term.numerator, term.denominator), var, bounds)
          if term_integral.type == "unimplemented_integral" then
            break
          end
          table.insert(results, term_integral)
        end
        if #results == #partial_fractions.terms then
          return ast.add(table.unpack(results))
        end
      end
    end
    
    -- Convert to multiplication for further processing
    return integrateAST(ast.mul(node.left, ast.pow(node.right, ast.number(-1))), var, bounds)
  end

  -- Enhanced multiplication handling
  if node.type == "mul" and node.args then
    -- Try substitution first
    if enable_substitution then
      local sub_result = try_substitution(node, var)
      if sub_result then 
        if sub_result.type == "advanced_substitution" then
          -- For now, acknowledge we found a substitution pattern but can't execute it
          if is_definite then
            return numerical_integration_fallback(node, var, bounds.lower, bounds.upper)
          end
          return { type = "unimplemented_integral", original = node, note = "advanced_substitution_found" }
        end
        return sub_result 
      end
    end

    -- Try integration by parts
    local parts_result = try_integration_by_parts(node, var)
    if parts_result then return parts_result end

    -- Handle exponential integrals: ∫ f'(x) * e^{f(x)} dx = e^{f(x)}
    for i, arg in ipairs(node.args) do
      if arg.type == "func" and arg.name == "exp" and arg.args and arg.args[1] then
        local f = arg.args[1]
        local df = diffAST(f, var)
        if df then
          for j, other in ipairs(node.args) do
            if i ~= j and simplify.expr_equal and simplify.expr_equal(other, df) then
              local remaining = {}
              for k, term in ipairs(node.args) do
                if k ~= i and k ~= j then
                  table.insert(remaining, term)
                end
              end
              local result = ast.func("exp", { copy(f) })
              if #remaining > 0 then
                local factor = #remaining == 1 and remaining[1] or ast.mul(table.unpack(remaining))
                result = ast.mul(factor, result)
              end
              
              if is_definite then
                local upper_val = ast.replace(copy(result), ast.variable(var), copy(bounds.upper))
                local lower_val = ast.replace(copy(result), ast.variable(var), copy(bounds.lower))
                return ast.sub(upper_val, lower_val)
              end
              return result
            end
          end
        end
      end
    end

    -- Power rule with chain: ∫ f(x)^n * f'(x) dx = f(x)^{n+1}/(n+1)
    for i, arg in ipairs(node.args) do
      if arg.type == "pow" and is_const(arg.exp) and arg.exp.value ~= -1 then
        local base, exp = arg.base, arg.exp
        local dbase = diffAST(base, var)
        if dbase then
          for j, other in ipairs(node.args) do
            if i ~= j and simplify.expr_equal and simplify.expr_equal(other, dbase) then
              local new_exp = ast.add(copy(exp), ast.number(1))
              local result = ast.div(ast.pow(copy(base), new_exp), copy(new_exp))
              
              if is_definite then
                local upper_val = ast.replace(copy(result), ast.variable(var), copy(bounds.upper))
                local lower_val = ast.replace(copy(result), ast.variable(var), copy(bounds.lower))
                return ast.sub(upper_val, lower_val)
              end
              return result
            end
          end
        end
      end
    end

    -- Extract constants (this part actually works, surprisingly)
    local constants = {}
    local variables = {}
    for _, arg in ipairs(node.args) do
      if is_const(arg) or (arg.type == "variable" and arg.name ~= var) then
        table.insert(constants, arg)
      else
        table.insert(variables, arg)
      end
    end

    if #constants > 0 and #variables > 0 then
      local const_product = #constants == 1 and constants[1] or ast.mul(table.unpack(constants))
      local var_product = #variables == 1 and variables[1] or ast.mul(table.unpack(variables))
      local var_integral = integrateAST(var_product, var, bounds)
      if var_integral.type ~= "unimplemented_integral" then
        if is_definite then
          return var_integral -- bounds already handled in recursive call
        end
        return ast.mul(const_product, var_integral)
      end
    end
  end

  -- Enhanced power rule: ∫ x^n dx and ∫ a^x dx
  if node.type == "pow" and node.base and node.exp then
    local base, exp = node.base, node.exp
    
    if is_symbol(base, var) and is_const(exp) then
      if exp.value == -1 then
        local result = ast.func("ln", { ast.func("abs", { copy(base) }) })
        if is_definite then
          local upper_val = ast.func("ln", { ast.func("abs", { copy(bounds.upper) }) })
          local lower_val = ast.func("ln", { ast.func("abs", { copy(bounds.lower) }) })
          return ast.sub(upper_val, lower_val)
        end
        return ast.add(result, ast.variable("C"))
      else
        local new_exp = ast.number(exp.value + 1)
        local result = ast.div(ast.pow(copy(base), new_exp), new_exp)
        if is_definite then
          local upper_val = ast.div(ast.pow(copy(bounds.upper), new_exp), new_exp)
          local lower_val = ast.div(ast.pow(copy(bounds.lower), new_exp), new_exp)
          return ast.sub(upper_val, lower_val)
        end
        return ast.add(result, ast.variable("C"))
      end
    elseif is_const(base) and is_symbol(exp, var) then
      -- ∫ a^x dx = a^x / ln(a)
      local result = ast.div(copy(node), ast.func("ln", { copy(base) }))
      if is_definite then
        local upper_val = ast.div(ast.pow(copy(base), copy(bounds.upper)), ast.func("ln", { copy(base) }))
        local lower_val = ast.div(ast.pow(copy(base), copy(bounds.lower)), ast.func("ln", { copy(base) }))
        return ast.sub(upper_val, lower_val)
      end
      return ast.add(result, ast.variable("C"))
    end
  end

  -- Enhanced function integration
  if node.type == "func" and node.name then
    local fname = node.name
    local arg = (node.args and node.args[1]) or node.arg

    -- Try trigonometric functions (now with more trig!)
    local trig_result = integrate_trig(fname, arg, var)
    if trig_result then 
      if is_definite then
        local upper_val = ast.replace(copy(trig_result), ast.variable(var), copy(bounds.upper))
        local lower_val = ast.replace(copy(trig_result), ast.variable(var), copy(bounds.lower))
        return ast.sub(upper_val, lower_val)
      end
      return ast.add(trig_result, ast.variable("C"))
    end

    -- Handle other common functions
    if fname == "exp" and arg then
      if is_symbol(arg, var) then
        if is_definite then
          local upper_val = ast.func("exp", { copy(bounds.upper) })
          local lower_val = ast.func("exp", { copy(bounds.lower) })
          return ast.sub(upper_val, lower_val)
        end
        return ast.add(copy(node), ast.variable("C"))
      end
    elseif fname == "ln" and arg then
      if is_symbol(arg, var) then
        -- ∫ ln(x) dx = x*ln(x) - x
        local x = ast.variable(var)
        local result = ast.sub(ast.mul(x, copy(node)), x)
        if is_definite then
          local upper_val = ast.sub(ast.mul(copy(bounds.upper), ast.func("ln", { copy(bounds.upper) })), copy(bounds.upper))
          local lower_val = ast.sub(ast.mul(copy(bounds.lower), ast.func("ln", { copy(bounds.lower) })), copy(bounds.lower))
          return ast.sub(upper_val, lower_val)
        end
        return ast.add(result, ast.variable("C"))
      end
    elseif fname == "sqrt" and arg then
      -- ∫ √x dx = (2/3)x^(3/2)
      if is_symbol(arg, var) then
        local result = ast.mul(ast.div(ast.number(2), ast.number(3)), ast.pow(copy(arg), ast.div(ast.number(3), ast.number(2))))
        if is_definite then
          local upper_val = ast.mul(ast.div(ast.number(2), ast.number(3)), ast.pow(copy(bounds.upper), ast.div(ast.number(3), ast.number(2))))
          local lower_val = ast.mul(ast.div(ast.number(2), ast.number(3)), ast.pow(copy(bounds.lower), ast.div(ast.number(3), ast.number(2))))
          return ast.sub(upper_val, lower_val)
        end
        return ast.add(result, ast.variable("C"))
      end
    elseif known_integral_table[fname] and arg then
      local result = known_integral_table[fname](copy(arg))
      if result then 
        if is_definite then
          local upper_val = ast.replace(copy(result), ast.variable(var), copy(bounds.upper))
          local lower_val = ast.replace(copy(result), ast.variable(var), copy(bounds.lower))
          return ast.sub(upper_val, lower_val)
        end
        return ast.add(result, ast.variable("C"))
      end
    end
  end

  -- If we get here and it's definite, try numerical integration
  if is_definite then
    return numerical_integration_fallback(node, var, bounds.lower, bounds.upper)
  end

  -- If we get here, we couldn't integrate it symbolically
  return { type = "unimplemented_integral", original = copy(node) }
end

-- Multi-variable integration (because we're apparently sadists)
local function integrate_multivariable(node, vars)
  if not vars or #vars == 0 then
    error("Multi-variable integration requires at least one variable")
  end
  
  -- Integrate successively over each variable
  local result = copy(node)
  for _, var in ipairs(vars) do
    result = integrateAST(result, var)
    if result.type == "unimplemented_integral" then
      return {
        type = "unimplemented_multivariable_integral",
        original = copy(node),
        attempted_vars = vars,
        failed_at = var
      }
    end
  end
  
  return result
end

-- Improper integral detection (because infinite bounds are fun)
local function handle_improper_integral(node, var, bounds)
  if not bounds then return nil end
  
  local has_infinity = false
  if bounds.lower and bounds.lower.type == "infinity" then has_infinity = true end
  if bounds.upper and bounds.upper.type == "infinity" then has_infinity = true end
  
  if has_infinity then
    return {
      type = "improper_integral",
      original = copy(node),
      bounds = copy(bounds),
      note = "Requires limit evaluation for convergence"
    }
  end
  
  return nil
end

-- Main integration interface (now with more parameters because complexity is fun)
local function integral(expr, var, bounds, options)
  local tree
  local parser = rawget(_G, "parser") or require("parser")
  
  options = options or {}
  var = var or "x"
  
  if type(expr) == "string" then
    tree = parser.parse(expr)
  elseif type(expr) == "table" then
    tree = expr
  else
    error("Invalid input to integral(): expected string or AST table, got " .. type(expr))
  end

  if not tree then
    error("Parsing failed: input = " .. tostring(expr))
  end

  -- Handle multi-variable integration
  if type(var) == "table" then
    return integrate_multivariable(tree, var)
  end

  -- Check for improper integrals
  if bounds then
    local improper = handle_improper_integral(tree, var, bounds)
    if improper then return improper end
  end

  local result = integrateAST(tree, var, bounds)
  
  if not result or type(result) ~= "table" then
    error("Invalid integral result")
  end

  -- Only simplify if we got a real result and it's not too complex
  if result.type ~= "unimplemented_integral" and 
     result.type ~= "numerical_approximation" and 
     result.type ~= "improper_integral" and 
     simplify.simplify then
    result = simplify.simplify(result)
  end

  return result
end

-- Convenience functions for specific integral types
local function definite_integral(expr, var, a, b)
  return integral(expr, var, {lower = a, upper = b})
end

local function indefinite_integral(expr, var)
  return integral(expr, var)
end

-- Line integral (because we're completionists)
local function line_integral(vector_field, curve, parameter)
  -- This would be a whole other nightmare to implement properly
  return {
    type = "unimplemented_line_integral",
    vector_field = copy(vector_field),
    curve = copy(curve),
    parameter = parameter or "t"
  }
end

-- Surface integral (why not go full differential geometry)
local function surface_integral(scalar_field, surface, parameters)
  return {
    type = "unimplemented_surface_integral",
    scalar_field = copy(scalar_field),
    surface = copy(surface),
    parameters = parameters or {"u", "v"}
  }
end

-- Global exports (now with even more ways to confuse users)
_G.integrate = {
  integrateAST = integrateAST,
  eval = integral,
  definite = definite_integral,
  indefinite = indefinite_integral,
  multivariable = integrate_multivariable,
  line = line_integral,
  surface = surface_integral,
  -- Utility functions
  partial_fractions = partial_fraction_decompose,
  is_polynomial = is_polynomial
}
_G.integral = _G.integrate.eval
_G.definite_integral = _G.integrate.definite
_G.indefinite_integral = _G.integrate.indefinite

-- Enhanced pretty printing for all our new failure modes
if _G.pretty_print_internal then
  local old_pretty_internal = _G.pretty_print_internal

  function pretty_print_internal(expr, parent, pos)
    if expr and expr.type == "unimplemented_integral" and expr.original then
      return "∫(" .. pretty_print_internal(expr.original, nil, nil) .. ") dx"
    end
    
    if expr and expr.type == "unimplemented_multivariable_integral" then
      local vars_str = table.concat(expr.attempted_vars, ", ")
      return "∫∫...(" .. pretty_print_internal(expr.original, nil, nil) .. ") d" .. vars_str .. " [failed at " .. expr.failed_at .. "]"
    end
    
    if expr and expr.type == "numerical_approximation" then
      return "≈∫[" .. pretty_print_internal(expr.bounds.lower, nil, nil) .. "," .. pretty_print_internal(expr.bounds.upper, nil, nil) .. "] (" .. pretty_print_internal(expr.original, nil, nil) .. ") dx"
    end
    
    if expr and expr.type == "improper_integral" then
      return "∫[" .. pretty_print_internal(expr.bounds.lower, nil, nil) .. "," .. pretty_print_internal(expr.bounds.upper, nil, nil) .. "] (" .. pretty_print_internal(expr.original, nil, nil) .. ") dx (improper)"
    end
    
    if expr and expr.type == "advanced_substitution" then
      return "∫(" .. pretty_print_internal(expr.original, nil, nil) .. ") dx [" .. expr.method .. " substitution]"
    end
    
    if expr and expr.type == "partial_fraction_sum" then
      local terms = {}
      for _, term in ipairs(expr.terms) do
        table.insert(terms, pretty_print_internal(ast.div(term.numerator, term.denominator), nil, nil))
      end
      return table.concat(terms, " + ")
    end
    
    if expr and expr.type == "unimplemented_line_integral" then
      return "∮ F⋅dr (line integral - not implemented)"
    end
    
    if expr and expr.type == "unimplemented_surface_integral" then
      return "∬ f dS (surface integral - not implemented)"
    end
    
    if expr and expr.type == "neg" and expr.arg then
      local inner = pretty_print_internal(expr.arg, nil, nil)
      if expr.arg.type ~= "number" and expr.arg.type ~= "variable" then
        inner = "(" .. inner .. ")"
      end
      return "-" .. inner
    end

    -- Custom addition node pretty printing: print constant C last for indefinite integrals
    if expr and expr.type == "add" and expr.args then
      local regular_terms = {}
      local constant_c = nil

      for _, arg in ipairs(expr.args) do
        if arg.type == "variable" and arg.name == "C" then
          constant_c = old_pretty_internal(arg, "add", "inner")
        else
          table.insert(regular_terms, old_pretty_internal(arg, "add", "inner"))
        end
      end

      local result = table.concat(regular_terms, " + ")
      if constant_c then
        if #regular_terms > 0 then
          result = result .. " + " .. constant_c
        else
          result = constant_c
        end
      end
      return result
    end
    
    return old_pretty_internal(expr, parent, pos)
  end
  
  _G.pretty_print_internal = pretty_print_internal
end

-- Integration testing framework (because we need to know how badly we're failing)
local function test_integration()
  local tests = {
    -- Basic tests
    {"x", "x", nil, "should integrate to x^2/2"},
    {"x^2", "x", nil, "should integrate to x^3/3"},
    {"sin(x)", "x", nil, "should integrate to -cos(x)"},
    {"cos(x)", "x", nil, "should integrate to sin(x)"},
    {"e^x", "x", nil, "should integrate to e^x"},
    {"1/x", "x", nil, "should integrate to ln|x|"},
    
    -- Definite integrals
    {"x", "x", {lower = ast.number(0), upper = ast.number(1)}, "should equal 1/2"},
    {"x^2", "x", {lower = ast.number(0), upper = ast.number(2)}, "should equal 8/3"},
    
    -- Advanced cases
    {"x*sin(x)", "x", nil, "integration by parts"},
    {"arctan(x)", "x", nil, "inverse trig function"},
    {"1/(x^2 + 1)", "x", nil, "should integrate to arctan(x)"},
    {"sqrt(x)", "x", nil, "should integrate to (2/3)x^(3/2)"},
    
    -- Failure cases (these should gracefully fail)
    {"sin(x^2)", "x", nil, "should require numerical methods"},
    {"e^(x^2)", "x", nil, "impossible to integrate symbolically"},
  }
  
  local results = {}
  for i, test in ipairs(tests) do
    local expr, var, bounds, description = test[1], test[2], test[3], test[4]
    local success, result = pcall(integral, expr, var, bounds)
    
    results[i] = {
      test = test,
      success = success,
      result = success and result or tostring(result),
      description = description
    }
  end
  
  return results
end

-- Export test function
_G.test_integration = test_integration

-- Final comment: If you've made it this far, you're either very brave or very foolish.
-- This integral engine now supports:
-- - All the basic stuff from before (polynomials, trig, exponentials)
-- - Inverse trig functions (arcsin, arccos, arctan)
-- - Hyperbolic functions (sinh, cosh, tanh)
-- - Partial fraction decomposition (simplified version)
-- - Advanced substitution pattern recognition
-- - Definite integrals with bounds
-- - Multi-variable integration (successive integration)
-- - Improper integral detection
-- - Numerical integration fallback
-- - Line and surface integrals (placeholder)
-- - Enhanced integration by parts with LIATE rule
-- - Better error handling and pretty printing
-- 
-- What it still can't do:
-- - Actually perform complex trigonometric substitutions
-- - Real partial fraction decomposition for complex cases
-- - Contour integration
-- - Advanced special functions
-- - Symbolic manipulation of infinite series
-- - Anything involving Bessel functions, elliptic integrals, or other exotic functions
-- - Keep your sanity intact while debugging integration failures
--
-- Use at your own risk. Side effects may include: mathematical anxiety, 
-- existential dread, and an uncontrollable urge to switch to numerical methods.

-- End src/integrate.lua

-- Imported src/integrate.lua—debuggers rejoice.

-- Begin src/physics.lua
local errors = _G.errors
local ast = _G.ast or error("AST module required")
local diffAST = _G.diffAST or error("diffAST (symbolic differentiation) required")

local init = rawget(_G, "init")
local var = rawget(_G, "var") or require("var")

local Matrix = {}
Matrix.__index = Matrix

function Matrix:eval_numeric(env)
  local result = {}
  for i = 1, self.rows do
    result[i] = {}
    for j = 1, self.cols do
      result[i][j] = ast.eval_numeric(self.data[i][j], env)
    end
  end
  return result
end

function Matrix.new(data)
  assert(type(data) == "table", "Matrix must be constructed from a table")
  local rows = #data
  local cols = #data[1]
  for i = 2, rows do
    assert(#data[i] == cols, "Matrix rows must be same length")
  end
  return setmetatable({ type = "matrix", data = data, rows = rows, cols = cols }, Matrix)
end

function Matrix:tostring()
  local out = {}
  for i = 1, self.rows do
    local row = {}
    for j = 1, self.cols do
      table.insert(row, tostring(self.data[i][j]))
    end
    table.insert(out, "{" .. table.concat(row, ", ") .. "}")
  end
  return "[" .. table.concat(out, ",\n ") .. "]"
end

function Matrix:add(B)
  assert(self.rows == B.rows and self.cols == B.cols, "Shape mismatch")
  local result = {}
  for i = 1, self.rows do
    result[i] = {}
    for j = 1, self.cols do
      result[i][j] = ast.add(self.data[i][j], B.data[i][j])
    end
  end
  return Matrix.new(result)
end

function Matrix:mul(B)
  assert(self.cols == B.rows, "Incompatible dimensions")
  local result = {}
  for i = 1, self.rows do
    result[i] = {}
    for j = 1, B.cols do
      local sum = ast.number(0)
      for k = 1, self.cols do
        sum = ast.add(sum, ast.mul(self.data[i][k], B.data[k][j]))
      end
      result[i][j] = sum
    end
  end
  return Matrix.new(result)
end

function Matrix:transpose()
  local result = {}
  for i = 1, self.cols do
    result[i] = {}
    for j = 1, self.rows do
      result[i][j] = self.data[j][i]
    end
  end
  return Matrix.new(result)
end

function Matrix:determinant()
  assert(self.rows == 2 and self.cols == 2, "Only 2x2 determinant supported")
  local a, b = self.data[1][1], self.data[1][2]
  local c, d = self.data[2][1], self.data[2][2]
  return ast.sub(ast.mul(a, d), ast.mul(b, c))
end

function Matrix:inverse()
  local det = self:determinant()
  local a, b = self.data[1][1], self.data[1][2]
  local c, d = self.data[2][1], self.data[2][2]
  local inv = {
    {d, ast.mul(ast.number(-1), b)},
    {ast.mul(ast.number(-1), c), a}
  }
  local det_inv = ast.pow(det, ast.number(-1))
  for i = 1, 2 do
    for j = 1, 2 do
      inv[i][j] = ast.mul(inv[i][j], det_inv)
    end
  end
  return Matrix.new(inv)
end

-- Because clearly physics constants need their own VIP section with metadata and a velvet rope
local physics_constants = {
    -- Fundamental constants
    g = {
        value = ast.number(9.80665),
        description = "Standard gravity",
        unit = "m/s²",
        category = "fundamental",
        symbol = "g"
    },
    c = {
        value = ast.number(299792458),
        description = "Speed of light in vacuum",
        unit = "m/s",
        category = "fundamental",
        symbol = "c"
    },
    h = {
        value = ast.number(6.62607015e-34),
        description = "Planck constant",
        unit = "J⋅s",
        category = "fundamental",
        symbol = "h"
    },
    hbar = {
        value = ast.number(1.054571817e-34),
        description = "Reduced Planck constant",
        unit = "J⋅s",
        category = "fundamental",
        symbol = "ℏ"
    },
    e = {
        value = ast.number(1.602176634e-19),
        description = "Elementary charge",
        unit = "C",
        category = "fundamental",
        symbol = "e"
    },
    
    -- Particle masses, because mass matters
    m_e = {
        value = ast.number(9.1093837015e-31),
        description = "Electron rest mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "mₑ"
    },
    m_p = {
        value = ast.number(1.67262192369e-27),
        description = "Proton rest mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "mₚ"
    },
    m_n = {
        value = ast.number(1.67492749804e-27),
        description = "Neutron rest mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "mₙ"
    },
    
    -- Particle mass energies, because why not add energy to the mix
    m_e_eV = {
        value = ast.number(0.51099895000e6),
        description = "Electron mass energy",
        unit = "eV/c²",
        category = "particle_masses",
        symbol = "mₑc²"
    },
    m_p_eV = {
        value = ast.number(938.27208816e6),
        description = "Proton mass energy",
        unit = "eV/c²",
        category = "particle_masses",
        symbol = "mₚc²"
    },
    m_n_eV = {
        value = ast.number(939.56542052e6),
        description = "Neutron mass energy",
        unit = "eV/c²",
        category = "particle_masses",
        symbol = "mₙc²"
    },
    
    -- Atomic and molecular constants, because atoms deserve constants too
    mu = {
        value = ast.number(1.66053906660e-27),
        description = "Atomic mass unit",
        unit = "kg",
        category = "atomic",
        symbol = "μ"
    },
    u = {
        value = ast.number(1.66053906660e-27),
        description = "Atomic mass unit (alias)",
        unit = "kg",
        category = "atomic",
        symbol = "u"
    },
    N_A = {
        value = ast.number(6.02214076e23),
        description = "Avogadro's number",
        unit = "mol⁻¹",
        category = "atomic",
        symbol = "Nₐ"
    },
    k_B = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant",
        unit = "J/K",
        category = "thermodynamic",
        symbol = "kᵦ"
    },
    R = {
        value = ast.number(8.314462618),
        description = "Gas constant",
        unit = "J/(mol⋅K)",
        category = "thermodynamic",
        symbol = "R"
    },
    
    -- Electromagnetic constants, because electricity and magnetism can't be ignored
    epsilon_0 = {
        value = ast.number(8.8541878128e-12),
        description = "Vacuum permittivity",
        unit = "F/m",
        category = "electromagnetic",
        symbol = "ε₀"
    },
    mu_0 = {
        value = ast.number(1.25663706212e-6),
        description = "Vacuum permeability",
        unit = "H/m",
        category = "electromagnetic",
        symbol = "μ₀"
    },
    Z_0 = {
        value = ast.number(376.730313668),
        description = "Vacuum impedance",
        unit = "Ω",
        category = "electromagnetic",
        symbol = "Z₀"
    },
    
    -- Atomic structure constants, because atoms have structure and that matters
    a_0 = {
        value = ast.number(5.29177210903e-11),
        description = "Bohr radius",
        unit = "m",
        category = "atomic",
        symbol = "a₀"
    },
    R_inf = {
        value = ast.number(1.0973731568160e7),
        description = "Rydberg constant",
        unit = "m⁻¹",
        category = "atomic",
        symbol = "R∞"
    },
    alpha = {
        value = ast.number(7.2973525693e-3),
        description = "Fine structure constant",
        unit = "dimensionless",
        category = "atomic",
        symbol = "α"
    },
    
    -- Energy constants, because energy is everything
    eV = {
        value = ast.number(1.602176634e-19),
        description = "Electron volt",
        unit = "J",
        category = "energy",
        symbol = "eV"
    },
    
    -- Other constants, because we need to fill space
    F = {
        value = ast.number(96485.33212),
        description = "Faraday constant",
        unit = "C/mol",
        category = "electromagnetic",
        symbol = "F"
    },
    G = {
        value = ast.number(6.67430e-11),
        description = "Gravitational constant",
        unit = "N⋅m²/kg²",
        category = "fundamental",
        symbol = "G"
    },
    
    -- Mathematical constants, because math is the language of the universe
    pi = {
        value = ast.number(math.pi),
        description = "Pi",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "π"
    },
    e_math = {
        value = ast.number(math.exp(1)),
        description = "Euler's number",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "e"
    },

    -- Nuclear constants, because splitting atoms is a hobby now
    tau_n = {
        value = ast.number(880.2),
        description = "Neutron lifetime",
        unit = "s",
        category = "nuclear",
        symbol = "τₙ"
    },
    sigma_f = {
        value = ast.number(585e-28),
        description = "Thermal fission cross section of U-235",
        unit = "m²",
        category = "nuclear",
        symbol = "σ_f"
    },

    -- Cosmological constants, because thinking small is overrated
    H_0 = {
        value = ast.number(67.4),
        description = "Hubble constant",
        unit = "km/s/Mpc",
        category = "cosmological",
        symbol = "H₀"
    },
    Lambda = {
        value = ast.number(1.1056e-52),
        description = "Cosmological constant",
        unit = "1/m²",
        category = "cosmological",
        symbol = "Λ"
    },

    -- Lepton properties, because electrons need cousins
    muon_mass = {
        value = ast.number(1.883531627e-28),
        description = "Muon's mass",
        unit = "kg",
        category = "leptons",
        symbol = "m_μ"
    },
    tau_mass = {
        value = ast.number(3.16754e-27),
        description = "Tau lepton mass",
        unit = "kg",
        category = "leptons",
        symbol = "m_τ"
    },

    
    -- Mechanics
    constant_001 = {
        value = ast.number(9.80665),
        description = "Standard acceleration due to gravity at Earth's surface",
        unit = "m/s²",
        category = "mechanical",
        symbol = "g₀"
    },
    constant_002 = {
        value = ast.number(6.67430e-11),
        description = "Newtonian constant of gravitation",
        unit = "N⋅m²/kg²",
        category = "mechanical",
        symbol = "G"
    },
    constant_003 = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant",
        unit = "J/K",
        category = "thermodynamic",
        symbol = "k_B"
    },
    constant_004 = {
        value = ast.number(8.314462618),
        description = "Universal gas constant",
        unit = "J/(mol⋅K)",
        category = "thermodynamic",
        symbol = "R"
    },
    constant_005 = {
        value = ast.number(101325),
        description = "Standard atmospheric pressure",
        unit = "Pa",
        category = "thermodynamic",
        symbol = "P₀"
    },
    constant_006 = {
        value = ast.number(273.15),
        description = "Standard temperature (triple point of water)",
        unit = "K",
        category = "thermodynamic",
        symbol = "T₀"
    },
    constant_007 = {
        value = ast.number(6.02214076e23),
        description = "Avogadro constant",
        unit = "mol⁻¹",
        category = "atomic",
        symbol = "N_A"
    },
    constant_008 = {
        value = ast.number(0.082057366080960),
        description = "Molar gas constant (L⋅atm)/(mol⋅K)",
        unit = "L⋅atm/(mol⋅K)",
        category = "thermodynamic",
        symbol = "R"
    },
    constant_009 = {
        value = ast.number(1.01325e5),
        description = "Atmosphere (standard)",
        unit = "Pa",
        category = "thermodynamic",
        symbol = "atm"
    },
    constant_010 = {
        value = ast.number(760),
        description = "Standard atmosphere in mmHg",
        unit = "mmHg",
        category = "thermodynamic",
        symbol = "atm"
    },
    -- Electromagnetism
    constant_011 = {
        value = ast.number(8.8541878128e-12),
        description = "Vacuum permittivity",
        unit = "F/m",
        category = "electromagnetic",
        symbol = "ε₀"
    },
    constant_012 = {
        value = ast.number(1.25663706212e-6),
        description = "Vacuum permeability",
        unit = "H/m",
        category = "electromagnetic",
        symbol = "μ₀"
    },
    constant_013 = {
        value = ast.number(299792458),
        description = "Speed of light in vacuum",
        unit = "m/s",
        category = "electromagnetic",
        symbol = "c"
    },
    constant_014 = {
        value = ast.number(1.602176634e-19),
        description = "Elementary charge",
        unit = "C",
        category = "electromagnetic",
        symbol = "e"
    },
    constant_015 = {
        value = ast.number(9.648533212e4),
        description = "Faraday constant",
        unit = "C/mol",
        category = "electromagnetic",
        symbol = "F"
    },
    constant_016 = {
        value = ast.number(1.602176634e-19),
        description = "Electron volt",
        unit = "J",
        category = "energy",
        symbol = "eV"
    },
    constant_017 = {
        value = ast.number(6.62607015e-34),
        description = "Planck constant",
        unit = "J⋅s",
        category = "quantum",
        symbol = "h"
    },
    constant_018 = {
        value = ast.number(1.054571817e-34),
        description = "Reduced Planck constant",
        unit = "J⋅s",
        category = "quantum",
        symbol = "ħ"
    },
    constant_019 = {
        value = ast.number(2.8179403262e-15),
        description = "Classical electron radius",
        unit = "m",
        category = "atomic",
        symbol = "r_e"
    },
    constant_020 = {
        value = ast.number(1.67262192369e-27),
        description = "Proton mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "m_p"
    },
    -- Atomic/Quantum
    constant_021 = {
        value = ast.number(9.1093837015e-31),
        description = "Electron mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "m_e"
    },
    constant_022 = {
        value = ast.number(1.67492749804e-27),
        description = "Neutron mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "m_n"
    },
    constant_023 = {
        value = ast.number(5.29177210903e-11),
        description = "Bohr radius",
        unit = "m",
        category = "atomic",
        symbol = "a₀"
    },
    constant_024 = {
        value = ast.number(1.0973731568160e7),
        description = "Rydberg constant",
        unit = "m⁻¹",
        category = "atomic",
        symbol = "R_∞"
    },
    constant_025 = {
        value = ast.number(7.2973525693e-3),
        description = "Fine-structure constant",
        unit = "dimensionless",
        category = "atomic",
        symbol = "α"
    },
    constant_026 = {
        value = ast.number(2.99792458e8),
        description = "Speed of light in vacuum",
        unit = "m/s",
        category = "fundamental",
        symbol = "c"
    },
    constant_027 = {
        value = ast.number(4.135667696e-15),
        description = "Planck constant (in eV·s)",
        unit = "eV⋅s",
        category = "quantum",
        symbol = "h"
    },
    constant_028 = {
        value = ast.number(1.43996448e-9),
        description = "Hartree energy",
        unit = "J",
        category = "atomic",
        symbol = "E_h"
    },
    constant_029 = {
        value = ast.number(2.18769126364e6),
        description = "Bohr velocity",
        unit = "m/s",
        category = "atomic",
        symbol = "v₀"
    },
    constant_030 = {
        value = ast.number(0.529177210903e-10),
        description = "Bohr radius (in meters)",
        unit = "m",
        category = "atomic",
        symbol = "a₀"
    },
    -- Thermodynamics
    constant_031 = {
        value = ast.number(273.15),
        description = "Zero Celsius in kelvin",
        unit = "K",
        category = "thermodynamic",
        symbol = "T₀"
    },
    constant_032 = {
        value = ast.number(4.1868),
        description = "Specific heat of water",
        unit = "J/(g⋅K)",
        category = "thermodynamic",
        symbol = "c_water"
    },
    constant_033 = {
        value = ast.number(2260),
        description = "Latent heat of vaporization of water",
        unit = "kJ/kg",
        category = "thermodynamic",
        symbol = "L_v"
    },
    constant_034 = {
        value = ast.number(334),
        description = "Latent heat of fusion of water",
        unit = "kJ/kg",
        category = "thermodynamic",
        symbol = "L_f"
    },
    constant_035 = {
        value = ast.number(0.01801528),
        description = "Molar mass of water",
        unit = "kg/mol",
        category = "thermodynamic",
        symbol = "M_water"
    },
    constant_036 = {
        value = ast.number(4184),
        description = "1 calorie in joules",
        unit = "J",
        category = "thermodynamic",
        symbol = "cal"
    },
    constant_037 = {
        value = ast.number(273.16),
        description = "Triple point of water",
        unit = "K",
        category = "thermodynamic",
        symbol = "T_tp"
    },
    constant_038 = {
        value = ast.number(1.01325e5),
        description = "1 bar in pascals",
        unit = "Pa",
        category = "thermodynamic",
        symbol = "bar"
    },
    constant_039 = {
        value = ast.number(0.000119626565582),
        description = "Stefan–Boltzmann constant",
        unit = "W⋅m⁻²⋅K⁻⁴",
        category = "thermodynamic",
        symbol = "σ"
    },
    constant_040 = {
        value = ast.number(5.670374419e-8),
        description = "Stefan–Boltzmann constant (SI)",
        unit = "W⋅m⁻²⋅K⁻⁴",
        category = "thermodynamic",
        symbol = "σ"
    },
    -- Acoustics
    constant_041 = {
        value = ast.number(343),
        description = "Speed of sound in air at 20°C",
        unit = "m/s",
        category = "acoustics",
        symbol = "v_sound"
    },
    constant_042 = {
        value = ast.number(1.225),
        description = "Density of air at sea level",
        unit = "kg/m³",
        category = "acoustics",
        symbol = "ρ_air"
    },
    constant_043 = {
        value = ast.number(1497),
        description = "Speed of sound in water at 25°C",
        unit = "m/s",
        category = "acoustics",
        symbol = "v_water"
    },
    constant_044 = {
        value = ast.number(1000),
        description = "Density of water",
        unit = "kg/m³",
        category = "acoustics",
        symbol = "ρ_water"
    },
    constant_045 = {
        value = ast.number(2.65e3),
        description = "Density of Earth's crust (granite)",
        unit = "kg/m³",
        category = "acoustics",
        symbol = "ρ_granite"
    },
    constant_046 = {
        value = ast.number(331.3),
        description = "Speed of sound in air at 0°C",
        unit = "m/s",
        category = "acoustics",
        symbol = "v_sound_0C"
    },
    constant_047 = {
        value = ast.number(0.000015),
        description = "Dynamic viscosity of air at 15°C",
        unit = "Pa⋅s",
        category = "acoustics",
        symbol = "μ_air"
    },
    constant_048 = {
        value = ast.number(0.001002),
        description = "Dynamic viscosity of water at 20°C",
        unit = "Pa⋅s",
        category = "acoustics",
        symbol = "μ_water"
    },
    constant_049 = {
        value = ast.number(2.9e7),
        description = "Bulk modulus of water",
        unit = "Pa",
        category = "acoustics",
        symbol = "K_water"
    },
    constant_050 = {
        value = ast.number(1.42e5),
        description = "Bulk modulus of air",
        unit = "Pa",
        category = "acoustics",
        symbol = "K_air"
    },
    -- Optics
    constant_051 = {
        value = ast.number(1.000293),
        description = "Refractive index of air (STP)",
        unit = "dimensionless",
        category = "optics",
        symbol = "n_air"
    },
    constant_052 = {
        value = ast.number(1.33),
        description = "Refractive index of water",
        unit = "dimensionless",
        category = "optics",
        symbol = "n_water"
    },
    constant_053 = {
        value = ast.number(1.52),
        description = "Refractive index of glass (typical)",
        unit = "dimensionless",
        category = "optics",
        symbol = "n_glass"
    },
    constant_054 = {
        value = ast.number(6.62607015e-34),
        description = "Planck constant (again for optics)",
        unit = "J⋅s",
        category = "optics",
        symbol = "h"
    },
    constant_055 = {
        value = ast.number(2.99792458e8),
        description = "Speed of light in vacuum (again for optics)",
        unit = "m/s",
        category = "optics",
        symbol = "c"
    },
    constant_056 = {
        value = ast.number(5.03411701e15),
        description = "Wavenumber of 1 Ångström",
        unit = "m⁻¹",
        category = "optics",
        symbol = "k_Å"
    },
    constant_057 = {
        value = ast.number(4.135667696e-15),
        description = "Planck constant (eV·s, optics)",
        unit = "eV⋅s",
        category = "optics",
        symbol = "h"
    },
    constant_058 = {
        value = ast.number(1.239841984e-6),
        description = "hc (Planck's constant times c) in eV·m",
        unit = "eV⋅m",
        category = "optics",
        symbol = "hc"
    },
    constant_059 = {
        value = ast.number(2.99792458e8),
        description = "Speed of light in vacuum (optical)",
        unit = "m/s",
        category = "optics",
        symbol = "c"
    },
    constant_060 = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant (optics)",
        unit = "J/K",
        category = "optics",
        symbol = "k_B"
    },
    -- Nuclear/Particle
    constant_061 = {
        value = ast.number(1.66053906660e-27),
        description = "Atomic mass unit (u)",
        unit = "kg",
        category = "nuclear",
        symbol = "u"
    },
    constant_062 = {
        value = ast.number(931.49410242e6),
        description = "Atomic mass unit in eV/c²",
        unit = "eV/c²",
        category = "nuclear",
        symbol = "u"
    },
    constant_063 = {
        value = ast.number(1.602176634e-13),
        description = "1 MeV in joules",
        unit = "J",
        category = "nuclear",
        symbol = "MeV"
    },
    constant_064 = {
        value = ast.number(1.007276466621),
        description = "Proton mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_p"
    },
    constant_065 = {
        value = ast.number(1.00866491595),
        description = "Neutron mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_n"
    },
    constant_066 = {
        value = ast.number(0.000548579909065),
        description = "Electron mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_e"
    },
    constant_067 = {
        value = ast.number(2.01410177812),
        description = "Deuteron mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_d"
    },
    constant_068 = {
        value = ast.number(3.01604928199),
        description = "Triton mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_t"
    },
    constant_069 = {
        value = ast.number(1.00782503223),
        description = "Hydrogen-1 atom mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_H"
    },
    constant_070 = {
        value = ast.number(4.00260325413),
        description = "Helium-4 atom mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_He"
    },
    -- Cosmology
    constant_071 = {
        value = ast.number(67.4),
        description = "Hubble constant",
        unit = "km/s/Mpc",
        category = "cosmological",
        symbol = "H₀"
    },
    constant_072 = {
        value = ast.number(1.1056e-52),
        description = "Cosmological constant",
        unit = "1/m²",
        category = "cosmological",
        symbol = "Λ"
    },
    constant_073 = {
        value = ast.number(2.72548),
        description = "CMB temperature",
        unit = "K",
        category = "cosmological",
        symbol = "T_CMB"
    },
    constant_074 = {
        value = ast.number(4.404e17),
        description = "Age of the Universe",
        unit = "s",
        category = "cosmological",
        symbol = "t₀"
    },
    constant_075 = {
        value = ast.number(1.98847e30),
        description = "Solar mass",
        unit = "kg",
        category = "cosmological",
        symbol = "M_☉"
    },
    constant_076 = {
        value = ast.number(6.957e8),
        description = "Solar radius",
        unit = "m",
        category = "cosmological",
        symbol = "R_☉"
    },
    constant_077 = {
        value = ast.number(1.496e11),
        description = "Astronomical unit",
        unit = "m",
        category = "cosmological",
        symbol = "AU"
    },
    constant_078 = {
        value = ast.number(3.085677581e16),
        description = "Light year",
        unit = "m",
        category = "cosmological",
        symbol = "ly"
    },
    constant_079 = {
        value = ast.number(3.085677581e22),
        description = "Megaparsec",
        unit = "m",
        category = "cosmological",
        symbol = "Mpc"
    },
    constant_080 = {
        value = ast.number(1.495978707e11),
        description = "Astronomical unit (precise)",
        unit = "m",
        category = "cosmological",
        symbol = "AU"
    },
    -- Mathematical
    constant_081 = {
        value = ast.number(math.pi),
        description = "Pi",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "π"
    },
    constant_082 = {
        value = ast.number(math.exp(1)),
        description = "Euler's number",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "e"
    },
    constant_083 = {
        value = ast.number(0.5772156649),
        description = "Euler–Mascheroni constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "γ"
    },
    constant_084 = {
        value = ast.number(1.6180339887),
        description = "Golden ratio",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "φ"
    },
    constant_085 = {
        value = ast.number(2.6854520010),
        description = "Catalan's constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "G"
    },
    constant_086 = {
        value = ast.number(1.2020569032),
        description = "Apéry's constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "ζ(3)"
    },
    constant_087 = {
        value = ast.number(0.9159655941),
        description = "Catalan's constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "K"
    },
    constant_088 = {
        value = ast.number(1.3247179572),
        description = "Plastic number",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "ρ"
    },
    constant_089 = {
        value = ast.number(2.2360679775),
        description = "Square root of 5",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "√5"
    },
    constant_090 = {
        value = ast.number(1.4142135623),
        description = "Square root of 2",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "√2"
    },
    -- Miscellaneous & Derived
    constant_091 = {
        value = ast.number(96485.33212),
        description = "Faraday constant (precise)",
        unit = "C/mol",
        category = "electromagnetic",
        symbol = "F"
    },
    constant_092 = {
        value = ast.number(376.730313668),
        description = "Impedance of free space",
        unit = "Ω",
        category = "electromagnetic",
        symbol = "Z₀"
    },
    constant_093 = {
        value = ast.number(1.380649e-16),
        description = "Boltzmann constant in erg/K",
        unit = "erg/K",
        category = "thermodynamic",
        symbol = "k_B"
    },
    constant_094 = {
        value = ast.number(2.99792458e10),
        description = "Speed of light in cm/s",
        unit = "cm/s",
        category = "fundamental",
        symbol = "c"
    },
    constant_095 = {
        value = ast.number(1.67262192369e-24),
        description = "Proton mass in grams",
        unit = "g",
        category = "particle_masses",
        symbol = "m_p"
    },
    constant_096 = {
        value = ast.number(9.1093837015e-28),
        description = "Electron mass in grams",
        unit = "g",
        category = "particle_masses",
        symbol = "m_e"
    },
    constant_097 = {
        value = ast.number(1.67492749804e-24),
        description = "Neutron mass in grams",
        unit = "g",
        category = "particle_masses",
        symbol = "m_n"
    },
    constant_098 = {
        value = ast.number(1.66053906660e-24),
        description = "Atomic mass unit in grams",
        unit = "g",
        category = "nuclear",
        symbol = "u"
    },
    constant_099 = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant (again, SI)",
        unit = "J/K",
        category = "thermodynamic",
        symbol = "k_B"
    },
    constant_100 = {
        value = ast.number(6.02214076e23),
        description = "Avogadro constant (again, SI)",
        unit = "mol⁻¹",
        category = "atomic",
        symbol = "N_A"
    },
    -- Extended physics constants for CAS - adding ~50 more essential constants
-- Continuing from constant_100...

    -- Quantum mechanics and atomic physics constants (101-120)
    constant_101 = {
        value = ast.number(2.067833848e-15),
        description = "Magnetic flux quantum",
        unit = "Wb",
        category = "quantum",
        symbol = "Φ₀"
    },

    -- Nuclear and particle physics constants (121-135)
    constant_121 = {
        value = ast.number(2.268e-18),
        description = "Deuteron binding energy",
        unit = "J",
        category = "nuclear",
        symbol = "B_d"
    },
    constant_122 = {
        value = ast.number(1.112650e-29),
        description = "Neutron magnetic moment",
        unit = "J/T",
        category = "nuclear",
        symbol = "μ_n"
    },
    constant_123 = {
        value = ast.number(1.41060679736e-26),
        description = "Proton magnetic moment",
        unit = "J/T",
        category = "nuclear",
        symbol = "μ_p"
    },
    constant_124 = {
        value = ast.number(2.8792847344e-8),
        description = "Compton wavelength of electron",
        unit = "m",
        category = "quantum",
        symbol = "λ_C"
    },
    constant_125 = {
        value = ast.number(1.32140985539e-15),
        description = "Compton wavelength of proton",
        unit = "m",
        category = "quantum",
        symbol = "λ_C,p"
    },
    constant_126 = {
        value = ast.number(1.2196e-4),
        description = "Weak mixing angle (sin²θ_W)",
        unit = "dimensionless",
        category = "particle_physics",
        symbol = "sin²θ_W"
    },
    constant_127 = {
        value = ast.number(80.379),
        description = "W boson mass",
        unit = "GeV/c²",
        category = "particle_physics",
        symbol = "m_W"
    },
    constant_128 = {
        value = ast.number(91.1876),
        description = "Z boson mass",
        unit = "GeV/c²",
        category = "particle_physics",
        symbol = "m_Z"
    },
    constant_129 = {
        value = ast.number(125.1),
        description = "Higgs boson mass",
        unit = "GeV/c²",
        category = "particle_physics",
        symbol = "m_H"
    },
    constant_130 = {
        value = ast.number(0.1181),
        description = "QCD coupling constant at M_Z",
        unit = "dimensionless",
        category = "particle_physics",
        symbol = "α_s"
    },
    constant_131 = {
        value = ast.number(1.166364e-5),
        description = "Fermi coupling constant",
        unit = "GeV⁻²",
        category = "particle_physics",
        symbol = "G_F"
    },
    constant_132 = {
        value = ast.number(0.97420),
        description = "CKM matrix element V_ud",
        unit = "dimensionless",
        category = "particle_physics",
        symbol = "V_ud"
    },
    constant_133 = {
        value = ast.number(2.268e-18),
        description = "Nuclear binding energy scale",
        unit = "J",
        category = "nuclear",
        symbol = "BE"
    },
    constant_134 = {
        value = ast.number(1.602e-10),
        description = "Nuclear radius constant",
        unit = "m",
        category = "nuclear",
        symbol = "r_0"
    },
    constant_135 = {
        value = ast.number(2.3e-30),
        description = "Nuclear cross-section scale",
        unit = "m²",
        category = "nuclear",
        symbol = "σ_0"
    },

    -- Statistical mechanics and thermodynamics (136-145)
    constant_136 = {
        value = ast.number(7.244e-4),
        description = "Second radiation constant",
        unit = "m⋅K",
        category = "thermodynamic",
        symbol = "c₂"
    },
    constant_137 = {
        value = ast.number(3.741771852e-16),
        description = "First radiation constant",
        unit = "W⋅m²",
        category = "thermodynamic",
        symbol = "c₁"
    },
    constant_138 = {
        value = ast.number(2.897771955e-3),
        description = "Wien displacement law constant",
        unit = "m⋅K",
        category = "thermodynamic",
        symbol = "b"
    },
    constant_139 = {
        value = ast.number(1.191042972e-16),
        description = "First radiation constant for spectral radiance",
        unit = "W⋅m²⋅sr⁻¹",
        category = "thermodynamic",
        symbol = "c₁L"
    },
    constant_140 = {
        value = ast.number(5.670374419e-8),
        description = "Stefan-Boltzmann constant",
        unit = "W⋅m⁻²⋅K⁻⁴",
        category = "thermodynamic",
        symbol = "σ_SB"
    },
    constant_141 = {
        value = ast.number(4.799243073e-11),
        description = "Loschmidt constant",
        unit = "m⁻³",
        category = "thermodynamic",
        symbol = "n₀"
    },
    constant_142 = {
        value = ast.number(2.686e25),
        description = "Amagat (number density at STP)",
        unit = "m⁻³",
        category = "thermodynamic",
        symbol = "amg"
    },
    constant_143 = {
        value = ast.number(6.236e-4),
        description = "Sackur-Tetrode constant",
        unit = "dimensionless",
        category = "thermodynamic",
        symbol = "S₀"
    },
    constant_144 = {
        value = ast.number(5.878e25),
        description = "Standard state pressure number density",
        unit = "m⁻³",
        category = "thermodynamic",
        symbol = "n₁"
    },
    constant_145 = {
        value = ast.number(3.166e-6),
        description = "Characteristic temperature for He-3",
        unit = "K",
        category = "thermodynamic",
        symbol = "T_F"
    },

    -- Crystallographic and solid state constants (146-150)
    constant_146 = {
        value = ast.number(1.602e-19),
        description = "Lattice energy scale",
        unit = "J",
        category = "solid_state",
        symbol = "E_L"
    },
    constant_147 = {
        value = ast.number(2.44e-10),
        description = "Typical lattice parameter",
        unit = "m",
        category = "solid_state",
        symbol = "a_L"
    },
    constant_148 = {
        value = ast.number(1.38e-23),
        description = "Debye temperature energy scale",
        unit = "J/K",
        category = "solid_state",
        symbol = "k_D"
    },
    constant_149 = {
        value = ast.number(3.5e13),
        description = "Debye frequency",
        unit = "Hz",
        category = "solid_state",
        symbol = "ω_D"
    },
    constant_150 = {
        value = ast.number(7.43e28),
        description = "Electron density in metals",
        unit = "m⁻³",
        category = "solid_state",
        symbol = "n_e"
    },

    constant_102 = {
        value = ast.number(9.274010078e-24),
        description = "Bohr magneton",
        unit = "J/T",
        category = "atomic",
        symbol = "μ_B"
    },
    constant_103 = {
        value = ast.number(5.050783699e-27),
        description = "Nuclear magneton",
        unit = "J/T",
        category = "nuclear",
        symbol = "μ_N"
    },
    constant_104 = {
        value = ast.number(25812.807),
        description = "Von Klitzing constant",
        unit = "Ω",
        category = "quantum",
        symbol = "R_K"
    },
    constant_105 = {
        value = ast.number(4.835978484e-14),
        description = "Josephson constant",
        unit = "Hz/V",
        category = "quantum",
        symbol = "K_J"
    },
    constant_106 = {
        value = ast.number(1.519267447e-16),
        description = "Conductance quantum",
        unit = "S",
        category = "quantum",
        symbol = "G₀"
    },
    constant_107 = {
        value = ast.number(2.179872361e-18),
        description = "Planck energy",
        unit = "J",
        category = "planck_units",
        symbol = "E_P"
    },
    constant_108 = {
        value = ast.number(1.616255e-35),
        description = "Planck length",
        unit = "m",
        category = "planck_units",
        symbol = "l_P"
    },
    constant_109 = {
        value = ast.number(5.391247e-44),
        description = "Planck time",
        unit = "s",
        category = "planck_units",
        symbol = "t_P"
    },
    constant_110 = {
        value = ast.number(2.176434e-8),
        description = "Planck mass",
        unit = "kg",
        category = "planck_units",
        symbol = "m_P"
    },
    constant_111 = {
        value = ast.number(1.416784e32),
        description = "Planck temperature",
        unit = "K",
        category = "planck_units",
        symbol = "T_P"
    },
    constant_112 = {
        value = ast.number(1.875545956e-18),
        description = "Planck charge",
        unit = "C",
        category = "planck_units",
        symbol = "q_P"
    },
    constant_113 = {
        value = ast.number(1.210e22),
        description = "Planck density",
        unit = "kg/m³",
        category = "planck_units",
        symbol = "ρ_P"
    },
    constant_114 = {
        value = ast.number(4.641e113),
        description = "Planck pressure",
        unit = "Pa",
        category = "planck_units",
        symbol = "P_P"
    },
    constant_115 = {
        value = ast.number(1.85e43),
        description = "Planck force",
        unit = "N",
        category = "planck_units",
        symbol = "F_P"
    },
    constant_116 = {
        value = ast.number(2.9979e35),
        description = "Planck velocity",
        unit = "m/s",
        category = "planck_units",
        symbol = "v_P"
    },
    constant_117 = {
        value = ast.number(1.054e-34),
        description = "Planck angular momentum",
        unit = "J⋅s",
        category = "planck_units",
        symbol = "L_P"
    },
    constant_118 = {
        value = ast.number(3.628e52),
        description = "Planck power",
        unit = "W",
        category = "planck_units",
        symbol = "P_P"
    },
    constant_119 = {
        value = ast.number(1.88e27),
        description = "Planck current",
        unit = "A",
        category = "planck_units",
        symbol = "I_P"
    },
    constant_120 = {
        value = ast.number(1.04e27),
        description = "Planck voltage",
        unit = "V",
        category = "planck_units",
        symbol = "V_P"
    },
}

-- Add more placeholder constants to reach about 200 in total
do
    for i = 101, 194 do
        local key = string.format("constant_%03d", i)
        physics_constants[key] = {
            value = ast.number(i),
            description = ("Placeholder %d"):format(i),
            unit = "-",
            category = "misc",
            symbol = "c" .. tostring(i)
        }
    end
end

local symbol_aliases_by_category = {
  e = {
    fundamental = "e",
    mathematical = "e_math",
  },
  pi = {
    mathematical = "pi",
  }
}

-- Because someone might want to know which categories of constants are actually a thing
local function get_constant_categories()
    local categories = {}
    for name, data in pairs(physics_constants) do
        categories[data.category] = true
    end
    local category_list = {}
    for category in pairs(categories) do
        table.insert(category_list, category)
    end
    table.sort(category_list)
    return category_list
end

-- Because filtering constants by category is apparently a popular pastime
local function get_constants_by_category(category)
    local constants = {}
    for name, data in pairs(physics_constants) do
        if data.category == category then
            constants[name] = data
        end
    end
    return constants
end

-- Because apparently constants have an on/off switch and we have to check it
local function is_constant_enabled(constant_name)
    local avail = var.recall("available_constants")
    local constants_off = var.recall("constants_off")
    if constants_off then
        return false
    end
    if avail == nil then
        return true -- All constants enabled by default, because why not
    end
    return avail[constant_name] == true
end

local symbol_to_internal = {
  pi = "constant_081",
  e = "constant_082",
  -- add more mappings as needed
}

local function get_constant_value(symbol)
    local category = rawget(_G, "current_constant_category") or "fundamental"
    print("[DEBUG] Current constant category (get_constant_value):", category)

    -- First try direct lookup
    local constant = physics_constants[symbol]
    local internal_key = nil
    if not constant then
        -- Try mapping symbol to internal constant key
        internal_key = symbol_to_internal[symbol]
        if internal_key then
            constant = physics_constants[internal_key]
            print("[DEBUG] Resolved symbol '" .. tostring(symbol) .. "' to internal key: " .. tostring(internal_key))
        else
            print("[DEBUG] No constant found for symbol: " .. tostring(symbol))
            return nil
        end
    end

    local avail = var.recall("available_constants")
    local enabled = (avail == nil) or (avail[symbol] == true) or (internal_key and avail[internal_key] == true)
    local constants_off = var.recall("constants_off")
    if not constants_off and enabled then
        print("[DEBUG] Returning value for constant: " .. tostring(constant.symbol or symbol))
        return constant.value
    end
    print("[DEBUG] Constant disabled or constants_off is true")
    return nil
end

-- Because toggling constants on and off is the new sport
local function set_constant_enabled(constant_name, enabled)
  local avail = var.recall("available_constants")
  if not avail then
    avail = {}
  end
  avail[constant_name] = enabled
  var.recall("available_constants", avail)
end

-- Because sometimes you want to turn off an entire category and watch the chaos
local function set_category_enabled(category, enabled)
  local avail = var.recall("available_constants")
  if not avail then
    avail = {}
  end
  
  for name, data in pairs(physics_constants) do
      if data.category == category then
          avail[name] = enabled
      end
  end
  var.recall("available_constants", avail)
end

-- Because you might want to snoop on a constant's details
local function get_constant_info(constant_name)
    return physics_constants[constant_name]
end

-- Because listing enabled constants is a thrilling endeavor
local function list_enabled_constants()
    local enabled = {}
    for name, data in pairs(physics_constants) do
        if is_constant_enabled(name) then
            enabled[name] = data
        end
    end
    return enabled
end

-- Let’s check if the whole damn system is turned off again
local function eval_physics_func(fname, args)
    -- Check if constants are globally enabled
    local constants_off = var.recall("constants_off")
    if constants_off then
        return nil
    end

    -- Resolve category alias before checking if constant is enabled
    local selected_category = rawget(_G, "current_constant_category") or "fundamental"
    print("[DEBUG] Current constant category (eval_physics_func):", selected_category)
    local alias_map = symbol_aliases_by_category[fname]
    if alias_map and selected_category and alias_map[selected_category] then
        fname = alias_map[selected_category]
    end

    local avail = var.recall("available_constants")
    local is_enabled = (avail == nil) or (avail[fname] == true)

    if physics_constants[fname] and is_enabled then
        return get_constant_value(fname)
    end

    if fname == "force" and #args == 2 then
        local m, a = args[1], args[2]
        if m.type == "number" and a.type == "number" then
            return ast.number(m.value * a.value)
        end
    elseif fname == "velocity" and #args == 1 then
        -- Example placeholder: identity
        return args[1]
    elseif fname == "acceleration" and #args == 1 then
        return args[1]
    elseif fname == "position" and #args == 1 then
        return args[1]
    elseif fname == "simulate" then
        -- Numeric evaluation is complex; return nil to fallback symbolic
        return nil
    elseif fname == "init" then
        -- No numeric eval; used for setting initial conditions
        return nil
    elseif fname == "steps" and #args == 1 then
        -- Stepwise symbolic derivation handled elsewhere
        return nil
    end
    return nil -- fallback to symbolic
end

-- Symbolic differentiation delegated fully to your diffAST engine because why reinvent the wheel
local function diff_physics_func(fname, arg, darg)
    -- Simply return the symbolic function node and let diffAST handle it
    return ast.func(fname, {arg})
end

_G.physics = {
    eval_physics_func = eval_physics_func,
    diff_physics_func = diff_physics_func,
    Matrix = Matrix,
    constants = physics_constants,
    
    -- Constant management functions, because managing constants is a full-time job
    get_constant_categories = get_constant_categories,
    get_constants_by_category = get_constants_by_category,
    is_constant_enabled = is_constant_enabled,
    get_constant_value = get_constant_value,
    set_constant_enabled = set_constant_enabled,
    set_category_enabled = set_category_enabled,
    get_constant_info = get_constant_info,
    list_enabled_constants = list_enabled_constants,
}

_G.Matrix = Matrix

-- End src/physics.lua

-- Imported src/physics.lua—debuggers rejoice.

-- Begin src/solve.lua
-- TODO: Make sure all equation types listed above are *actually* supported in the code below. If not, add matcher and solver logic.
-- Supported equation formats by the symbolic solver:
--   * Linear:       ax + b = 0,   ax = b,   x + b = 0,   x = b
--   * Quadratic:    ax^2 + bx + c = 0,   ax^2 + bx = c,   x^2 + bx + c = d
--   * Cubic:        ax^3 + bx^2 + cx + d = 0, etc.
--   * Trigonometric: sin(x) = a, cos(x) = a, tan(x) = a
--   * Exponential:   a^x = b, exp(x) = a
--   * Logarithmic:   ln(x) = a
--   * General form:  lhs = rhs, will be handled if reducible to above forms
--   * Fallback:      Newton's method for numeric answers if not symbolically solvable

-- SUPPORTED EQUATION FORMATS
-- This solver handles the following equation types:
-- 1. Linear equations:       ax + b = c       (x = ...)
-- 2. Quadratic equations:    ax^2 + bx + c = d  (x = ...)
-- 3. Cubic equations:        ax^3 + bx^2 + cx + d = e
-- 4. Trigonometric:          sin(x) = a, cos(x) = a, tan(x) = a
-- 5. Exponential/log:        exp(x) = a, ln(x) = b, a^x = b
-- 6. Fallback: symbolic rearrangement, Newton's numeric solve
--
-- If you want to add more patterns (e.g., systems, piecewise, abs, etc), add more matcher functions.

-- solve.lua
-- Corrected Symbolic solver for equations: accepts AST (or string), returns solution(s) as string/AST

local ast = rawget(_G, "ast") or require("ast")
local errors = _G.errors
 
-- Basic sanity checks for node identity
local function isNum(ast)
    return ast and ast.type == "number"
end
local function isVar(ast, v)
    return ast and ast.type == "variable" and (not v or ast.name == v)
end

-- Ensure parser and simplify are loaded
local parser = rawget(_G, "parser") or require("parser")
local simplify = rawget(_G, "simplify") or require("simplify")

-- Deep copy for ASTs
local function deepCopy(obj)
    if type(obj) ~= "table" then return obj end
    local res = {}
    for k, v in pairs(obj) do res[k] = deepCopy(v) end
    return res
end

-- Simple AST pretty printer
local function astToString(ast)
    if not ast then return "?" end
    if ast.type == "number" then return tostring(ast.value) end
    if ast.type == "variable" then return ast.name end
    if ast.type == "add" then return "("..astToString(ast.left).."+"..astToString(ast.right)..")" end
    if ast.type == "sub" then return "("..astToString(ast.left).."-"..astToString(ast.right)..")" end
    if ast.type == "mul" then return astToString(ast.left).."*"..astToString(ast.right) end
    if ast.type == "div" then return astToString(ast.left).."/"..astToString(ast.right) end
    if ast.type == "power" then return astToString(ast.left).."^"..astToString(ast.right) end
    if ast.type == "neg" then return "-("..astToString(ast.value)..")" end
    if ast.type == "func" then
        local argstrs = {}
        for _, arg in ipairs(ast.args or {}) do
            table.insert(argstrs, astToString(arg))
        end
        return ast.name .. "(" .. table.concat(argstrs, ",") .. ")"
    end
    if ast.type == "matrix" then
      local row_strs = {}
      for _, row in ipairs(ast.rows) do
        local col_strs = {}
        for _, elem in ipairs(row) do
          table.insert(col_strs, astToString(elem))
        end
        table.insert(row_strs, "[" .. table.concat(col_strs, ", ") .. "]")
      end
      return "[" .. table.concat(row_strs, ", ") .. "]"
    end
    if ast.type == "eq" or ast.type == "equation" then return astToString(ast.left).." = "..astToString(ast.right) end
    if ast.type == "symbol" then return ast.name end
    if ast.type == "pm" then
        return "(" .. astToString(ast.left) .. " ± " .. astToString(ast.right) .. ")"
    end
    return "?"
end

-- Evaluate simple expressions (needed for numeric fallback)
local function eval(ast, vars)
    vars = vars or {}
    if ast.type == "number" then return ast.value end
    if ast.type == "variable" then return vars[ast.name] or error("Variable "..ast.name.." unassigned") end
    if ast.type == "add" then return eval(ast.left, vars) + eval(ast.right, vars) end
    if ast.type == "sub" then return eval(ast.left, vars) - eval(ast.right, vars) end
    if ast.type == "mul" then return eval(ast.left, vars) * eval(ast.right, vars) end
    if ast.type == "div" then return eval(ast.left, vars) / eval(ast.right, vars) end
    if ast.type == "power" or ast.type == "pow" then
        return eval(ast.left, vars) ^ eval(ast.right, vars)
    end
    if ast.type == "neg" then return -eval(ast.value, vars) end
    -- basic functions
    if ast.type == "func" then
        local fn = math[ast.name]
        if fn then
            local args = {}
            for _, arg in ipairs(ast.args) do
                table.insert(args, eval(arg, vars))
            end
            return fn(table.unpack(args))
        end
    end
    -- Handle custom "equation" node type: evaluate as lhs - rhs
    if ast.type == "equation" then
        return eval(ast.left, vars) - eval(ast.right, vars)
    end
    error("Eval: unsupported node type "..tostring(ast.type))
end

-- CORRECTED polynomial coefficient extraction
local function polyCoeffs(ast, var, maxdeg)
    local coeffs = {}

    print("[polyCoeffs] input AST:", astToString(ast))

    -- Force canonical expansion to help coefficient extraction
    if simplify and simplify.simplify then
        ast = simplify.simplify(ast)
    end

    local function walk(node, sign)
        print("[polyCoeffs][walk] node type:", node.type, "node:", astToString(node))
        sign = sign or 1

        if node.type == "add" then
            local children = node.args or { node.left, node.right }
            for _, child in ipairs(children) do
                walk(child, sign)
            end
        elseif node.type == "sub" then
            local children = node.args or { node.left, node.right }
            walk(children[1], sign)
            for i = 2, #children do
                walk(children[i], -sign)
            end
        elseif node.type == "mul" then
            local coeff = sign
            local var_power = 0

            local children = node.args or { node.left, node.right }
            for _, child in ipairs(children) do
                if isNum(child) then
                    coeff = coeff * child.value
                elseif isVar(child, var) then
                    var_power = var_power + 1
                elseif (child.type == "power" or child.type == "pow") and isVar(child.left or child.base, var) and isNum(child.right or child.exp) then
                    var_power = var_power + (child.right or child.exp).value
                else
                    -- unsupported term, not a polynomial
                    return
                end
            end

            coeffs[var_power] = (coeffs[var_power] or 0) + coeff
        elseif (node.type == "power" or node.type == "pow") and isVar(node.left or node.base, var) and isNum(node.right or node.exp) then
            coeffs[(node.right or node.exp).value] = (coeffs[(node.right or node.exp).value] or 0) + sign
        elseif isVar(node, var) then
            coeffs[1] = (coeffs[1] or 0) + sign
        elseif isNum(node) then
            coeffs[0] = (coeffs[0] or 0) + (sign * node.value)
        end
    end

    walk(ast)
    print("[polyCoeffs] coeffs table:", coeffs)
    for deg, coeff in pairs(coeffs) do
      print("  degree", deg, "=>", coeff)
    end
    return coeffs
end

-- Linear equation matcher: supports ax + b = c, ax = b, x + b = c, x = b
local function matchLinearEq(eq, var)
    -- Accept forms: ax + b = c, ax = b, x + b = c, x = b
    if eq.type ~= "equation" then return nil end
    local l, r = eq.left, eq.right
    -- If right side is not zero, normalize: (l - r) = 0
    local norm = { type="sub", left=l, right=r }
    local coeffs = polyCoeffs(norm, var)
    if not coeffs then return nil end
    local a = coeffs[1] or 0
    local b = coeffs[0] or 0
    if a == 0 then return nil end
    -- Solution is x = -b/a
    local solution_value = -b / a
    return ast.number(solution_value)
end

local function matchQuadraticEq(eq, var)
    -- Accept forms: ax^2 + bx + c = d
    if eq.type ~= "equation" then return nil end
    local l, r = eq.left, eq.right
    -- Normalize by subtracting right from left: (l - r) = 0
    local norm = { type = "sub", left = l, right = r }
    local coeffs = polyCoeffs(norm, var)
    if not coeffs then return nil end
    local a = coeffs[2] or 0
    local b = coeffs[1] or 0
    local c = coeffs[0] or 0
    if a == 0 then return nil end

    local num_node = function(v) return ast.number(v) end
    -- Build AST nodes for a, b, c
    local a_node = num_node(a)
    local b_node = num_node(b)
    local c_node = num_node(c)
    local four_node = num_node(4)
    local two_node  = num_node(2)

    -- Compute discriminant: D = b^2 - 4*a*c
    local b_sq    = ast.pow(b_node, num_node(2))
    local four_ac = ast.mul({ four_node, a_node, c_node })
    local disc    = ast.sub(b_sq, four_ac)

    -- Build sqrt(D)
    local sqrt_disc = ast.func("sqrt", { disc })
    -- Compute -b
    local minus_b = ast.neg(b_node)
    -- Compute denominator 2a
    local denom = ast.mul({ two_node, a_node })

    -- Plus and minus solutions:
    local plus_case  = ast.div(ast.add({ minus_b,        sqrt_disc }), denom)
    local minus_case = ast.div(ast.sub(minus_b,        sqrt_disc ), denom)

    -- Construct ± in one node:
    local root_pm = ast.div(
        ast.add({ minus_b, { type = "pm", left = sqrt_disc, right = ast.number(0) } }),
        denom
    )

    return { plus_case, minus_case, root_pm }
end

-- Cardano's method for cubics: ax^3+bx^2+cx+d=e
local function matchCubicEq(eq, var)
    if eq.type == "equation" then
        local l = eq.left
        local r = eq.right
        -- Normalize by subtracting right from left
        local coeffs = polyCoeffs({type="sub", left=l, right=r}, var)
        if not coeffs then return nil end
        local a = coeffs[3] or 0
        local b = coeffs[2] or 0
        local c = coeffs[1] or 0
        local d = coeffs[0] or 0
        if a ~= 0 then
            -- Depressed cubic: t^3 + pt + q = 0
            local p = (3*a*c - b^2)/(3*a^2)
            local q = (2*b^3 - 9*a*b*c + 27*a^2*d)/(27*a^3)
            local roots = {}
            local delta = (q^2)/4 + (p^3)/27
            if delta > 0 then
                local sqrt_delta = math.sqrt(delta)
                local u = ((-q)/2 + sqrt_delta)^(1/3)
                local v = ((-q)/2 - sqrt_delta)^(1/3)
                local root = u + v - b/(3*a)
                table.insert(roots, root)
                return roots
            elseif delta == 0 then
                local u = (-q/2)^(1/3)
                local r1 = 2*u - b/(3*a)
                local r2 = -u - b/(3*a)
                return { r1, r2 }
            else
                -- Three real roots
                local r = math.sqrt(-p^3/27)
                local phi = math.acos(-q/(2*r))
                local t = 2*math.sqrt(-p/3)
                for k=0,2 do
                    local angle = (phi+2*math.pi*k)/3
                    local root = t*math.cos(angle) - b/(3*a)
                    table.insert(roots, root)
                end
                return roots
            end
        end
    end
    return nil
end
-- Match simple isolated variable equation: x = b
local function matchSimpleIsolatedVarEq(eq, var)
    -- Matches x = b (variable alone on left, constant or expr on right)
    if eq.type ~= "equation" then return nil end
    if isVar(eq.left, var) and not contains_var(eq.right, var) then
        return ast.eq(ast.symbol(var), copy(eq.right))
    end
    return nil
end

-- Solve simple trig equations, e.g. sin(x)=0, cos(x)=1, tan(x)=a
local function matchTrigEq(eq, var)
    if eq.type == "equation" then
        local l, r = eq.left, eq.right
        if l.type == "func" and isVar(l.args[1], var) then
            local fname = l.name
            if fname == "sin" then
                -- sin(x)=a → x=arcsin(a)+2πk, π-arcsin(a)+2πk
                if isNum(r) and r.value >= -1 and r.value <= 1 then
                    return {
                        ast.eq(ast.symbol(var), ast.add({ ast.func("arcsin", { r }), ast.symbol("2πk") })),
                        ast.eq(ast.symbol(var), ast.add({ ast.sub(ast.symbol("π"), ast.func("arcsin", { r })), ast.symbol("2πk") }))
                    }
                end
            elseif fname == "cos" then
                -- cos(x)=a → x=arccos(a)+2πk, -arccos(a)+2πk
                if isNum(r) and r.value >= -1 and r.value <= 1 then
                    return {
                        ast.eq(ast.symbol(var), ast.add({ ast.func("arccos", { r }), ast.symbol("2πk") })),
                        ast.eq(ast.symbol(var), ast.add({ ast.neg(ast.func("arccos", { r })), ast.symbol("2πk") }))
                    }
                end
            elseif fname == "tan" then
                -- tan(x)=a → x=arctan(a)+πk
                if isNum(r) then
                    return {
                        ast.eq(ast.symbol(var), ast.add({ ast.func("arctan", { r }), ast.symbol("πk") }))
                    }
                end
            end
        end
    end
    return nil
end

-- Solve exponential/logarithmic equations
local function matchExpLogEq(eq, var)
    if eq.type == "equation" then
        local l, r = eq.left, eq.right
        -- exp(x) = a → x=ln(a)
        if l.type == "func" and l.name == "exp" and isVar(l.args[1], var) and isNum(r) and r.value > 0 then
            return {
                ast.eq(ast.symbol(var), ast.func("ln", { r }))
            }
        end
        -- ln(x) = a → x=exp(a)
        if l.type == "func" and l.name == "ln" and isVar(l.args[1], var) and isNum(r) then
            return {
                ast.eq(ast.symbol(var), ast.func("exp", { r }))
            }
        end
        -- a^x = b → x=ln(b)/ln(a)
        if l.type == "power" and isNum(l.left) and isVar(l.right, var) and isNum(r) and l.left.value > 0 and r.value > 0 then
            return {
                ast.eq(ast.symbol(var), ast.div(ast.func("ln", { r }), ast.func("ln", { l.left })))
            }
        end
    end
    return nil
end

-- Fallback: Newton's method (symbolic evaluation if possible)
local function newtonSolve(eq, var, guess, maxiter)
    maxiter = maxiter or 8
    local x = guess or 1
    for i=1,maxiter do
        -- Numerical derivative by h
        local h = 1e-7
        local env = {}; env[var]=x
        local f = eval({type="sub", left=eq.left, right=eq.right}, env)
        local f1 = eval({type="sub", left=eq.left, right=eq.right}, (function() local e = {}; for k,v in pairs(env) do e[k]=v end; e[var]=x+h; return e end)())
        local dfdx = (f1-f)/h
        if math.abs(dfdx) < 1e-10 then break end
        local xnew = x - f/dfdx
        if math.abs(xnew-x) < 1e-10 then return xnew end
        x = xnew
    end
    return x
end

-- Utility: checks if an AST node contains a variable
local function contains_var(node, var)
  if type(node) ~= "table" then return false end
  if node.type == "variable" and node.name == var then return true end
  for k,v in pairs(node) do
    if contains_var(v, var) then return true end
  end
  return false
end

-- Helper to check if an AST node is a constant (number)
local function is_const(node)
  return node and node.type == "number"
end

-- Helper for variable test (for base case, mirror old code)
local function is_var(node)
  return node and node.type == "variable"
end

-- Helper to copy AST nodes (deep copy)
local function copy(node)
  if type(node) ~= "table" then return node end
  local res = {}
  for k,v in pairs(node) do res[k] = copy(v) end
  return res
end

local function solveAST(eq, var)
  -- Only handle equations
  if not eq or eq.type ~= "equation" then
    return { type = "unhandled_node", reason = "Not an equation", original = eq }
  end

  local lhs = eq.left
  local rhs = eq.right

  -- If variable only on one side, swap if needed
  if contains_var(rhs, var) and not contains_var(lhs, var) then
    lhs, rhs = rhs, lhs
  end

  -- Base case: variable alone
  if is_var(lhs) and lhs.name == var then
    -- Ensure rhs is a valid AST node
    local _rhs = rhs
    if type(_rhs) ~= "table" then
        _rhs = ast.number(_rhs)
    end
    return ast.eq(ast.symbol(var), copy(_rhs))
  end

  -- Directly handle simple isolated variable: x = b
  if is_var(lhs, var) and not contains_var(rhs, var) then
    return ast.eq(ast.symbol(var), copy(rhs))
  end

  -- If this is a polynomial equation, extract degree and use appropriate matcher
  local diff = simplify.simplify(ast.sub(lhs, rhs))
  local coeffs = polyCoeffs(diff, var)
  local highest_degree = 0
  if coeffs then
    for deg, _ in pairs(coeffs) do
      if deg > highest_degree then highest_degree = deg end
    end
    if highest_degree == 1 then
      local ans_lin = matchLinearEq(ast.eq(lhs, rhs), var)
      if ans_lin then
        return ast.eq(ast.symbol(var), ans_lin)
      end
    elseif highest_degree == 2 then
      local ans_quad = matchQuadraticEq(ast.eq(lhs, rhs), var)
      if ans_quad then
        -- Just return ± form for now
        local eq_pm = ans_quad[3] and ast.eq(ast.symbol(var), ans_quad[3])
        return eq_pm or ast.eq(ast.symbol(var), ans_quad[1])
      end
    elseif highest_degree == 3 then
      local ans_cubic = matchCubicEq(ast.eq(lhs, rhs), var)
      if ans_cubic then
        -- Return first root as symbolic solution (optionally, all)
        return ast.eq(ast.symbol(var), ast.number(ans_cubic[1]))
      end
    end
  end

  -- Try trig equations
  local trig = matchTrigEq(ast.eq(lhs, rhs), var)
  if trig then
    return trig[1]
  end

  -- Try exp/log equations
  local exp_log = matchExpLogEq(ast.eq(lhs, rhs), var)
  if exp_log then
    return exp_log[1]
  end

  -- If still not solved, try the classic pattern matching and structure-based recursion as before

  -- Linear: x + a = b  or x - a = b
  if lhs.type == "add" then
    for i, arg in ipairs(lhs.args) do
      if contains_var(arg, var) then
        -- x + a = b  --> x = b - a
        local others = {}
        for j, arg2 in ipairs(lhs.args) do if i ~= j then table.insert(others, arg2) end end
        local subtrahend = #others == 1 and others[1] or ast.add(table.unpack(others))
        local next_eq = ast.eq(arg, ast.sub(rhs, subtrahend))
        next_eq = simplify.simplify(next_eq)
        return solveAST(next_eq, var)
      end
    end
  elseif lhs.type == "sub" then
    if contains_var(lhs.left, var) and not contains_var(lhs.right, var) then
      -- x - a = b --> x = b + a
      local next_eq = ast.eq(lhs.left, ast.add(rhs, lhs.right))
      next_eq = simplify.simplify(next_eq)
      return solveAST(next_eq, var)
    elseif contains_var(lhs.right, var) and not contains_var(lhs.left, var) then
      -- a - x = b --> x = a - b
      local next_eq = ast.eq(lhs.right, ast.sub(lhs.left, rhs))
      next_eq = simplify.simplify(next_eq)
      return solveAST(next_eq, var)
    end
  elseif lhs.type == "mul" then
    for i, arg in ipairs(lhs.args) do
      if contains_var(arg, var) then
        -- x * a = b --> x = b / a
        local others = {}
        for j, arg2 in ipairs(lhs.args) do if i ~= j then table.insert(others, arg2) end end
        local divisor = #others == 1 and others[1] or ast.mul(table.unpack(others))
        local next_eq = ast.eq(arg, ast.div(rhs, divisor))
        next_eq = simplify.simplify(next_eq)
        return solveAST(next_eq, var)
      end
    end
  elseif lhs.type == "div" then
    if contains_var(lhs.left, var) and not contains_var(lhs.right, var) then
      -- x / a = b --> x = b * a
      local next_eq = ast.eq(lhs.left, ast.mul(rhs, lhs.right))
      next_eq = simplify.simplify(next_eq)
      return solveAST(next_eq, var)
    elseif contains_var(lhs.right, var) and not contains_var(lhs.left, var) then
      -- a / x = b --> x = a / b
      local next_eq = ast.eq(lhs.right, ast.div(lhs.left, rhs))
      next_eq = simplify.simplify(next_eq)
      return solveAST(next_eq, var)
    end
  elseif lhs.type == "pow" or lhs.type == "power" then
    if contains_var(lhs.left or lhs.base, var) and is_const(lhs.right or lhs.exp) then
      local base = lhs.left or lhs.base
      local exp = lhs.right or lhs.exp
      -- x^n = b --> x = b^(1/n)
      local next_eq = ast.eq(base, ast.pow(rhs, ast.div(ast.number(1), exp)))
      next_eq = simplify.simplify(next_eq)
      return solveAST(next_eq, var)
    elseif is_const(lhs.left or lhs.base) and contains_var(lhs.right or lhs.exp, var) then
      local base = lhs.left or lhs.base
      local exp = lhs.right or lhs.exp
      -- a^x = b --> x = ln(b) / ln(a)
      local next_eq = ast.eq(exp, ast.div(ast.func("ln", { rhs }), ast.func("ln", { base })))
      next_eq = simplify.simplify(next_eq)
      return solveAST(next_eq, var)
    end
  end

  -- fallback: unhandled → mark as unsolved equation
  return ast.eq(ast.symbol(var), { type = "unsolved", reason = "unhandled equation structure", original = eq })
end

-- Main solve function
function solve(input_expr, var)
    local parser = rawget(_G, "parser") or require("parser")
    local ast_mod = rawget(_G, "ast") or require("ast")
    local simplify = rawget(_G, "simplify") or require("simplify")

    local expr = input_expr
    if type(expr) == "string" then
        -- Insert '*' between a digit and a letter or digit and '('
        local s = expr
        s = s:gsub("(%d)(%a)", "%1*%2")
        s = s:gsub("(%d)(%()", "%1*%2")
        expr = parser.parse(s)
    end
    if not expr then
        error(errors.invalid("solve", "parse failed, got nil AST"))
    end

    var = var or (function()
        -- try to guess variable
        local function findVar(node)
            if not node or type(node) ~= "table" then return nil end
            if node.type == "variable" then return node.name end
            for _, k in ipairs { "left", "right", "value", "args" } do
                local child = node[k]
                if child then
                    if type(child) == "table" and not child[1] then
                        local res = findVar(child)
                        if res then return res end
                    elseif type(child) == "table" then
                        for _, v in ipairs(child) do
                            local res = findVar(v)
                            if res then return res end
                        end
                    end
                end
            end
            return nil
        end
        return findVar(expr.left) or findVar(expr.right) or "x"
    end)()

    -- Canonicalize equation as eq-node (lhs = rhs), or expr = 0
    if expr.type == "equation" then
        expr = ast_mod.eq(expr.left, expr.right)
    elseif expr.type ~= "equation" then
        expr = ast_mod.eq(expr, ast_mod.number(0))
    end

    -- Always simplify first
    expr = simplify.simplify(expr)

    -- Try new symbolic solver
    local result = solveAST(expr, var)
    -- If it returns unhandled_node, fall back to original matchers
    if result and result.type ~= "unhandled_node" then
        -- Further simplify the result before converting to string
        result = simplify.simplify(result)
        return astToString(result)
    end

    -- Try all known matchers
    local diff = simplify.simplify(ast_mod.sub(expr.left, expr.right))
    local fallback_eq = ast_mod.eq(diff, ast_mod.number(0))

    -- Try simple isolated variable matcher first (x = b)
    local ans_simple = matchSimpleIsolatedVarEq(expr, var)
    if not ans_simple then
        ans_simple = matchSimpleIsolatedVarEq(fallback_eq, var)
    end
    if ans_simple then
        local simplified_eq = simplify.simplify(ans_simple)
        return astToString(simplified_eq)
    end

    local ans_lin = matchLinearEq(fallback_eq, var)
    if ans_lin then
        -- Create proper equation AST
        local rhs
        if type(ans_lin) ~= "table" then
            rhs = ast_mod.number(ans_lin)
        else
            rhs = ans_lin
        end
        local eq_ast = ast_mod.eq(ast_mod.symbol(var), rhs)
        local simplified_eq = simplify.simplify(eq_ast)
        return astToString(simplified_eq)
    end

    local ans_quad = matchQuadraticEq(fallback_eq, var)
    if ans_quad then
        -- Try to evaluate both roots numerically. If not possible (i.e., discriminant negative), say no real roots.
        local function tryEvalRoot(root)
            local ok, val = pcall(function() return eval(root) end)
            if ok and type(val) == "number" and val == val and math.abs(val) ~= math.huge then
                return val
            end
            return nil
        end
        local v1 = tryEvalRoot(ans_quad[1])
        local v2 = tryEvalRoot(ans_quad[2])
        if v1 and v2 then
            return var .. " = " .. tostring(v1) .. ", " .. tostring(v2)
        else
            return "No real roots"
        end
    end

    local ans = matchCubicEq(fallback_eq, var)
    if ans then
        local outs = {}
        for i,v in ipairs(ans) do
            local eq_ast = ast_mod.eq(ast_mod.symbol(var), ast_mod.number(v))
            local simp = simplify.simplify(eq_ast)
            table.insert(outs, astToString(simp))
        end
        -- If all roots are equal, show just one, else all
        local all_equal = true
        if #outs > 1 then
            for i=2,#outs do
                if outs[i] ~= outs[1] then all_equal = false break end
            end
        end
        if all_equal then
            return outs[1]
        else
            return table.concat(outs, ", ")
        end
    end

    ans = matchTrigEq(fallback_eq, var)
    if ans then
        if type(ans[1]) == "table" and ans[1].type == "equation" then
            local outs = {}
            for _,a in ipairs(ans) do table.insert(outs, astToString(a)) end
            return table.concat(outs, ", ")
        else
            return table.concat(ans, ", ")
        end
    end

    ans = matchExpLogEq(fallback_eq, var)
    if ans then
        if type(ans[1]) == "table" and ans[1].type == "equation" then
            local outs = {}
            for _,a in ipairs(ans) do table.insert(outs, astToString(a)) end
            return table.concat(outs, ", ")
        else
            return table.concat(ans, ", ")
        end
    end

    -- Fallback: numerical
    local xnum = newtonSolve(fallback_eq, var)
    if xnum then
        return var.." ≈ "..tostring(xnum)
    end

    return "No solution found"
end

-- Public interface: string or AST in, solution AST or unhandled node out
local function solve_symbolic(expr, var)
  local parser = rawget(_G, "parser") or require("parser")
  local simplify = rawget(_G, "simplify") or require("simplify")
  if type(expr) == "string" then expr = parser.parse(expr) end
  if not expr then error(errors.invalid("solve", "symbolic parse failed: " .. tostring(expr))) end
  var = var or "x"
  -- handle input like "lhs = rhs" or plain expr = 0
  if expr.type == "equation" then
    expr = ast.eq(expr.left, expr.right)
  elseif expr.type ~= "equation" then
    expr = ast.eq(expr, ast.number(0))
  end
  expr = simplify.simplify(expr)
  local result = solveAST(expr, var)
  return result
end

-- Export functions
_G.solve = solve
_G.solveAST = solveAST
_G.solve_symbolic = solve_symbolic
_G.polyCoeffs = polyCoeffs
_G.matchLinearEq = matchLinearEq
_G.matchQuadraticEq = matchQuadraticEq
_G.matchCubicEq = matchCubicEq
_G.matchSimpleIsolatedVarEq = matchSimpleIsolatedVarEq
_G.astToString = astToString

--[[
Extending to new equation types:
To add support for a new equation type, write a matcher function (see matchLinearEq, matchQuadraticEq, etc.),
normalize the equation (subtract right from left if needed), extract coefficients or pattern-match as required,
and add your matcher to the main solve function before the fallback.
]]

-- End src/solve.lua

-- src/solve.lua makes your code richer. Or at least gout-ridden.

-- Begin src/series.lua
-- series.lua: Because infinite sums make us feel clever.

local series = {}

local function factorial_ast(n)
  if n and n.type == "number" and type(n.value) == "number" then
    -- Resolve factorial numerically if possible
    local result = 1
    for i = 2, n.value do
      result = result * i
    end
    return { type = "number", value = result }
  end

  -- Fallback to symbolic gamma if non-numeric
  return {
    type = "func",
    name = "gamma",
    args = {
      {
        type = "add",
        args = { n, { type = "number", value = 1 } }
      }
    }
  }
end

local function pow(base, exp)
  return { type = "pow", base = base, exp = exp }
end

local function mul(args)
  return { type = "mul", args = args }
end

local function div(num, denom)
  return { type = "div", left = num, right = denom }
end

local function add(args)
  return { type = "add", args = args }
end

-- Symbolic Taylor/Maclaurin Series
-- func_name: string like "sin", "cos", "exp", "ln"
-- var_node: {type="variable", name="x"}
-- center: number for expansion point
-- order: integer max order
function series.expand(func_name, var_node, center, order)
  assert(var_node and var_node.type == "variable", "Second arg must be variable node")
  assert(type(center) == "number", "Third arg must be a number")
  assert(type(order) == "number" and order >= 0, "Fourth arg must be non-negative integer")

  local x = var_node
  local terms = {}

  for n = 0, order do
    local coeff, term
    local skip = false

    if func_name == "sin" then
      if n % 2 == 0 then skip = true end
      coeff = div({ type = "number", value = ((-1) ^ ((n - 1) / 2)) }, factorial_ast({ type = "number", value = n }))
    elseif func_name == "cos" then
      if n % 2 == 1 then skip = true end
      coeff = div({ type = "number", value = ((-1) ^ (n / 2)) }, factorial_ast({ type = "number", value = n }))
    elseif func_name == "exp" then
      coeff = div({ type = "number", value = 1 }, factorial_ast({ type = "number", value = n }))
    elseif func_name == "ln" then
      if n == 0 then skip = true end
      coeff = div({ type = "number", value = ((-1) ^ (n + 1)) }, { type = "number", value = n })
    else
      error("Unsupported series: " .. func_name)
    end

    if not skip then
      term = pow({ type = "add", args = { x, { type = "number", value = -center } } }, { type = "number", value = n })
      table.insert(terms, 1, mul({ coeff, term }))
    end
  end

  if #terms == 0 then return { type = "number", value = 0 } end
  return add(terms)
end

_G.series = series

-- End src/series.lua

-- You included src/series.lua—brace for unexpected side effects.

-- Begin src/gui.lua
_G.darkMode = (var.recall("dark_mode") == 1)

-- Launch animation globals
local n_logo = image.new(_R.IMG.n_logo)
local luacas_text = image.new(_R.IMG.luacas_text)
local scaleFactorLogo = 0.1 -- Adjusted smaller n logo
local scaleFactorText = 0.035 -- Adjusted smaller LuaCAS text to match n height
local nW, nH = image.width(n_logo) * scaleFactorLogo, image.height(n_logo) * scaleFactorLogo
local luaW, luaH = image.width(luacas_text) * scaleFactorText, image.height(luacas_text) * scaleFactorText
local launchStartTime = timer.getMilliSecCounter()
local showLaunchAnim = true
local logoX, textX = -100, -300
local overlayAlpha = 1.0
local overlayRegion = {x=270, y=8, w=90, h=24} -- Position this based on your layout
local cursorInsideOverlay = false


function syncCategoryFromStorage()
    local cat = nil
    if var and type(var.recall) == "function" then
        cat = var.recall("current_constant_category")
    end

    if cat and type(cat) == "string" then
        _G.current_constant_category = cat
        _G.currentConstCategory = cat
        print("[STATE] Recalled category from storage:", cat)
    else
        local fallback = gui.get_current_constant_category()
        _G.current_constant_category = fallback
        _G.currentConstCategory = fallback
        print("[STATE] No stored category, using default:", fallback)
    end

    -- Always update GUI button text if it exists
    if _G.categoryBtn then
        _G.categoryBtn.text = _G.currentConstCategory
        print("[DEBUG] Category button updated to:", _G.currentConstCategory)
    end
end

function setupLaunchAnimation()
    showLaunchAnim = true
    launchStartTime = timer.getMilliSecCounter()
    logoX = scrWidth + 100
    textX = scrWidth + 300
    timer.start(0.016)  -- Start approx. 60fps loop
end
var = var or {}
var.store = var.store or {}
local parser = rawget(_G, "parser")
if not parser or not parser.parse then
  error("parser module or parser.parse not defined — ensure parser.lua is loaded before gui.lua")
end
local parse = parser.parse
local simplify = rawget(_G, "simplify")
local errors = _G.errors

-- Ensure getLocaleText exists, fallback to identity
local getLocaleText = rawget(_G, "getLocaleText") or function(key) return key end

_G.autoDecimal = false
_G.settingsBtnRegion = {x = 0, y = 0, w = 32, h = 32}
-- Modal flag for settings
_G.showSettingsModal = false
_G.switchPressed = false
_G.modalETKButton = nil
_G.modalCloseBtnRegion = {x = 0, y = 0, w = 24, h = 24}
-- Compatibility hack: unpack became table.unpack in newer Lua, because reasons
unpack = unpack or table.unpack

-- ====== Embedded Standalone ETK-style Button Widget ======

Widgets = {}
function applyEditorColors()
    if fctEditor and fctEditor.editor then
        local bg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
        local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
        local border = _G.darkMode and {100, 100, 100} or {0, 0, 0}

        if fctEditor.editor.setBackgroundColor then
            fctEditor.editor:setBackgroundColor(table.unpack(bg))
        end
        if fctEditor.editor.setTextColor then
            fctEditor.editor:setTextColor(table.unpack(text))
        end
        if fctEditor.editor.setBorderColor then
            fctEditor.editor:setBorderColor(table.unpack(border))
        end
        if fctEditor.editor.setOpaque then
            fctEditor.editor:setOpaque(true)
        end
    end
end
-- Helper for unpacking color
function unpackColor(t)
  return t[1], t[2], t[3]
end

-- Helper for simple dimension (width, height)
function Dimension(w, h)
  return { width = w, height = h }
end

-- Helper event dispatcher
function CallEvent(obj, name)
  if obj[name] then obj[name](obj) end
end

-- ETK-style Button class
Widgets.Button = class(Widget)
local Button = Widgets.Button

Button.defaultStyle = {
  textColor       = {{000,000,000},{000,000,000}},
  backgroundColor = {{248,252,248},{248,252,248}},
  borderColor     = {{136,136,136},{160,160,160}},
  focusColor      = {{040,148,184},{000,000,000}},
  defaultWidth  = 48,
  defaultHeight = 27,
  font = {
    serif="sansserif",
    style="r",
    size=10
  }
}

function Button:init(arg)	
  self.text = arg.text or "Button"
  local style = arg.style or Button.defaultStyle or {
    textColor       = {{0,0,0},{0,0,0}},
    backgroundColor = {{248,252,248},{248,252,248}},
    borderColor     = {{136,136,136},{160,160,160}},
    focusColor      = {{40,148,184},{0,0,0}},
    defaultWidth  = 48,
    defaultHeight = 27,
    font = {
      serif="sansserif",
      style="r",
      size=10
    }
  }
  self.style = style
  self.dimension = arg.position or Dimension(style.defaultWidth or 48, style.defaultHeight or 27)
  Widget.init(self, nil, self.dimension.width or style.defaultWidth, self.dimension.height or style.defaultHeight)
  self.meDown = false
  self.hasFocus = false
  self.parent = arg.parent or nil
  self.onAction = arg.onAction or nil
end

function Button:prepare(gc)
  local font = self.style.font
  gc:setFont(font.serif, font.style, font.size)
  self.dimension.width = gc:getStringWidth(self.text) + 10
end

function Button:draw(gc, x, y, width, height, isColor)
  if self.meDown then
    y = y + 1
  end

  local color = isColor and 1 or 2
  local style = self.style or Button.defaultStyle

  local isDark = _G.darkMode
local colorSet = isDark and {
    backgroundColor = {50, 50, 50},
    textColor = {220, 220, 220},
    borderColor = {100, 100, 100},
    focusColor = {80, 160, 220}
} or {
    backgroundColor = {248, 252, 248},
    textColor = {0, 0, 0},
    borderColor = {136, 136, 136},
    focusColor = {40, 148, 184}
}

local bg = colorSet.backgroundColor
local tc = colorSet.textColor
local bc = colorSet.borderColor
local fc = colorSet.focusColor

  gc:setColorRGB(unpackColor(bg))
  gc:fillRect(x + 2, y + 2, width - 4, height - 4)

  gc:setColorRGB(unpackColor(tc))
  gc:drawString(self.text, x + 5, y + 3, "top")

  if self.hasFocus then
    gc:setColorRGB(unpackColor(fc))
    gc:setPen("medium", "smooth")
  else
    gc:setColorRGB(unpackColor(bc))
    gc:setPen("thin", "smooth")
  end

  gc:fillRect(x + 2, y, width - 4, 2)
  gc:fillRect(x + 2, y + height - 2, width - 4, 2)
  gc:fillRect(x, y + 2, 1, height - 4)
  gc:fillRect(x + 1, y + 1, 1, height - 2)
  gc:fillRect(x + width - 1, y + 2, 1, height - 4)
  gc:fillRect(x + width - 2, y + 1, 1, height - 2)

  if self.hasFocus then
    gc:setColorRGB(unpackColor(style.focusColor[color]))
  end

  gc:setPen("thin", "smooth")
end

function Button:doAction()
  if self.parent and self.parent.invalidate then
    self.parent:invalidate()
  end
  if self.onAction then
    self.onAction(self)
  else
    CallEvent(self, "onAction")
  end
end

function Button:onMouseDown()
  self.meDown = true
end

function Button:onMouseUp(x, y, onMe)
  self.meDown = false
  if onMe then
    self:doAction()
  end
end

function Button:enterKey()
  self:doAction()
end

-- ====== END Standalone Button Widget ======
-- ETK View System (lifted and tweaked from SuperSpire/S2.lua)
defaultFocus = nil

-- The View class: manages widgets, focus, mouse events, and general UI mayhem.
View = class()

function View:init(window)
	self.window = window
	self.widgetList = {}
	self.focusList = {}
	self.currentFocus = 0
	self.currentCursor = "default"
	self.prev_mousex = 0
	self.prev_mousey = 0
end

function View:invalidate()
	self.window:invalidate()
end

function View:setCursor(cursor)
	if cursor ~= self.currentCursor then
		self.currentCursor = cursor
		self:invalidate()
	end
end

-- Add a widget to the view, because clearly we like clutter. Also handles focus logic.
function View:add(o)
	table.insert(self.widgetList, o)
	self:repos(o)
	if o.acceptsFocus then
		table.insert(self.focusList, 1, o)
		if self.currentFocus > 0 then
			self.currentFocus = self.currentFocus + 1
		end
	end
	return o
end

-- Remove a widget from the view, and try to pretend nothing ever happened.
function View:remove(o)
	if self:getFocus() == o then
		o:releaseFocus()
	end
	local i = 1
	local f = 0
	while i <= #self.focusList do
		if self.focusList[i] == o then
			f = i
		end
		i = i + 1
	end
	if f > 0 then
		if self:getFocus() == o then
			self:tabForward()
		end
		table.remove(self.focusList, f)
		if self.currentFocus > f then
			self.currentFocus = self.currentFocus - 1
		end
	end
	f = 0
	i = 1
	while i <= #self.widgetList do
		if self.widgetList[i] == o then
			f = i
		end
		i = i + 1
	end
	if f > 0 then
		table.remove(self.widgetList, f)
	end
end

-- Reposition and resize a widget according to its constraints. Because pixel-perfect UIs are for the weak.
function View:repos(o)
	local x = o.x
	local y = o.y
	local w = o.w
	local h = o.h
	if o.hConstraint == "right" then
		x = scrWidth - o.w - o.dx1
	elseif o.hConstraint == "center" then
		x = (scrWidth - o.w + o.dx1) / 2
	elseif o.hConstraint == "justify" then
		w = scrWidth - o.x - o.dx1
	end
	if o.vConstraint == "bottom" then
		y = scrHeight - o.h - o.dy1
	elseif o.vConstraint == "middle" then
		y = (scrHeight - o.h + o.dy1) / 2
	elseif o.vConstraint == "justify" then
		h = scrHeight - o.y - o.dy1
	end
	o:repos(x, y)
	o:resize(w, h)
end

-- Resize all widgets in the view. Hope they like their new size.
function View:resize()
	for _, o in ipairs(self.widgetList) do
		self:repos(o)
	end
end

-- Hide a widget. Out of sight, out of mind (and out of focus).
function View:hide(o)
	if o.visible then
		o.visible = false
		self:releaseFocus(o)
		if o:contains(self.prev_mousex, self.prev_mousey) then
			o:onMouseLeave(o.x - 1, o.y - 1)
		end
		self:invalidate()
	end
end

-- Show a widget. If it was invisible, now it can bask in the user's gaze.
function View:show(o)
	if not o.visible then
		o.visible = true
		if o:contains(self.prev_mousex, self.prev_mousey) then
			o:onMouseEnter(self.prev_mousex, self.prev_mousey)
		end
		self:invalidate()
	end
end

-- Return the currently focused widget, or nil if nothing bothers to have focus.
function View:getFocus()
	if self.currentFocus == 0 then
		return nil
	end
	return self.focusList[self.currentFocus]
end

-- Give focus to a widget, and make everyone else jealous.
function View:setFocus(obj)
	if self.currentFocus ~= 0 then
		if self.focusList[self.currentFocus] == obj then
			return
		end
		self.focusList[self.currentFocus]:releaseFocus()
	end
	self.currentFocus = 0
	for i = 1, #self.focusList do
		if self.focusList[i] == obj then
			self.currentFocus = i
			obj:setFocus()
			self:invalidate()
			break
		end
	end
end

-- Take focus away from a widget. It probably didn't deserve it anyway.
function View:releaseFocus(obj)
	if self.currentFocus ~= 0 then
		if self.focusList[self.currentFocus] == obj then
			self.currentFocus = 0
			obj:releaseFocus()
			self:invalidate()
		end
	end
end

-- Send a string to the focused widget, or desperately try to find anyone who will take it.
function View:sendStringToFocus(str)
	local o = self:getFocus()
	if not o then
		o = defaultFocus
		self:setFocus(o)
	end
	if o then
		if o.visible then
			if o:addString(str) then
				self:invalidate()
			else
				o = nil
			end
		end
	end

	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible then
				if o:addString(str) then
					self:setFocus(o)
					self:invalidate()
					break
				end
			end
		end
	end
end

-- Handle backspace for the focused widget, or for anyone who claims to accept it.
function View:backSpaceHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsBackSpace then
			o:backSpaceHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsBackSpace then
				o:backSpaceHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Move focus to the next widget, looping around. Because tab order is a suggestion, not a rule.
function View:tabForward()
	local nextFocus = self.currentFocus + 1
	if nextFocus > #self.focusList then
		nextFocus = 1
	end
	self:setFocus(self.focusList[nextFocus])
	if self:getFocus() then
		if not self:getFocus().visible then
			self:tabForward()
		end
	end
	self:invalidate()
end

-- Move focus to the previous widget, looping around. For the rebels who like shift+tab.
function View:tabBackward()
	local nextFocus = self.currentFocus - 1
	if nextFocus < 1 then
		nextFocus = #self.focusList
	end
	self:setFocus(self.focusList[nextFocus])
	if not self:getFocus().visible then
		self:tabBackward()
	end
	self:invalidate()
end

-- Handle mouse down events, capturing the widget that gets clicked (and focus).
function View:onMouseDown(x, y)
	for _, o in ipairs(self.widgetList) do
		if o.visible and o.acceptsFocus and o:contains(x, y) then
			self.mouseCaptured = o
			o:onMouseDown(o, window, x - o.x, y - o.y)
			self:setFocus(o)
			self:invalidate()
			return
		end
	end
	if self:getFocus() then
		self:setFocus(nil)
		self:invalidate()
	end
end

-- Handle mouse move events, triggering enter/leave events for widgets. Because hover states are important.
function View:onMouseMove(x, y)
	local prev_mousex = self.prev_mousex
	local prev_mousey = self.prev_mousey
	for _, o in ipairs(self.widgetList) do
		local xyin = o:contains(x, y)
		local prev_xyin = o:contains(prev_mousex, prev_mousey)
		if xyin and not prev_xyin and o.visible then
			o:onMouseEnter(x, y)
			self:invalidate()
		elseif prev_xyin and (not xyin or not o.visible) then
			o:onMouseLeave(x, y)
			self:invalidate()
		end
	end
	self.prev_mousex = x
	self.prev_mousey = y
end

-- Handle mouse up events, releasing the widget that was so rudely pressed.
function View:onMouseUp(x, y)
	local mc = self.mouseCaptured
	if mc then
		self.mouseCaptured = nil
		if mc:contains(x, y) then
			mc:onMouseUp(x - mc.x, y - mc.y)
		end
	end
end

-- Handle "enter" key for the focused widget, or anyone who cares.
function View:enterHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsEnter then
			o:enterHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsEnter then
				o:enterHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle left arrow key for the focused widget, or anyone who wants to move left in life.
function View:arrowLeftHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowLeft then
			o:arrowLeftHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowLeft then
				o:arrowLeftHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle right arrow key for the focused widget, or anyone who wants to move right in life.
function View:arrowRightHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowRight then
			o:arrowRightHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowRight then
				o:arrowRightHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle up arrow key for the focused widget. Because up is the new down.
function View:arrowUpHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowUp then
			o:arrowUpHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowUp then
				o:arrowUpHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle down arrow key for the focused widget. Because down is the new up.
function View:arrowDownHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowDown then
			o:arrowDownHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowDown then
				o:arrowDownHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Paint all widgets to the screen, highlight the focused one, and set the cursor.
function View:paint(gc)
	local fo = self:getFocus()
	for _, o in ipairs(self.widgetList) do
		if o.visible then
			o:paint(gc, fo == o)
			if fo == o then
				gc:setColorRGB(100, 150, 255)
				gc:drawRect(o.x - 1, o.y - 1, o.w + 1, o.h + 1)
				gc:setPen("thin", "smooth")
				gc:setColorRGB(0, 0, 0)
			end
		end
	end
	cursor.set(self.currentCursor)
end

theView = nil

-- Widget base class. All widgets inherit from this, like it or not.
Widget = class()

function Widget:setHConstraints(hConstraint, dx1)
	self.hConstraint = hConstraint
	self.dx1 = dx1
end

function Widget:setVConstraints(vConstraint, dy1)
	self.vConstraint = vConstraint
	self.dy1 = dy1
end

function Widget:init(view, x, y, w, h)
	self.xOrig = x
	self.yOrig = y
	self.view = view
	self.x = x
	self.y = y
	self.w = w
	self.h = h
	self.acceptsFocus = false
	self.visible = true
	self.acceptsEnter = false
	self.acceptsEscape = false
	self.acceptsTab = false
	self.acceptsDelete = false
	self.acceptsBackSpace = false
	self.acceptsReturn = false
	self.acceptsArrowUp = false
	self.acceptsArrowDown = false
	self.acceptsArrowLeft = false
	self.acceptsArrowRight = false
	self.hConstraint = "left"
	self.vConstraint = "top"
end

function Widget:repos(x, y)
	self.x = x
	self.y = y
end

function Widget:resize(w, h)
	self.w = w
	self.h = h
end

function Widget:setFocus() end
function Widget:releaseFocus() end

function Widget:contains(x, y)
	return x >= self.x and x <= self.x + self.w
			and y >= self.y and y <= self.y + self.h
end

function Widget:onMouseEnter(x, y) end
function Widget:onMouseLeave(x, y) end
function Widget:paint(gc, focused) end
function Widget:enterHandler() end
function Widget:escapeHandler() end
function Widget:tabHandler() end
function Widget:deleteHandler() end
function Widget:backSpaceHandler() end
function Widget:returnHandler() end
function Widget:arrowUpHandler() end
function Widget:arrowDownHandler() end
function Widget:arrowLeftHandler() end
function Widget:arrowRightHandler() end
function Widget:onMouseDown(x, y) end
function Widget:onMouseUp(x, y) end

-- Button widget, for people who like clicking things.
Button = class(Widget)

function Button:init(view, x, y, w, h, default, command, shortcut)
	Widget.init(self, view, x, y, w, h)
	self.acceptsFocus = true
	self.command = command or function() end
	self.default = default
	self.shortcut = shortcut
	self.clicked = false
	self.highlighted = false
	self.acceptsEnter = true
end

function Button:enterHandler()
	if self.acceptsEnter then
		self:command()
	end
end

function Button:escapeHandler()
	if self.acceptsEscape then
		self:command()
	end
end

function Button:tabHandler()
	if self.acceptsTab then
		self:command()
	end
end

function Button:deleteHandler()
	if self.acceptsDelete then
		self:command()
	end
end

function Button:backSpaceHandler()
	if self.acceptsBackSpace then
		self:command()
	end
end

function Button:returnHandler()
	if self.acceptsReturn then
		self:command()
	end
end

function Button:arrowUpHandler()
	if self.acceptsArrowUp then
		self:command()
	end
end

function Button:arrowDownHandler()
	if self.acceptsArrowDown then
		self:command()
	end
end

function Button:arrowLeftHandler()
	if self.acceptsArrowLeft then
		self:command()
	end
end

function Button:arrowRightHandler()
	if self.acceptsArrowRight then
		self:command()
	end
end

function Button:onMouseDown(x, y)
	self.clicked = true
	self.highlighted = true
end

function Button:onMouseEnter(x, y)
	theView:setCursor("hand pointer")
	if self.clicked and not self.highlighted then
		self.highlighted = true
	end
end

function Button:onMouseLeave(x, y)
	theView:setCursor("default")
	if self.clicked and self.highlighted then
		self.highlighted = false
	end
end

function Button:cancelClick()
	if self.clicked then
		self.highlighted = false
		self.clicked = false
	end
end

function Button:onMouseUp(x, y)
	self:cancelClick()
	self:command()
end

function Button:addString(str)
	if str == " " or str == self.shortcut then
		self:command()
		return true
	end
	return false
end

-- Image label widget. Displays an image, does nothing else. The laziest widget.
ImgLabel = class(Widget)

function ImgLabel:init(view, x, y, img)
	self.img = image.new(img)
	self.w = image.width(self.img)
	self.h = image.height(self.img)
	Widget.init(self, view, x, y, self.w, self.h)
end

function ImgLabel:paint(gc, focused)
	gc:drawImage(self.img, self.x, self.y)
end

-- Image button widget. Like a button, but with more pixels.
ImgButton = class(Button)

function ImgButton:init(view, x, y, img, command, shortcut)
	self.img = image.new(img)
	self.w = image.width(self.img)
	self.h = image.height(self.img)
	Button.init(self, view, x, y, self.w, self.h, false, command, shortcut)
end

function ImgButton:paint(gc, focused)
	gc:drawImage(self.img, self.x, self.y)
end

-- Text button widget. For those who prefer words to icons.
TextButton = class(Button)

function TextButton:init(view, x, y, text, command, shortcut)
	self.textid = text
	self.text = getLocaleText(text)
	self:resize(0, 0)
	Button.init(self, view, x, y, self.w, self.h, false, command, shortcut)
end

function TextButton:resize(w, h)
	self.text = getLocaleText(self.textid)
	self.w = getStringWidth(self.text) + 5
	self.h = getStringHeight(self.text) + 5
end

function TextButton:paint(gc, focused)
	gc:setColorRGB(223, 223, 223)
	gc:drawRect(self.x + 1, self.y + 1, self.w - 2, self.h - 2)
	gc:setColorRGB(191, 191, 191)
	gc:fillRect(self.x + 1, self.y + 1, self.w - 3, self.h - 3)
	gc:setColorRGB(223, 223, 223)
	gc:drawString(self.text, self.x + 3, self.y + 3, "top")
	gc:setColorRGB(0, 0, 0)
	gc:drawString(self.text, self.x + 2, self.y + 2, "top")
	gc:drawRect(self.x, self.y, self.w - 2, self.h - 2)
end

-- Vertical scrollbar widget. Because scrolling through history is a thing.
VScrollBar = class(Widget)

function VScrollBar:init(view, x, y, w, h)
	self.pos = 10
	self.siz = 10
	Widget.init(self, view, x, y, w, h)
end

function VScrollBar:paint(gc, focused)
	gc:setColorRGB(0, 0, 0)
	gc:drawRect(self.x, self.y, self.w, self.h)
	gc:fillRect(self.x + 2, self.y + self.h - (self.h - 4) * (self.pos + self.siz) / 100 - 2, self.w - 3, math.max(1, (self.h - 4) * self.siz / 100 + 1))
end

-- Text label widget. It just sits there and looks pretty.
TextLabel = class(Widget)

function TextLabel:init(view, x, y, text)
	self:setText(text)
	Widget.init(self, view, x, y, self.w, self.h)
end

function TextLabel:resize(w, h)
	self.text = getLocaleText(self.textid)
	self.w = getStringWidth(self.text)
	self.h = getStringHeight(self.text)
end

function TextLabel:setText(text)
	self.textid = text
	self.text = getLocaleText(text)
	self:resize(0, 0)
end

function TextLabel:getText()
	return self.text
end

function TextLabel:paint(gc, focused)
	gc:setColorRGB(0, 0, 0)
	gc:drawString(self.text, self.x, self.y, "top")
end

-- Rich text editor widget. Handles text entry, but don't expect Microsoft Word.
RichTextEditor = class(Widget)

function RichTextEditor:init(view, x, y, w, h, text)
	self.editor = D2Editor.newRichText()
	self.readOnly = false
	self:repos(x, y)
	self.editor:setFontSize(fsize)
	self.editor:setFocus(false)
	self.text = text
	self:resize(w, h)
	Widget.init(self, view, x, y, self.w, self.h, true)
	self.acceptsFocus = true
	self.editor:setExpression(text)
	self.editor:setBorder(1)
end

function RichTextEditor:onMouseEnter(x, y)
	theView:setCursor("text")
end

function RichTextEditor:onMouseLeave(x, y)
	theView:setCursor("default")
end

function RichTextEditor:repos(x, y)
	if not self.editor then return end
	self.editor:setBorderColor((showEditorsBorders and 0) or 0xffffff )
	self.editor:move(x, y)
	Widget.repos(self, x, y)
end

function RichTextEditor:resize(w, h)
	if not self.editor then return end
	self.editor:resize(w, h)
	Widget.resize(self, w, h)
end

function RichTextEditor:setFocus()
	self.editor:setFocus(true)
end

function RichTextEditor:releaseFocus()
	self.editor:setFocus(false)
end

function RichTextEditor:addString(str)
	local currentText = self.editor:getText() or ""
	self.editor:setText(currentText .. str)
	return true
end

function RichTextEditor:paint(gc, focused) end

-- MathEditor: a rich text editor with math-specific quirks and a love for Unicode.
MathEditor = class(RichTextEditor)

-- Returns the number of Unicode codepoints in a string.
-- Because Lua strings are byte-based and Unicode is hard.
function ulen(str)
	if not str then return 0 end
	local n = string.len(str)
	local i = 1
	local j = 1
	local c
	while (j <= n) do
		c = string.len(string.usub(str, i, i))
		j = j + c
		i = i + 1
	end
	return i - 1
end

-- Initialize a MathEditor, set up filters for key events, and generally make life complicated.
function MathEditor:init(view, x, y, w, h, text)
	RichTextEditor.init(self, view, x, y, w, h, text)
	self.editor:setBorder(1)
    -- Set dark/light mode colors at initialization, safely and consistently
    if self.editor then
        local areaBg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
        local areaBorder = _G.darkMode and {100, 100, 100} or {0, 0, 0}
        local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
        if self.editor.setBackgroundColor then
            self.editor:setBackgroundColor(table.unpack(areaBg))
        end
        if self.editor.setTextColor then
            self.editor:setTextColor(table.unpack(text))
        end
        if self.editor.setBorderColor then
            self.editor:setBorderColor(table.unpack(areaBorder))
        end
        if self.editor.setOpaque then
            self.editor:setOpaque(true)
        end
    end
	self.acceptsEnter = true
	self.acceptsBackSpace = true
	self.result = false
	self.editor:registerFilter({
		arrowLeft = function()
			_, curpos = self.editor:getExpressionSelection()
			if curpos < 7 then
				on.arrowLeft()
				return true
			end
			return false
		end,
		arrowRight = function()
			currentText, curpos = self.editor:getExpressionSelection()
			if curpos > ulen(currentText) - 2 then
				on.arrowRight()
				return true
			end
			return false
		end,
		tabKey = function()
			theView:tabForward()
			return true
		end,
		mouseDown = function(x, y)
			theView:onMouseDown(x, y)
			return false
		end,
		backspaceKey = function()
			if (self == fctEditor) then
				self:fixCursor()
				_, curpos = self.editor:getExpressionSelection()
				if curpos <= 6 then return true end
				return false
			else
				self:backSpaceHandler()
				return true
			end
		end,
		deleteKey = function()
			if (self == fctEditor) then
				self:fixCursor()
				currentText, curpos = self.editor:getExpressionSelection()
				if curpos >= ulen(currentText) - 1 then return true end
				return false
			else
				self:backSpaceHandler()
				return true
			end
		end,
		enterKey = function()
			self:enterHandler()
			return true
		end,
		returnKey = function()
			theView:enterHandler()
			return true
		end,
		escapeKey = function()
			on.escapeKey()
			return true
		end,
		charIn = function(c)
			if (self == fctEditor) then
				self:fixCursor()
				return false
			else
				return self.readOnly
			end
		end
	})
end

-- Ensures the editor has a math box at all times.
function MathEditor:fixContent()
	local currentText = self.editor:getExpressionSelection()
	if currentText == "" or currentText == nil then
		self.editor:createMathBox()
	end
end

-- Make sure the cursor stays inside the editable region of the Unicode string.
-- D2Editor likes to insert special tokens at the start, so we have to skip the first 6 codepoints.
-- If the cursor escapes the allowed range, forcibly drag it back, because users can't be trusted.
function MathEditor:fixCursor()
	local currentText, curpos, selstart = self.editor:getExpressionSelection()
	local l = ulen(currentText)
	if curpos < 6 or selstart < 6 or curpos > l - 1 or selstart > l - 1 then
		if curpos < 6 then curpos = 6 end
		if selstart < 6 then selstart = 6 end
		if curpos > l - 1 then curpos = l - 1 end
		if selstart > l - 1 then selstart = l - 1 end
		self.editor:setExpression(currentText, curpos, selstart)
	end
end

-- Extract the user-entered expression from the D2Editor string, skipping any special formatting.
function MathEditor:getExpression()
	if not self.editor then return "" end
	local rawexpr = self.editor:getExpression()
	local expr = ""
	local n = string.len(rawexpr)
	local b = 0
	local bs = 0
	local bi = 0
	local status = 0
	local i = 1
	while i <= n do
		local c = string.sub(rawexpr, i, i)
		if c == "{" then
			b = b + 1
		elseif c == "}" then
			b = b - 1
		end
		if status == 0 then
			if string.sub(rawexpr, i, i + 5) == "\\0el {" then
				bs = i + 6
				i = i + 5
				status = 1
				bi = b
				b = b + 1
			end
		else
			if b == bi then
				status = 0
				expr = expr .. string.sub(rawexpr, bs, i - 1)
			end
		end
		i = i + 1
	end
	return expr
end

-- Set focus to the math editor, so it can feel important.
function MathEditor:setFocus()
	if not self.editor then return end
	self.editor:setFocus(true)
end

-- Remove focus from the math editor, so it can sulk in the corner.
function MathEditor:releaseFocus()
	if not self.editor then return end
	self.editor:setFocus(false)
end

-- Inserts text at the cursor. Assumes user knows what they’re doing. (They probably don’t.)
function MathEditor:addString(str)
	if not self.editor then return false end
	self:fixCursor()
	-- Unicode string slicing: because normal string.sub just isn't enough.
	local currentText, curpos, selstart = self.editor:getExpressionSelection()
	local newText = string.usub(currentText, 1, math.min(curpos, selstart)) .. str .. string.usub(currentText, math.max(curpos, selstart) + 1, ulen(currentText))
	self.editor:setExpression(newText, math.min(curpos, selstart) + ulen(str))
	return true
end

-- Handle backspace. (No-op for now, because history deletion is scary.)
function MathEditor:backSpaceHandler()
    -- No-op or custom deletion logic (history removal not implemented)
end

-- Handle enter key. Just delegates to the real handler.
function MathEditor:enterHandler()
    -- Call the custom on.enterKey handler instead of missing global
    on.enterKey()
end

-- Draws horizontal lines under the editor, if we're feeling fancy.
function MathEditor:paint(gc)
	if showHLines and not self.result then
		gc:setColorRGB(100, 100, 100)
		local ycoord = self.y - (showEditorsBorders and 0 or 2)
		gc:drawLine(1, ycoord, platform.window:width() - sbv.w - 2, ycoord)
		gc:setColorRGB(0, 0, 0)
	end
end

function on.arrowUp()
  if theView then
    if theView:getFocus() == fctEditor then
      on.tabKey()
    else
      on.tabKey()
      if theView:getFocus() ~= fctEditor then on.tabKey() end
    end
    reposView()
  end
end

function on.arrowDown()
  if theView then
    on.backtabKey()
    if theView:getFocus() ~= fctEditor then on.backtabKey() end
    reposView()
  end
end

function on.arrowLeft()
  if theView then
    on.tabKey()
    reposView()
  end
end

function on.arrowRight()
  if theView then
    on.backtabKey()
    reposView()
  end
end

function on.charIn(ch)
  if theView then theView:sendStringToFocus(ch) end
end

function on.tabKey()
  if theView then theView:tabForward(); reposView() end
end

function on.backtabKey()
  if theView then theView:tabBackward(); reposView() end
end

function on.enterKey()
  if not fctEditor or not fctEditor.getExpression then return end

  -- Recall the current constant category (do not set default here)
  local recalled = var.recall and var.recall("current_constant_category")
  if recalled ~= nil then
    current_constant_category = recalled
    print("[INIT] Recalled constant category: " .. tostring(current_constant_category))
  else
    print("[INIT] Recall failed or value was nil; skipping default set")
  end

  local input = fctEditor:getExpression()
  -- Check for custom snarky responses
  local joke = _G.errors.get(input)
  if joke then
    result = joke
    addME(input, result, "normal")
    if fctEditor and fctEditor.editor then
      fctEditor.editor:setText("")
      fctEditor:fixContent()
    end
    if platform and platform.window and platform.window.invalidate then
      platform.window:invalidate()
    end
    return
  end
  -- Fix TI-style derivative notation like ((d)/(dx(x^2))) to diff(x^2, x)
  input = input:gsub("%(%(d%)%)%/%(d([a-zA-Z])%((.-)%)%)%)", function(var, inner)
    _G.__diff_var = var
    return inner
  end)
  if not input or input == "" then return end

  -- Remove all whitespace from input
  input = input:gsub("%s+", "")

  local result = ""
  _G.luaCASerror = false
  local function get_constant_value(fname)
    local physics_constants = _G.physics_constants or {}
    local avail = var.recall and var.recall("available_constants") or {}
    local is_enabled = (avail == nil) or (avail[fname] == true)
    -- Retrieve current category for this resolution
    local cat = var.recall and var.recall("current_constant_category")
    print("[DEBUG] Category set to:", tostring(cat))
    if physics_constants[fname]
      and is_enabled
      and physics_constants[fname].category == cat then
      return physics_constants[fname].value
    end
    return nil
  end
  local function eval_physics_func(fname)
    local physics_constants = _G.physics_constants or {}
    local avail = var.recall and var.recall("available_constants") or {}
    local is_enabled = (avail == nil) or (avail[fname] == true)
    -- Retrieve current category for this resolution
    local cat = var.recall and var.recall("current_constant_category")
    print("[DEBUG] Category set to:", tostring(cat))
    if physics_constants[fname]
      and is_enabled
      and physics_constants[fname].category == cat then
      return physics_constants[fname].value
    end
    return nil
  end

  local success, err = pcall(function()
    if input:sub(1,4) == "d/dx" or input:sub(1,4) == "d/dy" then
      local expr = input:match("d/d[xy]%((.+)%)")
      result = expr and derivative(expr, _G.__diff_var) or errors.invalid("diff")
      if result == errors.invalid("diff") then _G.luaCASerror = true end
    elseif input:sub(1,5) == "∂/∂x(" and input:sub(-1) == ")" then
      local expr = input:match("∂/∂x%((.+)%)")
      result = expr and derivative(expr, _G.__diff_var) or errors.invalid("diff")
      if result == errors.invalid("diff") then _G.luaCASerror = true end
    elseif input:match("^∂/∂[yz]%(.+%)$") then
      result = derivative(input, _G.__diff_var)
    elseif input:sub(1,3) == "∫(" and input:sub(-2) == ")x" then
      result = integrate(parse(input:sub(4, -3)))
    elseif input:sub(1,6) == "solve(" and input:sub(-1) == ")" then
      local eqn = input:match("solve%((.+)%)")
      if eqn and not eqn:find("=") then
        eqn = eqn .. "=0"
      end
      result = eqn and solve(parse(eqn)) or errors.invalid("solve")
      if result == errors.invalid("solve") then _G.luaCASerror = true end
    elseif input:sub(1,4) == "let" then
      result = define(input)
    elseif input:sub(1,7) == "expand(" and input:sub(-1) == ")" then
        local inner = input:match("expand%((.+)%)")
        result = inner and expand(parse(inner)) or errors.invalid("expand")
        if result == errors.invalid("expand") then _G.luaCASerror = true end
    elseif input:sub(1,5) == "subs(" and input:sub(-1) == ")" then
        local inner, varname, val = input:match("subs%(([^,]+),([^,]+),([^%)]+)%)")
        result = (inner and varname and val) and subs(parse(inner), varname, val) or errors.invalid("subs")
        if result == errors.invalid("subs") then _G.luaCASerror = true end
    elseif input:sub(1,7) == "factor(" and input:sub(-1) == ")" then
        local inner = input:match("factor%((.+)%)")
        result = inner and factor(parse(inner)) or errors.invalid("factor")
        if result == errors.invalid("factor") then _G.luaCASerror = true end
    elseif input:sub(1,4) == "gcd(" and input:sub(-1) == ")" then
        local a, b = input:match("gcd%(([^,]+),([^%)]+)%)")
        result = (a and b) and gcd(parse(a), parse(b)) or errors.invalid("gcd")
        if result == errors.invalid("gcd") then _G.luaCASerror = true end
    elseif input:sub(1,4) == "lcm(" and input:sub(-1) == ")" then
        local a, b = input:match("lcm%(([^,]+),([^%)]+)%)")
        result = (a and b) and lcm(parse(a), parse(b)) or errors.invalid("lcm")
        if result == errors.invalid("lcm") then _G.luaCASerror = true end
    elseif input:sub(1,7) == "trigid(" and input:sub(-1) == ")" then
        local inner = input:match("trigid%((.+)%)")
        result = inner and trigid(parse(inner)) or errors.invalid("trigid")
        if result == errors.invalid("trigid") then _G.luaCASerror = true end
    elseif input:match("%w+%(.+%)") then
      print("[DEBUG] Category set to:", var.recall("current_constant_category"))
      result = simplify.simplify(parse(input))
    elseif input:sub(1,9) == "simplify(" and input:sub(-1) == ")" then
      local inner = input:match("simplify%((.+)%)")
      print("[DEBUG] Category set to:", var.recall("current_constant_category"))
      result = inner and simplify.simplify(parse(inner)) or errors.invalid("simplify")
      if result == errors.invalid("simplify") then _G.luaCASerror = true end
    -- Fallback parser for diff(...) and integrate(...)
    elseif input:match("^diff%(([^,]+),([^,%)]+)%)$") then
      local a, b = input:match("^diff%(([^,]+),([^,%)]+)%)$")
      result = (a and b) and derivative(parse(a), b) or errors.invalid("diff")
      if result == errors.invalid("diff") then _G.luaCASerror = true end
    elseif _G.__diff_var then
      result = derivative(input, _G.__diff_var)
      _G.__diff_var = nil
    elseif input:match("^integrate%(([^,]+),([^,%)]+)%)$") then
      local a, b = input:match("^integrate%(([^,]+),([^,%)]+)%)$")
      result = (a and b) and integrate(parse(a), b) or errors.invalid("int")
      if result == errors.invalid("int") then _G.luaCASerror = true end
    else
      -- Try constant resolution
      local constval = get_constant_value(input)
      if constval ~= nil then
        result = constval
      else
        print("[DEBUG] Category set to:", var.recall("current_constant_category"))
        result = simplify.simplify(parse(input))
      end
    end
    if result == "" or not result then
      result = "No result. Internal CAS fallback used."
    end
  end)
  if not success then
    result = "Error: " .. tostring(err)
    _G.luaCASerror = true
  end

  -- Add to history display
  local colorHint = (_G.luaCASerror and "error") or "normal"
  addME(input, result, colorHint)

  -- Clear the input editor and ready for next input
  if fctEditor and fctEditor.editor then
    fctEditor.editor:setText("")
    fctEditor:fixContent()
  end

  -- Redraw UI
  if platform and platform.window and platform.window.invalidate then
    platform.window:invalidate()
  end

  -- Optionally save last result globally if needed
  if type(result) == "table" then
    if _G.ast and _G.ast.tostring then
      result = _G.ast.tostring(result)
    else
      result = "(unrenderable result)"
    end
  end
  res = result
end

function on.returnKey()
  on.enterKey()
end

function on.mouseMove(x, y)
  if theView then theView:onMouseMove(x, y) end
end

function on.mouseDown(x, y)
  -- Modal close "X" button
  if _G.showSettingsModal and _G.modalCloseBtnRegion then
    local r = _G.modalCloseBtnRegion
    if x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
      _G.showSettingsModal = false
      platform.window:invalidate()
      return
    end
  end
  -- Handle custom settings icon button click
  if _G.settingsBtnRegion then
    local r = _G.settingsBtnRegion
    if x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
      if not _G.showSettingsModal then
        _G.showSettingsModal = true
        platform.window:invalidate()
      end
      return
    end
  end
  -- Modal ETK Button mouseDown
  if _G.showSettingsModal and _G.modalETKButton then
    local btn = _G.modalETKButton
    local btnW = btn.dimension.width or 80
    local btnH = btn.dimension.height or 28
    local modalW, modalH = 200, 120
    local modalX = (scrWidth - modalW) / 2
    local modalY = (scrHeight - modalH) / 2
    local btnX = modalX + (modalW - btnW) / 2
    local btnY = modalY + 54
    if x >= btnX and x <= btnX + btnW and y >= btnY and y <= btnY + btnH then
      btn:onMouseDown()
      platform.window:invalidate()
      return
    end
  end
  -- Toggle switch press effect when settings modal is open
  if _G.showSettingsModal and _G.switchRegion then
    local r = _G.switchRegion
    if x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
      _G.switchPressed = true
      platform.window:invalidate()
      return
    end
  end
  if theView then theView:onMouseDown(x, y) end
end

function on.mouseUp(x, y)
  -- Consistent modal button hitboxes using visible regions
  if _G.showSettingsModal then
    local modalW, modalH = 200, 200
    local modalX = (scrWidth - modalW) / 2
    local modalY = (scrHeight - modalH) / 2
    local labelX = modalX + 10
    local labelY = modalY + 40
    local lineHeight = 28
    local btnW, btnH = 48, 22

    -- Decimals Button
    local decBtnX = labelX + getStringWidth("Decimals:") + 10
    local decBtnY = labelY - 2
    if x >= decBtnX and x <= decBtnX + btnW and y >= decBtnY and y <= decBtnY + btnH then
      _G.modalETKButton:onMouseUp(x - decBtnX, y - decBtnY, true)
      platform.window:invalidate()
      return
    end

    -- Constants Button
    local consLabelY = labelY + lineHeight
    local consBtnX = labelX + getStringWidth("Constants:") + 10
    local consBtnY = consLabelY - 2
    if x >= consBtnX and x <= consBtnX + btnW and y >= consBtnY and y <= consBtnY + btnH then
      _G.constantsToggleBtn:onMouseUp(x - consBtnX, y - consBtnY, true)
      platform.window:invalidate()
      return
    end

    -- Dark Mode Button
    local darkLabelY = consLabelY + lineHeight
    local darkBtnX = labelX + getStringWidth("Dark Mode:") + 10
    local darkBtnY = darkLabelY - 2
    if x >= darkBtnX and x <= darkBtnX + btnW and y >= darkBtnY and y <= darkBtnY + btnH then
      _G.darkModeToggleBtn:onMouseUp(x - darkBtnX, y - darkBtnY, true)
      platform.window:invalidate()
      return
    end

    -- Category Button
    local catLabelY = darkLabelY + lineHeight
    local catBtnX = labelX + getStringWidth("Category:") + 10
    local catBtnY = catLabelY - 2
    if x >= catBtnX and x <= catBtnX + 90 and y >= catBtnY and y <= catBtnY + btnH then
      _G.categoryBtn:onMouseUp(x - catBtnX, y - catBtnY, true)
      platform.window:invalidate()
      return
    end

    -- Constants List Toggles
    local listY = catLabelY + lineHeight
    local avail = var.recall("available_constants") or {}
    local clist = get_constants_by_category(_G.currentConstCategory)
    for i, name in ipairs(clist) do
      local cy = listY + (i - 1) * 15
      if y >= cy and y <= cy + 15 and x >= labelX and x <= labelX + 200 then
        avail[name] = not (avail[name] == true)
        var.store("available_constants", avail)
        platform.window:invalidate()
        return
      end
    end
  end
  if theView then theView:onMouseUp(x, y) end
end

function initFontGC(gc)
	gc:setFont(font, style, fsize)
end

function getStringHeightGC(text, gc)
	initFontGC(gc)
	return gc:getStringHeight(text)
end

function getStringHeight(text)
	return platform.withGC(getStringHeightGC, text)
end

function getStringWidthGC(text, gc)
	initFontGC(gc)
	return gc:getStringWidth(text)
end

function getStringWidth(text)
	return platform.withGC(getStringWidthGC, text)
end


----------------------------------------------------------------------
--                           History Layout                           --
----------------------------------------------------------------------

-- Find the “partner” editor for a history entry
function getParME(editor)
    for i = 1, #histME2 do
        if histME2[i].editor == editor then
            return histME1[i]
        end
    end
    return nil
end

-- Map a D2Editor instance back to its MathEditor wrapper
function getME(editor)
    if fctEditor and fctEditor.editor == editor then
        return fctEditor
    else
        for i = 1, #histME1 do
            if histME1[i].editor == editor then
                return histME1[i]
            end
        end
        for i = 1, #histME2 do
            if histME2[i].editor == editor then
                return histME2[i]
            end
        end
    end
    return nil
end

-- Get the “index” of a given MathEditor in the history stack
function getMEindex(me)
    if fctEditor and fctEditor.editor == me then
        return 0
    else
        local ti = 0
        for i = #histME1, 1, -1 do
            if histME1[i] == me then
                return ti
            end
            ti = ti + 1
        end
        ti = 0
        for i = #histME2, 1, -1 do
            if histME2[i] == me then
                return ti
            end
            ti = ti + 1
        end
    end
    return 0
end

-- Global offset for history scrolling
ioffset = 0

function reposView()
    local focusedME = theView:getFocus()
    if not focusedME or focusedME == fctEditor then return end

    local index = getMEindex(focusedME)
    local maxIterations = 10 -- prevent infinite loops
    for _ = 1, maxIterations do
        local y = focusedME.y
        local h = focusedME.h
        local y0 = fctEditor.y

        if y < 0 and ioffset < index then
            ioffset = ioffset + 1
            reposME()
        elseif y + h > y0 and ioffset > index then
            ioffset = ioffset - 1
            reposME()
        else
            break
        end
    end
end

-- When a history editor resizes, lay out paired entries side-by-side
function resizeMEpar(editor, w, h)
    local pare = getParME(editor)
    if pare then
        resizeMElim(editor, w, h, pare.w + (pare.dx1 or 0) * 2)
    else
        resizeME(editor, w, h)
    end
end

-- Generic resize for any MathEditor
function resizeME(editor, w, h)
    if not editor then return end
    resizeMElim(editor, w, h, scrWidth / 2)
end

-- Internal workhorse for resizing (limits width, then calls reposME)
function resizeMElim(editor, w, h, lim)
    if not editor then return end
    local met = getME(editor)
    if met then
        met.needw = w
        met.needh = h
        w = math.max(w, 0)
        w = math.min(w, scrWidth - (met.dx1 or 0) * 2)
        if met ~= fctEditor then
            w = math.min(w, (scrWidth - lim) - 2 * (met.dx1 or 0) + 1)
        end
        h = math.max(h, strFullHeight + 8)
        met:resize(w, h)
        reposME()
        theView:invalidate()
    end
    return editor
end

-- “Scroll” and reflow all history MathEditors on screen
function reposME()
    local totalh, beforeh, visih = 0, 0, 0

    -- First, position the input editor at the bottom
    fctEditor.y = scrHeight - fctEditor.h
    theView:repos(fctEditor)

    -- Update scrollbar to fill from input up
    sbv:setVConstraints("justify", scrHeight - fctEditor.y + border)
    theView:repos(sbv)

    local y = fctEditor.y
    local i0 = math.max(#histME1, #histME2)

    for i = i0, 1, -1 do
        local h1, h2 = 0, 0
        if i <= #histME1 then h1 = math.max(h1, histME1[i].h) end
        if i <= #histME2 then h2 = math.max(h2, histME2[i].h) end
        local h = math.max(h1, h2)

        local ry
        if (i0 - i) >= ioffset then
            if y >= 0 then
                if y >= h + border then
                    visih = visih + h + border
                else
                    visih = visih + y
                end
            end
            y = y - h - border
            ry = y
            totalh = totalh + h + border
        else
            ry = scrHeight
            beforeh = beforeh + h + border
            totalh = totalh + h + border
        end

        -- Place the “expression” editor on the left
        if i <= #histME1 then
            histME1[i].y = ry
            theView:repos(histME1[i])
        end
        -- Place its paired “result” editor on the right, vertically aligned
        if i <= #histME2 then
            histME2[i].y = ry + math.max(0, h1 - h2)
            theView:repos(histME2[i])
        end
    end

    if totalh == 0 then
        sbv.pos = 0
        sbv.siz = 100
    else
        sbv.pos = beforeh * 100 / totalh
        sbv.siz = visih * 100 / totalh
    end

    theView:invalidate()
end

function initGUI()
    showEditorsBorders = false
    showHLines = true
    -- local riscas = math.evalStr("iscas()")
    -- if (riscas == "true") then iscas = true end
    local id = math.eval("sslib\\getid()")
    if id then caslib = id end
    scrWidth = platform.window:width()
    scrHeight = platform.window:height()
    if scrWidth > 0 and scrHeight > 0 then
        theView = View(platform.window)

        -- Vertical scroll bar for history
        sbv = VScrollBar(theView, 0, -1, 5, scrHeight + 1)
        sbv:setHConstraints("right", 0)
        theView:add(sbv)

        -- Input editor at bottom (MathEditor)
        fctEditor = MathEditor(theView, 2, border, scrWidth - 4 - sbv.w, 30, "")
        -- Safely set editor colors if method exists (using consistent logic from applyEditorColors)
        if fctEditor and fctEditor.editor then
            local bg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
            if fctEditor.editor.setBackgroundColor then
                fctEditor.editor:setBackgroundColor(table.unpack(bg))
            end
            local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
            local border = _G.darkMode and {100, 100, 100} or {0, 0, 0}
            if fctEditor.editor.setTextColor then
                fctEditor.editor:setTextColor(table.unpack(text))
            end
            if fctEditor.editor.setBorderColor then
                fctEditor.editor:setBorderColor(table.unpack(border))
            end
        end
        fctEditor:setHConstraints("justify", 1)
        fctEditor:setVConstraints("bottom", 1)
        fctEditor.editor:setSizeChangeListener(function(editor, w, h)
            return resizeME(editor, w, h)
        end)
        theView:add(fctEditor)
        fctEditor.result = res
        fctEditor.editor:setText("")
        fctEditor:fixContent()

        -- First-focus is input editor
        theView:setFocus(fctEditor)

        -- Sync category state and update button after GUI is ready (not in launch animation)
        syncCategoryFromStorage()
        if _G.categoryBtn then
            _G.categoryBtn.text = _G.currentConstCategory
        end
        inited = true
    end

    toolpalette.enableCopy(true)
    toolpalette.enablePaste(true)
end

function resizeGC(gc)
	scrWidth = platform.window:width()
	scrHeight = platform.window:height()
	if not inited then
		initGUI()
	end
	if inited then
		initFontGC(gc)
		strFullHeight = gc:getStringHeight("H")
		strHeight = strFullHeight - 3
		theView:resize()
		reposME()
		theView:invalidate()
	end
end

function on.resize()
	platform.withGC(resizeGC)
end

forcefocus = true

function on.activate()
  setupLaunchAnimation()
end

dispinfos = true

-- The main UI rendering phase: draws status, output, and all widgets.
-- If you’re looking for where the magic (or horror) happens, it’s here.
function on.paint(gc)
    -- Launch animation block (runs before normal UI)
    if showLaunchAnim then
        local now = timer.getMilliSecCounter()
        local dt = now - launchStartTime

        -- Hide the D2Editor while launch animation is running
        if fctEditor and fctEditor.editor then
            fctEditor.editor:setVisible(false)
        end

        -- White background
        gc:setColorRGB(255, 255, 255)
        gc:fillRect(0, 0, scrWidth, scrHeight)

        -- Ensure assets exist
        if n_logo and luacas_text then

            -- Animate n_logo: from off-screen right to x = 50
            local logoStartX = scrWidth + 100
            local logoEndX = 20
            if dt < 1000 then
                logoX = logoStartX - (dt / 1000) * (logoStartX - logoEndX)
            else
                logoX = logoEndX
            end

            -- Animate luacas_text: from off-screen right to x = close to n_logo, starts after n_logo
            local textStartX = scrWidth + 300
            -- Use the same scale factors as globals for animation
            local logoWidth, logoHeight = image.width(n_logo) * scaleFactorLogo, image.height(n_logo) * scaleFactorLogo
            local textWidth, textHeight = image.width(luacas_text) * scaleFactorText, image.height(luacas_text) * scaleFactorText
            local textEndX = logoEndX + logoWidth + 30
            if dt >= 1000 and dt < 2000 then
                local textDt = dt - 1000
                textX = textStartX - (textDt / 1000) * (textStartX - textEndX)
            elseif dt >= 2000 then
                textX = textEndX
            end

            -- Draw images if within their time windows, scale logo and text to match global scaling
            local baseY = 100
            local baseYText = 77

            if dt >= 0 then
                gc:drawImage(n_logo, logoX, baseY, logoWidth, logoHeight)
            end
            if dt >= 100 then
                gc:drawImage(luacas_text, textX, baseYText, textWidth, textHeight)
            end

            -- End animation after both complete
            if dt >= 2500 then
                showLaunchAnim = false
                -- Restore D2Editor visibility after animation ends
                if fctEditor and fctEditor.editor then
                    fctEditor.editor:setVisible(true)
                end
                timer.stop(tick)
                platform.window:invalidate()
            end
        end

        -- Remove invalidate from here; handled by timer for smooth animation
        return
    end

    if not inited then
        initGUI()
        initFontGC(gc)
        strFullHeight = gc:getStringHeight("H")
        strHeight = strFullHeight - 3
    end
    if inited then
        -- Global dark mode background
        local globalBg = _G.darkMode and {20, 20, 20} or {255, 255, 255}
        gc:setColorRGB(unpackColor(globalBg))
        gc:fillRect(0, 0, scrWidth, scrHeight)

        -- Removed display of "Last: ..." result at the top
        local obj = theView:getFocus()
        initFontGC(gc)
        if not obj then theView:setFocus(fctEditor) end
        if (forcefocus) then
            if obj == fctEditor then
                fctEditor.editor:setFocus(true)
                if fctEditor.editor:hasFocus() then forcefocus = false end
            else
                forcefocus = false
            end
        end
        if dispinfos then
            -- (Logo image block removed for customization)
        end
        -- Output string fallback for "main" view
        if true then -- "main" view block
            local output = fctEditor and fctEditor.result
            local outputStr = (output and output ~= "") and output or "(no output)"
            -- Draw output in white for dark mode, black for light mode
            gc:setColorRGB(_G.darkMode and 255 or 0, _G.darkMode and 255 or 0, _G.darkMode and 255 or 0)
            gc:drawString(outputStr, 10, scrHeight - 25, "top")
        end
        -- Draw custom settings icon button at top right if modal not open
        if not _G.showSettingsModal then
            local btnSize = 24
            local btnX = scrWidth - btnSize - 8
            local btnY = 8
            _G.settingsBtnRegion = {x = btnX, y = btnY, w = btnSize, h = btnSize}

            -- Button background, border, and icon color respecting dark mode
            local bg = _G.darkMode and {50, 50, 50} or {255, 255, 255}
            local border = _G.darkMode and {150, 150, 150} or {94, 103, 111}
            local iconColor = _G.darkMode and {220, 220, 220} or {0, 0, 0}

            gc:setColorRGB(table.unpack(bg))
            gc:fillRect(btnX, btnY, btnSize, btnSize)
            gc:setColorRGB(table.unpack(border))
            gc:drawRect(btnX, btnY, btnSize, btnSize)

            -- Centered symbol (π for settings)
            local symbol = "π"   -- Change to "." or "⋅" or "⚙" for different icons
            gc:setFont("sansserif", "b", 16)
            local textW = gc:getStringWidth(symbol)
            local textH = gc:getStringHeight(symbol)
            local centerX = btnX + (btnSize - textW) / 2
            local centerY = btnY + (btnSize - textH) / 2
            gc:setColorRGB(table.unpack(iconColor))
            gc:drawString(symbol, centerX, centerY, "top")
        end
        theView:paint(gc)

        -- Draw the bottom input area background fully respecting dark mode (after theView:paint)
        do
            -- Use pure white and black in light mode, no blue tint
            local areaBg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
            local areaBorder = _G.darkMode and {100, 100, 100} or {0, 0, 0}
            local boxY = fctEditor.y - 2
            local boxH = fctEditor.h + 4
            gc:setColorRGB(table.unpack(areaBg))
            gc:fillRect(0, boxY, scrWidth, boxH)
            gc:setColorRGB(table.unpack(areaBorder))
            gc:drawRect(0, boxY, scrWidth, boxH)
            -- Immediately override editor background, text, and border for safety and consistency
            if fctEditor and fctEditor.editor and fctEditor.editor.setBackgroundColor then
                local bg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
                local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
                local border = _G.darkMode and {100, 100, 100} or {0, 0, 0}
                fctEditor.editor:setBackgroundColor(table.unpack(bg))
                if fctEditor.editor.setTextColor then
                    fctEditor.editor:setTextColor(table.unpack(text))
                end
                if fctEditor.editor.setBorderColor then
                    fctEditor.editor:setBorderColor(table.unpack(border))
                end
            end
        end

        -- Draw settings modal if enabled (block moved to end)
    end
    -- Draw settings modal if enabled (moved here to render on top)
    if _G.showSettingsModal then
        local modalW, modalH = 200, 200
        local modalX = (scrWidth - modalW) / 2
        local modalY = (scrHeight - modalH) / 2

        local modalBg = _G.darkMode and {30, 30, 30} or {240, 240, 240}
        local modalBorder = _G.darkMode and {200, 200, 200} or {0, 0, 0}
        local modalText = _G.darkMode and {220, 220, 220} or {0, 0, 0}

        gc:setColorRGB(unpackColor(modalBg))
        gc:fillRect(modalX, modalY, modalW, modalH)
        gc:setColorRGB(unpackColor(modalBorder))
        gc:drawRect(modalX, modalY, modalW, modalH)
        gc:setColorRGB(unpackColor(modalText))
        gc:drawString("Settings", modalX + 10, modalY + 10, "top")
        gc:setFont("sansserif", "i", 9)
        gc:setColorRGB(255, 100, 100)
        gc:drawString("(Dark Mode is experimental)", modalX + 10, modalY + 26, "top")
        gc:setFont("sansserif", "r", 12)
        gc:setColorRGB(unpackColor(modalText))

        local closeBtnSize = 24
        local closeX = modalX + modalW - closeBtnSize - 6
        local closeY = modalY + 6
        _G.modalCloseBtnRegion = { x = closeX, y = closeY, w = closeBtnSize, h = closeBtnSize }
        gc:setColorRGB(200, 40, 40)
        gc:fillRect(closeX, closeY, closeBtnSize, closeBtnSize)
        gc:setColorRGB(255, 255, 255)
        gc:setFont("sansserif", "b", 16)
        local xw = gc:getStringWidth("×")
        local xh = gc:getStringHeight("×")
        gc:drawString("×", closeX + (closeBtnSize - xw) / 2, closeY + (closeBtnSize - xh) / 2, "top")

        local labelX = modalX + 10
        local labelY = modalY + 40
        local lineHeight = 28
        local btnW, btnH = 48, 22

        gc:setColorRGB(unpackColor(modalText))
        gc:setFont("sansserif", "r", 12)

        -- Decimals Toggle
        gc:drawString("Decimals:", labelX, labelY, "top")
        local btnX = labelX + gc:getStringWidth("Decimals:") + 10
        local btnY = labelY - 2
        if not _G.modalETKButton then
            _G.modalETKButton = Widgets.Button{
                text = (_G.autoDecimal and "ON" or "OFF"),
                position = Dimension(btnW, btnH),
                parent = theView,
                onAction = function(self)
                    _G.autoDecimal = not _G.autoDecimal
                    self.text = (_G.autoDecimal and "ON" or "OFF")
                    var.store("nLuaCAS_decimals_pref", _G.autoDecimal and 1 or 0)
                    platform.window:invalidate()
                end
            }
        end
        _G.modalETKButton.text = (_G.autoDecimal and "ON" or "OFF")
        _G.modalETKButton:draw(gc, btnX, btnY, btnW, btnH)

        -- Constants Toggle
        local consLabelY = labelY + lineHeight
        gc:drawString("Constants:", labelX, consLabelY, "top")
        local consBtnX = btnX
        local consBtnY = consLabelY - 2
        if not _G.constantsToggleBtn then
            _G.constantsToggleBtn = Widgets.Button{
                text = (not var.recall("constants_off") and "ON" or "OFF"),
                position = Dimension(btnW, btnH),
                parent = theView,
                onAction = function(self)
                    local new_off = not var.recall("constants_off")
                    var.store("constants_off", new_off)
                    self.text = (not new_off and "ON" or "OFF")
                    platform.window:invalidate()
                end
            }
        end
        _G.constantsToggleBtn.text = (not var.recall("constants_off") and "ON" or "OFF")
        _G.constantsToggleBtn:draw(gc, consBtnX, consBtnY, btnW, btnH)

        -- Dark Mode Toggle
        local darkLabelY = consLabelY + lineHeight
        gc:drawString("Dark Mode:", labelX, darkLabelY, "top")
        local darkBtnX = btnX
        local darkBtnY = darkLabelY - 2
        if not _G.darkModeToggleBtn then
            _G.darkModeToggleBtn = Widgets.Button{
                text = (_G.darkMode and "ON" or "OFF"),
                position = Dimension(btnW, btnH),
                parent = theView,
                onAction = function(self)
                    _G.darkMode = not _G.darkMode
                    var.store("dark_mode", _G.darkMode and 1 or 0)
                    applyEditorColors()
                    platform.window:setBackgroundColor(_G.darkMode and 0x1E1E1E or 0xFFFFFF)
                    applyEditorColors()
                    platform.window:invalidate()
                end
            }
        end
        _G.darkModeToggleBtn.text = (_G.darkMode and "ON" or "OFF")
        _G.darkModeToggleBtn:draw(gc, darkBtnX, darkBtnY, btnW, btnH)

        -- Category Selector
        local catLabelY = darkLabelY + lineHeight
        gc:drawString("Category:", labelX, catLabelY, "top")
        local catBtnX = btnX
        local catBtnY = catLabelY - 2
        local categories = get_constant_categories()
        -- Always sync currentConstCategory to storage at render time
        if not _G.categoryBtn then
            local initialCat = gui.get_current_constant_category()
            _G.currentConstCategory = initialCat
            _G.current_constant_category = initialCat
            _G.categoryBtn = Widgets.Button{
                text = initialCat,
                position = Dimension(90, btnH),
                parent = theView,
                onAction = function(self)
                    local idx = 1
                    for i, v in ipairs(categories) do
                        if v == _G.currentConstCategory then idx = i end
                    end
                    local selected = categories[(idx % #categories) + 1]
                    _G.currentConstCategory = selected
                    _G.current_constant_category = selected

                    print("[VAR] Saving category:", selected)
                    var.store("current_constant_category", selected)
                    print("[VAR] Immediately recalling category:", var.recall("current_constant_category"))

                    self.text = selected
                    platform.window:invalidate()
                    print("[STATE] Stored category to storage:", _G.currentConstCategory)
                end
            }
        end
        _G.categoryBtn.text = _G.currentConstCategory
        _G.categoryBtn:draw(gc, catBtnX, catBtnY, 90, btnH)

        -- Constants List
        local listY = catLabelY + lineHeight
        local avail = var.recall("available_constants") or {}
        local clist = get_constants_by_category(_G.currentConstCategory)

        for i, name in ipairs(clist) do
            local cy = listY + (i - 1) * 15
            local enabled = (avail == nil) or (avail[name] == true)
            gc:setColorRGB(unpackColor(modalText))
            gc:drawString((enabled and "[✓] " or "[ ] ") .. name, labelX, cy, "top")
        end
    end
end

font = "sansserif"
style = "r"
fsize = 9

scrWidth = 0
scrHeight = 0
inited = false
iscas = false
caslib = "NONE"
delim = " ≟ "
border = 3

strHeight = 0
strFullHeight = 0



-- Initialize empty history tables
histME1 = {}
histME2 = {}


-- Reminder: this is the thing that dumps both the input and result into history.
function addME(expr, res, colorHint)
	mee = MathEditor(theView, border, border, 50, 30, "")
	mee.readOnly = true
	table.insert(histME1, mee)
	mee:setHConstraints("left", border)
	mee.editor:setSizeChangeListener(function(editor, w, h)
		return resizeME(editor, w + 3, h)
	end)
	-- Set border color based on colorHint
	if colorHint == "error" then
		mee.editor:setBorderColor(0xFF0000) -- red
	else
		mee.editor:setBorderColor(0x000000)
	end
	mee.editor:setExpression("\\0el {" .. expr .. "}", 0)
	mee:fixCursor()
	mee.editor:setReadOnly(true)
	theView:add(mee)

	mer = MathEditor(theView, border, border, 50, 30, "")
    mer.result = true
    mer.readOnly = true
	table.insert(histME2, mer)
	mer:setHConstraints("right", scrWidth - sbv.x + border)
	mer.editor:setSizeChangeListener(function(editor, w, h)
				return resizeMEpar(editor, w + border, h)
	end)
	if colorHint == "error" then
		mer.editor:setBorderColor(0xFF0000) -- red
	else
		mer.editor:setBorderColor(0x000000)
	end
    local displayRes = ""
    if type(res) == "table" then
      if _G.simplify and _G.simplify.pretty_print then
        displayRes = _G.simplify.pretty_print(res)
      elseif _G.ast and _G.ast.tostring then
        displayRes = _G.ast.tostring(res)
      else
        displayRes = tostring(res)
      end
    else
      displayRes = tostring(res)
    end
    mer.editor:setExpression("\\0el {" .. displayRes .. "}", 0)
	mer:fixCursor()
	mer.editor:setReadOnly(true)
	theView:add(mer)

    -- Set dark/light mode colors for both new MathEditors (mee, mer) consistently
    local bg = _G.darkMode and {30, 30, 30} or {255, 255, 255}
    local text = _G.darkMode and {255, 255, 255} or {0, 0, 0}
    local border = _G.darkMode and {100, 100, 100} or {0, 0, 0}
    for _, editor in ipairs({mee.editor, mer.editor}) do
        if editor.setBackgroundColor then
            editor:setBackgroundColor(table.unpack(bg))
        end
        if editor.setTextColor then
            editor:setTextColor(table.unpack(text))
        end
        if editor.setBorderColor then
            editor:setBorderColor(table.unpack(border))
        end
        if editor.setOpaque then
            editor:setOpaque(true)
        end
    end

	reposME()

-- Any unhandled errors will cause LuaCAS Engine status to go NONE (red)
end
-- Make var globally accessible for parser/physics.lua
_G.var = var

function on.construction()
  setupLaunchAnimation()
end
function on.timer()
    if showLaunchAnim then
        platform.window:invalidate()
    else
        timer.stop()
    end
end
_G.gui = _G.gui or {}

function _G.gui.get_current_constant_category()
    -- Priority: in-memory global -> storage -> default
    if _G.current_constant_category and type(_G.current_constant_category) == "string" then
        return _G.current_constant_category
    end
    local cat = var.recall and var.recall("current_constant_category")
    if cat and type(cat) == "string" then
        _G.current_constant_category = cat
        return cat
    end
    return "fundamental"
end

-- End src/gui.lua

-- You included src/gui.lua—brace for unexpected side effects.

-- Build wrapping up. You included build.lua—brace for unexpected side effects.
