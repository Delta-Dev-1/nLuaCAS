-- Autogenerated build. If you’re reading this, something probably broke upstream.

-- Begin src/init.lua
-- INIT MODULE (aka the great non-working relic)
local cat = nil
-- Try to fetch the elusive 'var', which may or may not exist
local var = rawget(_G, "var") or nil

if var and type(var.recall) == "function" then
  -- Attempt to recall the holy 'current_constant_category' from persistent memory (spoiler: it usually fails)
  cat = var.recall("current_constant_category")
  if cat then
    print("[INIT] Loaded stored constant category:", cat)
    _G.current_constant_category = cat
  else
    -- Yep, as predicted, recall fell flat on its face
    print("[INIT] Recall failed or value was nil; skipping default set")
  end
else
  -- Fallback plan: pretend 'fundamental' is what we wanted all along
  print("[INIT] var.recall unavailable; using default 'fundamental'")
  _G.current_constant_category = "fundamental"
end
function on.getSymbolList()
  return { "current_constant_category" }
end

-- End src/init.lua

-- Merged src/init.lua: pray those ASTs behave.

-- Begin src/ast.lua

-- Abstract Syntax Tree (AST) library for symbolic math
-- Defines constructors, utilities, transformation tools for symbolic expressions.
-- Built to be cold, deterministic, and unreasonably explicit.

table.unpack = unpack

-- Use simplify.pretty_print for all string conversion of ASTs
local ok, simplify = pcall(require, "simplify")
if ok and simplify and simplify.pretty_print then
  function ast_tostring(ast)
    return simplify.pretty_print(ast)
  end
  ast.tostring = ast_tostring
end

-- Recursively print AST structure with optional indentation
-- For when you want to debug something by yelling at trees
function ast_debug_print(ast, indent)
    indent = indent or ""
    if type(ast) ~= "table" then
        print(indent .. tostring(ast))
        return
    end
    if ast.type then
        local desc = ast.type
        if ast.name then desc = desc .. " (" .. tostring(ast.name) .. ")" end
        print(indent .. desc)
        if ast.value ~= nil then print(indent .. "  value: " .. tostring(ast.value)) end
        if ast.name ~= nil and ast.type ~= "variable" then print(indent .. "  name: " .. tostring(ast.name)) end
        if ast.args then
            print(indent .. "  args:")
            for i, arg in ipairs(ast.args) do
                ast_debug_print(arg, indent .. "    ")
            end
        end
        -- Print left/right for binary nodes
        if ast.left then
            print(indent .. "  left:")
            ast_debug_print(ast.left, indent .. "    ")
        end
        if ast.right then
            print(indent .. "  right:")
            ast_debug_print(ast.right, indent .. "    ")
        end
    else
        for k, v in pairs(ast) do
            print(indent .. tostring(k) .. ":")
            ast_debug_print(v, indent .. "  ")
        end
    end
end

-- If you're not using these, you're probably doing something wrong
-- Node constructors (convenience)
function ast_number(val) return { type = "number", value = val } end
function ast_symbol(name) return { type = "variable", name = name } end
function ast_func(name, args) return { type = "func", name = name, args = args or {} } end
function ast_binop(op, left, right) return { type = op, left = left, right = right } end
function ast_neg(val) return { type = "neg", value = val } end
function ast_pow(base, exp) return { type = "pow", base = base, exp = exp } end
function ast_raw(str) return { type = "raw", value = str } end


-- Patch all AST node constructors to auto-set tostring metamethod
-- So you can print them and pretend you understand the output
-- Make all AST nodes print pretty with print(ast)
local ast_mt = {
  __tostring = function(self)
    if _G.ast_tostring then
      return _G.ast_tostring(self)
    elseif _G.simplify and _G.simplify.pretty_print then
      return _G.simplify.pretty_print(self)
    else
      return "[AST]"
    end
  end
}
-- Patch constructors to set metatable for all AST nodes
local function set_ast_mt(node)
  if type(node) == "table" and node.type and getmetatable(node) ~= ast_mt then
    setmetatable(node, ast_mt)
    -- Recursively set for children
    if node.args then
      for _, v in ipairs(node.args) do set_ast_mt(v) end
    end
    if node.left then set_ast_mt(node.left) end
    if node.right then set_ast_mt(node.right) end
    if node.base then set_ast_mt(node.base) end
    if node.exp then set_ast_mt(node.exp) end
    if node.value and type(node.value) == "table" then set_ast_mt(node.value) end
    -- Patch matrix rows if present
    if node.rows then
      for _, row in ipairs(node.rows) do
        for i, cell in ipairs(row) do
          row[i] = set_ast_mt(cell)
        end
      end
    end
  end
  return node
end

function ast_matrix(rows)
  return set_ast_mt({ type = "matrix", rows = rows })
end

-- Deep copy an AST — because shallow regret isn't enough
function ast_deepcopy(obj)
    if type(obj) ~= "table" then return obj end
    local res = {}
    for k, v in pairs(obj) do
        res[k] = ast_deepcopy(v)
    end
    return res
end

-- Structural equality check for ASTs
-- Tests whether two expressions are indistinguishably boring
function ast_equal(a, b)
    if type(a) ~= type(b) then return false end
    if type(a) ~= "table" then return a == b end
    for k, v in pairs(a) do
        if not ast_equal(v, b[k]) then return false end
    end
    for k, v in pairs(b) do
        if not ast_equal(v, a[k]) then return false end
    end
    return true
end

-- Depth-first traversal of the AST
-- Applies a function to every node, top-down
function ast_traverse(ast, fn)
    fn(ast)
    if type(ast) == "table" then
        if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
            for _, v in ipairs(ast.args) do
                ast_traverse(v, fn)
            end
        else
            for k, v in pairs(ast) do
                if type(v) == "table" then ast_traverse(v, fn) end
            end
        end
    end
end

-- Like traverse, but returns a new AST
-- Good for transformations and bad ideas
function ast_map(ast, fn)
    if type(ast) ~= "table" then return fn(ast) end
    local mapped = {}
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        mapped.type = ast.type
        mapped.args = {}
        if ast.name then mapped.name = ast.name end
        for i, v in ipairs(ast.args) do
            mapped.args[i] = ast_map(v, fn)
        end
    else
        for k, v in pairs(ast) do
            mapped[k] = ast_map(v, fn)
        end
    end
    return fn(mapped)
end

-- Replace all occurrences of a subtree with another
-- Think copy/paste but with slightly more guilt
function ast_substitute(ast, target, replacement)
    if ast_equal(ast, target) then return ast_deepcopy(replacement) end
    if type(ast) ~= "table" then return ast end
    local res = {}
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        res.type = ast.type
        if ast.name then res.name = ast.name end
        res.args = {}
        for i, v in ipairs(ast.args) do
            res.args[i] = ast_substitute(v, target, replacement)
        end
    else
        for k, v in pairs(ast) do
            res[k] = ast_substitute(v, target, replacement)
        end
    end
    return res
end

-- Collect all variable symbols in the AST
-- Returns a set-like table of every symbol that dares to show up
function ast_vars(ast, found)
    found = found or {}
    if type(ast) ~= "table" then return found end
    if ast.type == "variable" then found[ast.name] = true end
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        for _, v in ipairs(ast.args) do
            ast_vars(v, found)
        end
    else
        for k, v in pairs(ast) do
            ast_vars(v, found)
        end
    end
    return found
end

-- Count the total number of nodes in an AST
-- Like measuring code size, but with more branches
function ast_size(ast)
    if type(ast) ~= "table" then return 1 end
    local sum = 1
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        for _, v in ipairs(ast.args) do sum = sum + ast_size(v) end
    else
        for k, v in pairs(ast) do sum = sum + ast_size(v) end
    end
    return sum
end

-- Computes the maximum depth of the AST
-- Deep code is not necessarily smart code
function ast_depth(ast)
    if type(ast) ~= "table" then return 0 end
    local maxd = 0
    if ast.type == "add" or ast.type == "mul" or ast.type == "func" then
        for _, v in ipairs(ast.args) do
            local d = ast_depth(v)
            if d > maxd then maxd = d end
        end
    else
        for k, v in pairs(ast) do
            local d = ast_depth(v)
            if d > maxd then maxd = d end
        end
    end
    return 1 + maxd
end


-- Original AST to string printer (for debugging)
function ast_tostring_raw(ast)
    if type(ast) ~= "table" then return tostring(ast) end
    if ast.type == "number" then return tostring(ast.value) end
    if ast.type == "variable" then return ast.name end
    if ast.type == "func" then
        local args = {}
        for i, v in ipairs(ast.args) do args[i] = ast_tostring_raw(v) end
        return ast.name .. "(" .. table.concat(args, ",") .. ")"
    end
    if ast.type == "neg" then
        return "-(" .. ast_tostring_raw(ast.value) .. ")"
    end
    if ast.type == "pow" then
        return "(" .. ast_tostring_raw(ast.base) .. ")^(" .. ast_tostring_raw(ast.exp) .. ")"
    end
    if ast.type == "add" then
        local parts = {}
        for i, v in ipairs(ast.args) do
            parts[i] = ast_tostring_raw(v)
        end
        return "(" .. table.concat(parts, " + ") .. ")"
    end
    if ast.type == "sub" then
        return "(" .. ast_tostring_raw(ast.left) .. ") - (" .. ast_tostring_raw(ast.right) .. ")"
    end
    if ast.type == "mul" then
        local parts = {}
        for i, v in ipairs(ast.args) do
            parts[i] = ast_tostring_raw(v)
        end
        -- Nice form: 2x, x2 for two args, otherwise with *
        if #parts == 2 then
            local a, b = ast.args[1], ast.args[2]
            if ast_is_number(a) and ast_is_variable(b) then
                return tostring(a.value) .. parts[2]
            elseif ast_is_variable(a) and ast_is_number(b) then
                return parts[1] .. tostring(b.value)
            end
        end
        return table.concat(parts, "*")
    end
    if ast.type == "div" then
        return "(" .. ast_tostring_raw(ast.left) .. ")/(" .. ast_tostring_raw(ast.right) .. ")"
    end
    if ast.type == "raw" then
        return "[RAW:" .. tostring(ast.value) .. "]"
    end
    -- fallback
    local str = "{" .. (ast.type or "?")
    for k, v in pairs(ast) do
        if k ~= "type" then str = str .. "," .. k .. "=" .. ast_tostring_raw(v) end
    end
    return str .. "}"
end

-- AST node type test helpers
function ast_is_number(node)
    return type(node) == "table" and node.type == "number"
end
function ast_is_variable(node)
    return type(node) == "table" and node.type == "variable"
end
function ast_is_func(node, fname)
    return type(node) == "table" and node.type == "func" and (not fname or node.name == fname)
end
function ast_is_op(node, op)
    return type(node) == "table" and node.type == op
end


-- Evaluate the AST numerically if it's purely numeric
-- Warning: does not handle symbolic stupidity
function ast_eval_numeric(ast, env)
    env = env or {}
    if ast.type == "number" then return ast.value end
    if ast.type == "variable" then
        return env[ast.name] or error("Unbound variable: " .. tostring(ast.name))
    end
    if ast.type == "func" then
        local argv = {}
        for i, v in ipairs(ast.args) do
            argv[i] = ast_eval_numeric(v, env)
        end
        if math[ast.name] then
            return math[ast.name](table.unpack(argv))
        elseif ast.name == "ln" then
            return math.log(argv[1])
        elseif ast.name == "log" then
            return math.log10(argv[1])
        elseif ast.name == "gamma" then
            local n = argv[1]
            if n > 0 and math.floor(n) == n then
                local factorial = 1
                for i = 1, n - 1 do
                    factorial = factorial * i
                end
                return factorial
            elseif n == 0.5 then
                return math.sqrt(math.pi)
            else
                error("Gamma function not implemented for value: " .. tostring(n))
            end
        else
            error("Unknown function: " .. ast.name)
        end
    end
    if ast.type == "add" then
        local sum = 0
        for _, v in ipairs(ast.args) do
            sum = sum + ast_eval_numeric(v, env)
        end
        return sum
    end
    if ast.type == "sub" then
        return ast_eval_numeric(ast.left, env) - ast_eval_numeric(ast.right, env)
    end
    if ast.type == "mul" then
        local prod = 1
        for _, v in ipairs(ast.args) do
            prod = prod * ast_eval_numeric(v, env)
        end
        return prod
    end
    if ast.type == "div" then
        return ast_eval_numeric(ast.left, env) / ast_eval_numeric(ast.right, env)
    end
    if ast.type == "pow" then
        return ast_eval_numeric(ast.base, env) ^ ast_eval_numeric(ast.exp, env)
    end
    if ast.type == "neg" then
        return -ast_eval_numeric(ast.value, env)
    end
    error("Unsupported node in ast_eval_numeric: " .. tostring(ast.type))
end

-- Pattern match against an AST using a pattern
-- Binds variables, fails if it sees something it doesn’t like
function ast_match(pattern, ast, bindings)
    bindings = bindings or {}
    if type(pattern) ~= "table" then
        if pattern == ast then return bindings else return nil end
    end
    if pattern.var then
        if bindings[pattern.var] then
            return ast_equal(bindings[pattern.var], ast) and bindings or nil
        else
            bindings[pattern.var] = ast
            return bindings
        end
    end
    if type(ast) ~= "table" then return nil end
    if pattern.type and pattern.type ~= ast.type then return nil end
    if (pattern.type == "add" or pattern.type == "mul" or pattern.type == "func") and pattern.args then
        if #pattern.args ~= #ast.args then return nil end
        for i = 1, #pattern.args do
            local sub = ast_match(pattern.args[i], ast.args[i], bindings)
            if not sub then return nil end
            bindings = sub
        end
    else
        for k, v in pairs(pattern) do
            if k ~= "var" and k ~= "args" then
                local sub = ast_match(v, ast[k], bindings)
                if not sub then return nil end
                bindings = sub
            end
        end
    end
    return bindings
end

-- Export all as ast.*
ast = {
    number = ast_number,
    symbol = ast_symbol,
    variable = ast_symbol,
    func = ast_func,
    binop = ast_binop,
    neg = ast_neg,
    pow = ast_pow,
    raw = ast_raw,
    matrix = ast_matrix,

    -- Shorthand binary operation constructors
    add = function(...) return { type = "add", args = {...} } end,
    sub = function(l, r) return ast_binop("sub", l, r) end,
    mul = function(...) return { type = "mul", args = {...} } end,
    div = function(l, r) return ast_binop("div", l, r) end,
    pow = function(l, r) return ast_pow(l, r) end,
    neg = ast_neg,
    eq = function(left, right) return { type = "equation", left = left, right = right } end,

    deepcopy = ast_deepcopy,
    equal = ast_equal,
    traverse = ast_traverse,
    map = ast_map,
    substitute = ast_substitute,
    vars = ast_vars,
    size = ast_size,
    depth = ast_depth,
    tostring = ast_tostring,

    is_number = ast_is_number,
    is_variable = ast_is_variable,
    is_func = ast_is_func,
    is_op = ast_is_op,

    eval_numeric = ast_eval_numeric,
    match = ast_match,
    debug_print = ast_debug_print,
}

-- Flattens nested additive/multiplicative trees
-- Useful for canonicalization, sorting, or general misuse
function ast_flatten_add(node)
    if not ast_is_op(node, "add") then return { node } end
    local parts = {}
    local function collect(n)
        if ast_is_op(n, "add") then
            for _, v in ipairs(n.args) do
                collect(v)
            end
        else
            table.insert(parts, n)
        end
    end
    collect(node)
    table.sort(parts, function(a, b) return ast_tostring(a) < ast_tostring(b) end)
    return parts
end

-- Flattens nested additive/multiplicative trees
-- Useful for canonicalization, sorting, or general misuse
function ast_flatten_mul(node)
    if not ast_is_op(node, "mul") then return { node } end
    local parts = {}
    local function collect(n)
        if ast_is_op(n, "mul") then
            for _, v in ipairs(n.args) do
                collect(v)
            end
        else
            table.insert(parts, n)
        end
    end
    collect(node)
    table.sort(parts, function(a, b) return ast_tostring(a) < ast_tostring(b) end)
    return parts
end

ast.flatten_add = ast_flatten_add
ast.flatten_mul = ast_flatten_mul

-- Generic AST node constructor
function ast_node(typ, opts)
    local node = { type = typ }
    for k, v in pairs(opts or {}) do
        node[k] = v
    end
    return node
end
ast.node = ast_node
_G.ast_node = ast.node
_G.ast = ast




_G.ast_debug_print = ast_debug_print


-- Patch ast.eval_numeric to support physics functions without cyclic load errors
do
  local old_eval_numeric = ast.eval_numeric

  function ast.eval_numeric(node, env)
    env = env or {}
    -- Lazy-load physics module to break cyclic dependency
    local physics = _G.physics or require("physics")

    if node.type == "func" then
      local args_eval = {}
      for i, arg in ipairs(node.args) do
        args_eval[i] = ast.eval_numeric(arg, env)
      end

      if math[node.name] then
        return math[node.name](table.unpack(args_eval))
      end

      if node.name == "ln" then return math.log(args_eval[1]) end
      if node.name == "log" then return math.log10(args_eval[1]) end
      if node.name == "gamma" then
        local n = args_eval[1]
        if n > 0 and math.floor(n) == n then
          local fact = 1
          for i = 1, n - 1 do fact = fact * i end
          return fact
        elseif n == 0.5 then
          return math.sqrt(math.pi)
        else
          error("Gamma function not implemented for value: " .. tostring(n))
        end
      end

      -- Delegate to physics evaluation if available
      local phys_val = physics.eval_physics_func(node.name, node.args)
      if phys_val ~= nil then
        return ast.eval_numeric(phys_val, env)
      end

      error("Unknown function: " .. tostring(node.name))
    else
      return old_eval_numeric(node, env)
    end
  end

  ast.eval_numeric = ast.eval_numeric
end

-- End src/ast.lua

-- Just added src/ast.lua—hope your logic is watertight.

-- Begin src/errors.lua
-- errors.lua: handles sarcastic diagnostics for the criminally wrong

_G.errors = {}

_G.errors.custom = {
  ["simplify(human_emotion)"] = {
  "simplify(human_emotion): undefined behavior. Try numbing instead.",
  "expression too irrational. Can't simplify that.",
  "simplify(): emotions do not cancel out algebraically."
},

["solve(economy)"] = {
  "solution too volatile. Try again next fiscal cycle.",
  "solve(economy): infinite variables, zero stability.",
  "output is imaginary. So is the value of your currency."
},

["int(motivation)"] = {
  "area under the curve is... flat. Burnout detected.",
  "integrated result: exhaustion + C",
  "int(motivation): indefinite. Like your deadlines."
},

["diff(common_sense)"] = {
  "∂/∂x(common_sense) = 0. It’s a constant…ly missing.",
  "derivative undefined. Assumed extinct.",
  "diff(): nothing to differentiate. It was never there."
},

["subs(truth, society, propaganda)"] = {
  "truth replaced with propaganda. Output looks familiar.",
  "subs(): societal override complete. Result: fiction.",
  "did you mean: rationalize(disaster)?"
},

["solve(existence = absurdity)"] = {
  "solve(): contradiction detected. Camus would approve.",
  "equation tautological. Output is void.",
  "solution: undefined. Please consult your local philosopher."
},

["tokenize(entropy)"] = {
  "tokenize(): too much randomness. Try less chaos.",
  "failed to classify: input appears stochastic.",
  "token stream is melting. So is reality."
},

["parse(hope)"] = {
  "parser found optimism. Immediately rejected.",
  "hope is not a valid token.",
  "parse(): unexpected symbol. Are you dreaming again?"
},
  ["simplify(existence)"] = {
    "undefined. Like your weekend plans.",
    "simplify(existence): returns 'absurd'. Camus approves.",
    "Trying to simplify existence? Good luck with that."
  },
  ["solve(life)"] = {
    "solution not found. Try philosophy().",
    "solve(life): result is complex. No real solutions.",
    "solve(life): nice try. Meaning remains undefined."
  },
  ["diff(nothing)"] = {
    "finally, something you can't screw up.",
    "∂/∂nothing = nothing. Revolutionary.",
    "You differentiated nothing. Ambitious."
  },
  ["d/dx(nothing))"] = {
    "d/dx(nothing): you're trying too hard and also failing.",
    "diff(expr, var): both required. Unlike your faith in syntax.",
    "You wrote a fraction that looks like math. But isn't."
  },
  ["int(hopelessness)"] = {
    "integrated result: depression + C",
    "area under the curve? it's flatlining.",
    "hope cancelled. integration complete."
  },
  ["subs(sanity, reality, chaos)"] = {
    "sanity → chaos applied. welcome to symbolic algebra.",
    "substitution complete. your mind is now unstable.",
    "why did you do that? too late now."
  },
  ["gcd(404, not_found)"] = {
    "Missing operand. Or file.",
    "gcd error: inputs not located.",
    "check your gcd privileges."
  }
}

function _G.errors.get(key)
  local val = _G.errors.custom and _G.errors.custom[key]
  if type(val) == "table" then
    return val[math.random(#val)]
  else
    return val
  end
end

function _G.errors.invalid(fn, hint)
  local base = {
    simplify = {
      default = "simplify() expects an expression. Yours was... questionable.",
      type = "simplify(): expected expression, got a math-themed prank."
    },
    solve = {
      default = "solve() needs an equation. Not interpretive math dance.",
      missing_eq = "solve(): that’s not an equation. It’s a suggestion.",
      empty = "solve(): nothing to solve. Existential, huh?"
    },
    subs = {
      default = "subs(expr, var, val): you're missing something. Probably 'val'.",
      args = "subs(): three arguments please. This isn’t blackjack.",
      type = "subs(): expected AST, got a philosophical void."
    },
    int = {
      default = "int(expr) wants an integrand. You gave hope.",
      type = "int(): we can’t integrate that. Not even symbolically."
    },
    diff = {
      default = "diff(expr, var): both required. Unlike your faith in syntax.",
      args = "diff(): expression and variable are not optional accessories.",
      type = "diff(): we differentiate functions, not vibes."
    },
    factor = {
      default = "factor(expr): we can’t factor air.",
      type = "factor(): expected expression. Got nihilism instead."
    },
    gcd = {
      default = "gcd(a, b): you forgot one. Math is a duet.",
      args = "gcd(): needs two numbers. This isn’t solo algebra.",
      type = "gcd(): expected integers. Got chaos."
    },
    lcm = {
      default = "lcm(a, b): needs two arguments. Try harder.",
      type = "lcm(): expected numeric inputs. Yours are... mysterious."
    },
    trigid = {
      default = "trigid(expr): not just for trig dreams.",
      arg = "trigid(): you forgot the trig part. Again."
    },
    parse = {
      default = "parse(): failed to understand your expression. Again.",
      unexpected = "parse(): unexpected token. Are you freestyling?"
    },
    tokenize = {
      default = "tokenize(): found something it couldn't classify. Like your handwriting.",
      badchar = "tokenize(): unknown character. Probably cursed."
    },
    compile = { default = "compile(): could not compile. You should feel bad." },
    eval = { default = "eval(): tried. Failed. Retrying won’t help." },
    ast = { default = "AST error: malformed tree. Roots missing." },
    gui = { default = "GUI error: screen logic borked. Blame the OS. Or you." },
    input = { default = "Input error: at least *pretend* to enter valid math." },
    runtime = { default = "Runtime error: no, seriously, what did you expect?" },
    default = { default = "Something broke. Again. This is why we can’t have nice things." }
  }

  local fnBlock = base[fn] or base["default"]
  if type(fnBlock) == "table" then
    return (hint and fnBlock[hint]) or fnBlock.default or base["default"].default
  else
    return fnBlock
  end
end

-- intentionally not returning anything because this file is concatenated

-- End src/errors.lua

-- Glued in src/errors.lua. Now question why you needed it.

-- Begin src/parser.lua
-- parser.lua: Because writing your own parser is the best way to avoid happiness.
--
-- For those who care about "compatibility": yes, the API is still the same.
--   tokenize(expr) => {tokens} -- like anyone remembers the output.
--   buildAST(tokens) => ast    -- because trees are the only way to understand math.
--   parseExpr(tokens, idx) => ast, nextIdx -- because recursion is fun until it isn't.
--
-- Now with more "features" you didn't ask for: error nagging, big numbers, functions, brackets, sneaky multiplication, negative numbers, and, because why not, matrix parsing.

local parser = {}
local init = rawget(_G, "init")
local errors = rawget(_G, "errors") or {
  invalid = function(fn, hint)
    return "parse(" .. (fn or "?") .. "): " .. (hint or "unknown error. also: _G.errors was nil.")
  end
}

-- Because seeing your AST in tree form is the only joy you'll get today.
local function print_ast(ast, indent)
  indent = indent or ""
  if type(ast) ~= "table" then
    print(indent .. tostring(ast))
    return
  end
  if ast.type then
    local desc = ast.type
    if ast.name then desc = desc .. " (" .. tostring(ast.name) .. ")" end
    print(indent .. desc)
    if ast.value ~= nil then print(indent .. "  value: " .. tostring(ast.value)) end
    if ast.name ~= nil and ast.type ~= "variable" then print(indent .. "  name: " .. tostring(ast.name)) end
    if ast.args then
      print(indent .. "  args:")
      for i, arg in ipairs(ast.args) do
        print_ast(arg, indent .. "    ")
      end
    end
    if ast.rows then
      print(indent .. "  rows:")
      for i, row in ipairs(ast.rows) do
        print(indent .. "    row " .. i .. ":")
        for j, elem in ipairs(row) do
          print_ast(elem, indent .. "      ")
        end
      end
    end
    if ast.base then
      print(indent .. "  base:")
      print_ast(ast.base, indent .. "    ")
    end
    if ast.exp then
      print(indent .. "  exp:")
      print_ast(ast.exp, indent .. "    ")
    end
    if ast.left then
      print(indent .. "  left:")
      print_ast(ast.left, indent .. "    ")
    end
    if ast.right then
      print(indent .. "  right:")
      print_ast(ast.right, indent .. "    ")
    end
  else
    for k, v in pairs(ast) do
      print(indent .. tostring(k) .. ":")
      print_ast(v, indent .. "  ")
    end
  end
end
parser.print_ast = print_ast
_G.print_ast = print_ast

-- Tokenizer: Because parsing math without slicing it into tiny pieces would be too easy.
do
  local function is_space(c) return c:match('%s') end
  local function is_digit(c) return c:match('%d') end
  local function is_alpha(c)
    return c:match("[%aα-ωΑ-ΩπΠμ]") ~= nil
  end

  -- Tokenizes your math misery into little fragments.
  -- Yes, it does implicit multiplication, because apparently writing '*' is too much work.
  -- Now with matrix support, because someone asked for it. Probably.
  function parser.tokenize(expr)
    local tokens = {}
    local i = 1
    while i <= #expr do
      local c = expr:sub(i,i)
      if is_space(c) then
        i = i + 1
      elseif is_digit(c) or (c == '.' and is_digit(expr:sub(i+1,i+1))) then
        -- Number: because apparently people can't just use variables.
        local num = c
        i = i + 1
        while i <= #expr and (is_digit(expr:sub(i,i)) or expr:sub(i,i) == '.') do
          num = num .. expr:sub(i,i)
          i = i + 1
        end
        table.insert(tokens, {type="number", value=tonumber(num)})
      elseif is_alpha(c) then
        -- Identifier or function: because 'x' is so much more meaningful than 42.
        local ident = c
        i = i + 1
        while i <= #expr and (is_alpha(expr:sub(i,i)) or is_digit(expr:sub(i,i))) do
          ident = ident .. expr:sub(i,i)
          i = i + 1
        end
        table.insert(tokens, {type="ident", value=ident})
        -- Lookahead: because humans can't be bothered to write multiplication symbols like civilized beings.
        -- (No action needed here; implicit multiplication insertion logic is below and will be updated)
      -- Greek letters: because Unicode exists to make parsing harder.
      elseif c:match('[\226\206\177-\226\206\191\206\177-\206\191\207\128-\207\191\208\128-\208\191\209\128-\209\191]') then
        -- Already handled by symbol_map in parser.parse; fall through for now.
        -- But if you want to treat Greek as variables, you could add logic here.
        -- For now, treat as unknown.
        error(errors.invalid("tokenize", "unexpected Greek letter: " .. c))
      elseif c:match('[₀₁₂₃₄₅₆₇₈₉]') then
        -- Subscript numbers because you just had to make notation harder.
        local sub_map = { ['₀']='0', ['₁']='1', ['₂']='2', ['₃']='3', ['₄']='4',
                          ['₅']='5', ['₆']='6', ['₇']='7', ['₈']='8', ['₉']='9' }
        local base = ''
        while i <= #expr and expr:sub(i,i):match('[₀₁₂₃₄₅₆₇₈₉]') do
          base = base .. sub_map[expr:sub(i,i)]
          i = i + 1
        end
        table.insert(tokens, {type="subscript", value=tonumber(base)})
      -- String literal support: because math needs more drama.
      elseif c == '"' or c == "'" then
        local quote = c
        local j = i + 1
        local str = ''
        while j <= #expr and expr:sub(j,j) ~= quote do
          str = str .. expr:sub(j,j)
          j = j + 1
        end
        if j > #expr then
          error(errors.invalid('tokenize', 'unterminated string literal (congrats, you broke the parser)'))
        end
        table.insert(tokens, {type='string', value=str})
        i = j + 1
      elseif c == ',' then
        table.insert(tokens, {type=",", value=","})
        i = i + 1
      elseif c == '(' or c == ')' then
        table.insert(tokens, {type=c})
        i = i + 1
      -- Because someone thought 2D arrays should be readable.
      elseif c == '[' or c == ']' then
        table.insert(tokens, {type=c})
        i = i + 1
      elseif c == '+' or c == '-' or c == '*' or c == '/' or c == '^' or c == '!' then
        table.insert(tokens, {type="op", value=c})
        i = i + 1
      elseif c == '=' then
        table.insert(tokens, {type="equals", value="="})
        i = i + 1
      else
        error(errors.invalid("tokenize", "unknown character: " .. c .. " (nice try)"))
      end
    end
    -- Insert '*' for things like '2x' or '3(x+1)' because writing '*' is apparently too mainstream.
    -- Now also handles '2[[1,2],[3,4]]', because you just had to make it harder.
    local j = 2
    while j <= #tokens do
      local t1, t2 = tokens[j-1], tokens[j]
      -- Only insert * between number or ')' and ident or '(' or '[' (not between ident and '(')
      if (t1.type == 'number' or t1.type == ')' ) and
         (t2.type == 'ident' or t2.type == '(' or t2.type == '[') then
        table.insert(tokens, j, {type="op", value="*"})
        j = j + 1
      end
      j = j + 1
    end
    return tokens
  end
end

-- Parser: Because recursion is the only way to feel alive.
--   Now with precedence, unary minus, function calls, and, of course, matrices.

-- Matrix parsing: because spreadsheets weren't enough.
local function parse_matrix(tokens, idx)
  -- Expect '[' to start, because obviously that's how math works now.
  assert(tokens[idx] and tokens[idx].type == '[', 
         errors.invalid("parse_matrix", "expected '[' to start matrix (did you mean to type something else?)"))
  
  local i = idx + 1
  
  -- Handle empty matrix case, because someone just loves empty brackets.
  if tokens[i] and tokens[i].type == ']' then
    return {type="matrix", rows={}}, i + 1
  end
  
  -- Decide if it's a 1D vector or a 2D matrix, because ambiguity is fun.
  -- Look ahead to see if first element is '['
  if tokens[i] and tokens[i].type == '[' then
    -- This is a 2D matrix [[...], [...]] -- because 1D was too boring.
    local rows = {}
    
    -- Parse first row, because why not nest things more.
    i = i + 1 -- skip '['
    local current_row = {}
    
    -- Parse elements in first row, because commas are the new semicolons.
    if tokens[i] and tokens[i].type ~= ']' then
      local elem, ni = parser.parseExpr(tokens, i)
      table.insert(current_row, elem)
      i = ni
      
      while tokens[i] and tokens[i].type == ',' do
        local next_elem
        next_elem, i = parser.parseExpr(tokens, i + 1)
        table.insert(current_row, next_elem)
      end
    end
    
    -- Expect ']' to end first row (because matching brackets is a core life skill).
    assert(tokens[i] and tokens[i].type == ']', 
           errors.invalid("parse_matrix", "expected ']' to end matrix row (or maybe just give up?)"))
    i = i + 1
    
    table.insert(rows, current_row)
    local expected_cols = #current_row
    
    -- Parse remaining rows, because you thought one row was enough? Ha.
    while tokens[i] and tokens[i].type == ',' do
      i = i + 1 -- skip comma
      
      -- Parse next row, because every matrix needs more rows.
      assert(tokens[i] and tokens[i].type == '[', 
             errors.invalid("parse_matrix", "expected '[' to start matrix row (you broke the symmetry)"))
      i = i + 1
      
      local row = {}
      
      -- Parse elements in this row, because repetition is the spice of life.
      if tokens[i] and tokens[i].type ~= ']' then
        local elem, ni = parser.parseExpr(tokens, i)
        table.insert(row, elem)
        i = ni
        
        while tokens[i] and tokens[i].type == ',' do
          local next_elem
          next_elem, i = parser.parseExpr(tokens, i + 1)
          table.insert(row, next_elem)
        end
      end
      
      -- Expect ']' to end this row (because brackets are your new best friend).
      assert(tokens[i] and tokens[i].type == ']', 
             errors.invalid("parse_matrix", "expected ']' to end matrix row (math is hard)"))
      i = i + 1
      
      -- Check row length consistency, because apparently rectangular matrices are a thing.
      assert(#row == expected_cols, 
             errors.invalid("parse_matrix", "matrix rows must have same number of columns (nice try)"))
      
      table.insert(rows, row)
    end
    
    -- Expect ']' to end matrix, because you love counting brackets.
    assert(tokens[i] and tokens[i].type == ']', 
           errors.invalid("parse_matrix", "expected ']' to end matrix (you almost made it)"))
    
    return {type="matrix", rows=rows}, i + 1
  else
    -- This is a 1D vector [a,b,c] - because 2D was too much work.
    local row = {}
    
    -- Parse elements, because lists are just sad matrices.
    if tokens[i] and tokens[i].type ~= ']' then
      local elem, ni = parser.parseExpr(tokens, i)
      table.insert(row, elem)
      i = ni
      
      while tokens[i] and tokens[i].type == ',' do
        local next_elem
        next_elem, i = parser.parseExpr(tokens, i + 1)
        table.insert(row, next_elem)
      end
    end
    
    -- Expect ']' to end vector (don't forget your closing bracket, rebel).
    assert(tokens[i] and tokens[i].type == ']', 
           errors.invalid("parse_matrix", "expected ']' to end vector (you just had to forget, didn't you?)"))
    
    return {type="matrix", rows={row}}, i + 1
  end
end

-- Handles literals, variables, function calls, parentheses, matrices, and unary minus.
-- Also wraps things in factorials if someone thought 'x!' was a good idea. Because, why not.
local function make_var(x) return {type="variable", name=x} end -- Because variables need love too.

-- Because parsing the "primary" is more important than parsing the "secondary".
local function parse_primary(tokens, idx)
  local tok = tokens[idx]
  if not tok then return nil, idx end

  local function wrap_factorial(node, i)
    if tokens[i] and tokens[i].type == "op" and tokens[i].value == "!" then
      return {
        type = "func",
        name = "factorial",
        args = { node }
      }, i + 1
    end
    return node, i
  end -- Because factorials are what everyone wanted.

  if tok.type == "number" then
    return wrap_factorial({type="number", value=tok.value}, idx+1)
  elseif tok.type == "ident" then
    if tokens[idx+1] and tokens[idx+1].type == '(' then
      -- Function call: because variables alone were too simple.
      local args = {}
      local i = idx + 2
      if tokens[i] and tokens[i].type ~= ')' then
        local arg, ni = parser.parseExpr(tokens, i)
        table.insert(args, arg)
        i = ni
        while tokens[i] and tokens[i].type == ',' do
          local arg2
          arg2, i = parser.parseExpr(tokens, i+1)
          table.insert(args, arg2)
        end
      end
      assert(tokens[i] and tokens[i].type == ')', errors.invalid("parse", "expected ')' after function call (parentheses are hard)"))
      -- Try to immediately evaluate trig functions for numeric input, because why not do more work for you.
      local fcall = {type="func", name=tok.value, args=args}
      if _G.trig and _G.trig.eval_trig_func then
        local trig_result = _G.trig.eval_trig_func(tok.value, args[1])
        if trig_result then
          return wrap_factorial(trig_result, i+1)
        end
      end
      return wrap_factorial(fcall, i+1)
    else
      if _G.var and type(_G.var) == "function" and _G.var("constants_off") then
  if _G.Constants and _G.Constants[tok.value] then
  return wrap_factorial({type = "constant", name = tok.value}, idx + 1)
else
  return wrap_factorial(make_var(tok.value), idx + 1)
end
end
      -- Only treat as variable if not followed by '(', because ambiguity is fun.
      if _G.Constants and _G.Constants[tok.value] then
  return wrap_factorial({type = "constant", name = tok.value}, idx + 1)
else
  return wrap_factorial(make_var(tok.value), idx + 1)
end
    end
  elseif tok.type == '(' then
    local node, ni = parser.parseExpr(tokens, idx+1)
    assert(tokens[ni] and tokens[ni].type == ')', errors.invalid("parse", "expected ')' (because you can't count)"))
    return wrap_factorial(node, ni+1)
  -- Because matrices are the new black.
  elseif tok.type == '[' then
    local matrix, ni = parse_matrix(tokens, idx)
    return wrap_factorial(matrix, ni)
  elseif tok.type == 'string' then
    -- String literal (for when you want to confuse your math parser).
    return {type='string', value=tok.value}, idx + 1
  elseif tok.type == "op" and tok.value == '-' then
    -- Unary minus, because negativity is important.
    local expr, ni = parser.parseExpr(tokens, idx+1)
    return wrap_factorial({type="neg", value=expr}, ni)
  else
    error(errors.invalid("parse", "unexpected token at parse_primary: " .. (tok.type or '?') .. " (surprise!)"))
  end
end

-- Parses exponentiation. Right-associative, because math teachers said so.
local function parse_power(tokens, idx)
  local left, i = parse_primary(tokens, idx)
  while tokens[i] and tokens[i].type == "op" and tokens[i].value == '^' do
    local right
    right, i = parse_primary(tokens, i+1)
    left = {type="pow", base=left, exp=right}
  end
  return left, i
end

-- Handles multiplication, division, and reciprocal logic.
-- Because a/b is really just a*1/b, right? (Sure, let's pretend.)
local function parse_term(tokens, idx)
  -- Parse the first factor, because you have to start somewhere.
  local factors = {}
  local i = idx
  local node, ni = parse_power(tokens, i)
  table.insert(factors, node)
  i = ni
  while tokens[i] and tokens[i].type == "op" and (tokens[i].value == '*' or tokens[i].value == '/') do
    local op = tokens[i].value
    local right
    right, i = parse_power(tokens, i+1)
    if op == '*' then
      table.insert(factors, right)
    else
      -- Division: because why not multiply by the reciprocal and confuse everyone.
      table.insert(factors, {type="pow", base=right, exp={type="number", value=-1}})
    end
  end
  if #factors == 1 then
    return factors[1], i
  else
    return {type="mul", args=factors}, i
  end
end

-- The real entry point for expressions. Supports + and -, but mostly supports your suffering.
-- Folds everything into a single add tree so simplify() doesn't go on strike.
function parser.parseExpr(tokens, idx)
  idx = idx or 1
  local terms = {}
  local signs = {}
  local node, i = parse_term(tokens, idx)
  table.insert(terms, node)
  table.insert(signs, 1)
  while tokens[i] and tokens[i].type == "op" and (tokens[i].value == '+' or tokens[i].value == '-') do
    local op = tokens[i].value
    local right
    right, i = parse_term(tokens, i+1)
    if op == '+' then
      table.insert(terms, right)
      table.insert(signs, 1)
    else
      -- Instead of wrapping just numbers in neg, wrap the whole right term
      table.insert(terms, right)
      table.insert(signs, -1)
    end
  end
  -- Flatten into n-ary add, handling subtraction as add of negative (because why not make it harder?)
  if #terms == 1 then
    if tokens[i] and tokens[i].type == "equals" then
      local rhs, next_i = parser.parseExpr(tokens, i + 1)
      return {type = "equation", left = node, right = rhs}, next_i -- Because equations make everything more complicated.
    end
    return node, i
  else
    local args = {}
    for j = 1, #terms do
      if signs[j] == 1 then
        table.insert(args, terms[j])
      else
        table.insert(args, {type="neg", value=terms[j]})
      end
    end
    local add_node = {type="add", args=args}
    if tokens[i] and tokens[i].type == "equals" then
      local rhs, next_i = parser.parseExpr(tokens, i + 1)
      return {type = "equation", left = add_node, right = rhs}, next_i -- Because why stop at arithmetic when you can do algebra?
    end
    return add_node, i
  end
end

-- Wraps parseExpr and checks for leftovers.
-- If you forgot a bracket, this will find it and yell at you.
function parser.buildAST(tokens)
  local ast, idx = parser.parseExpr(tokens, 1)
  if idx <= #tokens then
    error(errors.invalid("parse", "unexpected " .. tostring(tokens[idx].type or "?") .. " (you left something behind)"))
  end
  return ast
end

-- The main parse function: because you needed one more layer of indirection.
function parser.parse(expr)
  if _G.gui and _G.gui.get_current_constant_category then
    local cat = _G.gui.get_current_constant_category()
    if _G.var and _G.var.store then
      _G.var.store("current_constant_category", cat)
    end
  end
  -- Apply UTF-8 constant substitutions before tokenization
  if _G.Constants then
    for symbol, const in pairs(_G.Constants) do
      if type(symbol) == "string" and #symbol == 1 and expr:find(symbol, 1, true) then
        expr = expr:gsub(symbol, function(m)
          if _G.Constants[m] and _G.Constants[m].name then
            return _G.Constants[m].name
          elseif _G.Constants[m] then
            -- fallback: use key itself if name is missing
            for k,v in pairs(_G.Constants) do
              if v == _G.Constants[m] then return k end
            end
          end
          return m
        end)
      end
    end
  end
  -- Preprocess common TI symbols to Lua identifiers (because why use one alphabet when you can use two?)
  local symbol_map = {
    -- Greek letters (lowercase)
    ['α'] = 'alpha', ['β'] = 'beta', ['γ'] = 'gamma', ['δ'] = 'delta', ['ε'] = 'epsilon',
    ['ζ'] = 'zeta', ['η'] = 'eta', ['θ'] = 'theta', ['ι'] = 'iota', ['κ'] = 'kappa',
    ['λ'] = 'lambda', ['μ'] = 'mu', ['ν'] = 'nu', ['ξ'] = 'xi', ['ο'] = 'omicron',
    ['π'] = 'pi', ['ρ'] = 'rho', ['σ'] = 'sigma', ['τ'] = 'tau', ['φ'] = 'phi',
    ['χ'] = 'chi', ['ψ'] = 'psi', ['ω'] = 'omega',
    
    -- Greek letters (uppercase)
    ['Α'] = 'Alpha', ['Β'] = 'Beta', ['Γ'] = 'Gamma', ['Δ'] = 'Delta', ['Ε'] = 'Epsilon',
    ['Ζ'] = 'Zeta', ['Η'] = 'Eta', ['Θ'] = 'Theta', ['Ι'] = 'Iota', ['Κ'] = 'Kappa',
    ['Λ'] = 'Lambda', ['Μ'] = 'Mu', ['Ν'] = 'Nu', ['Ξ'] = 'Xi', ['Ο'] = 'Omicron',
    ['Π'] = 'Pi', ['Ρ'] = 'Rho', ['Σ'] = 'Sigma', ['Τ'] = 'Tau', ['Φ'] = 'Phi',
    ['Χ'] = 'Chi', ['Ψ'] = 'Psi', ['Ω'] = 'Omega',
    
    -- Arithmetic operators
    ['±'] = 'plusminus', ['×'] = 'times', ['÷'] = 'divide', ['•'] = 'dot', 
    ['⁄'] = 'fraction', ['√'] = 'sqrt', ['∛'] = 'cbrt',
    
    -- Relations
    ['≤'] = 'leq', ['≥'] = 'geq', ['≠'] = 'neq', ['≈'] = 'approx', ['≡'] = 'equiv',
    
    -- Calculus & summation
    ['∑'] = 'sum', ['∏'] = 'prod', ['∫'] = 'integral', ['∂'] = 'partial', ['∞'] = 'infinity',
    
    -- Other symbols
    ['∆'] = 'Delta', ['°'] = 'degree', ['→'] = 'rightarrow', ['←'] = 'leftarrow',
    ['ℏ'] = 'hbar', ['ℯ'] = 'e_math',
}
  -- Normalize TI symbols to Lua identifiers using direct gsub on keys (because copy-paste is a lifestyle).
  local constants_off = _G.var and _G.var.recall and _G.var.recall("constants_off")
  local current_category = nil
  if init and init.get_category then
    current_category = init.get_category()
  end
  -- Second attempt at memory: because the first one failed, obviously.
  if not current_category and _G.var and _G.var.recall then
    current_category = _G.var.recall("current_constant_category")
  end
  -- Of course it failed. Let's just give up and assume 'fundamental' like a good pessimist.
  if not current_category then
    current_category = "fundamental"
  end
  -- Look ma, still can't remember anything past a reboot. Time to fake memory with more hacks.
  print("[DEBUG] Current constant category:", current_category)

  -- Replace symbols with constant names if enabled and constant is enabled.
  -- If current_category is set, only match constants in that category.
  -- If current_category is nil, allow any enabled constant to be replaced.
  -- Because users just love typing π instead of pi.
  if not constants_off and _G.physics then
    local constants = _G.physics.constants
    expr = expr:gsub("[%z\1-\127\194-\244][\128-\191]*", function(symbol)
      for name, data in pairs(constants) do
        if data.symbol == symbol
          and (
            not current_category
            or data.category == current_category
            or data.symbol == symbol
          )
          and _G.physics.is_constant_enabled(name)
        then
          return name
        end
      end
      return symbol
    end)
  end
  local tokens = parser.tokenize(expr)
  -- Insert joke/custom AST support, because this parser is a comedian now.
  local joke = _G.errors.get(expr)
  if joke then
    return {type = "custom", value = joke}
  end
  print("[DEBUG] parser.tokenize result:")
  for _, t in ipairs(tokens) do
    print("  type=" .. t.type .. (t.value and (", value="..tostring(t.value)) or ""))
  end
  local ok, ast_or_err = pcall(parser.buildAST, tokens)
  if not ok then
    error(errors.invalid("parse", tostring(ast_or_err)))
  end
  local ast = ast_or_err
  print("[DEBUG] parser.buildAST result (AST structure):")
  parser.print_ast(ast)
  print("[DEBUG] parser.parse returning AST:")
  parser.print_ast(ast)
  return ast
end

_G.parser = parser
_G.parse = parser.parse

_G.parser = parser

-- Expose a direct solve_equation interface for global use, because everyone wants to solve everything.
if _G.solve_equation then
  _G.solve = function(expr)
    local ast = parser.parse(expr)
    return _G.solve_equation(ast)
  end
end

-- Wraps two arguments in a 'sub' node, because subtraction isn't just minus.
function parser.make_sub(left, right)
  return {type = "sub", left = left, right = right}
end

-- Wraps two arguments in a 'div' node, because division is just misunderstood multiplication.
function parser.make_div(num, denom)
  return {type = "div", left = num, right = denom}
end


-- Greek letter aliases (UTF-8 mapped to standard names)
-- Greek letter aliases for physics constants (assumes Constants table exists)
if _G.Constants then
    -- Basic Greek alphabet
    Constants[utf8(945)] = Constants["alpha"] or Constants[utf8(945)]  -- α (fine structure already exists)
Constants[utf8(946)] = Constants["beta"]                           -- β  
Constants[utf8(947)] = Constants["gamma"]                          -- γ
Constants[utf8(948)] = Constants["delta"]                          -- δ
Constants[utf8(949)] = Constants["epsilon"] or Constants[utf8(949).."0"] -- ε (permittivity already exists)
Constants[utf8(950)] = Constants["zeta"]                           -- ζ
Constants[utf8(951)] = Constants["eta"]                            -- η
Constants[utf8(952)] = Constants["theta"]                          -- θ
Constants[utf8(953)] = Constants["iota"]                           -- ι
Constants[utf8(954)] = Constants["kappa"]                          -- κ
Constants[utf8(955)] = Constants["lambda"]                         -- λ
Constants[utf8(956)] = Constants["mu"] or Constants[utf8(956).."0"] -- μ (permeability already exists)
Constants[utf8(957)] = Constants["nu"]                             -- ν
Constants[utf8(958)] = Constants["xi"]                             -- ξ
Constants[utf8(959)] = Constants["omicron"]                        -- ο
Constants[utf8(960)] = Constants["pi"]                             -- π (already exists)
Constants[utf8(961)] = Constants["rho"]                            -- ρ
Constants[utf8(962)] = Constants["sigma_final"]                    -- ς (final sigma)
Constants[utf8(963)] = Constants["sigma"]                          -- σ
Constants[utf8(964)] = Constants["tau"]                            -- τ
Constants[utf8(965)] = Constants["upsilon"]                        -- υ
Constants[utf8(966)] = Constants["phi"]                            -- φ
Constants[utf8(967)] = Constants["chi"]                            -- χ
Constants[utf8(968)] = Constants["psi"]                            -- ψ
Constants[utf8(969)] = Constants["omega"]                          -- ω

-- Greek letters (uppercase)
Constants[utf8(913)] = Constants["Alpha"]                          -- Α
Constants[utf8(914)] = Constants["Beta"]                           -- Β
Constants[utf8(915)] = Constants["Gamma"]                          -- Γ
Constants[utf8(916)] = Constants["Delta"]                          -- Δ
Constants[utf8(917)] = Constants["Epsilon"]                        -- Ε
Constants[utf8(918)] = Constants["Zeta"]                           -- Ζ
Constants[utf8(919)] = Constants["Eta"]                            -- Η
Constants[utf8(920)] = Constants["Theta"]                          -- Θ
Constants[utf8(921)] = Constants["Iota"]                           -- Ι
Constants[utf8(922)] = Constants["Kappa"]                          -- Κ
Constants[utf8(923)] = Constants["Lambda"]                         -- Λ
Constants[utf8(924)] = Constants["Mu"]                             -- Μ
Constants[utf8(925)] = Constants["Nu"]                             -- Ν
Constants[utf8(926)] = Constants["Xi"]                             -- Ξ
Constants[utf8(927)] = Constants["Omicron"]                        -- Ο
Constants[utf8(928)] = Constants["Pi"]                             -- Π
Constants[utf8(929)] = Constants["Rho"]                            -- Ρ
Constants[utf8(931)] = Constants["Sigma"]                          -- Σ
Constants[utf8(932)] = Constants["Tau"]                            -- Τ
Constants[utf8(933)] = Constants["Upsilon"]                        -- Υ
Constants[utf8(934)] = Constants["Phi"]                            -- Φ
Constants[utf8(935)] = Constants["Chi"]                            -- Χ
Constants[utf8(936)] = Constants["Psi"]                            -- Ψ
Constants[utf8(937)] = Constants["Omega"]                          -- Ω

-- PHYSICS-SPECIFIC CONSTANTS AND ALIASES

-- Common physics symbols
Constants[utf8(8463)] = Constants["h"] or Constants["planck"]      -- ℏ (reduced Planck)
Constants["hbar"] = Constants[utf8(8463)]

-- Mass-energy relations
Constants[utf8(956).."e"] = Constants["me"]                        -- μe (electron mass)
Constants[utf8(956).."p"] = Constants["mp"]                        -- μp (proton mass) 
Constants[utf8(956).."n"] = Constants["mn"]                        -- μn (neutron mass)

-- Coupling constants
Constants[utf8(945).."s"] = Constants["strong_coupling"]           -- αs (strong coupling)
Constants[utf8(945).."em"] = Constants[utf8(945)]                  -- αem (electromagnetic, same as fine structure)

-- Particle physics masses (if you add them)
Constants[utf8(956).."_e"] = Constants["electron_mass"]            -- μ_e
Constants[utf8(956).."_"..utf8(956)] = Constants["muon_mass"]      -- μ_μ (muon)
Constants[utf8(956).."_"..utf8(964)] = Constants["tau_mass"]       -- μ_τ (tau)
Constants["m_W"] = Constants["w_boson_mass"]                       -- W boson
Constants["m_Z"] = Constants["z_boson_mass"]                       -- Z boson
Constants["m_H"] = Constants["higgs_mass"]                         -- Higgs
Constants["m_t"] = Constants["top_mass"]                          -- top quark
Constants["m_b"] = Constants["bottom_mass"]                       -- bottom quark
Constants["m_c"] = Constants["charm_mass"]                        -- charm quark
Constants["m_s"] = Constants["strange_mass"]                      -- strange quark
Constants["m_u"] = Constants["up_mass"]                           -- up quark
Constants["m_d"] = Constants["down_mass"]                         -- down quark

-- QCD scale
Constants[utf8(923).."_QCD"] = Constants["lambda_qcd"]            -- Λ_QCD
Constants[utf8(952).."_QCD"] = Constants["theta_qcd"]             -- θ_QCD

-- Weinberg angle
Constants[utf8(952).."_W"] = Constants["weinberg_angle"]          -- θ_W
Constants["sin2"..utf8(952).."_W"] = Constants["sin2_theta_w"]    -- sin²θ_W

-- Cosmological constants
Constants[utf8(923)] = Constants["cosmological_constant"]         -- Λ
Constants[utf8(937).."_m"] = Constants["matter_density"]          -- Ω_m
Constants[utf8(937).."_"..utf8(923)] = Constants["dark_energy"]  -- Ω_Λ
Constants[utf8(937).."_b"] = Constants["baryon_density"]          -- Ω_b
Constants["H_0"] = Constants["hubble_constant"]                   -- H₀

-- Thermodynamic
Constants[utf8(946)] = Constants["inverse_temperature"]           -- β = 1/(kT)
Constants[utf8(963).."_SB"] = Constants["stefan_boltzmann"]       -- σ_SB

-- CKM matrix elements (quark mixing)
Constants["V_ud"] = Constants["ckm_ud"]
Constants["V_us"] = Constants["ckm_us"] 
Constants["V_ub"] = Constants["ckm_ub"]
Constants["V_cd"] = Constants["ckm_cd"]
Constants["V_cs"] = Constants["ckm_cs"]
Constants["V_cb"] = Constants["ckm_cb"]
Constants["V_td"] = Constants["ckm_td"]
Constants["V_ts"] = Constants["ckm_ts"]
Constants["V_tb"] = Constants["ckm_tb"]

-- PMNS matrix elements (neutrino mixing)
Constants[utf8(952).."_12"] = Constants["solar_angle"]           -- θ₁₂
Constants[utf8(952).."_23"] = Constants["atmospheric_angle"]     -- θ₂₃  
Constants[utf8(952).."_13"] = Constants["reactor_angle"]         -- θ₁₃
Constants[utf8(948).."_CP"] = Constants["cp_phase"]              -- δ_CP

-- Neutrino mass differences
Constants[utf8(916).."m2_21"] = Constants["delta_m21_squared"]   -- Δm²₂₁
Constants[utf8(916).."m2_31"] = Constants["delta_m31_squared"]   -- Δm²₃₁

-- Running couplings (scale dependent)
Constants[utf8(945).."("..utf8(956)..")"] = Constants["running_alpha"]     -- α(μ)
Constants[utf8(945).."s("..utf8(956)..")"] = Constants["running_alphas"]   -- αs(μ)

-- Renormalization scales  
Constants[utf8(956).."_R"] = Constants["renormalization_scale"]  -- μ_R
Constants[utf8(956).."_F"] = Constants["factorization_scale"]    -- μ_F

-- Effective field theory cutoffs
Constants[utf8(923).."_UV"] = Constants["uv_cutoff"]             -- Λ_UV
Constants[utf8(923).."_IR"] = Constants["ir_cutoff"]             -- Λ_IR

-- Supersymmetry parameters
Constants["M_SUSY"] = Constants["susy_scale"]
Constants["tan"..utf8(946)] = Constants["tan_beta"]              -- tan β
Constants[utf8(956).."_SUSY"] = Constants["susy_mu"]             -- μ_SUSY

-- Axion physics
Constants["f_a"] = Constants["axion_decay_constant"]             -- f_a
Constants[utf8(952).."_strong"] = Constants["strong_cp_angle"]   -- θ_strong

-- Dark matter
Constants[utf8(963).."_SI"] = Constants["dm_si_cross_section"]   -- σ_SI
Constants[utf8(963).."_SD"] = Constants["dm_sd_cross_section"]   -- σ_SD
Constants["<"..utf8(963).."v>"] = Constants["dm_annihilation"]   -- ⟨σv⟩

-- Extra dimensions
Constants["M_D"] = Constants["extra_dim_scale"]
Constants["R_extra"] = Constants["extra_dim_radius"]

-- String theory scale
Constants["M_string"] = Constants["string_scale"]
Constants["M_Pl"] = Constants["planck_mass"]

-- AdS/CFT
Constants["L_AdS"] = Constants["ads_radius"]
Constants["c_central"] = Constants["central_charge"]

-- Instantons and topology
Constants[utf8(952)] = Constants["theta_angle"]                  -- θ
Constants["w"] = Constants["winding_number"]
end

-- End src/parser.lua

-- Just added src/parser.lua—hope your logic is watertight.

-- Begin src/simplify.lua

local parser = rawget(_G, "parser") or require("parser")

-- Ensure 'var' is always the global function, not a shadowing table
local var = rawget(_G, "var")
local errors = _G.errors
-- Decimals preference is stored globally and persisted using var API (if present)
if var and var.recall and var.store then
  local stored = var.recall("nLuaCAS_decimals_pref")
  if stored == 1 or stored == 0 then
    _G.autoDecimal = (stored == 1)
  end
end
_G.autoDecimal = _G.autoDecimal or false

-- Helper functions for AST node type checks and value extraction
local function is_num(e) return e and e.type == "number" end
local function is_var(e) return e and e.type == "variable" end
local function is_add(e) return e and e.type == "add" end
local function is_mul(e) return e and e.type == "mul" end
local function is_pow(e) return e and e.type == "pow" end
local function is_neg(e) return e and e.type == "neg" end
local function is_func(e) return e and e.type == "func" end
local function numval(e) return e.value end
local function is_integer(n) return math.floor(n) == n end
local function is_zero(e) return is_num(e) and numval(e) == 0 end
local function is_one(e) return is_num(e) and numval(e) == 1 end
local function is_minus_one(e) return is_num(e) and numval(e) == -1 end

-- AST Node Constructors (moved up for rule access)
local function num(n) return {type="number", value=n} end
local function make_var(x) return {type="variable", name=x} end
local function add(args) return {type="add", args=args} end
local function mul(args) return {type="mul", args=args} end
local function pow(base, exp) return {type="pow", base=base, exp=exp} end
local function neg(arg) return {type="neg", arg=arg} end
local function func(name, args) return {type="func", name=name, args=args} end
--[[
  Symbolic Expression Simplification Engine (CAS)
  Standalone Lua module: no dependencies, all helpers and rules included.
  Entrypoint: simplify.simplify(expr_ast)
  AST node types: assumes standard 'number', 'variable', 'add', 'mul', 'pow', 'neg', 'func', etc.
  Extensible: just add rules to the rule table or helper functions.
  See comments for structure and extension points.
--]]



local simplify = {}

-- Aggressively rewrite all div nodes (everywhere, recursively, always)
local function force_div_to_mul_pow(node)
  if type(node) ~= "table" then return node end
  if node.type == "div" and node.left and node.right then
    return {
      type = "mul",
      args = {
        force_div_to_mul_pow(node.left),
        { type = "pow", base = force_div_to_mul_pow(node.right), exp = { type = "number", value = -1 } }
      }
    }
  end
  local out = {}
  for k,v in pairs(node) do
    out[k] = force_div_to_mul_pow(v)
  end
  return out
end


-- Symbolic mode: set to true to preserve structure of ±, sqrt, frac, etc.
simplify.symbolicOnly = false
-- ± (plus-minus) node: always preserve symbolically if symbolicOnly
function simplify_pm(node)
    local left = simplify.simplify(node[1])
    local right = simplify.simplify(node[2])
    -- Preserve ± symbolically, even if numeric
    return {
        tag = "pm",
        [1] = left,
        [2] = right
    }
end

local DEBUG = true
local function dbgprint(...)
  if DEBUG then print("[DEBUG]", ...) end
end



local function ast_eq(a, b)
  if type(a) ~= type(b) then return false end
  if type(a) ~= "table" then return a == b end
  if a.type ~= b.type then return false end
  -- Compare keys present in both
  for k,v in pairs(a) do
    if not ast_eq(v, b[k]) then return false end
  end
  for k,v in pairs(b) do
    if not ast_eq(v, a[k]) then return false end
  end
  return true
end

local rules = {}

local function constants_disabled()
  if var and var.recall then
    -- Use correct TI-Nspire var API
    return var.recall("constants_off") == 1 or var.recall("constants_off") == true
  elseif var and type(var) == "function" then
    local v = var("constants_off")
    return v == 1 or v == true
  end
  return false
end

-- Replace physics constant variables with their numeric AST values, but only if enabled and not globally disabled
table.insert(rules, 1, function(expr)
  if expr.type == "variable" then
    if not constants_disabled() then
      local physics = _G.physics or (pcall(require, "physics") and require("physics")) or nil
      if physics and physics.is_constant_enabled and physics.is_constant_enabled(expr.name) then
        local category = _G.current_constant_category or "fundamental"
        print("[DEBUG] Current constant category (simplify):", category)
        local const_val = physics.get_constant_value(expr.name, category)
        if const_val then return const_val end
      end
    end
  end
end)

-- Numeric evaluation of physics functions: if all args are numbers, delegate to physics.eval_physics_func
table.insert(rules, 1, function(expr)
  if expr.type == "func" and expr.args then
    -- Check if all arguments are numeric constants
    local allnum = true
    for _, a in ipairs(expr.args) do
      if not (type(a) == "table" and a.type == "number") then
        allnum = false
        break
      end
    end
    if allnum then
      local physics = _G.physics or require("physics")
      local result = physics.eval_physics_func(expr.name, expr.args)
      if result and result.type == "number" then
        return result
      end
    end
  end
end)

-- Combine two power nodes of the same base: x^a * x^b -> x^(a+b)
table.insert(rules, 1, function(expr)
  if is_mul(expr) and #expr.args == 2 then
    local a, b = expr.args[1], expr.args[2]
    if is_pow(a) and is_pow(b) and ast_eq(a.base, b.base) and is_num(a.exp) and is_num(b.exp) then
      local e1, e2 = numval(a.exp), numval(b.exp)
      local sum = e1 + e2
      if sum == 0 then
        return num(1)
      elseif sum == 1 then
        return a.base
      else
        return pow(a.base, num(sum))
      end
    end
  end
end)

-- Simplify any expression multiplied by its own reciprocal (including variables): expr * expr^-1 -> 1
table.insert(rules, 1, function(expr)
  if is_mul(expr) and #expr.args == 2 then
    local a, b = expr.args[1], expr.args[2]
    -- Case: expr * expr^-1
    if is_pow(b) and is_minus_one(b.exp) and ast_eq(a, b.base) then
      return num(1)
    end
    -- Case: expr^-1 * expr
    if is_pow(a) and is_minus_one(a.exp) and ast_eq(b, a.base) then
      return num(1)
    end
  end
end)

-- Special case: collapse equal numeric reciprocal pairs (e.g., 2 * 2^-1) to 1
table.insert(rules, 1, function(expr)
  if is_mul(expr) and #expr.args == 2 then
    local a, b = expr.args[1], expr.args[2]
    -- Case: number * (number^-1)
    if is_num(a) and is_pow(b) and is_num(b.base) and is_num(b.exp)
       and numval(b.exp) == -1 and numval(a) == numval(b.base) then
      return num(1)
    end
    -- Case: (number^-1) * number
    if is_pow(a) and is_num(a.base) and is_num(a.exp)
       and numval(a.exp) == -1 and is_num(b) and numval(a.base) == numval(b) then
      return num(1)
    end
  end
end)


-- Patch: Numeric simplification: a * b^-1 where a and b are numbers (with decimals OFF)
table.insert(rules, 1, function(expr)
  if is_mul(expr) and #expr.args == 2 then
    local a, b = expr.args[1], expr.args[2]
    -- Case 1: (number) * (pow(number, -1))
    if is_num(a) and is_pow(b) and is_num(b.base) and is_num(b.exp) and numval(b.exp) == -1 then
      if _G.autoDecimal then
        return num(numval(a) / numval(b.base))
      else
        -- Reduce fraction
        local n, d = numval(a), numval(b.base)
        local function gcd(x, y)
          if y == 0 then return x end
          return gcd(y, x % y)
        end
        local g = gcd(math.abs(n), math.abs(d))
        n = n / g
        d = d / g
        if d < 0 then n = -n; d = -d end
        if d == 1 then return num(n) end
        return { type = "div", left = num(n), right = num(d) }
      end
    end
    -- Case 2: (pow(number, -1)) * (number)
    if is_pow(a) and is_num(a.base) and is_num(a.exp) and numval(a.exp) == -1 and is_num(b) then
      if _G.autoDecimal then
        return num(numval(b) / numval(a.base))
      else
        -- Reduce fraction
        local n, d = numval(b), numval(a.base)
        local function gcd(x, y)
          if y == 0 then return x end
          return gcd(y, x % y)
        end
        local g = gcd(math.abs(n), math.abs(d))
        n = n / g
        d = d / g
        if d < 0 then n = -n; d = -d end
        if d == 1 then return num(n) end
        return { type = "div", left = num(n), right = num(d) }
      end
    end
  end
end)

-- Remove multiplication by 1 (identity)
table.insert(rules, 2, function(expr)
  if expr.type == "mul" and expr.args then
    local new_args = {}
    for _, a in ipairs(expr.args) do
      if not (a.type == "number" and a.value == 1) then
        table.insert(new_args, a)
      end
    end
    if #new_args < #expr.args then
      if #new_args == 0 then return num(1) end
      if #new_args == 1 then return new_args[1] end
      return { type = "mul", args = new_args }
    end
  end
end)

-- Rule: Rewrite all "div" nodes as "mul" with power -1 (reciprocal), before any other div rules
table.insert(rules, 1, function(expr)
  if expr.type == "div" and expr.left and expr.right then
    return { type = "mul", args = { expr.left, { type = "pow", base = expr.right, exp = { type = "number", value = -1 } } } }
  end
end)

-- Rewrite all "sub" nodes as "add" + "neg"
table.insert(rules, 1, function(expr)
  if expr.type == "sub" and expr.left and expr.right then
    return { type = "add", args = { expr.left, { type = "neg", arg = expr.right } } }
  end
end)

-- Rule for equation node: recursively simplify left and right sides
rules["equation"] = function(node)
  return {
    type = "equation",
    left = recursive_simplify(node.left),
    right = recursive_simplify(node.right)
  }
end


local function deepcopy(expr)
  if type(expr) ~= "table" then return expr end
  local t = {}
  for k,v in pairs(expr) do t[k] = deepcopy(v) end
  return t
end

-- Hash an AST for cycle detection
local function ast_hash(expr)
  local function ser(e)
    if type(e) ~= 'table' then return tostring(e) end
    local t = { e.type }
    for k,v in pairs(e) do if k ~= 'type' then table.insert(t, k .. ':' .. ser(v)) end end
    table.sort(t)
    return table.concat(t, '|')
  end
  return ser(expr)
end



local function flatten(node)
  if node.type ~= "add" and node.type ~= "mul" then return node end
  local args = {}
  local function gather(n)
    if n.type == node.type and n.args then
      for _,a in ipairs(n.args) do gather(a) end
    else
      table.insert(args, n)
    end
  end
  gather(node)
  return {type=node.type, args=args}
end

local function serialize_for_sort(node)
  if is_num(node) then return "N:" .. tostring(node.value)
  elseif is_var(node) then return "V:" .. node.name
  elseif is_add(node) then
    local parts = {}
    for _, arg in ipairs(node.args) do table.insert(parts, serialize_for_sort(arg)) end
    table.sort(parts)
    return "A:" .. table.concat(parts, ",")
  elseif is_mul(node) then
    local parts = {}
    for _, arg in ipairs(node.args) do table.insert(parts, serialize_for_sort(arg)) end
    table.sort(parts)
    return "M:" .. table.concat(parts, ",")
  elseif is_pow(node) then
    return "P:" .. serialize_for_sort(node.base) .. "^" .. serialize_for_sort(node.exp)
  elseif is_neg(node) then
    return "Neg:" .. serialize_for_sort(node.arg)
  elseif is_func(node) then
    local parts = {}
    for _, arg in ipairs(node.args) do table.insert(parts, serialize_for_sort(arg)) end
    return "F:" .. node.name .. "(" .. table.concat(parts, ",") .. ")"
  else
    return "U:" .. tostring(node)
  end
end

local function sort_args(node)
  if node.type ~= "add" and node.type ~= "mul" then return node end
  local args = {}
  for _,a in ipairs(node.args) do table.insert(args, a) end
  table.sort(args, function(a,b)
    local sa = serialize_for_sort(a)
    local sb = serialize_for_sort(b)
    return sa < sb
  end)
  return {type=node.type, args=args}
end

-- Forward declaration for recursive_simplify to allow its use in canonicalize
local recursive_simplify

local function canonicalize(expr)
  if type(expr) ~= "table" then return expr end
  local e = deepcopy(expr)
  if e.type == "sub" then
    -- Rewrite sub(a,b) as add(a, neg(b)) and then canonicalize again:
    return canonicalize({
      type = "add",
      args = {
        e.left,
        { type = "neg", arg = e.right }
      }
    })
  end
  if e.type == "add" or e.type == "mul" then
    local new_args = {}
    for i, a in ipairs(e.args) do new_args[i] = canonicalize(a) end
    e.args = new_args
    e = flatten(e)
    e = sort_args(e)
    return e
  elseif e.type == "pow" then
    e.base = canonicalize(e.base)
    e.exp = canonicalize(e.exp)
    return e
  elseif e.type == "neg" then
    e.arg = canonicalize(e.arg)
    return e
  elseif e.type == "func" then
    local new_args = {}
    for i,a in ipairs(e.args) do new_args[i] = canonicalize(a) end
    e.args = new_args
    return e
  end
  return e
end

local function occurs(var, expr)
  if is_var(expr) and expr.name == var then return true end
  if type(expr) ~= "table" then return false end
  for k,v in pairs(expr) do
    if occurs(var, v) then return true end
  end
  return false
end

local function copy_node(node, fields)
  local t = {type=node.type}
  for k,v in pairs(fields or {}) do t[k] = v end
  return t
end

local function map_args(node, f)
  if not node.args then return node end
  local new_args = {}
  for i,a in ipairs(node.args) do new_args[i] = f(a) end
  return {type=node.type, args=new_args}
end


-- Negation simplification rules
table.insert(rules, 1, function(expr)
  -- Handle negation of a number: neg(number) → number with sign flipped
  if expr.type == "neg" and expr.arg and expr.arg.type == "number" then
    return {type = "number", value = -expr.arg.value}
  end
  -- Handle negation of a negation: neg(neg(x)) → x
  if expr.type == "neg" and expr.arg and expr.arg.type == "neg" then
    return expr.arg.arg
  end
end)

-- Helper Predicates
local function is_integer(n) return math.floor(n) == n end
local function is_zero(e) return is_num(e) and numval(e) == 0 end
local function is_one(e) return is_num(e) and numval(e) == 1 end
local function is_minus_one(e) return is_num(e) and numval(e) == -1 end
-- Helpers from the second snippet
local function is_positive(e) return is_num(e) and numval(e) > 0 end
local function is_negative(e) return is_num(e) and numval(e) < 0 end
local function is_even(e) return is_num(e) and is_integer(numval(e)) and numval(e) % 2 == 0 end
local function is_odd(e) return is_num(e) and is_integer(numval(e)) and numval(e) % 2 == 1 end


--[[
  Rule Engine: Each rule is a function: rule(expr) -> new_expr or nil
  The rules are applied recursively and iteratively until stable.
  To add new rules, insert into the rules table.
--]]


-- Constants: for quick lookup
local ZERO = num(0)
local ONE = num(1)
local MINUS_ONE = num(-1)
-- Constants from the second snippet
local TWO = num(2)
local PI = num(math.pi)
local E = num(math.e)


table.insert(rules, 1, function(expr)
  -- Direct arithmetic for sub and div at top level
  if expr.type == "sub" and is_num(expr.left) and is_num(expr.right) then
    return num(numval(expr.left) - numval(expr.right))
  end
  if expr.type == "div" and is_num(expr.left) and is_num(expr.right) and numval(expr.right) ~= 0 then
    local n = numval(expr.left)
    local d = numval(expr.right)
    -- Only convert to decimal if _G.autoDecimal is true
    if _G.autoDecimal then
      return num(n / d)
    end
    -- Reduce fraction
    local function gcd(a, b)
      if b == 0 then return a end
      return gcd(b, a % b)
    end
    local g = gcd(math.abs(n), math.abs(d))
    n = n / g
    d = d / g
    if d < 0 then n = -n; d = -d end
    -- If denominator is 1, just return integer
    if d == 1 then return num(n) end
    return { type = "div", left = num(n), right = num(d) }
  end
end)
table.insert(rules, function(expr)
  if is_add(expr) then
    -- Fold numeric terms in addition
    local sum = 0
    local others = {}
    for _,a in ipairs(expr.args) do
      if is_num(a) then sum = sum + numval(a) else table.insert(others, a) end
    end
    if sum ~= 0 or #others == 0 then table.insert(others, 1, num(sum)) end
    -- Remove leading zero if there are other terms
    if #others > 1 and is_zero(others[1]) then table.remove(others, 1) end
    if #others == 1 then return others[1] end
    if #others ~= #expr.args or (is_num(expr.args[1]) and numval(expr.args[1]) ~= sum) then
      return add(others)
    end
  elseif is_mul(expr) then
    -- Fold numeric and reciprocal terms to fraction if decimals are off
    local numer, denom = 1, 1
    local others = {}
    for _,a in ipairs(expr.args) do
      if is_num(a) then
        numer = numer * numval(a)
      elseif is_pow(a) and is_num(a.base) and is_num(a.exp) and numval(a.exp) == -1 then
        denom = denom * numval(a.base)
      else
        table.insert(others, a)
      end
    end
    -- If decimals ON, just divide
    if _G.autoDecimal then
      local val = numer / denom
      if #others == 0 then return num(val)
      else table.insert(others, 1, num(val)); return mul(others) end
    end
    -- Reduce fraction
    local function gcd(a, b)
      if b == 0 then return a end
      return gcd(b, a % b)
    end
    local g = gcd(math.abs(numer), math.abs(denom))
    numer = numer / g
    denom = denom / g
    if denom == 1 then
      if #others == 0 then return num(numer)
      else table.insert(others, 1, num(numer)); return mul(others) end
    end
    -- return as fraction
    local frac = { type = "div", left = num(numer), right = num(denom) }
    if #others == 0 then return frac
    else table.insert(others, 1, frac); return mul(others) end
  elseif is_pow(expr) then
    -- Enhanced pow simplification block
    if is_one(expr.exp) then return expr.base end
    if is_zero(expr.exp) then return ONE end
    if is_zero(expr.base) then return ZERO end
    if is_one(expr.base) then return ONE end
    if is_num(expr.base) and is_num(expr.exp) then
      local b, e = numval(expr.base), numval(expr.exp)
      if math.floor(e) == e then
        -- integer exponent: always compute exactly
        if e >= 0 then
          return num(b ^ e)
        else
          -- negative integer exponent
          if _G.autoDecimal then
            return num(b ^ e)
          else
            -- represent as exact fraction: 1 / (b^|e|)
            local d = b ^ (-e)
            return { type = "div", left = num(1), right = num(d) }
          end
        end
      elseif _G.autoDecimal and b > 0 then
        -- non-integer exponent: only compute if decimals on and base positive
        return num(b ^ e)
      end
    end
  end
end)

-- Simplify x^1 => x
table.insert(rules, function(expr)
  if is_pow(expr) and is_one(expr.exp) then
    return expr.base
  end
end)

-- Flatten nested adds/muls (associativity)
table.insert(rules, function(expr)
  if is_add(expr) or is_mul(expr) then
    local flat = flatten(expr)
    if #flat.args ~= #expr.args then return flat end
  end
end)

-- Sort args (commutativity)
table.insert(rules, function(expr)
  if is_add(expr) or is_mul(expr) then
    local sorted = sort_args(expr)
    -- Compare by structure
    for i=1,#expr.args do
      if not ast_eq(expr.args[i], sorted.args[i]) then return sorted end
    end
  end
end)

table.insert(rules, function(expr)
  if is_add(expr) then
    local out = {}
    for _,a in ipairs(expr.args) do if not is_zero(a) then table.insert(out,a) end end
    if #out == 0 then return ZERO end
    if #out == 1 then return out[1] end
    if #out < #expr.args then return add(out) end
  elseif is_mul(expr) then
    local out = {}
    for _,a in ipairs(expr.args) do
      if is_zero(a) then return ZERO end
      if not is_one(a) then table.insert(out,a) end
    end
    if #out == 0 then return ONE end
    if #out == 1 then return out[1] end
    if #out < #expr.args then return mul(out) end
  end
end)

table.insert(rules, function(expr)
  if is_neg(expr) then
    if is_num(expr.arg) then return num(-numval(expr.arg)) end
    if is_neg(expr.arg) then return expr.arg.arg end -- --a = a
    -- -a + b = b - a, handled by add/mul rules
  end
end)

-- Rewrite -a*b*c as -1 * a * b * c
table.insert(rules, function(expr)
  if is_neg(expr) and is_mul(expr.arg) then
    local new_args = {num(-1)}
    for _, a in ipairs(expr.arg.args) do
      table.insert(new_args, a)
    end
    return mul(new_args)
  end
end)

table.insert(rules, function(expr)
  if is_add(expr) then
    -- Group by non-numeric term
    local coeffs = {}
    local others = {}
    for _,a in ipairs(expr.args) do
      if is_mul(a) then
        -- Look for numeric coefficient
        local c, rest = nil, {}
        for _,f in ipairs(a.args) do
          if is_num(f) then c = (c or 1) * numval(f) else table.insert(rest, f) end
        end
        if #rest > 0 then
          local key_parts = {} -- Use a table for complex keys
          for _, r_term in ipairs(rest) do table.insert(key_parts, serialize_for_sort(r_term)) end
          table.sort(key_parts)
          local key = table.concat(key_parts, "*")
          
          coeffs[key] = coeffs[key] or {c=0, term=rest}
          coeffs[key].c = coeffs[key].c + (c or 1)
        else -- All terms in mul were numbers, should have been folded
          table.insert(others, a)
        end
      elseif is_num(a) then
        coeffs["#num"] = coeffs["#num"] or {c=0, term={}} -- term is not really applicable here
        coeffs["#num"].c = coeffs["#num"].c + numval(a)
      elseif is_var(a) then
        local key = serialize_for_sort(a) -- Use serialize for consistency
        coeffs[key] = coeffs[key] or {c=0, term={a}}
        coeffs[key].c = coeffs[key].c + 1
      else
        table.insert(others, a)
      end
    end
    local out = {}
    local changed_from_coeffs = false
    for k,info in pairs(coeffs) do
      if k == "#num" then
        if info.c ~= 0 then table.insert(out, num(info.c)) end
        if info.c == 0 and #expr.args > 1 then changed_from_coeffs = true end -- A number became zero
      else
        if info.c ~= 0 then
          if info.c == 1 then
            if #info.term == 1 then table.insert(out, info.term[1])
            else table.insert(out, mul(info.term)) end
          else
            local t_terms = deepcopy(info.term)
            table.insert(t_terms, 1, num(info.c)) -- Coefficient first
            table.insert(out, mul(t_terms))
          end
        else -- Coefficient became zero, term vanishes
           changed_from_coeffs = true
        end
      end
    end

    for _,a in ipairs(others) do table.insert(out, a) end
    
    if #out == 0 then return ZERO end
    if #out == 1 and #others == 0 and not (coeffs["#num"] and #expr.args == 1 and ast_eq(expr.args[1], out[1])) then -- Avoid infinite loop for single number
        return out[1] 
    end

    -- Check if a meaningful change occurred or if the number of terms was reduced
    if #out < #expr.args or changed_from_coeffs then
        if #out == 0 then return ZERO end
        if #out == 1 then return out[1] end
        return add(out)
    end
  end
end)

-- Cancel additive inverses: a + (-a) => 0
table.insert(rules, function(expr)
  if is_add(expr) and #expr.args >= 2 then
    local to_remove = {}
    for i = 1, #expr.args do
      for j = i + 1, #expr.args do
        local a, b = expr.args[i], expr.args[j]
        if is_neg(a) and ast_eq(a.arg, b) then
          table.insert(to_remove, i)
          table.insert(to_remove, j)
        elseif is_neg(b) and ast_eq(b.arg, a) then
          table.insert(to_remove, i)
          table.insert(to_remove, j)
        end
      end
    end
    if #to_remove > 0 then
      local keep = {}
      local skip = {}
      for _, idx in ipairs(to_remove) do skip[idx] = true end
      for i = 1, #expr.args do
        if not skip[i] then table.insert(keep, expr.args[i]) end
      end
      if #keep == 0 then return num(0) end
      if #keep == 1 then return keep[1] end
      return add(keep)
    end
  end
end)


-- Combining exponents: x^a * x^b = x^(a+b)
table.insert(rules, function(expr)
  if is_mul(expr) then
    local exps = {} -- base_repr -> list of exponents
    local others = {}
    local has_combined = false

    for _,a in ipairs(expr.args) do
      local base_node, exp_node
      if is_pow(a) then
        base_node = a.base
        exp_node = a.exp
      elseif is_var(a) then
        base_node = a
        exp_node = ONE
      else
        table.insert(others, a)
      end

      if base_node then
        local key = serialize_for_sort(base_node)
        exps[key] = exps[key] or {base = base_node, exps_list = {}}
        table.insert(exps[key].exps_list, exp_node)
      end
    end

    local out = {}
    for _,a in ipairs(others) do table.insert(out, a) end -- Add non-power/non-var terms first

    for _,info in pairs(exps) do
      local current_base = info.base
      local current_exps_list = info.exps_list
      local final_exp
      if #current_exps_list == 1 then
        final_exp = current_exps_list[1]
      else
        final_exp = simplify.simplify(add(current_exps_list)) -- Simplify the sum of exponents
        has_combined = true -- Mark that we combined exponents
      end

      if is_zero(final_exp) then
        table.insert(out, ONE) -- x^0 = 1
        has_combined = true
      elseif is_one(final_exp) then
        table.insert(out, current_base) -- x^1 = x
      else
        table.insert(out, pow(current_base, final_exp))
      end
    end
    
    if not has_combined and #out == #expr.args then return nil end -- No change

    -- Post-process 'out' to remove ONEs if other terms exist, and handle products of ONEs
    local final_out = {}
    local non_one_terms = 0
    for _, term in ipairs(out) do
        if not is_one(term) then
            table.insert(final_out, term)
            non_one_terms = non_one_terms + 1
        end
    end

    if #final_out == 0 then return ONE end -- All terms were ONE or cancelled to ONE
    if #final_out == 1 then return final_out[1] end
    if #final_out < #expr.args or has_combined or non_one_terms < #out then -- Check if simplification occurred
      return mul(final_out)
    end
  end
end)


-- Distributive law: a*(b + c) => a*b + a*c
table.insert(rules, function(expr)
  if is_mul(expr) then
    for i, arg_outer in ipairs(expr.args) do
      if is_add(arg_outer) then
        local factor_terms = {} -- The terms not being distributed over
        for j, other_arg in ipairs(expr.args) do
          if i ~= j then table.insert(factor_terms, other_arg) end
        end

        if #factor_terms == 0 then return nil end -- e.g. just (b+c), no a to distribute

        local expanded_terms = {}
        for _, term_inner in ipairs(arg_outer.args) do
          local current_product_args = {deepcopy(term_inner)}
          for _, ft in ipairs(factor_terms) do
            table.insert(current_product_args, deepcopy(ft))
          end
          table.insert(expanded_terms, mul(current_product_args))
        end
        return add(expanded_terms)
      end
    end
  end
end)


-- Expand (a+b)^n for small integer n
table.insert(rules, function(expr)
    if is_pow(expr) and is_add(expr.base) and #expr.base.args == 2 and is_num(expr.exp) and is_integer(numval(expr.exp)) then
        local n_val = numval(expr.exp)
        if n_val > 1 and n_val <= 5 then -- Limit expansion to avoid blowup, e.g. (a+b)^2 to (a+b)^5
            local n = n_val
            local function binom(N, K) -- N choose K
                if K < 0 or K > N then return 0 end
                if K == 0 or K == N then return 1 end
                if K > N / 2 then K = N - K end -- Symmetry
                local res = 1
                for i = 1, K do
                    res = res * (N - i + 1) / i
                end
                return res
            end

            local terms = {}
            local term_a, term_b -- Assuming base is a sum of two terms a+b
            
            -- Handle cases like (x-y)^n which is (x + (-y))^n
            local base_args = expr.base.args
            term_a = base_args[1]

            -- Check if the second term is a negation or part of a subtraction
            if is_neg(base_args[2]) then
                term_b = base_args[2] -- Keep as neg node for a + (-b)
            else
                -- This part needs to correctly identify (a-b) which might be represented as add(a, mul(-1, b)) after some canonicalization
                -- For now, let's assume a simple add({a, b}) or add({a, neg(b)})
                term_b = base_args[2] 
            end


            for k = 0, n do
                local coeff_val = binom(n, k)
                if coeff_val ~= 0 then
                    local coeff_node = num(coeff_val)
                    
                    local parts_of_term = {}
                    if not is_one(coeff_node) or (n==0 and k==0) then -- Add coefficient unless it's 1 (and not for 1*1^0*b^0)
                        table.insert(parts_of_term, coeff_node)
                    end

                    -- term_a^(n-k)
                    if n - k > 0 then
                        if n - k == 1 then
                            table.insert(parts_of_term, deepcopy(term_a))
                        else
                            table.insert(parts_of_term, pow(deepcopy(term_a), num(n - k)))
                        end
                    elseif n-k == 0 and is_one(coeff_node) and k == n and n ~= 0 then -- case a^0 * b^n, don't add 1 if coeff is 1
                         -- but if it's just (a+b)^0 = 1, the coeff_node=1 is already there
                    elseif n-k == 0 and not (is_one(coeff_node) and #parts_of_term > 0) and #parts_of_term == 0 then
                         -- if coefficient is not 1, or if it's the only term so far (e.g. for 1 * a^0 * b^0)
                        -- table.insert(parts_of_term, ONE) -- a^0 = 1
                    end

                    -- term_b^k
                    if k > 0 then
                        if k == 1 then
                            table.insert(parts_of_term, deepcopy(term_b))
                        else
                            table.insert(parts_of_term, pow(deepcopy(term_b), num(k)))
                        end
                    elseif k == 0 and is_one(coeff_node) and n-k == n and n ~=0 then
                        -- case a^n * b^0, don't add 1
                    elseif k == 0 and not (is_one(coeff_node) and #parts_of_term > 0) and #parts_of_term == 0 then
                        -- table.insert(parts_of_term, ONE) -- b^0 = 1
                    end
                    
                    if #parts_of_term == 0 then -- e.g. for (a+b)^0, only coefficient 1 remains
                        if is_one(coeff_node) then table.insert(terms, ONE)
                        else table.insert(terms, coeff_node) end -- Should not happen if binom(0,0)=1
                    elseif #parts_of_term == 1 then
                        table.insert(terms, parts_of_term[1])
                    else
                        table.insert(terms, mul(parts_of_term))
                    end
                end
            end
            if #terms == 0 then return ONE end -- e.g. (a+b)^0 results in one term: 1
            if #terms == 1 then return terms[1] end
            return add(terms)
        end
    end
end)


-- Expand (a-b)^2, (a+b)^2, (a-b)^3, etc (This rule seems redundant if the above handles it for n<=5)
-- table.insert(rules, function(expr)
--   if is_pow(expr) and is_add(expr.base) and is_num(expr.exp) and is_integer(numval(expr.exp)) and numval(expr.exp) > 1 then
--     -- Already handled for n <= 5 above
--     -- For larger n, skip (to avoid blowup)
--   end
-- end)

-- x^a^b = x^(a*b)
table.insert(rules, function(expr)
  if is_pow(expr) and is_pow(expr.base) then
    return pow(expr.base.base, mul{expr.base.exp, expr.exp})
  end
end)

-- Logarithmic and exponential rules
table.insert(rules, function(expr)
  if is_func(expr) then
    local n = expr.name
    local a = expr.args[1] -- Assuming single argument for most of these
    -- sqrt: preserve structure if symbolicOnly
    if n == "sqrt" then
      if simplify.symbolicOnly then return expr end
      -- Otherwise, try to evaluate sqrt numerically if argument is numeric and >=0
      if is_num(a) and numval(a) >= 0 then
        return num(math.sqrt(numval(a)))
      end
    end
    if n == "log" then
      if not a then return expr end -- Should not happen with valid AST
      -- log(1) = 0
      if is_one(a) then return ZERO end
      -- log(x^a) = a*log(x)
      if is_pow(a) then return mul{deepcopy(a.exp), func("log",{deepcopy(a.base)})} end
      -- log(e^x) = x (if base e is implied, or if E constant is used for base)
      if is_pow(a) and ((is_var(a.base) and a.base.name == "e") or (is_num(a.base) and math.abs(numval(a.base) - math.exp(1)) < 1e-10)) then
        return a.exp
      end
      if is_func(a) and a.name == "exp" then -- log(exp(x)) = x
        return a.args[1]
      end
      -- log(a*b) = log(a) + log(b)
      if is_mul(a) then
        local logs = {}
        for _,t in ipairs(a.args) do table.insert(logs, func("log",{deepcopy(t)})) end
        return add(logs)
      end
       -- log(a/b) = log(a) - log(b)
      if is_mul(a) and #a.args == 2 and is_pow(a.args[2]) and is_minus_one(a.args[2].exp) then
        -- a is of form term1 * term2^-1
        local term1 = a.args[1]
        local term2_base = a.args[2].base
        return add({ func("log", {deepcopy(term1)}), neg(func("log", {deepcopy(term2_base)})) })
      end
    elseif n == "exp" then
      if not a then return expr end
      -- exp(0) = 1
      if is_zero(a) then return ONE end
      -- exp(log(x)) = x
      if is_func(a) and a.name == "log" then return a.args[1] end
      -- exp(a+b) = exp(a)*exp(b)
      if is_add(a) then
        local exps = {}
        for _,term in ipairs(a.args) do
          table.insert(exps, func("exp", {deepcopy(term)}))
        end
        return mul(exps)
      end
      -- (e^a)^b = e^(a*b) -- exp(a*log(b)) = b^a; exp(b*log(a)) = a^b
      -- This one is tricky: exp(X) where X = Y * log(Z)  => Z^Y
      if is_mul(a) and #a.args == 2 then
          local arg1, arg2 = a.args[1], a.args[2]
          if is_func(arg2) and arg2.name == "log" then -- arg1 * log(arg2_inner)
              return pow(deepcopy(arg2.args[1]), deepcopy(arg1))
          elseif is_func(arg1) and arg1.name == "log" then -- log(arg1_inner) * arg2
              return pow(deepcopy(arg1.args[1]), deepcopy(arg2))
          end
      end

    elseif n == "sin" or n == "cos" then
      if not a then return expr end
      -- sin(0)=0, cos(0)=1
      if is_zero(a) then return n == "sin" and ZERO or ONE end
      -- sin(-x) = -sin(x), cos(-x) = cos(x)
      if is_neg(a) then
        if n == "sin" then return neg(func("sin", {deepcopy(a.arg)})) end
        if n == "cos" then return func("cos", {deepcopy(a.arg)}) end
      end
      -- sin(n*pi) = 0 for integer n
      if n == "sin" and is_mul(a) and #a.args == 2 then
          local factor1, factor2 = a.args[1], a.args[2]
          if is_num(factor1) and is_integer(numval(factor1)) and is_var(factor2) and factor2.name == "pi" then return ZERO end
          if is_num(factor2) and is_integer(numval(factor2)) and is_var(factor1) and factor1.name == "pi" then return ZERO end
          if is_num(factor1) and is_integer(numval(factor1)) and is_num(factor2) and math.abs(numval(factor2) - math.pi) < 1e-9 then return ZERO end
          if is_num(factor2) and is_integer(numval(factor2)) and is_num(factor1) and math.abs(numval(factor1) - math.pi) < 1e-9 then return ZERO end
      end
      -- cos(n*pi) = (-1)^n for integer n
      if n == "cos" and is_mul(a) and #a.args == 2 then
          local factor_n, factor_pi
          if is_num(a.args[1]) and is_integer(numval(a.args[1])) and ((is_var(a.args[2]) and a.args[2].name == "pi") or (is_num(a.args[2]) and math.abs(numval(a.args[2]) - math.pi) < 1e-9)) then
              factor_n = a.args[1]
          elseif is_num(a.args[2]) and is_integer(numval(a.args[2])) and ((is_var(a.args[1]) and a.args[1].name == "pi") or (is_num(a.args[1]) and math.abs(numval(a.args[1]) - math.pi) < 1e-9)) then
              factor_n = a.args[2]
          end
          if factor_n then
              if numval(factor_n) % 2 == 0 then return ONE else return MINUS_ONE end
          end
      end

    elseif n == "tan" then
      if not a then return expr end
      -- tan(0)=0
      if is_zero(a) then return ZERO end
      -- tan(-x) = -tan(x)
      if is_neg(a) then return neg(func("tan", {deepcopy(a.arg)})) end
    end
  end
end)

-- Trig identities (basic)
table.insert(rules, function(expr)
  -- sin^2(x) + cos^2(x) = 1
  if is_add(expr) and #expr.args == 2 then
    local term1, term2 = expr.args[1], expr.args[2]
    local sin_arg, cos_arg

    local function check_sq_func(term, func_name)
        if is_pow(term) and is_num(term.exp) and numval(term.exp) == 2 and
           is_func(term.base) and term.base.name == func_name and #term.base.args == 1 then
            return term.base.args[1]
        end
        return nil
    end

    sin_arg = check_sq_func(term1, "sin")
    cos_arg = check_sq_func(term2, "cos")
    if sin_arg and cos_arg and ast_eq(sin_arg, cos_arg) then return ONE end

    sin_arg = check_sq_func(term2, "sin")
    cos_arg = check_sq_func(term1, "cos")
    if sin_arg and cos_arg and ast_eq(sin_arg, cos_arg) then return ONE end
  end

  -- tan(x) = sin(x)/cos(x) => sin(x) * cos(x)^-1
  if is_func(expr) and expr.name == "tan" and #expr.args == 1 then
    local arg = expr.args[1]
    return mul({ func("sin", {deepcopy(arg)}), pow(func("cos", {deepcopy(arg)}), MINUS_ONE) })
  end
  
  -- 1 - cos^2(x) = sin^2(x)
  if is_add(expr) and #expr.args == 2 then
    local one_term, minus_cos_sq_term
    if is_one(expr.args[1]) and is_neg(expr.args[2]) and is_pow(expr.args[2].arg) and is_num(expr.args[2].arg.exp) and numval(expr.args[2].arg.exp) == 2 and is_func(expr.args[2].arg.base) and expr.args[2].arg.base.name == "cos" then
        return pow(func("sin", {deepcopy(expr.args[2].arg.base.args)}), TWO)
    elseif is_one(expr.args[2]) and is_neg(expr.args[1]) and is_pow(expr.args[1].arg) and is_num(expr.args[1].arg.exp) and numval(expr.args[1].arg.exp) == 2 and is_func(expr.args[1].arg.base) and expr.args[1].arg.base.name == "cos" then
        return pow(func("sin", {deepcopy(expr.args[1].arg.base.args)}), TWO)
    end
  end
  -- 1 - sin^2(x) = cos^2(x)
  if is_add(expr) and #expr.args == 2 then
    local one_term, minus_sin_sq_term
    if is_one(expr.args[1]) and is_neg(expr.args[2]) and is_pow(expr.args[2].arg) and is_num(expr.args[2].arg.exp) and numval(expr.args[2].arg.exp) == 2 and is_func(expr.args[2].arg.base) and expr.args[2].arg.base.name == "sin" then
        return pow(func("cos", {deepcopy(expr.args[2].arg.base.args)}), TWO)
    elseif is_one(expr.args[2]) and is_neg(expr.args[1]) and is_pow(expr.args[1].arg) and is_num(expr.args[1].arg.exp) and numval(expr.args[1].arg.exp) == 2 and is_func(expr.args[1].arg.base) and expr.args[1].arg.base.name == "sin" then
        return pow(func("cos", {deepcopy(expr.args[1].arg.base.args)}), TWO)
    end
  end

end)


table.insert(rules, function(expr)
-- Multiplication of fractions: (a/b) * (c/d) = (a*c)/(b*d)
  -- This is generally handled by canonicalization (flattening muls, combining powers)
  -- e.g. a * b^-1 * c * d^-1  becomes a * c * b^-1 * d^-1 which is mul({a,c}, pow(mul({b,d}), MINUS_ONE))

  -- Addition of fractions: a/b + c/d = (ad+bc)/bd
  -- This rule can be complex and lead to expression blowup if not careful.
  -- The existing rule is a bit basic, this is a placeholder for more advanced common denominator logic.
  -- Current implementation tries to make a common denominator by just multiplying all denominators.
  -- A more advanced version would find the LCM of denominators.
  if is_add(expr) then
    local terms_with_denominators = {}
    local other_terms = {}
    local has_fractions = false

    for _, arg in ipairs(expr.args) do
      -- Guard for frac node: preserve if symbolicOnly
      if arg.type == "frac" then
        if simplify.symbolicOnly then return expr end
      end
      if is_mul(arg) and #arg.args > 0 then
        local num_parts = {}
        local den_parts = {}
        for _, factor in ipairs(arg.args) do
          if is_pow(factor) and is_num(factor.exp) and numval(factor.exp) < 0 then
            table.insert(den_parts, pow(deepcopy(factor.base), num(-numval(factor.exp))))
            has_fractions = true
          else
            table.insert(num_parts, deepcopy(factor))
          end
        end
        if #den_parts > 0 then
          local numerator = (#num_parts == 0) and ONE or ((#num_parts == 1) and num_parts[1] or mul(num_parts))
          local denominator = (#den_parts == 1) and den_parts[1] or mul(den_parts)
          table.insert(terms_with_denominators, {n = numerator, d = denominator})
        else
          table.insert(other_terms, arg) -- Not a fraction of the form num * den^-1
        end
      elseif is_pow(arg) and is_num(arg.exp) and numval(arg.exp) < 0 then
        table.insert(terms_with_denominators, {n = ONE, d = pow(deepcopy(arg.base), num(-numval(arg.exp)))})
        has_fractions = true
      else
        table.insert(other_terms, arg)
      end
    end

    if not has_fractions or #terms_with_denominators == 0 then return nil end
    
    -- If there are other terms not in fraction form, treat them as other_term / 1
    for _, ot in ipairs(other_terms) do
        table.insert(terms_with_denominators, {n = ot, d = ONE})
    end
    if #terms_with_denominators <= 1 and #other_terms == 0 then return nil end -- only one fraction, or no fractions

    -- Find common denominator (simplified: product of all unique denominators)
    -- More advanced: LCM. For now, product of simplified denominators.
    local denominators_list = {}
    for _, frac in ipairs(terms_with_denominators) do
        table.insert(denominators_list, frac.d)
    end
    
    -- This is a very naive common denominator.
    -- A proper GCD/LCM for polynomials would be needed for better results.
    -- For now, just multiply them if more than one distinct.
    local common_denominator_terms = {}
    local unique_denoms_str = {}
    for _,d_node in ipairs(denominators_list) do
        if not is_one(d_node) then
            local s = serialize_for_sort(simplify.simplify(d_node)) -- Simplify and serialize
            if not unique_denoms_str[s] then
                table.insert(common_denominator_terms, simplify.simplify(d_node))
                unique_denoms_str[s] = true
            end
        end
    end
    
    local common_denominator
    if #common_denominator_terms == 0 then
        common_denominator = ONE
    elseif #common_denominator_terms == 1 then
        common_denominator = common_denominator_terms[1]
    else
        common_denominator = simplify.simplify(mul(common_denominator_terms))
    end
    
    if is_one(common_denominator) and #other_terms == #expr.args then return nil end -- all were whole numbers


    local new_numerators_sum_args = {}
    for _, frac in ipairs(terms_with_denominators) do
      local current_num = frac.n
      local current_den = frac.d

      if ast_eq(current_den, common_denominator) then
        table.insert(new_numerators_sum_args, current_num)
      else
        -- multiplier = common_denominator / current_den
        -- To avoid explicit division in AST if current_den is complex,
        -- we are essentially doing: num * (common_den / current_den)
        -- = num * common_den * current_den^-1
        -- This needs careful simplification itself.
        -- A simpler approach: find what to multiply num by.
        -- If common_den = d1*d2*d3 and current_den = d1, multiplier is d2*d3.
        -- This requires factorization of denominators. Too complex for now.
        -- Naive: new_num_part = current_num * (common_denominator / current_den)
        -- Let's use the simplify engine for (common_denominator * current_den^-1)
        if is_one(current_den) then
             table.insert(new_numerators_sum_args, simplify.simplify(mul({current_num, common_denominator})))
        else
            local den_inv = simplify.simplify(pow(current_den, MINUS_ONE))
            local multiplier = simplify.simplify(mul({common_denominator, den_inv}))
            table.insert(new_numerators_sum_args, simplify.simplify(mul({current_num, multiplier})))
        end
      end
    end
    
    local sum_of_new_numerators = simplify.simplify(add(new_numerators_sum_args))

    if is_zero(sum_of_new_numerators) then return ZERO end
    if is_one(common_denominator) then return sum_of_new_numerators end

    return mul({sum_of_new_numerators, pow(common_denominator, MINUS_ONE)})
  end
end)


table.insert(rules, function(expr)
  -- Simplify x^1 => x (already present, but good to have as a cleanup)
  if is_pow(expr) and is_one(expr.exp) then
    return expr.base
  end
  -- Simplify ...*1*... => ...
  if is_mul(expr) then
    local out = {}
    local changed = false
    for _,a in ipairs(expr.args) do
      if not is_one(a) then table.insert(out, a)
      else changed = true
      end
    end
    if not changed then return nil end
    if #out == 0 then return ONE end
    if #out == 1 then return out[1] end
    return mul(out)
  end
  -- Simplify add({n}) => n and mul({n}) => n (general cleanup)
  if (is_add(expr) or is_mul(expr)) and #expr.args == 1 then
    return expr.args[1]
  end
end)

table.insert(rules, function(expr)
  -- Clean up powers
  if is_pow(expr) then
    if is_one(expr.exp) then return expr.base end
    if is_zero(expr.exp) and not is_zero(expr.base) then return ONE end -- 0^0 is undefined/contextual, often 1 in combinatorics
    if is_zero(expr.base) and is_num(expr.exp) and numval(expr.exp) > 0 then return ZERO end -- 0^positive = 0
    if is_one(expr.base) then return ONE end -- 1^x = 1
  end
  -- Clean up multiplication by zero or one
  if is_mul(expr) then
    local out = {}
    local has_zero = false
    local changed = false
    for _, a in ipairs(expr.args) do
      if is_zero(a) then has_zero = true; break end
      if not is_one(a) then table.insert(out, a)
      else changed = true -- A '1' was removed
      end
    end
    if has_zero then return ZERO end
    if not changed and #out == #expr.args then return nil end -- No change

    if #out == 0 then return ONE end -- Product of ones
    if #out == 1 then return out[1] end
    return mul(out)
  end
  -- Clean up addition of zero
  if is_add(expr) then
    local out = {}
    local changed = false
    for _, a in ipairs(expr.args) do
      if not is_zero(a) then table.insert(out, a)
      else changed = true -- A '0' was removed
      end
    end
    if not changed and #out == #expr.args then return nil end -- No change

    if #out == 0 then return ZERO end -- Sum of zeros
    if #out == 1 then return out[1] end
    return add(out)
  end
end)


local function factorial(n_val)
  if not (n_val >= 0 and math.floor(n_val) == n_val) then
    -- For non-integer or negative, factorial is often undefined or uses Gamma
    -- This CAS might want to return gamma(n+1) or an error/unevaluated
    return nil -- Or perhaps func("gamma", {add({num(n_val), ONE})}) if that's desired behavior
  end
  local result = 1
  for i = 2, n_val do result = result * i end
  return result
end

-- Approximate gamma using Lanczos approximation
local function gamma_lanczos(z_val)
    local p_coeffs = {
        676.5203681218851, -1259.1392167224028, 771.32342877765313,
        -176.61502916214059, 12.507343278686905,
        -0.13857109526572012, 9.9843695780195716e-6,
        1.5056327351493116e-7
    }
    if z_val < 0.5 then
        if math.sin(math.pi * z_val) == 0 then return nil end -- Pole, undefined
        local gamma_one_minus_z = gamma_lanczos(1 - z_val)
        if not gamma_one_minus_z then return nil end
        return math.pi / (math.sin(math.pi * z_val) * gamma_one_minus_z)
    else
        local z_adj = z_val - 1
        local x = 0.99999999999980993
        for i = 1, #p_coeffs do
            x = x + p_coeffs[i] / (z_adj + i)
        end
        local t = z_adj + #p_coeffs - 0.5
        return math.sqrt(2 * math.pi) * (t^(z_adj + 0.5)) * math.exp(-t) * x
    end
end


-- Gamma and Factorial function rules
table.insert(rules, function(expr)
  if is_func(expr) then
    if expr.name == "gamma" and #expr.args == 1 and is_num(expr.args[1]) then
      local x_val = numval(expr.args[1])
      if x_val > 0 then
        if is_integer(x_val) then -- gamma(n) = (n-1)! for positive integer n
          local fact_val = factorial(x_val - 1)
          if fact_val then return num(fact_val) end
        else -- Positive non-integer
          local gamma_val = gamma_lanczos(x_val)
          if gamma_val then return num(gamma_val) end
        end
      elseif x_val <= 0 and is_integer(x_val) then
          return nil -- Undefined (pole) for 0 and negative integers
      else -- Negative non-integer, use reflection formula if gamma_lanczos handles it or transformed
          local gamma_val = gamma_lanczos(x_val)
          if gamma_val then return num(gamma_val) end
      end
    elseif expr.name == "factorial" and expr.args and #expr.args == 1 then
      local arg_node = expr.args[1]
      if is_num(arg_node) then
        local n_val = numval(arg_node)
        if is_integer(n_val) and n_val >= 0 then
          local fact_val = factorial(n_val)
          if fact_val then return num(fact_val) end
        else
          -- factorial(non-integer) -> gamma(non-integer + 1)
          local gamma_arg = simplify.simplify(add({ arg_node, ONE }))
          return func("gamma", { gamma_arg })
        end
      -- factorial(x+1) is often kept as is, or gamma(x+2)
      -- No specific symbolic transformation here beyond numerical evaluation or gamma conversion
      end
    end
  end
end)

-- Symbolic simplification for factorial/gamma relations
table.insert(rules, function(expr)
    -- gamma(x+1) => x*gamma(x) or x! if x is suitable for factorial
    if is_func(expr) and expr.name == "gamma" and #expr.args == 1 then
        local arg = expr.args[1]
        if is_add(arg) and #arg.args == 2 then
            local term1, term2
            if is_one(arg.args[2]) then -- x + 1 form
                term1 = arg.args[1] 
                term2 = arg.args[2]
            elseif is_one(arg.args[1]) then -- 1 + x form
                term1 = arg.args[2]
                term2 = arg.args[1]
            end
            if term1 then
                -- If term1 is an integer or variable for which factorial makes sense:
                -- gamma(n+1) = n!
                -- This transformation to factorial is often preferred
                -- For now, let's do x*gamma(x)
                -- return mul({deepcopy(term1), func("gamma", {deepcopy(term1)})})
                -- The transformFactorial function already handles factorial -> gamma,
                -- so perhaps we want gamma(x+1) -> x! if it simplifies things
                 return func("factorial", {deepcopy(term1)}) -- This is done by transformFactorial's intent or a specific rule.
                                                           -- Re-evaluate if this rule is beneficial here or creates loops.
                                                           -- Given transformFactorial, this might be redundant or better placed.
                                                           -- Let's keep it as is per user's original structure intent.
            end
        end
    end

    -- x! / (x-1)! = x
    -- Representation: mul({ factorial(x), pow(factorial(add({x, num(-1)})), MINUS_ONE) })
    if is_mul(expr) and #expr.args == 2 then
        local fac_term, inv_fac_term
        if is_func(expr.args[1]) and expr.args[1].name == "factorial" and
           is_pow(expr.args[2]) and is_func(expr.args[2].base) and expr.args[2].base.name == "factorial" and
           is_minus_one(expr.args[2].exp) then
            fac_term = expr.args[1]
            inv_fac_term = expr.args[2].base
        elseif is_func(expr.args[2]) and expr.args[2].name == "factorial" and
                 is_pow(expr.args[1]) and is_func(expr.args[1].base) and expr.args[1].base.name == "factorial" and
                 is_minus_one(expr.args[1].exp) then
            fac_term = expr.args[2]
            inv_fac_term = expr.args[1].base
        end

        if fac_term and inv_fac_term then
            local fac_arg = fac_term.args[1]
            local inv_fac_arg = inv_fac_term.args[1]
            -- Check if fac_arg is inv_fac_arg + 1
            local diff_check = simplify.simplify(add({deepcopy(inv_fac_arg), ONE}))
            if ast_eq(fac_arg, diff_check) then
                return deepcopy(fac_arg) -- Returns x (if fac_arg was x, from x! / (x-1)!)
            end
        end
    end

    -- x! / x = (x-1)!
    -- Representation: mul({ factorial(x), pow(x, MINUS_ONE) })
    if is_mul(expr) and #expr.args == 2 then
        local fac_node, var_inv_node
        if is_func(expr.args[1]) and expr.args[1].name == "factorial" and is_pow(expr.args[2]) and is_minus_one(expr.args[2].exp) then
            fac_node = expr.args[1]
            var_inv_node = expr.args[2]
        elseif is_func(expr.args[2]) and expr.args[2].name == "factorial" and is_pow(expr.args[1]) and is_minus_one(expr.args[1].exp) then
            fac_node = expr.args[2]
            var_inv_node = expr.args[1]
        end

        if fac_node and var_inv_node then
            if ast_eq(fac_node.args[1], var_inv_node.base) then
                return func("factorial", {simplify.simplify(add({deepcopy(fac_node.args[1]), MINUS_ONE}))})
            end
        end
    end
    
    -- x! * x = (x+1)! -- This rule seems to be implemented inversely below, x! * x usually doesn't combine this way unless it's (x-1)! * x
    -- More common is (x-1)! * x = x!
    if is_mul(expr) and #expr.args == 2 then
        local term1, term2 = expr.args[1], expr.args[2]
        local fac_node, var_node
        if is_func(term1) and term1.name == "factorial" then
            fac_node = term1; var_node = term2;
        elseif is_func(term2) and term2.name == "factorial" then
            fac_node = term2; var_node = term1;
        end

        if fac_node and var_node then -- var_node must be a variable or expression
            -- We want to match (X)! * (X+1)  -> (X+1)!
            -- Or X! * (X+1) -> (X+1)!
            local fac_arg_plus_one = simplify.simplify(add({deepcopy(fac_node.args[1]), ONE}))
            if ast_eq(var_node, fac_arg_plus_one) then
                 return func("factorial", {deepcopy(var_node)}) -- { (X+1)! }
            end
        end
    end


    -- x! / x! = 1
    if is_mul(expr) and #expr.args == 2 and is_func(expr.args[1]) and expr.args[1].name == "factorial" and
       is_pow(expr.args[2]) and is_func(expr.args[2].base) and expr.args[2].base.name == "factorial" and
       is_minus_one(expr.args[2].exp) then
        if ast_eq(expr.args[1].args[1], expr.args[2].base.args[1]) then return ONE end
    end
end)


--[[
------------------------------------------------------------------------------------
-- PLACEHOLDER FOR ADDITIONAL RULES FROM THE (INCOMPLETE) SECOND SNIPPET:
-- If the second snippet (Comprehensive CAS) had complete rule definitions like:
-- table.insert(rules, function(expr) ... advanced rule ... end)
-- They would be added here.
-- For example, if the second snippet contained:
-- table.insert(rules, function(expr)
--   -- Example advanced rule for derivative, e.g. d/dx(sin(x)) = cos(x)
--   if is_func(expr) and expr.name == "diff" and #expr.args == 2 then
--     local func_to_diff = expr.args[1]
--     local diff_var = expr.args[2]
--     if is_func(func_to_diff) and func_to_diff.name == "sin" and ast_eq(func_to_diff.args[1], diff_var) then
--       return func("cos", {deepcopy(diff_var)})
--     end
--   end
-- end)
-- That block of code would be inserted in this section.
------------------------------------------------------------------------------------
--]]

-- Fallback: return the node unchanged (already part of the iterative loop logic)
-- local function fallback(expr) return nil end

--[[
  Recursive and Iterative Simplification
  - Recursively simplify children
  - Apply all rules in order
  - Repeat passes until stable (fixed point)
--]]

-- Define recursive_simplify before its first usage (e.g., in canonicalize or simplify.simplify)
recursive_simplify = function(expr, recursion_depth)
  -- Patch: Recognize constants if enabled and variable matches a known constant
  if type(expr) == "table" and expr.type == "variable" then
    if not constants_disabled() then
      -- Physics constants (if enabled)
      local physics = _G.physics or (pcall(require, "physics") and require("physics")) or nil
      if physics and physics.is_constant_enabled and physics.is_constant_enabled(expr.name) then
        local category = _G.current_constant_category or "fundamental"
        print("[DEBUG] Current constant category (simplify):", category)
        local const_val = physics.get_constant_value(expr.name, category)
        if const_val then return const_val end
      end
      -- Math constants: e, pi, etc.
      if physics and physics.is_constant_enabled then
        local category = _G.current_constant_category or "fundamental"
        print("[DEBUG] Current constant category (simplify):", category)
        if expr.name == "e" and physics.is_constant_enabled("e") then
          local e_val = physics.get_constant_value("e", category)
          if e_val then return e_val end
        elseif expr.name == "pi" and physics.is_constant_enabled("pi") then
          local pi_val = physics.get_constant_value("pi", category)
          if pi_val then return pi_val end
        end
      end
      -- Fallback: legacy constants table (if present)
      if constants then
        local constant_entry = constants[expr.name]
        if constant_entry then
          local parsed = parser.parse(constant_entry.value)
          return simplify.simplify(parsed)
        end
      end
    end
  end
  dbgprint("recursive_simplify called for:", simplify.pretty_print(expr))
  recursion_depth = recursion_depth or 0
  if recursion_depth > 50 then -- Max recursion depth to prevent infinite loops
    return expr 
  end

  -- Preserve string literals (e.g., commands) without simplification
  if type(expr) == 'table' and expr.type == 'string' then
    return expr
  end

  if type(expr) ~= "table" then return expr end

  -- Handle matrix node type: recursively simplify each element (NEW BLOCK)
  if expr.type == "matrix" then
    local new_rows = {}
    for i, row in ipairs(expr.rows) do
      local new_row = {}
      for j, elem in ipairs(row) do
        table.insert(new_row, recursive_simplify(elem, recursion_depth + 1))
      end
      table.insert(new_rows, new_row)
    end
    return ast.matrix(new_rows)
  end

  -- Handle equation node type: recursively simplify left and right
  if expr.type == "equation" then
    return {
      type = "equation",
      left = recursive_simplify(expr.left, recursion_depth + 1),
      right = recursive_simplify(expr.right, recursion_depth + 1)
    }
  end
  
  local e = deepcopy(expr) -- Work on a copy to allow changes

  -- Recursively simplify children first
  if e.type == "add" or e.type == "mul" or e.type == "func" then
    if e.args then
        local new_args = {}
        for i,a in ipairs(e.args) do new_args[i] = recursive_simplify(a, recursion_depth + 1) end
        e.args = new_args
    end
  elseif e.type == "pow" then
    e.base = recursive_simplify(e.base, recursion_depth + 1)
    e.exp = recursive_simplify(e.exp, recursion_depth + 1)
  elseif e.type == "neg" then
    e.arg = recursive_simplify(e.arg, recursion_depth + 1)
  elseif e.type == "div" then
    e.left = recursive_simplify(e.left, recursion_depth + 1)
    e.right = recursive_simplify(e.right, recursion_depth + 1)
  end

  -- Apply rules iteratively until no more changes
  local max_rule_passes = 50 -- Prevent runaway rule application
  for pass = 1, max_rule_passes do
    local changed_in_pass = false
    e = canonicalize(e) -- Canonicalize before each rule pass

    for _, rule in ipairs(rules) do
      local res = rule(e)
      if res and not ast_eq(res, e) then
        e = res
        e = canonicalize(e) -- Canonicalize after applying one rule
        changed_in_pass = true
        break  -- Stop after first applicable rule; outer loops handle further simplification
      end
    end
    if not changed_in_pass then break end -- Stable state for this level
    if pass == max_rule_passes then
    end
  end
  
  dbgprint("recursive_simplify result:", simplify.pretty_print(e))
  return canonicalize(e) -- Final canonical form for this level
end


-- Transform factorial(n) to gamma(n+1), recursively for all subnodes.
-- This should ideally run once before the main simplification loop,
-- or be integrated as a rule if gamma is the preferred internal form.
local function transformFactorialToGamma(expr)
  if type(expr) ~= "table" then return expr end

  local new_expr = deepcopy(expr) -- Operate on a copy

  if new_expr.type == "func" and new_expr.name == "factorial" and new_expr.args and #new_expr.args == 1 then
    local arg_transformed = transformFactorialToGamma(new_expr.args[1])
    return {
      type = "func",
      name = "gamma",
      args = {
        simplify.simplify(add({ arg_transformed, ONE })) -- Simplify (arg + 1)
      }
    }
  end

  -- Recursively transform arguments/parts of the expression
  if new_expr.args then
    for i, arg_child in ipairs(new_expr.args) do
      new_expr.args[i] = transformFactorialToGamma(arg_child)
    end
  elseif new_expr.arg then -- For unary operations like 'neg'
    new_expr.arg = transformFactorialToGamma(new_expr.arg)
  elseif new_expr.base and new_expr.exp then -- For 'pow'
    new_expr.base = transformFactorialToGamma(new_expr.base)
    new_expr.exp = transformFactorialToGamma(new_expr.exp)
  end
  
  return new_expr
end

-- Entry point: simplify this AST until it stops complaining
-- May loop forever if your grammar is complex enough
function simplify.simplify(expr_input)
  dbgprint("Input to simplify:", simplify.pretty_print(expr_input))
  local expr = deepcopy(expr_input) -- Ensure we don't modify the input AST

  -- --- PATCH: Store current GUI constant category before simplification
  if gui and gui.get_current_category then
      local cat = gui.get_current_category()
      if cat then
          var("current_constant_category", cat)
      end
  end

  -- Handle derivative syntax d/dx(f): transform to diff(f, x)
  if expr.type == "div"
     and expr.left.type == "variable" and expr.left.name == "d"
     and expr.right.type == "func"
     and type(expr.right.name) == "string"
     and expr.right.name:sub(1,1) == "d" then
    -- Extract variable name after leading 'd'
    local varname = expr.right.name:sub(2)
    local fnode = expr.right.args and expr.right.args[1] or nil
    if fnode then
      expr = diff(fnode, make_var(varname))
    end
  else
    -- Original division-to-multiplication transform
    expr = force_div_to_mul_pow(expr)
  end

  -- Step 1: Transform all factorial(n) to gamma(n+1) as a preprocessing step
  -- This makes gamma the canonical form for these types of functions.
  expr = transformFactorialToGamma(expr)
  expr = canonicalize(expr) -- Canonicalize after transformation

  -- Symbolic-only wrapper removed: numeric simplification always proceeds regardless of symbolicOnly.

  dbgprint("Starting simplification main loop. Initial expr:", simplify.pretty_print(expr))
  local current_expr = expr
  local max_iterations = 20 -- Max iterations for the main simplification loop
  local seen = {}
  for i = 1, max_iterations do
    dbgprint("Iteration", i, "Current expr:", simplify.pretty_print(current_expr))
    local h = ast_hash(current_expr)
    if seen[h] then
      dbgprint("Cycle detected at iteration", i, h)
      break -- Prevent infinite loops on cycling expressions
    end
    seen[h] = true
    local simplified_once = recursive_simplify(current_expr)
    local next_expr = canonicalize(simplified_once)
    if ast_eq(current_expr, next_expr) then
      break -- Fixed point reached
    end
    current_expr = next_expr
    dbgprint("After iteration", i, "Next expr:", simplify.pretty_print(current_expr))
    if i == max_iterations then
        dbgprint("Warning: Simplification reached max iterations (" .. max_iterations .. ").")
    end
  end
  return current_expr
end

function simplify.solve_equation(eq, varname)
  varname = varname or "x"
  eq = simplify.simplify(eq)
  if type(eq) ~= "table" or eq.type ~= "equation" then
    error(errors.invalid("solve", "not an equation AST"))
  end

  -- Move all terms to one side: left - right = 0
  local expr = simplify.simplify({type="add", args={eq.left, {type="neg", arg=eq.right}}})

  -- Helper: degree of the variable in expr
  local function degree(e)
    if type(e) ~= "table" then return 0 end
    if e.type == "variable" and e.name == varname then return 1 end
    if e.type == "pow" and e.base.type == "variable" and e.base.name == varname and e.exp.type == "number" then
      return e.exp.value
    end
    if e.args then
      local maxd = 0
      for _, a in ipairs(e.args) do
        local d = degree(a)
        if d > maxd then maxd = d end
      end
      return maxd
    end
    if e.left or e.right then
      return math.max(degree(e.left or 0), degree(e.right or 0))
    end
    return 0
  end

  -- Helper: robust coefficient extraction for up to cubic: a*x^3 + b*x^2 + c*x + d
  -- Improved robust coefficient extraction for up to cubic: a*x^3 + b*x^2 + c*x + d
local function extract_coeffs(expr)
  local coeffs = { [0]=0, [1]=0, [2]=0, [3]=0 }
  local function add_coeff(deg, val)
    coeffs[deg] = (coeffs[deg] or 0) + val
  end
  local function walk(e, sign)
    sign = sign or 1
    if type(e) ~= "table" then return end
    if e.type == "add" then
      for _, t in ipairs(e.args) do walk(t, sign) end
    elseif e.type == "sub" then
      walk(e.left, sign)
      walk(e.right, -sign)
    elseif e.type == "neg" then
      walk(e.arg or e.value, -sign)
    elseif e.type == "number" then
      add_coeff(0, sign * e.value)
    elseif e.type == "variable" and e.name == varname then
      add_coeff(1, sign)
    elseif e.type == "pow" and e.base and e.exp then
      if e.base.type == "variable" and e.base.name == varname and e.exp.type == "number" then
        add_coeff(e.exp.value, sign)
      end
    elseif e.type == "mul" and e.args then
      -- Handle things like -5x, 2x^2, -3, etc.
      local num = 1
      local deg = 0
      local valid = true
      for _, a in ipairs(e.args) do
        if a.type == "number" then
          num = num * a.value
        elseif a.type == "variable" and a.name == varname then
          deg = deg + 1
        elseif a.type == "pow" and a.base.type == "variable" and a.base.name == varname and a.exp.type == "number" then
          deg = deg + a.exp.value
        else
          valid = false
        end
      end
      if valid then
        add_coeff(deg, sign * num)
      end
    else
      -- DEBUG: Print any unhandled term structures
      print("[DEBUG][extract_coeffs] Unhandled expr node:", require('inspect')(e))
    end
  end
  walk(expr)
  print(string.format("[DEBUG][extract_coeffs] coeffs: x^2=%s, x^1=%s, const=%s", coeffs[2], coeffs[1], coeffs[0]))
  return coeffs
end

  local deg = degree(expr)

  -- Linear: ax + b = 0
  if deg == 1 then
    local coeffs = extract_coeffs(expr)
    local a = coeffs[1] or 0
    local b = coeffs[0] or 0
    if a ~= 0 then
      return {
        type="equation",
        left={type="variable", name=varname},
        right={type="number", value = -b/a}
      }
    end
  end

  -- Quadratic: ax^2 + bx + c = 0
  if deg == 2 then
    local coeffs = extract_coeffs(expr)
    local a = coeffs[2] or 0
    local b = coeffs[1] or 0
    local c = coeffs[0] or 0
    if a ~= 0 then
      local disc = b*b - 4*a*c
      -- Patch: Defensive nil check before comparison (fix "attempt to compare nil with number")
      if disc ~= nil and disc < 0 then
        -- negative discriminant, still show symbolic sqrt
      end
      -- Always use symbolic sqrt, so we can show solutions for negative discriminant
      local sqrt_node = {type="func", name="sqrt", args={ {type="number", value=disc} } }
      local denom = 2*a
      return {
        type="set",
        solutions={
          {
            type="equation",
            left={type="variable", name=varname},
            right={
              type="div",
              left={ type="add", args={ {type="number", value=-b}, sqrt_node } },
              right={ type="number", value=denom }
            }
          },
          {
            type="equation",
            left={type="variable", name=varname},
            right={
              type="div",
              left={ type="add", args={ {type="number", value=-b}, {type="neg", arg=sqrt_node } } },
              right={ type="number", value=denom }
            }
          }
        }
      }
    end
  end

  -- Cubic: Just return implicit solution
  if deg == 3 then
    return {
      type="implicit",
      left={type="variable", name=varname},
      right={type="raw", value="(cubic solution not implemented)"}
    }
  end

  -- Higher degree or unsolvable: fallback to implicit
  return {
    type="implicit",
    left={type="variable", name=varname},
    right={type="raw", value="Cannot isolate variable; implicit solution"}
  }
end


-- Export all utilities
simplify.rules = rules
simplify.deepcopy = deepcopy
simplify.ast_eq = ast_eq
simplify.is_num = is_num
simplify.is_var = is_var
simplify.is_add = is_add
simplify.is_mul = is_mul
simplify.is_pow = is_pow
simplify.is_neg = is_neg
simplify.is_func = is_func
simplify.num = num
simplify.var = make_var
simplify.add = add
simplify.mul = mul
simplify.pow = pow
simplify.neg = neg
simplify.func = func
simplify.flatten = flatten
simplify.sort_args = sort_args
simplify.occurs = occurs
simplify.copy_node = copy_node
simplify.map_args = map_args
simplify.canonicalize = canonicalize
simplify.solve_equation = simplify.solve_equation

_G.simplify = simplify -- For use in environment if not loaded as a module
_G.simplify.pretty_print = pretty_print

-- Rule from original first snippet (already present before your comment)
-- x! * x^(-1) => (x - 1)! -- This is effectively gamma(x+1) * x^-1 => gamma(x)
-- Given transformFactorialToGamma, this rule might be better expressed in terms of gamma,
-- or ensured that factorial forms are simplified before transformation if this specific form is desired.
table.insert(rules, function(expr)
  if is_mul(expr) and #expr.args == 2 then
    local term_a, term_b = expr.args[1], expr.args[2]
    local fac_node, inv_node
    
    if is_func(term_a) and term_a.name == "factorial" and is_pow(term_b) and is_minus_one(term_b.exp) then
        fac_node = term_a
        inv_node = term_b
    elseif is_func(term_b) and term_b.name == "factorial" and is_pow(term_a) and is_minus_one(term_a.exp) then
        fac_node = term_b
        inv_node = term_a
    end

    if fac_node and inv_node and ast_eq(fac_node.args[1], inv_node.base) then
      -- fac_node.args[1] is 'x' from x!
      -- We want (x-1)! which is factorial(add({x, num(-1)}))
      return func("factorial", { add({ deepcopy(fac_node.args[1]), MINUS_ONE }) })
    end
  end
end)

table.insert(rules, function(expr)
  -- factorial(x) * x^(-1) → factorial(x - 1)
  if is_mul(expr) and #expr.args == 2 then
    local a, b = expr.args[1], expr.args[2]
    if is_func(a) and a.name == "factorial"
        and is_pow(b)
        and is_var(b.base)
        and ast_eq(b.base, a.args[1])
        and is_minus_one(b.exp) then
      return func("factorial", { add{a.args[1], num(-1)} })
    end
  end
end)
table.insert(rules, function(expr)
  -- x * x^(-1) → 1
  if is_mul(expr) and #expr.args == 2 then
    local a, b = expr.args[1], expr.args[2]
    if is_var(a) and is_pow(b)
       and ast_eq(a, b.base)
       and is_minus_one(b.exp) then
      return num(1)
    end
    if is_var(b) and is_pow(a)
       and ast_eq(b, a.base)
       and is_minus_one(a.exp) then
      return num(1)
    end
  end
end)
-- Simplify expressions like x * x^(-1) or x / x to 1
table.insert(rules, function(expr)
  if is_mul(expr) and #expr.args == 2 then
    local a, b = expr.args[1], expr.args[2]
    local function is_inverse_pair(u, v)
      return ast_eq(u, v.base) and is_pow(v) and is_minus_one(v.exp)
    end
    if is_inverse_pair(a, b) or is_inverse_pair(b, a) then
      return num(1)
    end
  end
end)
-- Symbolic inverse simplification: x^(-1) * x → 1
table.insert(rules, function(expr)
  if is_mul(expr) and #expr.args == 2 then
    local a, b = expr.args[1], expr.args[2]

    local function is_inverse_pair(x, y)
      return is_pow(x) and ast_eq(x.base, y) and is_num(x.exp) and numval(x.exp) == -1
    end

    if is_inverse_pair(a, b) or is_inverse_pair(b, a) then
      return num(1)
    end
  end
end)

-- Pretty printer: convert AST to human-readable math string
local function pretty_print_recursive(expr, parent_precedence)
  parent_precedence = parent_precedence or 0
  local current_precedence

  -- Defensive clause: malformed or non-table node
  if type(expr) ~= "table" or not expr.type then
    return "<unrecognized expression>"  -- replaced '<?>'' with something more informative
  end
  -- Check for missing left/right in equation
  if expr.type == "equation" and (not expr.left or not expr.right) then
    return "<?equation>"
  end
  -- Defensive checks for malformed nodes
  if expr.type == "pow" and (not expr.base or not expr.exp) then
    return "<malformed pow>"
  end
  if expr.type == "mul" and not expr.args then
    return "<malformed mul>"
  end
  if expr.type == "add" and not expr.args then
    return "<malformed add>"
  end
  if expr.type == "variable" and not expr.name then
    return "<malformed var>"
  end
  if expr.type == "number" and expr.value == nil then
    return "<malformed num>"
  end

  -- Print equation as "left = right"
  if expr.type == "equation" then
    if not expr.left or not expr.right then
      return "<?equation>"
    end
    local left_str = pretty_print_recursive(expr.left, 0)
    local right_str = pretty_print_recursive(expr.right, 0)
    return left_str .. " = " .. right_str
  end

  -- Print string literals with quotes
  if expr.type == "string" then
    return '"' .. tostring(expr.value or "") .. '"'
  end

  if is_num(expr) then
    if _G.autoDecimal then
      return string.format("%.10g", tonumber(expr.value))
    else
      return tostring(expr.value)
    end
  end
  -- Pretty print for exact division/fraction as decimal if needed
  if expr.type == "div" and is_num(expr.left) and is_num(expr.right) and _G.autoDecimal then
    local n, d = expr.left.value, expr.right.value
    if d ~= 0 then
      return string.format("%.10g", n / d)
    end
  end
  -- Pretty print for division (fraction) nodes
  if expr.type == "div" then
    local current_precedence = 2  -- use multiplication precedence
    local left_str = pretty_print_recursive(expr.left, current_precedence)
    local right_str = pretty_print_recursive(expr.right, current_precedence + 1)
    local res = left_str .. "/" .. right_str
    if current_precedence < parent_precedence then
      return "(" .. res .. ")"
    end
    return res
  end
  if is_var(expr) then return expr.name end
  if expr.type == "sub" then
    local current_precedence = 1  -- same precedence level as addition
    local left_str  = pretty_print_recursive(expr.left,  current_precedence)
    local right_str = pretty_print_recursive(expr.right, current_precedence)
    local res = left_str .. "-" .. right_str
    if current_precedence < parent_precedence then
      return "(" .. res .. ")"
    end
    return res
  end
  
  if is_neg(expr) then
    current_precedence = 4 -- Precedence of unary minus
    local arg_str = pretty_print_recursive(expr.arg, current_precedence)
    return "-" .. arg_str
  end
  
  if is_add(expr) then
    current_precedence = 1 -- Precedence of addition
    local parts = {}
    for i, arg in ipairs(expr.args) do
      local s = pretty_print_recursive(arg, current_precedence)
      if i > 1 and (type(s) == "string" and s:sub(1,1) ~= "-") then 
        table.insert(parts, "+") 
      end
      table.insert(parts, s)
    end
    local res = table.concat(parts)
    if current_precedence < parent_precedence then return "(" .. res .. ")" end
    return res
  end

  
  if is_mul(expr) then
    current_precedence = 2 -- Precedence of multiplication
    local parts = {}
    for i, arg in ipairs(expr.args) do
      local s = pretty_print_recursive(arg, current_precedence)
      parts[i] = s
    end
    -- Try to print 2x instead of 2*x if the form is (number, variable)
    if #parts == 2 and is_num(expr.args[1]) and is_var(expr.args[2]) then
      local res = tostring(expr.args[1].value) .. parts[2]
      if current_precedence < parent_precedence then return "(" .. res .. ")" end
      return res
    end
    -- Or variable*number as x2
    if #parts == 2 and is_var(expr.args[1]) and is_num(expr.args[2]) then
      local res = parts[1] .. tostring(expr.args[2].value)
      if current_precedence < parent_precedence then return "(" .. res .. ")" end
      return res
    end
    -- Otherwise print with *
    local res = table.concat(parts, "*")
    if current_precedence < parent_precedence then return "(" .. res .. ")" end
    return res
  end
  
  if is_pow(expr) then
    current_precedence = 3 -- Precedence of power
    local base_str = pretty_print_recursive(expr.base, current_precedence)
    local exp_str = pretty_print_recursive(expr.exp, 0) -- Exponent is usually fine without parens unless it's complex itself
    -- if is_add(expr.base) or is_mul(expr.base) then base_str = "(" .. base_str .. ")" end -- Handled by precedence
    -- if is_add(expr.exp) or is_mul(expr.exp) or is_pow(expr.exp) or is_neg(expr.exp) then exp_str = "(" .. exp_str .. ")" end -- Handled by precedence in recursive call
    local res = base_str .. "^" .. exp_str
    -- No, power is right-associative, so only add parens if parent_precedence is higher (e.g. (a^b)^c needs parens for a^b)
    -- However, (a*b)^c needs parens for a*b. This is handled by recursive call's parent_precedence.
    if current_precedence < parent_precedence then return "(" .. res .. ")" end -- This might be too aggressive
    return res
  end
  
  if is_func(expr) then
    local args_str = {}
    for _, a in ipairs(expr.args) do table.insert(args_str, pretty_print_recursive(a, 0)) end
    return expr.name .. "(" .. table.concat(args_str, ", ") .. ")"
  end
  
  return "<unknown node type '" .. tostring(expr.type) .. "'>"
end

simplify.pretty_print = function(expr)
    return pretty_print_recursive(expr, 0)
end

-- x * x^-1 => 1
table.insert(rules, function(expr)
  if is_mul(expr) then -- Check if it's a multiplication node
    -- Iterate through all pairs of arguments to find an inverse pair
    for i = 1, #expr.args do
      for j = i + 1, #expr.args do
        local a = expr.args[i]
        local b = expr.args[j]
        
        local function is_inverse_pair(u, v)
          -- u is base, v is base^-1 OR v is base, u is base^-1
          if is_pow(v) and is_minus_one(v.exp) and ast_eq(u, v.base) then return true end
          if is_pow(u) and is_minus_one(u.exp) and ast_eq(v, u.base) then return true end
          return false
        end

        if is_inverse_pair(a, b) then
          local others = {}
          for k = 1, #expr.args do
            if k ~= i and k ~= j then
              table.insert(others, expr.args[k])
            end
          end
          if #others == 0 then return ONE end -- Only a*a^-1, result is 1
          table.insert(others, 1, ONE) -- Add 1 to the remaining terms
          return mul(others) -- This will simplify to mul(others) after another rule pass removes the 1
        end
      end
    end
  end
end)


-- Patch: always set metatable on all AST results from simplify
if _G.set_ast_mt then
  local _old_simplify = simplify.simplify
  function simplify.simplify(expr_input)
    local result = _old_simplify(expr_input)
    _G.set_ast_mt(result)
    return result
  end
end
-- Numeric subtraction simplification
table.insert(rules, function(expr)
  -- 2 - 7 → -5
  if expr.type == "sub" and is_num(expr.left) and is_num(expr.right) then
    return num(numval(expr.left) - numval(expr.right))
  end
end)
-- Explicit rules for subtraction node simplification
table.insert(rules, function(expr)
  -- Numeric subtraction: sub(number, number) -> number
  if expr.type == "sub" and is_num(expr.left) and is_num(expr.right) then
    return num(numval(expr.left) - numval(expr.right))
  end
  -- 0 - x -> -x
  if expr.type == "sub" and is_zero(expr.left) then
    return neg(expr.right)
  end
  -- x - 0 -> x
  if expr.type == "sub" and is_zero(expr.right) then
    return expr.left
  end
  -- x - x -> 0
  if expr.type == "sub" and ast_eq(expr.left, expr.right) then
    return num(0)
  end
end)

-- Remove unconditional numeric division simplification rule (now handled above with _G.autoDecimal logic)

-- Distributive law for subtraction over addition: (a + b) - c = a - c + b - c
table.insert(rules, function(expr)
  if expr.type == "sub" and is_add(expr.left) then
    local new_args = {}
    for _, a in ipairs(expr.left.args) do
      table.insert(new_args, {type = "sub", left = a, right = deepcopy(expr.right)})
    end
    return add(new_args)
  end
end)

-- Distributive law for multiplication over subtraction: a * (b - c) = a * b - a * c
table.insert(rules, function(expr)
  if is_mul(expr) then
    for i, arg in ipairs(expr.args) do
      if arg.type == "sub" then
        local left_factors = {}
        for j, other in ipairs(expr.args) do
          if i ~= j then table.insert(left_factors, deepcopy(other)) end
        end
        return {
          type = "sub",
          left = mul({deepcopy(arg.left), table.unpack(left_factors)}),
          right = mul({deepcopy(arg.right), table.unpack(left_factors)})
        }
      end
    end
  end
end)

-- Basic binomial expansion: (a + b)^2 = a^2 + 2ab + b^2
table.insert(rules, function(expr)
  if is_pow(expr) and is_add(expr.base) and is_num(expr.exp) then
    local n = numval(expr.exp)
    if #expr.base.args == 2 and n == 2 then
      local a, b = expr.base.args[1], expr.base.args[2]
      return add({
        pow(deepcopy(a), num(2)),
        mul({num(2), deepcopy(a), deepcopy(b)}),
        pow(deepcopy(b), num(2))
      })
    end
  end
end)

-- Rules for negation simplification
table.insert(rules, function(expr)
  -- -(-x) = x
  if is_neg(expr) and is_neg(expr.arg) then
    return expr.arg.arg
  end
  -- -0 = 0
  if is_neg(expr) and is_zero(expr.arg) then
    return num(0)
  end
end)

-- Rule: x + (-y) = x - y
table.insert(rules, function(expr)
  if is_add(expr) and #expr.args == 2 then
    local a, b = expr.args[1], expr.args[2]
    if is_neg(b) then
      return {type = "sub", left = a, right = b.arg}
    end
    if is_neg(a) then
      return {type = "sub", left = b, right = a.arg}
    end
  end
end)

-- Rule: -(a + b) = -a - b
table.insert(rules, function(expr)
  if is_neg(expr) and is_add(expr.arg) then
    local new_args = {}
    for _, a in ipairs(expr.arg.args) do
      table.insert(new_args, neg(deepcopy(a)))
    end
    return add(new_args)
  end
end)

-- Rules for power of negatives: (-a)^2 = a^2, (-a)^n = (-1)^n * a^n
table.insert(rules, function(expr)
  if is_pow(expr) and is_neg(expr.base) and is_num(expr.exp) then
    local n = numval(expr.exp)
    if n % 2 == 0 then
      return pow(expr.base.arg, num(n))
    else
      return mul({num(-1), pow(expr.base.arg, num(n))})
    end
  end
end)

-- End src/simplify.lua

-- src/simplify.lua has arrived. Prepare to blame someone.

-- Begin src/matrix.lua
local ast = _G.ast or error("AST module required")

local Matrix = {}
Matrix.__index = Matrix

function Matrix:eval_numeric(env)
  local result = {}
  for i = 1, self.rows do
    result[i] = {}
    for j = 1, self.cols do
      result[i][j] = ast.eval_numeric(self.data[i][j], env)
    end
  end
  return result
end

function Matrix.new(data)
  assert(type(data) == "table", "Matrix must be constructed from a table")
  local rows = #data
  local cols = #data[1]
  for i = 2, rows do
    assert(#data[i] == cols, "Matrix rows must be same length")
  end
  return setmetatable({ type = "matrix", data = data, rows = rows, cols = cols }, Matrix)
end

function Matrix:tostring()
  local out = {}
  for i = 1, self.rows do
    local row = {}
    for j = 1, self.cols do
      table.insert(row, tostring(self.data[i][j]))
    end
    table.insert(out, "{" .. table.concat(row, ", ") .. "}")
  end
  return "[" .. table.concat(out, ",\n ") .. "]"
end

function Matrix:add(B)
  assert(self.rows == B.rows and self.cols == B.cols, "Shape mismatch")
  local result = {}
  for i = 1, self.rows do
    result[i] = {}
    for j = 1, self.cols do
      result[i][j] = ast.add(self.data[i][j], B.data[i][j])
    end
  end
  return Matrix.new(result)
end

function Matrix:mul(B)
  assert(self.cols == B.rows, "Incompatible dimensions")
  local result = {}
  for i = 1, self.rows do
    result[i] = {}
    for j = 1, B.cols do
      local sum = ast.number(0)
      for k = 1, self.cols do
        sum = ast.add(sum, ast.mul(self.data[i][k], B.data[k][j]))
      end
      result[i][j] = sum
    end
  end
  return Matrix.new(result)
end

function Matrix:transpose()
  local result = {}
  for i = 1, self.cols do
    result[i] = {}
    for j = 1, self.rows do
      result[i][j] = self.data[j][i]
    end
  end
  return Matrix.new(result)
end

function Matrix:determinant()
  assert(self.rows == 2 and self.cols == 2, "Only 2x2 determinant supported")
  local a, b = self.data[1][1], self.data[1][2]
  local c, d = self.data[2][1], self.data[2][2]
  return ast.sub(ast.mul(a, d), ast.mul(b, c))
end

function Matrix:inverse()
  local det = self:determinant()
  local a, b = self.data[1][1], self.data[1][2]
  local c, d = self.data[2][1], self.data[2][2]
  local inv = {
    {d, ast.mul(ast.number(-1), b)},
    {ast.mul(ast.number(-1), c), a}
  }
  local det_inv = ast.pow(det, ast.number(-1))
  for i = 1, 2 do
    for j = 1, 2 do
      inv[i][j] = ast.mul(inv[i][j], det_inv)
    end
  end
  return Matrix.new(inv)
end

_G.Matrix = Matrix

-- End src/matrix.lua

-- src/matrix.lua has arrived. Prepare to blame someone.

-- Begin src/trig.lua
-- trig.lua
-- Trig evaluation and symbolic helpers for nLuaCAS
-- Mostly here to pretend we remember SOHCAHTOA and the chain rule

local errors = _G.errors

-- Handles numeric evaluation of trig functions
-- Assumes degrees because radians scare most calculator users
-- Falls back to symbolic if it smells like algebra
-- Numeric trig evaluation (angle in degrees if constant input)
local function eval_trig_func(fname, arg)
  if type(arg) == "table" and arg.type == "number" then
    local val = arg.value
    -- Assume degrees for simple numbers (can adapt for radians)
    local rad = math.rad(val)
    if fname == "sin" then return ast.number(math.sin(rad)) end
    if fname == "cos" then return ast.number(math.cos(rad)) end
    if fname == "tan" then return ast.number(math.tan(rad)) end
    if fname == "cot" then return ast.number(1 / math.tan(rad)) end
    if fname == "sec" then return ast.number(1 / math.cos(rad)) end
    if fname == "csc" then return ast.number(1 / math.sin(rad)) end
  end
  -- Not a numeric constant: return nil, fall back to symbolic
  return nil -- fallback to symbolic; not a number
end

-- Symbolic derivatives of trig functions
-- Applies the chain rule without asking for permission
-- Sins become cosines, cosines become negative sins, and so on
-- Symbolic differentiation of all trig functions (chain rule applied)
local function diff_trig_func(fname, arg, darg)
  if fname == "sin" then
    return ast.mul(ast.func("cos", {arg}), darg)
  elseif fname == "cos" then
    return ast.mul(ast.neg(ast.func("sin", {arg})), darg)
  elseif fname == "tan" then
    return ast.mul(ast.add(ast.number(1), ast.pow(ast.func("tan", {arg}), ast.number(2))), darg)
  elseif fname == "cot" then
    return ast.mul(ast.neg(ast.add(ast.number(1), ast.pow(ast.func("cot", {arg}), ast.number(2)))), darg)
  elseif fname == "sec" then
    return ast.mul(ast.mul(ast.func("sec", {arg}), ast.func("tan", {arg})), darg)
  elseif fname == "csc" then
    return ast.mul(ast.neg(ast.mul(ast.func("csc", {arg}), ast.func("cot", {arg}))), darg)
  end
  return error(errors.invalid("diff", "unknown trig function: " .. tostring(fname)))
end

-- Bundle it up for the global namespace
-- Hopefully avoids circular dependency chaos
_G.trig = {
  eval_trig_func = eval_trig_func,
  diff_trig_func = diff_trig_func,
}

-- End src/trig.lua

-- Glued in src/trig.lua. Now question why you needed it.

-- Begin src/derivative.lua
-- Derivative Engine (WIP)
-- Tries to symbolically differentiate expressions.
-- Some parts work. Some parts pretend to work.
-- Expect broken edge cases, unimplemented branches, and fallback logic.

local ast = rawget(_G, "ast") or require("ast")
local trig = rawget(_G, "trig")

-- Utility: shallow copy of a table
local function copy(tbl)
  if type(tbl) ~= "table" then return tbl end
  local t = {}
  for k,v in pairs(tbl) do t[k]=v end
  return t
end
-- Utility: check if AST is a constant (number)
local function is_const(ast)
  return ast.type == "number"
end

-- Utility: check if AST is a variable (symbol)
local function is_var(ast)
  return ast.type == "variable"
end

-- Utility: check if AST is a specific symbol
local function is_symbol(ast, name)
  return ast.type == "variable" and ast.name == name
end

-- Utility: limit AST node
local function lim(expr, var, to)
  return { type = 'lim', expr = expr, var = var, to = to }
end

-- Symbolic differentiation core. Tries to pretend it understands your math.
-- Falls back to limit definitions when it gives up.
local function diffAST(ast_node, var)
  if not ast_node then
    error("diffAST: invalid AST node passed in")
  end
  if type(ast_node) ~= "table" then
    error("diffAST: encountered non-AST node of type " .. type(ast_node))
  end
  var = var or "x"
  -- Numbers don't change. That's kind of the point.
  if ast_node.type == "number" then
    -- x → 1, everything else → 0. Classic.
    return ast.number(0)
  end
  -- x → 1, everything else → 0. Classic.
  if ast_node.type == "variable" then
    if ast_node.name == var then
      return ast.number(1)
    else
      return ast.number(0)
    end
  end
  -- Negation: signs flip, but rules stay the same.
  if ast_node.type == "neg" then
    return ast.neg(diffAST(ast_node.value, var))
  end
  -- Addition: term-wise differentiation. Nothing surprising.
  if ast_node.type == "add" then
    local deriv_args = {}
    for i, term in ipairs(ast_node.args) do
      deriv_args[i] = diffAST(term, var)
    end
    return ast.add(table.unpack(deriv_args))
  end
  -- Subtraction: just addition's grumpy cousin.
  if ast_node.type == "sub" then
    return ast.sub(diffAST(ast_node.left, var), diffAST(ast_node.right, var))
  end
  -- Multiplication: full product rule. Brace yourself.
  if ast_node.type == "mul" then
    local n = #ast_node.args
    local terms = {}
    for k = 1, n do
      local prod_args = {}
      for i = 1, n do
        if i == k then
          prod_args[i] = diffAST(ast_node.args[i], var)
        else
          prod_args[i] = copy(ast_node.args[i])
        end
      end
      terms[k] = ast.mul(table.unpack(prod_args))
    end
    return ast.add(table.unpack(terms))
  end
  -- Quotient rule. Surprisingly tidy, even here.
  if ast_node.type == "div" then
    local u = ast_node.left
    local v = ast_node.right
    local du = diffAST(u, var)
    local dv = diffAST(v, var)

    local numerator = ast.sub(
      ast.mul(du, copy(v)),
      ast.mul(copy(u), dv)
    )

    local denominator = ast.pow(copy(v), ast.number(2))

    return ast.div(numerator, denominator)
  end
  -- Powers: handles constants, variables, and full u^v chains.
  -- Tries to be clever with logs if needed.
  if ast_node.type == "pow" then
    local u, n = ast_node.base, ast_node.exp
    -- Case: u^c, c constant
    if is_const(n) then
      -- d/dx(u^c) = c*u^(c-1) * du/dx
      return ast.mul(
        ast.mul(copy(n), ast.pow(copy(u), ast.number(n.value - 1))),
        diffAST(u, var)
      )
    -- Case: c^v, c constant
    elseif is_const(u) then
      -- d/dx(c^v) = ln(c) * c^v * dv/dx
      return ast.mul(
        ast.mul(ast.func("ln", { copy(u) }), ast.pow(copy(u), copy(n))),
        diffAST(n, var)
      )
    else
      -- General case: d/dx(u^v) = u^v * (v' * ln(u) + v * u'/u)
      -- (by logarithmic differentiation)
      return ast.mul(
        ast.pow(copy(u), copy(n)),
        ast.add(
          ast.mul(diffAST(n, var), ast.func("ln", { copy(u) })),
          ast.mul(copy(n), ast.div(diffAST(u, var), copy(u)))
        )
      )
    end
  end
  -- Function differentiation: sin, exp, ln, etc.
  -- Tries trig.lua first. Falls back to hardcoded rules.
  -- Anything unknown? It gets the limit treatment.
  if ast_node.type == "func" then
    local fname = ast_node.name
    -- Support both .arg (single) and .args (list) notation
    local u = ast_node.arg or (ast_node.args and ast_node.args[1])
    local du = diffAST(u, var)
    -- Use trig.lua for trigonometric differentiation if available
    if trig and trig.diff_trig_func then
      local trig_result = trig.diff_trig_func(fname, copy(u), du)
      if trig_result then return trig_result end
    end
    if fname == "exp" then
      return ast.mul(ast.func("exp", { copy(u) }), du)
    elseif fname == "ln" then
      return ast.mul(ast.div(ast.number(1), copy(u)), du)
    elseif fname == "log" then
      -- log(x) = ln(x) / ln(10), so derivative is 1/(x ln(10))
      return ast.mul(ast.div(ast.number(1), ast.mul(copy(u), ast.func("ln", { ast.number(10) }))), du)
    elseif fname == "sqrt" then
      -- d/dx sqrt(u) = 1/(2*sqrt(u)) * du/dx
      return ast.mul(ast.div(ast.number(1), ast.mul(ast.number(2), ast.func("sqrt", { copy(u) }))), du)
    elseif fname == "asin" then
      -- d/dx asin(u) = 1/sqrt(1-u^2) * du/dx
      return ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2))) })), du)
    elseif fname == "acos" then
      -- d/dx acos(u) = -1/sqrt(1-u^2) * du/dx
      return ast.mul(ast.neg(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2))) }))), du)
    elseif fname == "atan" then
      -- d/dx atan(u) = 1/(1+u^2) * du/dx
      return ast.mul(ast.div(ast.number(1), ast.add(ast.number(1), ast.pow(copy(u), ast.number(2)))), du)
    elseif fname == "sinh" then
      return ast.mul(ast.func("cosh", { copy(u) }), du)
    elseif fname == "cosh" then
      return ast.mul(ast.func("sinh", { copy(u) }), du)
    elseif fname == "tanh" then
      return ast.mul(ast.sub(ast.number(1), ast.pow(ast.func("tanh", { copy(u) }), ast.number(2))), du)
    elseif fname == "asinh" then
      return ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.add(ast.pow(copy(u), ast.number(2)), ast.number(1)) })), du)
    elseif fname == "acosh" then
      return ast.mul(ast.div(ast.number(1), ast.func("sqrt", { ast.sub(ast.pow(copy(u), ast.number(2)), ast.number(1)) })), du)
    elseif fname == "atanh" then
      return ast.mul(ast.div(ast.number(1), ast.sub(ast.number(1), ast.pow(copy(u), ast.number(2)))), du)
    elseif fname == "log10" then
      return ast.mul(ast.div(ast.number(1), ast.mul(copy(u), ast.func("ln", { ast.number(10) }))), du)
    elseif fname == "log2" then
      return ast.mul(ast.div(ast.number(1), ast.mul(copy(u), ast.func("ln", { ast.number(2) }))), du)
    elseif fname == "abs" then
      return ast.mul(ast.div(copy(u), ast.func("abs", { copy(u) })), du)
    elseif fname == "sign" then
      return ast.number(0)
    elseif fname == "floor" or fname == "ceil" or fname == "round" then
      -- Derivative is zero except at discontinuity
      return ast.number(0)
    elseif fname == "erf" then
      -- d/dx erf(u) = 2/sqrt(pi) * exp(-u^2) * du/dx
      return ast.mul(ast.mul(ast.div(ast.number(2), ast.func("sqrt", { ast.number(math.pi) })), ast.func("exp", { ast.neg(ast.pow(copy(u), ast.number(2))) })), du)
    elseif fname == "gamma" then
      -- d/dx gamma(u) = gamma(u) * digamma(u) * du/dx (digamma not implemented, fallback)
      return { type = "unimplemented_derivative", func = fname, arg = copy(u) }
    elseif fname == "digamma" then
      -- d/dx digamma(u) = trigamma(u) * du/dx
      return ast.mul(ast.func("trigamma", { copy(u) }), du)
    elseif fname == "trigamma" then
      -- d/dx trigamma(u) = polygamma(2, u) * du/dx
      return ast.mul(ast.func("polygamma", { ast.number(2), copy(u) }), du)
    else
      -- Fallback: Use limit definition for unknown function
      -- f'(x) = lim_{h->0} [f(x+h)-f(x)]/h
      local h = ast.symbol("__h__")
      local u_ph = ast.add(copy(u), h)
      local fxh = ast.func(fname, { u_ph })
      local fx = ast.func(fname, { copy(u) })
      local nume = ast.sub(fxh, fx)
      local quot = ast.div(nume, h)
      return lim(quot, "__h__", ast.number(0))
    end
  end
  -- No clue what this is. Marked for manual inspection later.
  -- As a safety fallback, return an unknown node
  local result = { type = "unhandled_node", original = ast_node }
  if type(result) ~= "table" or not result.type then
    error("diffAST: returned invalid AST node structure")
  end
  return result
end


-- Public interface: takes string input, returns simplified derivative AST.
-- If it doesn't break, it probably worked.
local function derivative(expr, var)
  -- Load parser
  local parser = rawget(_G, "parser") or require("parser")
  -- Input validation and debug print
  if type(expr) ~= "string" then
    error("Invalid input to derivative(): expected string, got " .. type(expr))
  end
  print("DEBUG: input to parser.parse =", expr)
  -- Parse expr string to AST
  local tree = parser.parse(expr)
  if not tree then
    error("Parsing failed: input = " .. expr)
  end
  local result = diffAST(tree, var)
  if type(result) ~= "table" or not result.type then
    error("Invalid derivative AST structure")
  end
  return (rawget(_G, "simplify") or require("simplify")).simplify(result)
end
_G.derivative = derivative
_G.diffAST = diffAST

-- End src/derivative.lua

-- Just added src/derivative.lua—hope your logic is watertight.

-- Begin src/integrate.lua


-- Integral Engine (WIP)
-- Tries to symbolically integrate expressions.
-- Some parts work; fallback logic for unknown cases.

local ast = rawget(_G, "ast") or require("ast")
local diffAST = rawget(_G, "diffAST") or error("diffAST: differentiation function required for integration by parts")
local trig = rawget(_G, "trig")

-- Utility: shallow copy of a table
local function copy(tbl)
  if type(tbl) ~= "table" then return tbl end
  local t = {}
  for k,v in pairs(tbl) do t[k] = v end
  return t
end

-- Utility: check if AST is a constant (number)
local function is_const(node)
  return node.type == "number"
end

-- Utility: check if AST is a variable (symbol)
local function is_var(node)
  return node.type == "variable"
end

-- Utility: check if AST is a specific symbol
local function is_symbol(node, name)
  return node.type == "variable" and node.name == name
end

-- Core symbolic integration function
local function integrateAST(node, var)
  if not node then error("integrateAST: invalid AST node") end
  var = var or "x"

  -- ∫ c dx = c * x
  if node.type == "number" then
    return ast.mul(node, ast.symbol(var))
  end

  -- ∫ x dx = x^2/2 ; ∫ y dx = y * x
  if node.type == "variable" then
    if node.name == var then
      return ast.div(ast.pow(ast.symbol(var), ast.number(2)), ast.number(2))
    else
      return ast.mul(ast.symbol(node.name), ast.symbol(var))
    end
  end

  -- ∫ (u + v) dx = ∫u + ∫v
  if node.type == "add" then
    local out = {}
    for i,v in ipairs(node.args) do
      out[i] = integrateAST(v, var)
    end
    return ast.add(table.unpack(out))
  end

  -- ∫ (u - v) dx = ∫u - ∫v
  if node.type == "sub" then
    return ast.sub(integrateAST(node.left, var), integrateAST(node.right, var))
  end

  -- ∫ c * u dx = c * ∫u dx
  if node.type == "mul" then
    -- constant factor
    if is_const(node.args[1]) then
      return ast.mul(node.args[1], integrateAST(node.args[2], var))
    end
    if is_const(node.args[#node.args]) then
      local c = node.args[#node.args]
      local u = node.args[1]
      return ast.mul(c, integrateAST(u, var))
    end
    -- fallback: integration by parts ∫u dv = u*v - ∫v du
    local u = node.args[1]
    local dv = node.args[2]
    local V = integrateAST(dv, var)
    local du = diffAST(u, var)
    return ast.sub(ast.mul(u, V), integrateAST(ast.mul(V, du), var))
  end

  -- ∫ u/v dx = ∫ u * v^-1 dx
  if node.type == "div" then
    return integrateAST(ast.mul(node.left, ast.pow(node.right, ast.number(-1))), var)
  end

  -- ∫ u^n dx for u=x or fallback
  if node.type == "pow" then
    local base, exp = node.base, node.exp
    if is_symbol(base, var) and is_const(exp) and exp.value ~= -1 then
      return ast.div(ast.pow(base, ast.number(exp.value + 1)), ast.number(exp.value + 1))
    elseif is_const(base) and is_var(exp) then
      -- ∫ a^x dx = a^x / ln(a)
      return ast.div(ast.pow(base, exp), ast.func("ln", { copy(base) }))
    else
      return { type = "unimplemented_integral", original = node }
    end
  end

  -- ∫ f(u) dx for common functions
  if node.type == "func" then
    local fname = node.name
    local u = node.arg or (node.args and node.args[1])
    if fname == "sin" then
      return ast.neg(ast.func("cos", { copy(u) }))
    elseif fname == "cos" then
      return ast.func("sin", { copy(u) })
    elseif fname == "exp" then
      return ast.func("exp", { copy(u) })
    elseif fname == "ln" then
      -- ∫ ln(u) dx = x*ln(u) - ∫ x*(u'/u) dx
      local du = diffAST(u, var)
      local x = ast.symbol(var)
      local term = ast.sub(
        ast.mul(x, ast.func("ln", { copy(u) })),
        integrateAST(ast.mul(x, ast.div(du, copy(u))), var)
      )
      return term
    else
      return { type = "unimplemented_integral", original = node }
    end
  end

  -- fallback for unhandled nodes
  return { type = "unimplemented_integral", original = node }
end

-- Public interface: takes string input, returns simplified integral AST
local function integral(expr, var)
  local tree
  local parser = rawget(_G, "parser") or require("parser")
  if type(expr) == "string" then
    print("DEBUG: input to parser.parse =", expr)
    tree = parser.parse(expr)
  elseif type(expr) == "table" then
    tree = expr
  else
    error("Invalid input to integral(): expected string or AST table, got " .. type(expr))
  end
  if not tree then
    error("Parsing failed: input = " .. tostring(expr))
  end
  local result = integrateAST(tree, var)
  if type(result) ~= "table" or not result.type then
    error("Invalid integral AST structure")
  end
  return (rawget(_G, "simplify") or require("simplify")).simplify(result)
end

_G.integral = integral
_G.integrate = integral
_G.integrateAST = integrateAST

-- End src/integrate.lua

-- Merged src/integrate.lua: pray those ASTs behave.

-- Begin src/physics.lua
local errors = _G.errors
local ast = _G.ast or error("AST module required")
local diffAST = _G.diffAST or error("diffAST (symbolic differentiation) required")

local init = rawget(_G, "init")
local var = rawget(_G, "var") or require("var")

local Matrix = {}
Matrix.__index = Matrix

function Matrix:eval_numeric(env)
  local result = {}
  for i = 1, self.rows do
    result[i] = {}
    for j = 1, self.cols do
      result[i][j] = ast.eval_numeric(self.data[i][j], env)
    end
  end
  return result
end

function Matrix.new(data)
  assert(type(data) == "table", "Matrix must be constructed from a table")
  local rows = #data
  local cols = #data[1]
  for i = 2, rows do
    assert(#data[i] == cols, "Matrix rows must be same length")
  end
  return setmetatable({ type = "matrix", data = data, rows = rows, cols = cols }, Matrix)
end

function Matrix:tostring()
  local out = {}
  for i = 1, self.rows do
    local row = {}
    for j = 1, self.cols do
      table.insert(row, tostring(self.data[i][j]))
    end
    table.insert(out, "{" .. table.concat(row, ", ") .. "}")
  end
  return "[" .. table.concat(out, ",\n ") .. "]"
end

function Matrix:add(B)
  assert(self.rows == B.rows and self.cols == B.cols, "Shape mismatch")
  local result = {}
  for i = 1, self.rows do
    result[i] = {}
    for j = 1, self.cols do
      result[i][j] = ast.add(self.data[i][j], B.data[i][j])
    end
  end
  return Matrix.new(result)
end

function Matrix:mul(B)
  assert(self.cols == B.rows, "Incompatible dimensions")
  local result = {}
  for i = 1, self.rows do
    result[i] = {}
    for j = 1, B.cols do
      local sum = ast.number(0)
      for k = 1, self.cols do
        sum = ast.add(sum, ast.mul(self.data[i][k], B.data[k][j]))
      end
      result[i][j] = sum
    end
  end
  return Matrix.new(result)
end

function Matrix:transpose()
  local result = {}
  for i = 1, self.cols do
    result[i] = {}
    for j = 1, self.rows do
      result[i][j] = self.data[j][i]
    end
  end
  return Matrix.new(result)
end

function Matrix:determinant()
  assert(self.rows == 2 and self.cols == 2, "Only 2x2 determinant supported")
  local a, b = self.data[1][1], self.data[1][2]
  local c, d = self.data[2][1], self.data[2][2]
  return ast.sub(ast.mul(a, d), ast.mul(b, c))
end

function Matrix:inverse()
  local det = self:determinant()
  local a, b = self.data[1][1], self.data[1][2]
  local c, d = self.data[2][1], self.data[2][2]
  local inv = {
    {d, ast.mul(ast.number(-1), b)},
    {ast.mul(ast.number(-1), c), a}
  }
  local det_inv = ast.pow(det, ast.number(-1))
  for i = 1, 2 do
    for j = 1, 2 do
      inv[i][j] = ast.mul(inv[i][j], det_inv)
    end
  end
  return Matrix.new(inv)
end

-- Because clearly physics constants need their own VIP section with metadata and a velvet rope
local physics_constants = {
    -- Fundamental constants
    g = {
        value = ast.number(9.80665),
        description = "Standard gravity",
        unit = "m/s²",
        category = "fundamental",
        symbol = "g"
    },
    c = {
        value = ast.number(299792458),
        description = "Speed of light in vacuum",
        unit = "m/s",
        category = "fundamental",
        symbol = "c"
    },
    h = {
        value = ast.number(6.62607015e-34),
        description = "Planck constant",
        unit = "J⋅s",
        category = "fundamental",
        symbol = "h"
    },
    hbar = {
        value = ast.number(1.054571817e-34),
        description = "Reduced Planck constant",
        unit = "J⋅s",
        category = "fundamental",
        symbol = "ℏ"
    },
    e = {
        value = ast.number(1.602176634e-19),
        description = "Elementary charge",
        unit = "C",
        category = "fundamental",
        symbol = "e"
    },
    
    -- Particle masses, because mass matters
    m_e = {
        value = ast.number(9.1093837015e-31),
        description = "Electron rest mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "mₑ"
    },
    m_p = {
        value = ast.number(1.67262192369e-27),
        description = "Proton rest mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "mₚ"
    },
    m_n = {
        value = ast.number(1.67492749804e-27),
        description = "Neutron rest mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "mₙ"
    },
    
    -- Particle mass energies, because why not add energy to the mix
    m_e_eV = {
        value = ast.number(0.51099895000e6),
        description = "Electron mass energy",
        unit = "eV/c²",
        category = "particle_masses",
        symbol = "mₑc²"
    },
    m_p_eV = {
        value = ast.number(938.27208816e6),
        description = "Proton mass energy",
        unit = "eV/c²",
        category = "particle_masses",
        symbol = "mₚc²"
    },
    m_n_eV = {
        value = ast.number(939.56542052e6),
        description = "Neutron mass energy",
        unit = "eV/c²",
        category = "particle_masses",
        symbol = "mₙc²"
    },
    
    -- Atomic and molecular constants, because atoms deserve constants too
    mu = {
        value = ast.number(1.66053906660e-27),
        description = "Atomic mass unit",
        unit = "kg",
        category = "atomic",
        symbol = "μ"
    },
    u = {
        value = ast.number(1.66053906660e-27),
        description = "Atomic mass unit (alias)",
        unit = "kg",
        category = "atomic",
        symbol = "u"
    },
    N_A = {
        value = ast.number(6.02214076e23),
        description = "Avogadro's number",
        unit = "mol⁻¹",
        category = "atomic",
        symbol = "Nₐ"
    },
    k_B = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant",
        unit = "J/K",
        category = "thermodynamic",
        symbol = "kᵦ"
    },
    R = {
        value = ast.number(8.314462618),
        description = "Gas constant",
        unit = "J/(mol⋅K)",
        category = "thermodynamic",
        symbol = "R"
    },
    
    -- Electromagnetic constants, because electricity and magnetism can't be ignored
    epsilon_0 = {
        value = ast.number(8.8541878128e-12),
        description = "Vacuum permittivity",
        unit = "F/m",
        category = "electromagnetic",
        symbol = "ε₀"
    },
    mu_0 = {
        value = ast.number(1.25663706212e-6),
        description = "Vacuum permeability",
        unit = "H/m",
        category = "electromagnetic",
        symbol = "μ₀"
    },
    Z_0 = {
        value = ast.number(376.730313668),
        description = "Vacuum impedance",
        unit = "Ω",
        category = "electromagnetic",
        symbol = "Z₀"
    },
    
    -- Atomic structure constants, because atoms have structure and that matters
    a_0 = {
        value = ast.number(5.29177210903e-11),
        description = "Bohr radius",
        unit = "m",
        category = "atomic",
        symbol = "a₀"
    },
    R_inf = {
        value = ast.number(1.0973731568160e7),
        description = "Rydberg constant",
        unit = "m⁻¹",
        category = "atomic",
        symbol = "R∞"
    },
    alpha = {
        value = ast.number(7.2973525693e-3),
        description = "Fine structure constant",
        unit = "dimensionless",
        category = "atomic",
        symbol = "α"
    },
    
    -- Energy constants, because energy is everything
    eV = {
        value = ast.number(1.602176634e-19),
        description = "Electron volt",
        unit = "J",
        category = "energy",
        symbol = "eV"
    },
    
    -- Other constants, because we need to fill space
    F = {
        value = ast.number(96485.33212),
        description = "Faraday constant",
        unit = "C/mol",
        category = "electromagnetic",
        symbol = "F"
    },
    G = {
        value = ast.number(6.67430e-11),
        description = "Gravitational constant",
        unit = "N⋅m²/kg²",
        category = "fundamental",
        symbol = "G"
    },
    
    -- Mathematical constants, because math is the language of the universe
    pi = {
        value = ast.number(math.pi),
        description = "Pi",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "π"
    },
    e_math = {
        value = ast.number(math.exp(1)),
        description = "Euler's number",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "e"
    },

    -- Nuclear constants, because splitting atoms is a hobby now
    tau_n = {
        value = ast.number(880.2),
        description = "Neutron lifetime",
        unit = "s",
        category = "nuclear",
        symbol = "τₙ"
    },
    sigma_f = {
        value = ast.number(585e-28),
        description = "Thermal fission cross section of U-235",
        unit = "m²",
        category = "nuclear",
        symbol = "σ_f"
    },

    -- Cosmological constants, because thinking small is overrated
    H_0 = {
        value = ast.number(67.4),
        description = "Hubble constant",
        unit = "km/s/Mpc",
        category = "cosmological",
        symbol = "H₀"
    },
    Lambda = {
        value = ast.number(1.1056e-52),
        description = "Cosmological constant",
        unit = "1/m²",
        category = "cosmological",
        symbol = "Λ"
    },

    -- Lepton properties, because electrons need cousins
    muon_mass = {
        value = ast.number(1.883531627e-28),
        description = "Muon's mass",
        unit = "kg",
        category = "leptons",
        symbol = "m_μ"
    },
    tau_mass = {
        value = ast.number(3.16754e-27),
        description = "Tau lepton mass",
        unit = "kg",
        category = "leptons",
        symbol = "m_τ"
    },

    
    -- Mechanics
    constant_001 = {
        value = ast.number(9.80665),
        description = "Standard acceleration due to gravity at Earth's surface",
        unit = "m/s²",
        category = "mechanical",
        symbol = "g₀"
    },
    constant_002 = {
        value = ast.number(6.67430e-11),
        description = "Newtonian constant of gravitation",
        unit = "N⋅m²/kg²",
        category = "mechanical",
        symbol = "G"
    },
    constant_003 = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant",
        unit = "J/K",
        category = "thermodynamic",
        symbol = "k_B"
    },
    constant_004 = {
        value = ast.number(8.314462618),
        description = "Universal gas constant",
        unit = "J/(mol⋅K)",
        category = "thermodynamic",
        symbol = "R"
    },
    constant_005 = {
        value = ast.number(101325),
        description = "Standard atmospheric pressure",
        unit = "Pa",
        category = "thermodynamic",
        symbol = "P₀"
    },
    constant_006 = {
        value = ast.number(273.15),
        description = "Standard temperature (triple point of water)",
        unit = "K",
        category = "thermodynamic",
        symbol = "T₀"
    },
    constant_007 = {
        value = ast.number(6.02214076e23),
        description = "Avogadro constant",
        unit = "mol⁻¹",
        category = "atomic",
        symbol = "N_A"
    },
    constant_008 = {
        value = ast.number(0.082057366080960),
        description = "Molar gas constant (L⋅atm)/(mol⋅K)",
        unit = "L⋅atm/(mol⋅K)",
        category = "thermodynamic",
        symbol = "R"
    },
    constant_009 = {
        value = ast.number(1.01325e5),
        description = "Atmosphere (standard)",
        unit = "Pa",
        category = "thermodynamic",
        symbol = "atm"
    },
    constant_010 = {
        value = ast.number(760),
        description = "Standard atmosphere in mmHg",
        unit = "mmHg",
        category = "thermodynamic",
        symbol = "atm"
    },
    -- Electromagnetism
    constant_011 = {
        value = ast.number(8.8541878128e-12),
        description = "Vacuum permittivity",
        unit = "F/m",
        category = "electromagnetic",
        symbol = "ε₀"
    },
    constant_012 = {
        value = ast.number(1.25663706212e-6),
        description = "Vacuum permeability",
        unit = "H/m",
        category = "electromagnetic",
        symbol = "μ₀"
    },
    constant_013 = {
        value = ast.number(299792458),
        description = "Speed of light in vacuum",
        unit = "m/s",
        category = "electromagnetic",
        symbol = "c"
    },
    constant_014 = {
        value = ast.number(1.602176634e-19),
        description = "Elementary charge",
        unit = "C",
        category = "electromagnetic",
        symbol = "e"
    },
    constant_015 = {
        value = ast.number(9.648533212e4),
        description = "Faraday constant",
        unit = "C/mol",
        category = "electromagnetic",
        symbol = "F"
    },
    constant_016 = {
        value = ast.number(1.602176634e-19),
        description = "Electron volt",
        unit = "J",
        category = "energy",
        symbol = "eV"
    },
    constant_017 = {
        value = ast.number(6.62607015e-34),
        description = "Planck constant",
        unit = "J⋅s",
        category = "quantum",
        symbol = "h"
    },
    constant_018 = {
        value = ast.number(1.054571817e-34),
        description = "Reduced Planck constant",
        unit = "J⋅s",
        category = "quantum",
        symbol = "ħ"
    },
    constant_019 = {
        value = ast.number(2.8179403262e-15),
        description = "Classical electron radius",
        unit = "m",
        category = "atomic",
        symbol = "r_e"
    },
    constant_020 = {
        value = ast.number(1.67262192369e-27),
        description = "Proton mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "m_p"
    },
    -- Atomic/Quantum
    constant_021 = {
        value = ast.number(9.1093837015e-31),
        description = "Electron mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "m_e"
    },
    constant_022 = {
        value = ast.number(1.67492749804e-27),
        description = "Neutron mass",
        unit = "kg",
        category = "particle_masses",
        symbol = "m_n"
    },
    constant_023 = {
        value = ast.number(5.29177210903e-11),
        description = "Bohr radius",
        unit = "m",
        category = "atomic",
        symbol = "a₀"
    },
    constant_024 = {
        value = ast.number(1.0973731568160e7),
        description = "Rydberg constant",
        unit = "m⁻¹",
        category = "atomic",
        symbol = "R_∞"
    },
    constant_025 = {
        value = ast.number(7.2973525693e-3),
        description = "Fine-structure constant",
        unit = "dimensionless",
        category = "atomic",
        symbol = "α"
    },
    constant_026 = {
        value = ast.number(2.99792458e8),
        description = "Speed of light in vacuum",
        unit = "m/s",
        category = "fundamental",
        symbol = "c"
    },
    constant_027 = {
        value = ast.number(4.135667696e-15),
        description = "Planck constant (in eV·s)",
        unit = "eV⋅s",
        category = "quantum",
        symbol = "h"
    },
    constant_028 = {
        value = ast.number(1.43996448e-9),
        description = "Hartree energy",
        unit = "J",
        category = "atomic",
        symbol = "E_h"
    },
    constant_029 = {
        value = ast.number(2.18769126364e6),
        description = "Bohr velocity",
        unit = "m/s",
        category = "atomic",
        symbol = "v₀"
    },
    constant_030 = {
        value = ast.number(0.529177210903e-10),
        description = "Bohr radius (in meters)",
        unit = "m",
        category = "atomic",
        symbol = "a₀"
    },
    -- Thermodynamics
    constant_031 = {
        value = ast.number(273.15),
        description = "Zero Celsius in kelvin",
        unit = "K",
        category = "thermodynamic",
        symbol = "T₀"
    },
    constant_032 = {
        value = ast.number(4.1868),
        description = "Specific heat of water",
        unit = "J/(g⋅K)",
        category = "thermodynamic",
        symbol = "c_water"
    },
    constant_033 = {
        value = ast.number(2260),
        description = "Latent heat of vaporization of water",
        unit = "kJ/kg",
        category = "thermodynamic",
        symbol = "L_v"
    },
    constant_034 = {
        value = ast.number(334),
        description = "Latent heat of fusion of water",
        unit = "kJ/kg",
        category = "thermodynamic",
        symbol = "L_f"
    },
    constant_035 = {
        value = ast.number(0.01801528),
        description = "Molar mass of water",
        unit = "kg/mol",
        category = "thermodynamic",
        symbol = "M_water"
    },
    constant_036 = {
        value = ast.number(4184),
        description = "1 calorie in joules",
        unit = "J",
        category = "thermodynamic",
        symbol = "cal"
    },
    constant_037 = {
        value = ast.number(273.16),
        description = "Triple point of water",
        unit = "K",
        category = "thermodynamic",
        symbol = "T_tp"
    },
    constant_038 = {
        value = ast.number(1.01325e5),
        description = "1 bar in pascals",
        unit = "Pa",
        category = "thermodynamic",
        symbol = "bar"
    },
    constant_039 = {
        value = ast.number(0.000119626565582),
        description = "Stefan–Boltzmann constant",
        unit = "W⋅m⁻²⋅K⁻⁴",
        category = "thermodynamic",
        symbol = "σ"
    },
    constant_040 = {
        value = ast.number(5.670374419e-8),
        description = "Stefan–Boltzmann constant (SI)",
        unit = "W⋅m⁻²⋅K⁻⁴",
        category = "thermodynamic",
        symbol = "σ"
    },
    -- Acoustics
    constant_041 = {
        value = ast.number(343),
        description = "Speed of sound in air at 20°C",
        unit = "m/s",
        category = "acoustics",
        symbol = "v_sound"
    },
    constant_042 = {
        value = ast.number(1.225),
        description = "Density of air at sea level",
        unit = "kg/m³",
        category = "acoustics",
        symbol = "ρ_air"
    },
    constant_043 = {
        value = ast.number(1497),
        description = "Speed of sound in water at 25°C",
        unit = "m/s",
        category = "acoustics",
        symbol = "v_water"
    },
    constant_044 = {
        value = ast.number(1000),
        description = "Density of water",
        unit = "kg/m³",
        category = "acoustics",
        symbol = "ρ_water"
    },
    constant_045 = {
        value = ast.number(2.65e3),
        description = "Density of Earth's crust (granite)",
        unit = "kg/m³",
        category = "acoustics",
        symbol = "ρ_granite"
    },
    constant_046 = {
        value = ast.number(331.3),
        description = "Speed of sound in air at 0°C",
        unit = "m/s",
        category = "acoustics",
        symbol = "v_sound_0C"
    },
    constant_047 = {
        value = ast.number(0.000015),
        description = "Dynamic viscosity of air at 15°C",
        unit = "Pa⋅s",
        category = "acoustics",
        symbol = "μ_air"
    },
    constant_048 = {
        value = ast.number(0.001002),
        description = "Dynamic viscosity of water at 20°C",
        unit = "Pa⋅s",
        category = "acoustics",
        symbol = "μ_water"
    },
    constant_049 = {
        value = ast.number(2.9e7),
        description = "Bulk modulus of water",
        unit = "Pa",
        category = "acoustics",
        symbol = "K_water"
    },
    constant_050 = {
        value = ast.number(1.42e5),
        description = "Bulk modulus of air",
        unit = "Pa",
        category = "acoustics",
        symbol = "K_air"
    },
    -- Optics
    constant_051 = {
        value = ast.number(1.000293),
        description = "Refractive index of air (STP)",
        unit = "dimensionless",
        category = "optics",
        symbol = "n_air"
    },
    constant_052 = {
        value = ast.number(1.33),
        description = "Refractive index of water",
        unit = "dimensionless",
        category = "optics",
        symbol = "n_water"
    },
    constant_053 = {
        value = ast.number(1.52),
        description = "Refractive index of glass (typical)",
        unit = "dimensionless",
        category = "optics",
        symbol = "n_glass"
    },
    constant_054 = {
        value = ast.number(6.62607015e-34),
        description = "Planck constant (again for optics)",
        unit = "J⋅s",
        category = "optics",
        symbol = "h"
    },
    constant_055 = {
        value = ast.number(2.99792458e8),
        description = "Speed of light in vacuum (again for optics)",
        unit = "m/s",
        category = "optics",
        symbol = "c"
    },
    constant_056 = {
        value = ast.number(5.03411701e15),
        description = "Wavenumber of 1 Ångström",
        unit = "m⁻¹",
        category = "optics",
        symbol = "k_Å"
    },
    constant_057 = {
        value = ast.number(4.135667696e-15),
        description = "Planck constant (eV·s, optics)",
        unit = "eV⋅s",
        category = "optics",
        symbol = "h"
    },
    constant_058 = {
        value = ast.number(1.239841984e-6),
        description = "hc (Planck's constant times c) in eV·m",
        unit = "eV⋅m",
        category = "optics",
        symbol = "hc"
    },
    constant_059 = {
        value = ast.number(2.99792458e8),
        description = "Speed of light in vacuum (optical)",
        unit = "m/s",
        category = "optics",
        symbol = "c"
    },
    constant_060 = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant (optics)",
        unit = "J/K",
        category = "optics",
        symbol = "k_B"
    },
    -- Nuclear/Particle
    constant_061 = {
        value = ast.number(1.66053906660e-27),
        description = "Atomic mass unit (u)",
        unit = "kg",
        category = "nuclear",
        symbol = "u"
    },
    constant_062 = {
        value = ast.number(931.49410242e6),
        description = "Atomic mass unit in eV/c²",
        unit = "eV/c²",
        category = "nuclear",
        symbol = "u"
    },
    constant_063 = {
        value = ast.number(1.602176634e-13),
        description = "1 MeV in joules",
        unit = "J",
        category = "nuclear",
        symbol = "MeV"
    },
    constant_064 = {
        value = ast.number(1.007276466621),
        description = "Proton mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_p"
    },
    constant_065 = {
        value = ast.number(1.00866491595),
        description = "Neutron mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_n"
    },
    constant_066 = {
        value = ast.number(0.000548579909065),
        description = "Electron mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_e"
    },
    constant_067 = {
        value = ast.number(2.01410177812),
        description = "Deuteron mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_d"
    },
    constant_068 = {
        value = ast.number(3.01604928199),
        description = "Triton mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_t"
    },
    constant_069 = {
        value = ast.number(1.00782503223),
        description = "Hydrogen-1 atom mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_H"
    },
    constant_070 = {
        value = ast.number(4.00260325413),
        description = "Helium-4 atom mass in u",
        unit = "u",
        category = "nuclear",
        symbol = "m_He"
    },
    -- Cosmology
    constant_071 = {
        value = ast.number(67.4),
        description = "Hubble constant",
        unit = "km/s/Mpc",
        category = "cosmological",
        symbol = "H₀"
    },
    constant_072 = {
        value = ast.number(1.1056e-52),
        description = "Cosmological constant",
        unit = "1/m²",
        category = "cosmological",
        symbol = "Λ"
    },
    constant_073 = {
        value = ast.number(2.72548),
        description = "CMB temperature",
        unit = "K",
        category = "cosmological",
        symbol = "T_CMB"
    },
    constant_074 = {
        value = ast.number(4.404e17),
        description = "Age of the Universe",
        unit = "s",
        category = "cosmological",
        symbol = "t₀"
    },
    constant_075 = {
        value = ast.number(1.98847e30),
        description = "Solar mass",
        unit = "kg",
        category = "cosmological",
        symbol = "M_☉"
    },
    constant_076 = {
        value = ast.number(6.957e8),
        description = "Solar radius",
        unit = "m",
        category = "cosmological",
        symbol = "R_☉"
    },
    constant_077 = {
        value = ast.number(1.496e11),
        description = "Astronomical unit",
        unit = "m",
        category = "cosmological",
        symbol = "AU"
    },
    constant_078 = {
        value = ast.number(3.085677581e16),
        description = "Light year",
        unit = "m",
        category = "cosmological",
        symbol = "ly"
    },
    constant_079 = {
        value = ast.number(3.085677581e22),
        description = "Megaparsec",
        unit = "m",
        category = "cosmological",
        symbol = "Mpc"
    },
    constant_080 = {
        value = ast.number(1.495978707e11),
        description = "Astronomical unit (precise)",
        unit = "m",
        category = "cosmological",
        symbol = "AU"
    },
    -- Mathematical
    constant_081 = {
        value = ast.number(math.pi),
        description = "Pi",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "π"
    },
    constant_082 = {
        value = ast.number(math.exp(1)),
        description = "Euler's number",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "e"
    },
    constant_083 = {
        value = ast.number(0.5772156649),
        description = "Euler–Mascheroni constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "γ"
    },
    constant_084 = {
        value = ast.number(1.6180339887),
        description = "Golden ratio",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "φ"
    },
    constant_085 = {
        value = ast.number(2.6854520010),
        description = "Catalan's constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "G"
    },
    constant_086 = {
        value = ast.number(1.2020569032),
        description = "Apéry's constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "ζ(3)"
    },
    constant_087 = {
        value = ast.number(0.9159655941),
        description = "Catalan's constant",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "K"
    },
    constant_088 = {
        value = ast.number(1.3247179572),
        description = "Plastic number",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "ρ"
    },
    constant_089 = {
        value = ast.number(2.2360679775),
        description = "Square root of 5",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "√5"
    },
    constant_090 = {
        value = ast.number(1.4142135623),
        description = "Square root of 2",
        unit = "dimensionless",
        category = "mathematical",
        symbol = "√2"
    },
    -- Miscellaneous & Derived
    constant_091 = {
        value = ast.number(96485.33212),
        description = "Faraday constant (precise)",
        unit = "C/mol",
        category = "electromagnetic",
        symbol = "F"
    },
    constant_092 = {
        value = ast.number(376.730313668),
        description = "Impedance of free space",
        unit = "Ω",
        category = "electromagnetic",
        symbol = "Z₀"
    },
    constant_093 = {
        value = ast.number(1.380649e-16),
        description = "Boltzmann constant in erg/K",
        unit = "erg/K",
        category = "thermodynamic",
        symbol = "k_B"
    },
    constant_094 = {
        value = ast.number(2.99792458e10),
        description = "Speed of light in cm/s",
        unit = "cm/s",
        category = "fundamental",
        symbol = "c"
    },
    constant_095 = {
        value = ast.number(1.67262192369e-24),
        description = "Proton mass in grams",
        unit = "g",
        category = "particle_masses",
        symbol = "m_p"
    },
    constant_096 = {
        value = ast.number(9.1093837015e-28),
        description = "Electron mass in grams",
        unit = "g",
        category = "particle_masses",
        symbol = "m_e"
    },
    constant_097 = {
        value = ast.number(1.67492749804e-24),
        description = "Neutron mass in grams",
        unit = "g",
        category = "particle_masses",
        symbol = "m_n"
    },
    constant_098 = {
        value = ast.number(1.66053906660e-24),
        description = "Atomic mass unit in grams",
        unit = "g",
        category = "nuclear",
        symbol = "u"
    },
    constant_099 = {
        value = ast.number(1.380649e-23),
        description = "Boltzmann constant (again, SI)",
        unit = "J/K",
        category = "thermodynamic",
        symbol = "k_B"
    },
    constant_100 = {
        value = ast.number(6.02214076e23),
        description = "Avogadro constant (again, SI)",
        unit = "mol⁻¹",
        category = "atomic",
        symbol = "N_A"
    },
    -- Extended physics constants for CAS - adding ~50 more essential constants
-- Continuing from constant_100...

    -- Quantum mechanics and atomic physics constants (101-120)
    constant_101 = {
        value = ast.number(2.067833848e-15),
        description = "Magnetic flux quantum",
        unit = "Wb",
        category = "quantum",
        symbol = "Φ₀"
    },

    -- Nuclear and particle physics constants (121-135)
    constant_121 = {
        value = ast.number(2.268e-18),
        description = "Deuteron binding energy",
        unit = "J",
        category = "nuclear",
        symbol = "B_d"
    },
    constant_122 = {
        value = ast.number(1.112650e-29),
        description = "Neutron magnetic moment",
        unit = "J/T",
        category = "nuclear",
        symbol = "μ_n"
    },
    constant_123 = {
        value = ast.number(1.41060679736e-26),
        description = "Proton magnetic moment",
        unit = "J/T",
        category = "nuclear",
        symbol = "μ_p"
    },
    constant_124 = {
        value = ast.number(2.8792847344e-8),
        description = "Compton wavelength of electron",
        unit = "m",
        category = "quantum",
        symbol = "λ_C"
    },
    constant_125 = {
        value = ast.number(1.32140985539e-15),
        description = "Compton wavelength of proton",
        unit = "m",
        category = "quantum",
        symbol = "λ_C,p"
    },
    constant_126 = {
        value = ast.number(1.2196e-4),
        description = "Weak mixing angle (sin²θ_W)",
        unit = "dimensionless",
        category = "particle_physics",
        symbol = "sin²θ_W"
    },
    constant_127 = {
        value = ast.number(80.379),
        description = "W boson mass",
        unit = "GeV/c²",
        category = "particle_physics",
        symbol = "m_W"
    },
    constant_128 = {
        value = ast.number(91.1876),
        description = "Z boson mass",
        unit = "GeV/c²",
        category = "particle_physics",
        symbol = "m_Z"
    },
    constant_129 = {
        value = ast.number(125.1),
        description = "Higgs boson mass",
        unit = "GeV/c²",
        category = "particle_physics",
        symbol = "m_H"
    },
    constant_130 = {
        value = ast.number(0.1181),
        description = "QCD coupling constant at M_Z",
        unit = "dimensionless",
        category = "particle_physics",
        symbol = "α_s"
    },
    constant_131 = {
        value = ast.number(1.166364e-5),
        description = "Fermi coupling constant",
        unit = "GeV⁻²",
        category = "particle_physics",
        symbol = "G_F"
    },
    constant_132 = {
        value = ast.number(0.97420),
        description = "CKM matrix element V_ud",
        unit = "dimensionless",
        category = "particle_physics",
        symbol = "V_ud"
    },
    constant_133 = {
        value = ast.number(2.268e-18),
        description = "Nuclear binding energy scale",
        unit = "J",
        category = "nuclear",
        symbol = "BE"
    },
    constant_134 = {
        value = ast.number(1.602e-10),
        description = "Nuclear radius constant",
        unit = "m",
        category = "nuclear",
        symbol = "r_0"
    },
    constant_135 = {
        value = ast.number(2.3e-30),
        description = "Nuclear cross-section scale",
        unit = "m²",
        category = "nuclear",
        symbol = "σ_0"
    },

    -- Statistical mechanics and thermodynamics (136-145)
    constant_136 = {
        value = ast.number(7.244e-4),
        description = "Second radiation constant",
        unit = "m⋅K",
        category = "thermodynamic",
        symbol = "c₂"
    },
    constant_137 = {
        value = ast.number(3.741771852e-16),
        description = "First radiation constant",
        unit = "W⋅m²",
        category = "thermodynamic",
        symbol = "c₁"
    },
    constant_138 = {
        value = ast.number(2.897771955e-3),
        description = "Wien displacement law constant",
        unit = "m⋅K",
        category = "thermodynamic",
        symbol = "b"
    },
    constant_139 = {
        value = ast.number(1.191042972e-16),
        description = "First radiation constant for spectral radiance",
        unit = "W⋅m²⋅sr⁻¹",
        category = "thermodynamic",
        symbol = "c₁L"
    },
    constant_140 = {
        value = ast.number(5.670374419e-8),
        description = "Stefan-Boltzmann constant",
        unit = "W⋅m⁻²⋅K⁻⁴",
        category = "thermodynamic",
        symbol = "σ_SB"
    },
    constant_141 = {
        value = ast.number(4.799243073e-11),
        description = "Loschmidt constant",
        unit = "m⁻³",
        category = "thermodynamic",
        symbol = "n₀"
    },
    constant_142 = {
        value = ast.number(2.686e25),
        description = "Amagat (number density at STP)",
        unit = "m⁻³",
        category = "thermodynamic",
        symbol = "amg"
    },
    constant_143 = {
        value = ast.number(6.236e-4),
        description = "Sackur-Tetrode constant",
        unit = "dimensionless",
        category = "thermodynamic",
        symbol = "S₀"
    },
    constant_144 = {
        value = ast.number(5.878e25),
        description = "Standard state pressure number density",
        unit = "m⁻³",
        category = "thermodynamic",
        symbol = "n₁"
    },
    constant_145 = {
        value = ast.number(3.166e-6),
        description = "Characteristic temperature for He-3",
        unit = "K",
        category = "thermodynamic",
        symbol = "T_F"
    },

    -- Crystallographic and solid state constants (146-150)
    constant_146 = {
        value = ast.number(1.602e-19),
        description = "Lattice energy scale",
        unit = "J",
        category = "solid_state",
        symbol = "E_L"
    },
    constant_147 = {
        value = ast.number(2.44e-10),
        description = "Typical lattice parameter",
        unit = "m",
        category = "solid_state",
        symbol = "a_L"
    },
    constant_148 = {
        value = ast.number(1.38e-23),
        description = "Debye temperature energy scale",
        unit = "J/K",
        category = "solid_state",
        symbol = "k_D"
    },
    constant_149 = {
        value = ast.number(3.5e13),
        description = "Debye frequency",
        unit = "Hz",
        category = "solid_state",
        symbol = "ω_D"
    },
    constant_150 = {
        value = ast.number(7.43e28),
        description = "Electron density in metals",
        unit = "m⁻³",
        category = "solid_state",
        symbol = "n_e"
    },

    constant_102 = {
        value = ast.number(9.274010078e-24),
        description = "Bohr magneton",
        unit = "J/T",
        category = "atomic",
        symbol = "μ_B"
    },
    constant_103 = {
        value = ast.number(5.050783699e-27),
        description = "Nuclear magneton",
        unit = "J/T",
        category = "nuclear",
        symbol = "μ_N"
    },
    constant_104 = {
        value = ast.number(25812.807),
        description = "Von Klitzing constant",
        unit = "Ω",
        category = "quantum",
        symbol = "R_K"
    },
    constant_105 = {
        value = ast.number(4.835978484e-14),
        description = "Josephson constant",
        unit = "Hz/V",
        category = "quantum",
        symbol = "K_J"
    },
    constant_106 = {
        value = ast.number(1.519267447e-16),
        description = "Conductance quantum",
        unit = "S",
        category = "quantum",
        symbol = "G₀"
    },
    constant_107 = {
        value = ast.number(2.179872361e-18),
        description = "Planck energy",
        unit = "J",
        category = "planck_units",
        symbol = "E_P"
    },
    constant_108 = {
        value = ast.number(1.616255e-35),
        description = "Planck length",
        unit = "m",
        category = "planck_units",
        symbol = "l_P"
    },
    constant_109 = {
        value = ast.number(5.391247e-44),
        description = "Planck time",
        unit = "s",
        category = "planck_units",
        symbol = "t_P"
    },
    constant_110 = {
        value = ast.number(2.176434e-8),
        description = "Planck mass",
        unit = "kg",
        category = "planck_units",
        symbol = "m_P"
    },
    constant_111 = {
        value = ast.number(1.416784e32),
        description = "Planck temperature",
        unit = "K",
        category = "planck_units",
        symbol = "T_P"
    },
    constant_112 = {
        value = ast.number(1.875545956e-18),
        description = "Planck charge",
        unit = "C",
        category = "planck_units",
        symbol = "q_P"
    },
    constant_113 = {
        value = ast.number(1.210e22),
        description = "Planck density",
        unit = "kg/m³",
        category = "planck_units",
        symbol = "ρ_P"
    },
    constant_114 = {
        value = ast.number(4.641e113),
        description = "Planck pressure",
        unit = "Pa",
        category = "planck_units",
        symbol = "P_P"
    },
    constant_115 = {
        value = ast.number(1.85e43),
        description = "Planck force",
        unit = "N",
        category = "planck_units",
        symbol = "F_P"
    },
    constant_116 = {
        value = ast.number(2.9979e35),
        description = "Planck velocity",
        unit = "m/s",
        category = "planck_units",
        symbol = "v_P"
    },
    constant_117 = {
        value = ast.number(1.054e-34),
        description = "Planck angular momentum",
        unit = "J⋅s",
        category = "planck_units",
        symbol = "L_P"
    },
    constant_118 = {
        value = ast.number(3.628e52),
        description = "Planck power",
        unit = "W",
        category = "planck_units",
        symbol = "P_P"
    },
    constant_119 = {
        value = ast.number(1.88e27),
        description = "Planck current",
        unit = "A",
        category = "planck_units",
        symbol = "I_P"
    },
    constant_120 = {
        value = ast.number(1.04e27),
        description = "Planck voltage",
        unit = "V",
        category = "planck_units",
        symbol = "V_P"
    },
}

-- Add more placeholder constants to reach about 200 in total
do
    for i = 101, 194 do
        local key = string.format("constant_%03d", i)
        physics_constants[key] = {
            value = ast.number(i),
            description = ("Placeholder %d"):format(i),
            unit = "-",
            category = "misc",
            symbol = "c" .. tostring(i)
        }
    end
end

local symbol_aliases_by_category = {
  e = {
    fundamental = "e",
    mathematical = "e_math",
  },
  pi = {
    mathematical = "pi",
  }
}

-- Because someone might want to know which categories of constants are actually a thing
local function get_constant_categories()
    local categories = {}
    for name, data in pairs(physics_constants) do
        categories[data.category] = true
    end
    local category_list = {}
    for category in pairs(categories) do
        table.insert(category_list, category)
    end
    table.sort(category_list)
    return category_list
end

-- Because filtering constants by category is apparently a popular pastime
local function get_constants_by_category(category)
    local constants = {}
    for name, data in pairs(physics_constants) do
        if data.category == category then
            constants[name] = data
        end
    end
    return constants
end

-- Because apparently constants have an on/off switch and we have to check it
local function is_constant_enabled(constant_name)
    local avail = var.recall("available_constants")
    local constants_off = var.recall("constants_off")
    if constants_off then
        return false
    end
    if avail == nil then
        return true -- All constants enabled by default, because why not
    end
    return avail[constant_name] == true
end

-- Because clearly we only want constants when we *say so*
local function get_constant_value(symbol)
    local category = rawget(_G, "current_constant_category") or "fundamental"
    print("[DEBUG] Current constant category (get_constant_value):", category)
    local alias_map = symbol_aliases_by_category[symbol]
    local resolved_name = (alias_map and category and alias_map[category]) or symbol

    local constant = physics_constants[resolved_name]
    if constant then
        local avail = var.recall("available_constants")
        local enabled = (avail == nil) or (avail[resolved_name] == true)
        local constants_off = var.recall("constants_off")
        if not constants_off and enabled then
            return constant.value
        end
    end
    return nil
end

-- Because toggling constants on and off is the new sport
local function set_constant_enabled(constant_name, enabled)
  local avail = var.recall("available_constants")
  if not avail then
    avail = {}
  end
  avail[constant_name] = enabled
  var.recall("available_constants", avail)
end

-- Because sometimes you want to turn off an entire category and watch the chaos
local function set_category_enabled(category, enabled)
  local avail = var.recall("available_constants")
  if not avail then
    avail = {}
  end
  
  for name, data in pairs(physics_constants) do
      if data.category == category then
          avail[name] = enabled
      end
  end
  var.recall("available_constants", avail)
end

-- Because you might want to snoop on a constant's details
local function get_constant_info(constant_name)
    return physics_constants[constant_name]
end

-- Because listing enabled constants is a thrilling endeavor
local function list_enabled_constants()
    local enabled = {}
    for name, data in pairs(physics_constants) do
        if is_constant_enabled(name) then
            enabled[name] = data
        end
    end
    return enabled
end

-- Let’s check if the whole damn system is turned off again
local function eval_physics_func(fname, args)
    -- Check if constants are globally enabled
    local constants_off = var.recall("constants_off")
    if constants_off then
        return nil
    end

    -- Resolve category alias before checking if constant is enabled
    local selected_category = rawget(_G, "current_constant_category") or "fundamental"
    print("[DEBUG] Current constant category (eval_physics_func):", selected_category)
    local alias_map = symbol_aliases_by_category[fname]
    if alias_map and selected_category and alias_map[selected_category] then
        fname = alias_map[selected_category]
    end

    local avail = var.recall("available_constants")
    local is_enabled = (avail == nil) or (avail[fname] == true)

    if physics_constants[fname] and is_enabled then
        return get_constant_value(fname)
    end

    if fname == "force" and #args == 2 then
        local m, a = args[1], args[2]
        if m.type == "number" and a.type == "number" then
            return ast.number(m.value * a.value)
        end
    elseif fname == "velocity" and #args == 1 then
        -- Example placeholder: identity
        return args[1]
    elseif fname == "acceleration" and #args == 1 then
        return args[1]
    elseif fname == "position" and #args == 1 then
        return args[1]
    elseif fname == "simulate" then
        -- Numeric evaluation is complex; return nil to fallback symbolic
        return nil
    elseif fname == "init" then
        -- No numeric eval; used for setting initial conditions
        return nil
    elseif fname == "steps" and #args == 1 then
        -- Stepwise symbolic derivation handled elsewhere
        return nil
    end
    return nil -- fallback to symbolic
end

-- Symbolic differentiation delegated fully to your diffAST engine because why reinvent the wheel
local function diff_physics_func(fname, arg, darg)
    -- Simply return the symbolic function node and let diffAST handle it
    return ast.func(fname, {arg})
end

_G.physics = {
    eval_physics_func = eval_physics_func,
    diff_physics_func = diff_physics_func,
    Matrix = Matrix,
    constants = physics_constants,
    
    -- Constant management functions, because managing constants is a full-time job
    get_constant_categories = get_constant_categories,
    get_constants_by_category = get_constants_by_category,
    is_constant_enabled = is_constant_enabled,
    get_constant_value = get_constant_value,
    set_constant_enabled = set_constant_enabled,
    set_category_enabled = set_category_enabled,
    get_constant_info = get_constant_info,
    list_enabled_constants = list_enabled_constants,
}

_G.Matrix = Matrix

-- End src/physics.lua

-- Integrated src/physics.lua: let’s hope it compiles this time.

-- Begin src/solve.lua
-- TODO: Make sure all equation types listed above are *actually* supported in the code below. If not, add matcher and solver logic.
-- Supported equation formats by the symbolic solver:
--   * Linear:       ax + b = 0,   ax = b,   x + b = 0,   x = b
--   * Quadratic:    ax^2 + bx + c = 0,   ax^2 + bx = c,   x^2 + bx + c = d
--   * Cubic:        ax^3 + bx^2 + cx + d = 0, etc.
--   * Trigonometric: sin(x) = a, cos(x) = a, tan(x) = a
--   * Exponential:   a^x = b, exp(x) = a
--   * Logarithmic:   ln(x) = a
--   * General form:  lhs = rhs, will be handled if reducible to above forms
--   * Fallback:      Newton's method for numeric answers if not symbolically solvable

-- SUPPORTED EQUATION FORMATS
-- This solver handles the following equation types:
-- 1. Linear equations:       ax + b = c       (x = ...)
-- 2. Quadratic equations:    ax^2 + bx + c = d  (x = ...)
-- 3. Cubic equations:        ax^3 + bx^2 + cx + d = e
-- 4. Trigonometric:          sin(x) = a, cos(x) = a, tan(x) = a
-- 5. Exponential/log:        exp(x) = a, ln(x) = b, a^x = b
-- 6. Fallback: symbolic rearrangement, Newton's numeric solve
--
-- If you want to add more patterns (e.g., systems, piecewise, abs, etc), add more matcher functions.

-- solve.lua
-- Corrected Symbolic solver for equations: accepts AST (or string), returns solution(s) as string/AST

local ast = rawget(_G, "ast") or require("ast")
local errors = _G.errors
 
-- Basic sanity checks for node identity
local function isNum(ast)
    return ast and ast.type == "number"
end
local function isVar(ast, v)
    return ast and ast.type == "variable" and (not v or ast.name == v)
end

-- Ensure parser and simplify are loaded
local parser = rawget(_G, "parser") or require("parser")
local simplify = rawget(_G, "simplify") or require("simplify")

-- Deep copy for ASTs
local function deepCopy(obj)
    if type(obj) ~= "table" then return obj end
    local res = {}
    for k, v in pairs(obj) do res[k] = deepCopy(v) end
    return res
end

-- Simple AST pretty printer
local function astToString(ast)
    if not ast then return "?" end
    if ast.type == "number" then return tostring(ast.value) end
    if ast.type == "variable" then return ast.name end
    if ast.type == "add" then return "("..astToString(ast.left).."+"..astToString(ast.right)..")" end
    if ast.type == "sub" then return "("..astToString(ast.left).."-"..astToString(ast.right)..")" end
    if ast.type == "mul" then return astToString(ast.left).."*"..astToString(ast.right) end
    if ast.type == "div" then return astToString(ast.left).."/"..astToString(ast.right) end
    if ast.type == "power" then return astToString(ast.left).."^"..astToString(ast.right) end
    if ast.type == "neg" then return "-("..astToString(ast.value)..")" end
    if ast.type == "func" then
        local argstrs = {}
        for _, arg in ipairs(ast.args or {}) do
            table.insert(argstrs, astToString(arg))
        end
        return ast.name .. "(" .. table.concat(argstrs, ",") .. ")"
    end
    if ast.type == "matrix" then
      local row_strs = {}
      for _, row in ipairs(ast.rows) do
        local col_strs = {}
        for _, elem in ipairs(row) do
          table.insert(col_strs, astToString(elem))
        end
        table.insert(row_strs, "[" .. table.concat(col_strs, ", ") .. "]")
      end
      return "[" .. table.concat(row_strs, ", ") .. "]"
    end
    if ast.type == "eq" or ast.type == "equation" then return astToString(ast.left).." = "..astToString(ast.right) end
    if ast.type == "symbol" then return ast.name end
    if ast.type == "pm" then
        return "(" .. astToString(ast.left) .. " ± " .. astToString(ast.right) .. ")"
    end
    return "?"
end

-- Evaluate simple expressions (needed for numeric fallback)
local function eval(ast, vars)
    vars = vars or {}
    if ast.type == "number" then return ast.value end
    if ast.type == "variable" then return vars[ast.name] or error("Variable "..ast.name.." unassigned") end
    if ast.type == "add" then return eval(ast.left, vars) + eval(ast.right, vars) end
    if ast.type == "sub" then return eval(ast.left, vars) - eval(ast.right, vars) end
    if ast.type == "mul" then return eval(ast.left, vars) * eval(ast.right, vars) end
    if ast.type == "div" then return eval(ast.left, vars) / eval(ast.right, vars) end
    if ast.type == "power" or ast.type == "pow" then
        return eval(ast.left, vars) ^ eval(ast.right, vars)
    end
    if ast.type == "neg" then return -eval(ast.value, vars) end
    -- basic functions
    if ast.type == "func" then
        local fn = math[ast.name]
        if fn then
            local args = {}
            for _, arg in ipairs(ast.args) do
                table.insert(args, eval(arg, vars))
            end
            return fn(table.unpack(args))
        end
    end
    -- Handle custom "equation" node type: evaluate as lhs - rhs
    if ast.type == "equation" then
        return eval(ast.left, vars) - eval(ast.right, vars)
    end
    error("Eval: unsupported node type "..tostring(ast.type))
end

-- CORRECTED polynomial coefficient extraction
local function polyCoeffs(ast, var, maxdeg)
    local coeffs = {}

    print("[polyCoeffs] input AST:", astToString(ast))

    -- Force canonical expansion to help coefficient extraction
    if simplify and simplify.simplify then
        ast = simplify.simplify(ast)
    end

    local function walk(node, sign)
        print("[polyCoeffs][walk] node type:", node.type, "node:", astToString(node))
        sign = sign or 1

        if node.type == "add" then
            local children = node.args or { node.left, node.right }
            for _, child in ipairs(children) do
                walk(child, sign)
            end
        elseif node.type == "sub" then
            local children = node.args or { node.left, node.right }
            walk(children[1], sign)
            for i = 2, #children do
                walk(children[i], -sign)
            end
        elseif node.type == "mul" then
            local coeff = sign
            local var_power = 0

            local children = node.args or { node.left, node.right }
            for _, child in ipairs(children) do
                if isNum(child) then
                    coeff = coeff * child.value
                elseif isVar(child, var) then
                    var_power = var_power + 1
                elseif (child.type == "power" or child.type == "pow") and isVar(child.left or child.base, var) and isNum(child.right or child.exp) then
                    var_power = var_power + (child.right or child.exp).value
                else
                    -- unsupported term, not a polynomial
                    return
                end
            end

            coeffs[var_power] = (coeffs[var_power] or 0) + coeff
        elseif (node.type == "power" or node.type == "pow") and isVar(node.left or node.base, var) and isNum(node.right or node.exp) then
            coeffs[(node.right or node.exp).value] = (coeffs[(node.right or node.exp).value] or 0) + sign
        elseif isVar(node, var) then
            coeffs[1] = (coeffs[1] or 0) + sign
        elseif isNum(node) then
            coeffs[0] = (coeffs[0] or 0) + (sign * node.value)
        end
    end

    walk(ast)
    print("[polyCoeffs] coeffs table:", coeffs)
    for deg, coeff in pairs(coeffs) do
      print("  degree", deg, "=>", coeff)
    end
    return coeffs
end

-- Linear equation matcher: supports ax + b = c, ax = b, x + b = c, x = b
local function matchLinearEq(eq, var)
    -- Accept forms: ax + b = c, ax = b, x + b = c, x = b
    if eq.type ~= "equation" then return nil end
    local l, r = eq.left, eq.right
    -- If right side is not zero, normalize: (l - r) = 0
    local norm = { type="sub", left=l, right=r }
    local coeffs = polyCoeffs(norm, var)
    if not coeffs then return nil end
    local a = coeffs[1] or 0
    local b = coeffs[0] or 0
    if a == 0 then return nil end
    -- Solution is x = -b/a
    local solution_value = -b / a
    return ast.number(solution_value)
end

local function matchQuadraticEq(eq, var)
    -- Accept forms: ax^2 + bx + c = d
    if eq.type ~= "equation" then return nil end
    local l, r = eq.left, eq.right
    -- Normalize by subtracting right from left: (l - r) = 0
    local norm = { type = "sub", left = l, right = r }
    local coeffs = polyCoeffs(norm, var)
    if not coeffs then return nil end
    local a = coeffs[2] or 0
    local b = coeffs[1] or 0
    local c = coeffs[0] or 0
    if a == 0 then return nil end

    local num_node = function(v) return ast.number(v) end
    -- Build AST nodes for a, b, c
    local a_node = num_node(a)
    local b_node = num_node(b)
    local c_node = num_node(c)
    local four_node = num_node(4)
    local two_node  = num_node(2)

    -- Compute discriminant: D = b^2 - 4*a*c
    local b_sq    = ast.pow(b_node, num_node(2))
    local four_ac = ast.mul({ four_node, a_node, c_node })
    local disc    = ast.sub(b_sq, four_ac)

    -- Build sqrt(D)
    local sqrt_disc = ast.func("sqrt", { disc })
    -- Compute -b
    local minus_b = ast.neg(b_node)
    -- Compute denominator 2a
    local denom = ast.mul({ two_node, a_node })

    -- Plus and minus solutions:
    local plus_case  = ast.div(ast.add({ minus_b,        sqrt_disc }), denom)
    local minus_case = ast.div(ast.sub(minus_b,        sqrt_disc ), denom)

    -- Construct ± in one node:
    local root_pm = ast.div(
        ast.add({ minus_b, { type = "pm", left = sqrt_disc, right = ast.number(0) } }),
        denom
    )

    return { plus_case, minus_case, root_pm }
end

-- Cardano's method for cubics: ax^3+bx^2+cx+d=e
local function matchCubicEq(eq, var)
    if eq.type == "equation" then
        local l = eq.left
        local r = eq.right
        -- Normalize by subtracting right from left
        local coeffs = polyCoeffs({type="sub", left=l, right=r}, var)
        if not coeffs then return nil end
        local a = coeffs[3] or 0
        local b = coeffs[2] or 0
        local c = coeffs[1] or 0
        local d = coeffs[0] or 0
        if a ~= 0 then
            -- Depressed cubic: t^3 + pt + q = 0
            local p = (3*a*c - b^2)/(3*a^2)
            local q = (2*b^3 - 9*a*b*c + 27*a^2*d)/(27*a^3)
            local roots = {}
            local delta = (q^2)/4 + (p^3)/27
            if delta > 0 then
                local sqrt_delta = math.sqrt(delta)
                local u = ((-q)/2 + sqrt_delta)^(1/3)
                local v = ((-q)/2 - sqrt_delta)^(1/3)
                local root = u + v - b/(3*a)
                table.insert(roots, root)
                return roots
            elseif delta == 0 then
                local u = (-q/2)^(1/3)
                local r1 = 2*u - b/(3*a)
                local r2 = -u - b/(3*a)
                return { r1, r2 }
            else
                -- Three real roots
                local r = math.sqrt(-p^3/27)
                local phi = math.acos(-q/(2*r))
                local t = 2*math.sqrt(-p/3)
                for k=0,2 do
                    local angle = (phi+2*math.pi*k)/3
                    local root = t*math.cos(angle) - b/(3*a)
                    table.insert(roots, root)
                end
                return roots
            end
        end
    end
    return nil
end
-- Match simple isolated variable equation: x = b
local function matchSimpleIsolatedVarEq(eq, var)
    -- Matches x = b (variable alone on left, constant or expr on right)
    if eq.type ~= "equation" then return nil end
    if isVar(eq.left, var) and not contains_var(eq.right, var) then
        return ast.eq(ast.symbol(var), copy(eq.right))
    end
    return nil
end

-- Solve simple trig equations, e.g. sin(x)=0, cos(x)=1, tan(x)=a
local function matchTrigEq(eq, var)
    if eq.type == "equation" then
        local l, r = eq.left, eq.right
        if l.type == "func" and isVar(l.args[1], var) then
            local fname = l.name
            if fname == "sin" then
                -- sin(x)=a → x=arcsin(a)+2πk, π-arcsin(a)+2πk
                if isNum(r) and r.value >= -1 and r.value <= 1 then
                    return {
                        ast.eq(ast.symbol(var), ast.add({ ast.func("arcsin", { r }), ast.symbol("2πk") })),
                        ast.eq(ast.symbol(var), ast.add({ ast.sub(ast.symbol("π"), ast.func("arcsin", { r })), ast.symbol("2πk") }))
                    }
                end
            elseif fname == "cos" then
                -- cos(x)=a → x=arccos(a)+2πk, -arccos(a)+2πk
                if isNum(r) and r.value >= -1 and r.value <= 1 then
                    return {
                        ast.eq(ast.symbol(var), ast.add({ ast.func("arccos", { r }), ast.symbol("2πk") })),
                        ast.eq(ast.symbol(var), ast.add({ ast.neg(ast.func("arccos", { r })), ast.symbol("2πk") }))
                    }
                end
            elseif fname == "tan" then
                -- tan(x)=a → x=arctan(a)+πk
                if isNum(r) then
                    return {
                        ast.eq(ast.symbol(var), ast.add({ ast.func("arctan", { r }), ast.symbol("πk") }))
                    }
                end
            end
        end
    end
    return nil
end

-- Solve exponential/logarithmic equations
local function matchExpLogEq(eq, var)
    if eq.type == "equation" then
        local l, r = eq.left, eq.right
        -- exp(x) = a → x=ln(a)
        if l.type == "func" and l.name == "exp" and isVar(l.args[1], var) and isNum(r) and r.value > 0 then
            return {
                ast.eq(ast.symbol(var), ast.func("ln", { r }))
            }
        end
        -- ln(x) = a → x=exp(a)
        if l.type == "func" and l.name == "ln" and isVar(l.args[1], var) and isNum(r) then
            return {
                ast.eq(ast.symbol(var), ast.func("exp", { r }))
            }
        end
        -- a^x = b → x=ln(b)/ln(a)
        if l.type == "power" and isNum(l.left) and isVar(l.right, var) and isNum(r) and l.left.value > 0 and r.value > 0 then
            return {
                ast.eq(ast.symbol(var), ast.div(ast.func("ln", { r }), ast.func("ln", { l.left })))
            }
        end
    end
    return nil
end

-- Fallback: Newton's method (symbolic evaluation if possible)
local function newtonSolve(eq, var, guess, maxiter)
    maxiter = maxiter or 8
    local x = guess or 1
    for i=1,maxiter do
        -- Numerical derivative by h
        local h = 1e-7
        local env = {}; env[var]=x
        local f = eval({type="sub", left=eq.left, right=eq.right}, env)
        local f1 = eval({type="sub", left=eq.left, right=eq.right}, (function() local e = {}; for k,v in pairs(env) do e[k]=v end; e[var]=x+h; return e end)())
        local dfdx = (f1-f)/h
        if math.abs(dfdx) < 1e-10 then break end
        local xnew = x - f/dfdx
        if math.abs(xnew-x) < 1e-10 then return xnew end
        x = xnew
    end
    return x
end

-- Utility: checks if an AST node contains a variable
local function contains_var(node, var)
  if type(node) ~= "table" then return false end
  if node.type == "variable" and node.name == var then return true end
  for k,v in pairs(node) do
    if contains_var(v, var) then return true end
  end
  return false
end

-- Helper to check if an AST node is a constant (number)
local function is_const(node)
  return node and node.type == "number"
end

-- Helper for variable test (for base case, mirror old code)
local function is_var(node)
  return node and node.type == "variable"
end

-- Helper to copy AST nodes (deep copy)
local function copy(node)
  if type(node) ~= "table" then return node end
  local res = {}
  for k,v in pairs(node) do res[k] = copy(v) end
  return res
end

local function solveAST(eq, var)
  -- Only handle equations
  if not eq or eq.type ~= "equation" then
    return { type = "unhandled_node", reason = "Not an equation", original = eq }
  end

  local lhs = eq.left
  local rhs = eq.right

  -- If variable only on one side, swap if needed
  if contains_var(rhs, var) and not contains_var(lhs, var) then
    lhs, rhs = rhs, lhs
  end

  -- Base case: variable alone
  if is_var(lhs) and lhs.name == var then
    -- Ensure rhs is a valid AST node
    local _rhs = rhs
    if type(_rhs) ~= "table" then
        _rhs = ast.number(_rhs)
    end
    return ast.eq(ast.symbol(var), copy(_rhs))
  end

  -- Directly handle simple isolated variable: x = b
  if is_var(lhs, var) and not contains_var(rhs, var) then
    return ast.eq(ast.symbol(var), copy(rhs))
  end

  -- If this is a polynomial equation, extract degree and use appropriate matcher
  local diff = simplify.simplify(ast.sub(lhs, rhs))
  local coeffs = polyCoeffs(diff, var)
  local highest_degree = 0
  if coeffs then
    for deg, _ in pairs(coeffs) do
      if deg > highest_degree then highest_degree = deg end
    end
    if highest_degree == 1 then
      local ans_lin = matchLinearEq(ast.eq(lhs, rhs), var)
      if ans_lin then
        return ast.eq(ast.symbol(var), ans_lin)
      end
    elseif highest_degree == 2 then
      local ans_quad = matchQuadraticEq(ast.eq(lhs, rhs), var)
      if ans_quad then
        -- Just return ± form for now
        local eq_pm = ans_quad[3] and ast.eq(ast.symbol(var), ans_quad[3])
        return eq_pm or ast.eq(ast.symbol(var), ans_quad[1])
      end
    elseif highest_degree == 3 then
      local ans_cubic = matchCubicEq(ast.eq(lhs, rhs), var)
      if ans_cubic then
        -- Return first root as symbolic solution (optionally, all)
        return ast.eq(ast.symbol(var), ast.number(ans_cubic[1]))
      end
    end
  end

  -- Try trig equations
  local trig = matchTrigEq(ast.eq(lhs, rhs), var)
  if trig then
    return trig[1]
  end

  -- Try exp/log equations
  local exp_log = matchExpLogEq(ast.eq(lhs, rhs), var)
  if exp_log then
    return exp_log[1]
  end

  -- If still not solved, try the classic pattern matching and structure-based recursion as before

  -- Linear: x + a = b  or x - a = b
  if lhs.type == "add" then
    for i, arg in ipairs(lhs.args) do
      if contains_var(arg, var) then
        -- x + a = b  --> x = b - a
        local others = {}
        for j, arg2 in ipairs(lhs.args) do if i ~= j then table.insert(others, arg2) end end
        local subtrahend = #others == 1 and others[1] or ast.add(table.unpack(others))
        local next_eq = ast.eq(arg, ast.sub(rhs, subtrahend))
        next_eq = simplify.simplify(next_eq)
        return solveAST(next_eq, var)
      end
    end
  elseif lhs.type == "sub" then
    if contains_var(lhs.left, var) and not contains_var(lhs.right, var) then
      -- x - a = b --> x = b + a
      local next_eq = ast.eq(lhs.left, ast.add(rhs, lhs.right))
      next_eq = simplify.simplify(next_eq)
      return solveAST(next_eq, var)
    elseif contains_var(lhs.right, var) and not contains_var(lhs.left, var) then
      -- a - x = b --> x = a - b
      local next_eq = ast.eq(lhs.right, ast.sub(lhs.left, rhs))
      next_eq = simplify.simplify(next_eq)
      return solveAST(next_eq, var)
    end
  elseif lhs.type == "mul" then
    for i, arg in ipairs(lhs.args) do
      if contains_var(arg, var) then
        -- x * a = b --> x = b / a
        local others = {}
        for j, arg2 in ipairs(lhs.args) do if i ~= j then table.insert(others, arg2) end end
        local divisor = #others == 1 and others[1] or ast.mul(table.unpack(others))
        local next_eq = ast.eq(arg, ast.div(rhs, divisor))
        next_eq = simplify.simplify(next_eq)
        return solveAST(next_eq, var)
      end
    end
  elseif lhs.type == "div" then
    if contains_var(lhs.left, var) and not contains_var(lhs.right, var) then
      -- x / a = b --> x = b * a
      local next_eq = ast.eq(lhs.left, ast.mul(rhs, lhs.right))
      next_eq = simplify.simplify(next_eq)
      return solveAST(next_eq, var)
    elseif contains_var(lhs.right, var) and not contains_var(lhs.left, var) then
      -- a / x = b --> x = a / b
      local next_eq = ast.eq(lhs.right, ast.div(lhs.left, rhs))
      next_eq = simplify.simplify(next_eq)
      return solveAST(next_eq, var)
    end
  elseif lhs.type == "pow" or lhs.type == "power" then
    if contains_var(lhs.left or lhs.base, var) and is_const(lhs.right or lhs.exp) then
      local base = lhs.left or lhs.base
      local exp = lhs.right or lhs.exp
      -- x^n = b --> x = b^(1/n)
      local next_eq = ast.eq(base, ast.pow(rhs, ast.div(ast.number(1), exp)))
      next_eq = simplify.simplify(next_eq)
      return solveAST(next_eq, var)
    elseif is_const(lhs.left or lhs.base) and contains_var(lhs.right or lhs.exp, var) then
      local base = lhs.left or lhs.base
      local exp = lhs.right or lhs.exp
      -- a^x = b --> x = ln(b) / ln(a)
      local next_eq = ast.eq(exp, ast.div(ast.func("ln", { rhs }), ast.func("ln", { base })))
      next_eq = simplify.simplify(next_eq)
      return solveAST(next_eq, var)
    end
  end

  -- fallback: unhandled → mark as unsolved equation
  return ast.eq(ast.symbol(var), { type = "unsolved", reason = "unhandled equation structure", original = eq })
end

-- Main solve function
function solve(input_expr, var)
    local parser = rawget(_G, "parser") or require("parser")
    local ast_mod = rawget(_G, "ast") or require("ast")
    local simplify = rawget(_G, "simplify") or require("simplify")

    local expr = input_expr
    if type(expr) == "string" then
        -- Insert '*' between a digit and a letter or digit and '('
        local s = expr
        s = s:gsub("(%d)(%a)", "%1*%2")
        s = s:gsub("(%d)(%()", "%1*%2")
        expr = parser.parse(s)
    end
    if not expr then
        error(errors.invalid("solve", "parse failed, got nil AST"))
    end

    var = var or (function()
        -- try to guess variable
        local function findVar(node)
            if not node or type(node) ~= "table" then return nil end
            if node.type == "variable" then return node.name end
            for _, k in ipairs { "left", "right", "value", "args" } do
                local child = node[k]
                if child then
                    if type(child) == "table" and not child[1] then
                        local res = findVar(child)
                        if res then return res end
                    elseif type(child) == "table" then
                        for _, v in ipairs(child) do
                            local res = findVar(v)
                            if res then return res end
                        end
                    end
                end
            end
            return nil
        end
        return findVar(expr.left) or findVar(expr.right) or "x"
    end)()

    -- Canonicalize equation as eq-node (lhs = rhs), or expr = 0
    if expr.type == "equation" then
        expr = ast_mod.eq(expr.left, expr.right)
    elseif expr.type ~= "equation" then
        expr = ast_mod.eq(expr, ast_mod.number(0))
    end

    -- Always simplify first
    expr = simplify.simplify(expr)

    -- Try new symbolic solver
    local result = solveAST(expr, var)
    -- If it returns unhandled_node, fall back to original matchers
    if result and result.type ~= "unhandled_node" then
        -- Further simplify the result before converting to string
        result = simplify.simplify(result)
        return astToString(result)
    end

    -- Try all known matchers
    local diff = simplify.simplify(ast_mod.sub(expr.left, expr.right))
    local fallback_eq = ast_mod.eq(diff, ast_mod.number(0))

    -- Try simple isolated variable matcher first (x = b)
    local ans_simple = matchSimpleIsolatedVarEq(expr, var)
    if not ans_simple then
        ans_simple = matchSimpleIsolatedVarEq(fallback_eq, var)
    end
    if ans_simple then
        local simplified_eq = simplify.simplify(ans_simple)
        return astToString(simplified_eq)
    end

    local ans_lin = matchLinearEq(fallback_eq, var)
    if ans_lin then
        -- Create proper equation AST
        local rhs
        if type(ans_lin) ~= "table" then
            rhs = ast_mod.number(ans_lin)
        else
            rhs = ans_lin
        end
        local eq_ast = ast_mod.eq(ast_mod.symbol(var), rhs)
        local simplified_eq = simplify.simplify(eq_ast)
        return astToString(simplified_eq)
    end

    local ans_quad = matchQuadraticEq(fallback_eq, var)
    if ans_quad then
        -- Try to evaluate both roots numerically. If not possible (i.e., discriminant negative), say no real roots.
        local function tryEvalRoot(root)
            local ok, val = pcall(function() return eval(root) end)
            if ok and type(val) == "number" and val == val and math.abs(val) ~= math.huge then
                return val
            end
            return nil
        end
        local v1 = tryEvalRoot(ans_quad[1])
        local v2 = tryEvalRoot(ans_quad[2])
        if v1 and v2 then
            return var .. " = " .. tostring(v1) .. ", " .. tostring(v2)
        else
            return "No real roots"
        end
    end

    local ans = matchCubicEq(fallback_eq, var)
    if ans then
        local outs = {}
        for i,v in ipairs(ans) do
            local eq_ast = ast_mod.eq(ast_mod.symbol(var), ast_mod.number(v))
            local simp = simplify.simplify(eq_ast)
            table.insert(outs, astToString(simp))
        end
        -- If all roots are equal, show just one, else all
        local all_equal = true
        if #outs > 1 then
            for i=2,#outs do
                if outs[i] ~= outs[1] then all_equal = false break end
            end
        end
        if all_equal then
            return outs[1]
        else
            return table.concat(outs, ", ")
        end
    end

    ans = matchTrigEq(fallback_eq, var)
    if ans then
        if type(ans[1]) == "table" and ans[1].type == "equation" then
            local outs = {}
            for _,a in ipairs(ans) do table.insert(outs, astToString(a)) end
            return table.concat(outs, ", ")
        else
            return table.concat(ans, ", ")
        end
    end

    ans = matchExpLogEq(fallback_eq, var)
    if ans then
        if type(ans[1]) == "table" and ans[1].type == "equation" then
            local outs = {}
            for _,a in ipairs(ans) do table.insert(outs, astToString(a)) end
            return table.concat(outs, ", ")
        else
            return table.concat(ans, ", ")
        end
    end

    -- Fallback: numerical
    local xnum = newtonSolve(fallback_eq, var)
    if xnum then
        return var.." ≈ "..tostring(xnum)
    end

    return "No solution found"
end

-- Public interface: string or AST in, solution AST or unhandled node out
local function solve_symbolic(expr, var)
  local parser = rawget(_G, "parser") or require("parser")
  local simplify = rawget(_G, "simplify") or require("simplify")
  if type(expr) == "string" then expr = parser.parse(expr) end
  if not expr then error(errors.invalid("solve", "symbolic parse failed: " .. tostring(expr))) end
  var = var or "x"
  -- handle input like "lhs = rhs" or plain expr = 0
  if expr.type == "equation" then
    expr = ast.eq(expr.left, expr.right)
  elseif expr.type ~= "equation" then
    expr = ast.eq(expr, ast.number(0))
  end
  expr = simplify.simplify(expr)
  local result = solveAST(expr, var)
  return result
end

-- Export functions
_G.solve = solve
_G.solveAST = solveAST
_G.solve_symbolic = solve_symbolic
_G.polyCoeffs = polyCoeffs
_G.matchLinearEq = matchLinearEq
_G.matchQuadraticEq = matchQuadraticEq
_G.matchCubicEq = matchCubicEq
_G.matchSimpleIsolatedVarEq = matchSimpleIsolatedVarEq
_G.astToString = astToString

--[[
Extending to new equation types:
To add support for a new equation type, write a matcher function (see matchLinearEq, matchQuadraticEq, etc.),
normalize the equation (subtract right from left if needed), extract coefficients or pattern-match as required,
and add your matcher to the main solve function before the fallback.
]]

-- End src/solve.lua

-- Glued in src/solve.lua. Now question why you needed it.

-- Begin src/factorial.lua
-- factorial.lua
-- Converts symbolic factorial calls to Gamma-based equivalents
-- Works even when you feed it algebra instead of numbers, which is both useful and terrifying

-- Numerical fallback (not actually used in AST transforms)
-- Just here for completeness, or when someone evaluates factorial(5) directly
local function factorial(n)
  assert(n >= 0 and math.floor(n) == n, "factorial only defined for non-negative integers")
  local result = 1
  for i = 2, n do result = result * i end
  return result
end

-- Matches factorial(x) and returns gamma(x + 1)
-- Strictly cosmetic — lets us pretend we know how to differentiate factorials
local function matchFactorial(ast)
  if ast.type == "func" and ast.name == "factorial" and ast.args and #ast.args == 1 then
    local arg = ast.args[1]
    -- Convert factorial(n) to gamma(n+1)
    return {
      type = "func",
      name = "gamma",
      args = {
        {
          type = "add",
          args = { arg, { type = "number", value = 1 } }  -- ← Fixed: Use args array
        }
      }
    }
  end
  return ast
end

-- Walks the AST and replaces every factorial(...) with gamma(... + 1)
-- Recursively rewrites child nodes as well, whether they like it or not
function transformFactorial(ast)
  if type(ast) ~= "table" then return ast end
  
  -- Transform factorial(n) → gamma(n+1)
  if ast.type == "func" and ast.name == "factorial" and ast.args and #ast.args == 1 then
    local arg = transformFactorial(ast.args[1])
    return {
      type = "func",
      name = "gamma",
      args = {
        {
          type = "add",
          args = { arg, { type = "number", value = 1 } }  -- ← Fixed: Use args array
        }
      }
    }
  end
  
  local out = {}
  for k, v in pairs(ast) do
    if type(v) == "table" then
      if #v > 0 then
        out[k] = {}
        for i = 1, #v do
          out[k][i] = transformFactorial(v[i])
        end
      else
        out[k] = transformFactorial(v)
      end
    else
      out[k] = v
    end
  end
  return out
end

_G.transformFactorial = transformFactorial

-- End src/factorial.lua

-- Merged src/factorial.lua: pray those ASTs behave.

-- Begin src/gui.lua
local overlayAlpha = 1.0
local overlayRegion = {x=270, y=8, w=90, h=24} -- Position this based on your layout
local cursorInsideOverlay = false
var = var or {}
var.store = var.store or {}
local parser = rawget(_G, "parser")
if not parser or not parser.parse then
  error("parser module or parser.parse not defined — ensure parser.lua is loaded before gui.lua")
end
local parse = parser.parse
local simplify = rawget(_G, "simplify")
local errors = _G.errors

-- Ensure getLocaleText exists, fallback to identity
local getLocaleText = rawget(_G, "getLocaleText") or function(key) return key end

_G.autoDecimal = false
_G.settingsBtnRegion = {x = 0, y = 0, w = 32, h = 32}
-- Modal flag for settings
_G.showSettingsModal = false
_G.switchPressed = false
_G.modalETKButton = nil
_G.modalCloseBtnRegion = {x = 0, y = 0, w = 24, h = 24}
-- Compatibility hack: unpack became table.unpack in newer Lua, because reasons
unpack = unpack or table.unpack

-- ====== Embedded Standalone ETK-style Button Widget ======

Widgets = {}

-- Helper for unpacking color
function unpackColor(t)
  return t[1], t[2], t[3]
end

-- Helper for simple dimension (width, height)
function Dimension(w, h)
  return { width = w, height = h }
end

-- Helper event dispatcher
function CallEvent(obj, name)
  if obj[name] then obj[name](obj) end
end

-- ETK-style Button class
Widgets.Button = class(Widget)
local Button = Widgets.Button

Button.defaultStyle = {
  textColor       = {{000,000,000},{000,000,000}},
  backgroundColor = {{248,252,248},{248,252,248}},
  borderColor     = {{136,136,136},{160,160,160}},
  focusColor      = {{040,148,184},{000,000,000}},
  defaultWidth  = 48,
  defaultHeight = 27,
  font = {
    serif="sansserif",
    style="r",
    size=10
  }
}

function Button:init(arg)	
  self.text = arg.text or "Button"
  local style = arg.style or Button.defaultStyle or {
    textColor       = {{0,0,0},{0,0,0}},
    backgroundColor = {{248,252,248},{248,252,248}},
    borderColor     = {{136,136,136},{160,160,160}},
    focusColor      = {{40,148,184},{0,0,0}},
    defaultWidth  = 48,
    defaultHeight = 27,
    font = {
      serif="sansserif",
      style="r",
      size=10
    }
  }
  self.style = style
  self.dimension = arg.position or Dimension(style.defaultWidth or 48, style.defaultHeight or 27)
  Widget.init(self, nil, self.dimension.width or style.defaultWidth, self.dimension.height or style.defaultHeight)
  self.meDown = false
  self.hasFocus = false
  self.parent = arg.parent or nil
  self.onAction = arg.onAction or nil
end

function Button:prepare(gc)
  local font = self.style.font
  gc:setFont(font.serif, font.style, font.size)
  self.dimension.width = gc:getStringWidth(self.text) + 10
end

function Button:draw(gc, x, y, width, height, isColor)
  if self.meDown then
    y = y + 1
  end

  local color = isColor and 1 or 2
  local style = self.style or Button.defaultStyle

  local bg = style.backgroundColor and style.backgroundColor[color] or Button.defaultStyle.backgroundColor[color]
  local tc = style.textColor and style.textColor[color] or Button.defaultStyle.textColor[color]
  local bc = style.borderColor and style.borderColor[color] or Button.defaultStyle.borderColor[color]
  local fc = style.focusColor and style.focusColor[color] or Button.defaultStyle.focusColor[color]

  gc:setColorRGB(unpackColor(bg))
  gc:fillRect(x + 2, y + 2, width - 4, height - 4)

  gc:setColorRGB(unpackColor(tc))
  gc:drawString(self.text, x + 5, y + 3, "top")

  if self.hasFocus then
    gc:setColorRGB(unpackColor(fc))
    gc:setPen("medium", "smooth")
  else
    gc:setColorRGB(unpackColor(bc))
    gc:setPen("thin", "smooth")
  end

  gc:fillRect(x + 2, y, width - 4, 2)
  gc:fillRect(x + 2, y + height - 2, width - 4, 2)
  gc:fillRect(x, y + 2, 1, height - 4)
  gc:fillRect(x + 1, y + 1, 1, height - 2)
  gc:fillRect(x + width - 1, y + 2, 1, height - 4)
  gc:fillRect(x + width - 2, y + 1, 1, height - 2)

  if self.hasFocus then
    gc:setColorRGB(unpackColor(style.focusColor[color]))
  end

  gc:setPen("thin", "smooth")
end

function Button:doAction()
  if self.parent and self.parent.invalidate then
    self.parent:invalidate()
  end
  if self.onAction then
    self.onAction(self)
  else
    CallEvent(self, "onAction")
  end
end

function Button:onMouseDown()
  self.meDown = true
end

function Button:onMouseUp(x, y, onMe)
  self.meDown = false
  if onMe then
    self:doAction()
  end
end

function Button:enterKey()
  self:doAction()
end

-- ====== END Standalone Button Widget ======
-- ETK View System (lifted and tweaked from SuperSpire/S2.lua)
defaultFocus = nil

-- The View class: manages widgets, focus, mouse events, and general UI mayhem.
View = class()

function View:init(window)
	self.window = window
	self.widgetList = {}
	self.focusList = {}
	self.currentFocus = 0
	self.currentCursor = "default"
	self.prev_mousex = 0
	self.prev_mousey = 0
end

function View:invalidate()
	self.window:invalidate()
end

function View:setCursor(cursor)
	if cursor ~= self.currentCursor then
		self.currentCursor = cursor
		self:invalidate()
	end
end

-- Add a widget to the view, because clearly we like clutter. Also handles focus logic.
function View:add(o)
	table.insert(self.widgetList, o)
	self:repos(o)
	if o.acceptsFocus then
		table.insert(self.focusList, 1, o)
		if self.currentFocus > 0 then
			self.currentFocus = self.currentFocus + 1
		end
	end
	return o
end

-- Remove a widget from the view, and try to pretend nothing ever happened.
function View:remove(o)
	if self:getFocus() == o then
		o:releaseFocus()
	end
	local i = 1
	local f = 0
	while i <= #self.focusList do
		if self.focusList[i] == o then
			f = i
		end
		i = i + 1
	end
	if f > 0 then
		if self:getFocus() == o then
			self:tabForward()
		end
		table.remove(self.focusList, f)
		if self.currentFocus > f then
			self.currentFocus = self.currentFocus - 1
		end
	end
	f = 0
	i = 1
	while i <= #self.widgetList do
		if self.widgetList[i] == o then
			f = i
		end
		i = i + 1
	end
	if f > 0 then
		table.remove(self.widgetList, f)
	end
end

-- Reposition and resize a widget according to its constraints. Because pixel-perfect UIs are for the weak.
function View:repos(o)
	local x = o.x
	local y = o.y
	local w = o.w
	local h = o.h
	if o.hConstraint == "right" then
		x = scrWidth - o.w - o.dx1
	elseif o.hConstraint == "center" then
		x = (scrWidth - o.w + o.dx1) / 2
	elseif o.hConstraint == "justify" then
		w = scrWidth - o.x - o.dx1
	end
	if o.vConstraint == "bottom" then
		y = scrHeight - o.h - o.dy1
	elseif o.vConstraint == "middle" then
		y = (scrHeight - o.h + o.dy1) / 2
	elseif o.vConstraint == "justify" then
		h = scrHeight - o.y - o.dy1
	end
	o:repos(x, y)
	o:resize(w, h)
end

-- Resize all widgets in the view. Hope they like their new size.
function View:resize()
	for _, o in ipairs(self.widgetList) do
		self:repos(o)
	end
end

-- Hide a widget. Out of sight, out of mind (and out of focus).
function View:hide(o)
	if o.visible then
		o.visible = false
		self:releaseFocus(o)
		if o:contains(self.prev_mousex, self.prev_mousey) then
			o:onMouseLeave(o.x - 1, o.y - 1)
		end
		self:invalidate()
	end
end

-- Show a widget. If it was invisible, now it can bask in the user's gaze.
function View:show(o)
	if not o.visible then
		o.visible = true
		if o:contains(self.prev_mousex, self.prev_mousey) then
			o:onMouseEnter(self.prev_mousex, self.prev_mousey)
		end
		self:invalidate()
	end
end

-- Return the currently focused widget, or nil if nothing bothers to have focus.
function View:getFocus()
	if self.currentFocus == 0 then
		return nil
	end
	return self.focusList[self.currentFocus]
end

-- Give focus to a widget, and make everyone else jealous.
function View:setFocus(obj)
	if self.currentFocus ~= 0 then
		if self.focusList[self.currentFocus] == obj then
			return
		end
		self.focusList[self.currentFocus]:releaseFocus()
	end
	self.currentFocus = 0
	for i = 1, #self.focusList do
		if self.focusList[i] == obj then
			self.currentFocus = i
			obj:setFocus()
			self:invalidate()
			break
		end
	end
end

-- Take focus away from a widget. It probably didn't deserve it anyway.
function View:releaseFocus(obj)
	if self.currentFocus ~= 0 then
		if self.focusList[self.currentFocus] == obj then
			self.currentFocus = 0
			obj:releaseFocus()
			self:invalidate()
		end
	end
end

-- Send a string to the focused widget, or desperately try to find anyone who will take it.
function View:sendStringToFocus(str)
	local o = self:getFocus()
	if not o then
		o = defaultFocus
		self:setFocus(o)
	end
	if o then
		if o.visible then
			if o:addString(str) then
				self:invalidate()
			else
				o = nil
			end
		end
	end

	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible then
				if o:addString(str) then
					self:setFocus(o)
					self:invalidate()
					break
				end
			end
		end
	end
end

-- Handle backspace for the focused widget, or for anyone who claims to accept it.
function View:backSpaceHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsBackSpace then
			o:backSpaceHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsBackSpace then
				o:backSpaceHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Move focus to the next widget, looping around. Because tab order is a suggestion, not a rule.
function View:tabForward()
	local nextFocus = self.currentFocus + 1
	if nextFocus > #self.focusList then
		nextFocus = 1
	end
	self:setFocus(self.focusList[nextFocus])
	if self:getFocus() then
		if not self:getFocus().visible then
			self:tabForward()
		end
	end
	self:invalidate()
end

-- Move focus to the previous widget, looping around. For the rebels who like shift+tab.
function View:tabBackward()
	local nextFocus = self.currentFocus - 1
	if nextFocus < 1 then
		nextFocus = #self.focusList
	end
	self:setFocus(self.focusList[nextFocus])
	if not self:getFocus().visible then
		self:tabBackward()
	end
	self:invalidate()
end

-- Handle mouse down events, capturing the widget that gets clicked (and focus).
function View:onMouseDown(x, y)
	for _, o in ipairs(self.widgetList) do
		if o.visible and o.acceptsFocus and o:contains(x, y) then
			self.mouseCaptured = o
			o:onMouseDown(o, window, x - o.x, y - o.y)
			self:setFocus(o)
			self:invalidate()
			return
		end
	end
	if self:getFocus() then
		self:setFocus(nil)
		self:invalidate()
	end
end

-- Handle mouse move events, triggering enter/leave events for widgets. Because hover states are important.
function View:onMouseMove(x, y)
	local prev_mousex = self.prev_mousex
	local prev_mousey = self.prev_mousey
	for _, o in ipairs(self.widgetList) do
		local xyin = o:contains(x, y)
		local prev_xyin = o:contains(prev_mousex, prev_mousey)
		if xyin and not prev_xyin and o.visible then
			o:onMouseEnter(x, y)
			self:invalidate()
		elseif prev_xyin and (not xyin or not o.visible) then
			o:onMouseLeave(x, y)
			self:invalidate()
		end
	end
	self.prev_mousex = x
	self.prev_mousey = y
end

-- Handle mouse up events, releasing the widget that was so rudely pressed.
function View:onMouseUp(x, y)
	local mc = self.mouseCaptured
	if mc then
		self.mouseCaptured = nil
		if mc:contains(x, y) then
			mc:onMouseUp(x - mc.x, y - mc.y)
		end
	end
end

-- Handle "enter" key for the focused widget, or anyone who cares.
function View:enterHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsEnter then
			o:enterHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsEnter then
				o:enterHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle left arrow key for the focused widget, or anyone who wants to move left in life.
function View:arrowLeftHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowLeft then
			o:arrowLeftHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowLeft then
				o:arrowLeftHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle right arrow key for the focused widget, or anyone who wants to move right in life.
function View:arrowRightHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowRight then
			o:arrowRightHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowRight then
				o:arrowRightHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle up arrow key for the focused widget. Because up is the new down.
function View:arrowUpHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowUp then
			o:arrowUpHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowUp then
				o:arrowUpHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Handle down arrow key for the focused widget. Because down is the new up.
function View:arrowDownHandler()
	local o = self:getFocus()
	if o then
		if o.visible and o.acceptsArrowDown then
			o:arrowDownHandler()
			self:setFocus(o)
			self:invalidate()
		else
			o = nil
		end
	end
	if not o then
		for _, o in ipairs(self.focusList) do
			if o.visible and o.acceptsArrowDown then
				o:arrowDownHandler()
				self:setFocus(o)
				self:invalidate()
				break
			end
		end
	end
end

-- Paint all widgets to the screen, highlight the focused one, and set the cursor.
function View:paint(gc)
	local fo = self:getFocus()
	for _, o in ipairs(self.widgetList) do
		if o.visible then
			o:paint(gc, fo == o)
			if fo == o then
				gc:setColorRGB(100, 150, 255)
				gc:drawRect(o.x - 1, o.y - 1, o.w + 1, o.h + 1)
				gc:setPen("thin", "smooth")
				gc:setColorRGB(0, 0, 0)
			end
		end
	end
	cursor.set(self.currentCursor)
end

theView = nil

-- Widget base class. All widgets inherit from this, like it or not.
Widget = class()

function Widget:setHConstraints(hConstraint, dx1)
	self.hConstraint = hConstraint
	self.dx1 = dx1
end

function Widget:setVConstraints(vConstraint, dy1)
	self.vConstraint = vConstraint
	self.dy1 = dy1
end

function Widget:init(view, x, y, w, h)
	self.xOrig = x
	self.yOrig = y
	self.view = view
	self.x = x
	self.y = y
	self.w = w
	self.h = h
	self.acceptsFocus = false
	self.visible = true
	self.acceptsEnter = false
	self.acceptsEscape = false
	self.acceptsTab = false
	self.acceptsDelete = false
	self.acceptsBackSpace = false
	self.acceptsReturn = false
	self.acceptsArrowUp = false
	self.acceptsArrowDown = false
	self.acceptsArrowLeft = false
	self.acceptsArrowRight = false
	self.hConstraint = "left"
	self.vConstraint = "top"
end

function Widget:repos(x, y)
	self.x = x
	self.y = y
end

function Widget:resize(w, h)
	self.w = w
	self.h = h
end

function Widget:setFocus() end
function Widget:releaseFocus() end

function Widget:contains(x, y)
	return x >= self.x and x <= self.x + self.w
			and y >= self.y and y <= self.y + self.h
end

function Widget:onMouseEnter(x, y) end
function Widget:onMouseLeave(x, y) end
function Widget:paint(gc, focused) end
function Widget:enterHandler() end
function Widget:escapeHandler() end
function Widget:tabHandler() end
function Widget:deleteHandler() end
function Widget:backSpaceHandler() end
function Widget:returnHandler() end
function Widget:arrowUpHandler() end
function Widget:arrowDownHandler() end
function Widget:arrowLeftHandler() end
function Widget:arrowRightHandler() end
function Widget:onMouseDown(x, y) end
function Widget:onMouseUp(x, y) end

-- Button widget, for people who like clicking things.
Button = class(Widget)

function Button:init(view, x, y, w, h, default, command, shortcut)
	Widget.init(self, view, x, y, w, h)
	self.acceptsFocus = true
	self.command = command or function() end
	self.default = default
	self.shortcut = shortcut
	self.clicked = false
	self.highlighted = false
	self.acceptsEnter = true
end

function Button:enterHandler()
	if self.acceptsEnter then
		self:command()
	end
end

function Button:escapeHandler()
	if self.acceptsEscape then
		self:command()
	end
end

function Button:tabHandler()
	if self.acceptsTab then
		self:command()
	end
end

function Button:deleteHandler()
	if self.acceptsDelete then
		self:command()
	end
end

function Button:backSpaceHandler()
	if self.acceptsBackSpace then
		self:command()
	end
end

function Button:returnHandler()
	if self.acceptsReturn then
		self:command()
	end
end

function Button:arrowUpHandler()
	if self.acceptsArrowUp then
		self:command()
	end
end

function Button:arrowDownHandler()
	if self.acceptsArrowDown then
		self:command()
	end
end

function Button:arrowLeftHandler()
	if self.acceptsArrowLeft then
		self:command()
	end
end

function Button:arrowRightHandler()
	if self.acceptsArrowRight then
		self:command()
	end
end

function Button:onMouseDown(x, y)
	self.clicked = true
	self.highlighted = true
end

function Button:onMouseEnter(x, y)
	theView:setCursor("hand pointer")
	if self.clicked and not self.highlighted then
		self.highlighted = true
	end
end

function Button:onMouseLeave(x, y)
	theView:setCursor("default")
	if self.clicked and self.highlighted then
		self.highlighted = false
	end
end

function Button:cancelClick()
	if self.clicked then
		self.highlighted = false
		self.clicked = false
	end
end

function Button:onMouseUp(x, y)
	self:cancelClick()
	self:command()
end

function Button:addString(str)
	if str == " " or str == self.shortcut then
		self:command()
		return true
	end
	return false
end

-- Image label widget. Displays an image, does nothing else. The laziest widget.
ImgLabel = class(Widget)

function ImgLabel:init(view, x, y, img)
	self.img = image.new(img)
	self.w = image.width(self.img)
	self.h = image.height(self.img)
	Widget.init(self, view, x, y, self.w, self.h)
end

function ImgLabel:paint(gc, focused)
	gc:drawImage(self.img, self.x, self.y)
end

-- Image button widget. Like a button, but with more pixels.
ImgButton = class(Button)

function ImgButton:init(view, x, y, img, command, shortcut)
	self.img = image.new(img)
	self.w = image.width(self.img)
	self.h = image.height(self.img)
	Button.init(self, view, x, y, self.w, self.h, false, command, shortcut)
end

function ImgButton:paint(gc, focused)
	gc:drawImage(self.img, self.x, self.y)
end

-- Text button widget. For those who prefer words to icons.
TextButton = class(Button)

function TextButton:init(view, x, y, text, command, shortcut)
	self.textid = text
	self.text = getLocaleText(text)
	self:resize(0, 0)
	Button.init(self, view, x, y, self.w, self.h, false, command, shortcut)
end

function TextButton:resize(w, h)
	self.text = getLocaleText(self.textid)
	self.w = getStringWidth(self.text) + 5
	self.h = getStringHeight(self.text) + 5
end

function TextButton:paint(gc, focused)
	gc:setColorRGB(223, 223, 223)
	gc:drawRect(self.x + 1, self.y + 1, self.w - 2, self.h - 2)
	gc:setColorRGB(191, 191, 191)
	gc:fillRect(self.x + 1, self.y + 1, self.w - 3, self.h - 3)
	gc:setColorRGB(223, 223, 223)
	gc:drawString(self.text, self.x + 3, self.y + 3, "top")
	gc:setColorRGB(0, 0, 0)
	gc:drawString(self.text, self.x + 2, self.y + 2, "top")
	gc:drawRect(self.x, self.y, self.w - 2, self.h - 2)
end

-- Vertical scrollbar widget. Because scrolling through history is a thing.
VScrollBar = class(Widget)

function VScrollBar:init(view, x, y, w, h)
	self.pos = 10
	self.siz = 10
	Widget.init(self, view, x, y, w, h)
end

function VScrollBar:paint(gc, focused)
	gc:setColorRGB(0, 0, 0)
	gc:drawRect(self.x, self.y, self.w, self.h)
	gc:fillRect(self.x + 2, self.y + self.h - (self.h - 4) * (self.pos + self.siz) / 100 - 2, self.w - 3, math.max(1, (self.h - 4) * self.siz / 100 + 1))
end

-- Text label widget. It just sits there and looks pretty.
TextLabel = class(Widget)

function TextLabel:init(view, x, y, text)
	self:setText(text)
	Widget.init(self, view, x, y, self.w, self.h)
end

function TextLabel:resize(w, h)
	self.text = getLocaleText(self.textid)
	self.w = getStringWidth(self.text)
	self.h = getStringHeight(self.text)
end

function TextLabel:setText(text)
	self.textid = text
	self.text = getLocaleText(text)
	self:resize(0, 0)
end

function TextLabel:getText()
	return self.text
end

function TextLabel:paint(gc, focused)
	gc:setColorRGB(0, 0, 0)
	gc:drawString(self.text, self.x, self.y, "top")
end

-- Rich text editor widget. Handles text entry, but don't expect Microsoft Word.
RichTextEditor = class(Widget)

function RichTextEditor:init(view, x, y, w, h, text)
	self.editor = D2Editor.newRichText()
	self.readOnly = false
	self:repos(x, y)
	self.editor:setFontSize(fsize)
	self.editor:setFocus(false)
	self.text = text
	self:resize(w, h)
	Widget.init(self, view, x, y, self.w, self.h, true)
	self.acceptsFocus = true
	self.editor:setExpression(text)
	self.editor:setBorder(1)
end

function RichTextEditor:onMouseEnter(x, y)
	theView:setCursor("text")
end

function RichTextEditor:onMouseLeave(x, y)
	theView:setCursor("default")
end

function RichTextEditor:repos(x, y)
	if not self.editor then return end
	self.editor:setBorderColor((showEditorsBorders and 0) or 0xffffff )
	self.editor:move(x, y)
	Widget.repos(self, x, y)
end

function RichTextEditor:resize(w, h)
	if not self.editor then return end
	self.editor:resize(w, h)
	Widget.resize(self, w, h)
end

function RichTextEditor:setFocus()
	self.editor:setFocus(true)
end

function RichTextEditor:releaseFocus()
	self.editor:setFocus(false)
end

function RichTextEditor:addString(str)
	local currentText = self.editor:getText() or ""
	self.editor:setText(currentText .. str)
	return true
end

function RichTextEditor:paint(gc, focused) end

-- MathEditor: a rich text editor with math-specific quirks and a love for Unicode.
MathEditor = class(RichTextEditor)

-- Returns the number of Unicode codepoints in a string.
-- Because Lua strings are byte-based and Unicode is hard.
function ulen(str)
	if not str then return 0 end
	local n = string.len(str)
	local i = 1
	local j = 1
	local c
	while (j <= n) do
		c = string.len(string.usub(str, i, i))
		j = j + c
		i = i + 1
	end
	return i - 1
end

-- Initialize a MathEditor, set up filters for key events, and generally make life complicated.
function MathEditor:init(view, x, y, w, h, text)
	RichTextEditor.init(self, view, x, y, w, h, text)
	self.editor:setBorder(1)
	self.acceptsEnter = true
	self.acceptsBackSpace = true
	self.result = false
	self.editor:registerFilter({
		arrowLeft = function()
			_, curpos = self.editor:getExpressionSelection()
			if curpos < 7 then
				on.arrowLeft()
				return true
			end
			return false
		end,
		arrowRight = function()
			currentText, curpos = self.editor:getExpressionSelection()
			if curpos > ulen(currentText) - 2 then
				on.arrowRight()
				return true
			end
			return false
		end,
		tabKey = function()
			theView:tabForward()
			return true
		end,
		mouseDown = function(x, y)
			theView:onMouseDown(x, y)
			return false
		end,
		backspaceKey = function()
			if (self == fctEditor) then
				self:fixCursor()
				_, curpos = self.editor:getExpressionSelection()
				if curpos <= 6 then return true end
				return false
			else
				self:backSpaceHandler()
				return true
			end
		end,
		deleteKey = function()
			if (self == fctEditor) then
				self:fixCursor()
				currentText, curpos = self.editor:getExpressionSelection()
				if curpos >= ulen(currentText) - 1 then return true end
				return false
			else
				self:backSpaceHandler()
				return true
			end
		end,
		enterKey = function()
			self:enterHandler()
			return true
		end,
		returnKey = function()
			theView:enterHandler()
			return true
		end,
		escapeKey = function()
			on.escapeKey()
			return true
		end,
		charIn = function(c)
			if (self == fctEditor) then
				self:fixCursor()
				return false
			else
				return self.readOnly
			end
		end
	})
end

-- Ensures the editor has a math box at all times.
function MathEditor:fixContent()
	local currentText = self.editor:getExpressionSelection()
	if currentText == "" or currentText == nil then
		self.editor:createMathBox()
	end
end

-- Make sure the cursor stays inside the editable region of the Unicode string.
-- D2Editor likes to insert special tokens at the start, so we have to skip the first 6 codepoints.
-- If the cursor escapes the allowed range, forcibly drag it back, because users can't be trusted.
function MathEditor:fixCursor()
	local currentText, curpos, selstart = self.editor:getExpressionSelection()
	local l = ulen(currentText)
	if curpos < 6 or selstart < 6 or curpos > l - 1 or selstart > l - 1 then
		if curpos < 6 then curpos = 6 end
		if selstart < 6 then selstart = 6 end
		if curpos > l - 1 then curpos = l - 1 end
		if selstart > l - 1 then selstart = l - 1 end
		self.editor:setExpression(currentText, curpos, selstart)
	end
end

-- Extract the user-entered expression from the D2Editor string, skipping any special formatting.
function MathEditor:getExpression()
	if not self.editor then return "" end
	local rawexpr = self.editor:getExpression()
	local expr = ""
	local n = string.len(rawexpr)
	local b = 0
	local bs = 0
	local bi = 0
	local status = 0
	local i = 1
	while i <= n do
		local c = string.sub(rawexpr, i, i)
		if c == "{" then
			b = b + 1
		elseif c == "}" then
			b = b - 1
		end
		if status == 0 then
			if string.sub(rawexpr, i, i + 5) == "\\0el {" then
				bs = i + 6
				i = i + 5
				status = 1
				bi = b
				b = b + 1
			end
		else
			if b == bi then
				status = 0
				expr = expr .. string.sub(rawexpr, bs, i - 1)
			end
		end
		i = i + 1
	end
	return expr
end

-- Set focus to the math editor, so it can feel important.
function MathEditor:setFocus()
	if not self.editor then return end
	self.editor:setFocus(true)
end

-- Remove focus from the math editor, so it can sulk in the corner.
function MathEditor:releaseFocus()
	if not self.editor then return end
	self.editor:setFocus(false)
end

-- Inserts text at the cursor. Assumes user knows what they’re doing. (They probably don’t.)
function MathEditor:addString(str)
	if not self.editor then return false end
	self:fixCursor()
	-- Unicode string slicing: because normal string.sub just isn't enough.
	local currentText, curpos, selstart = self.editor:getExpressionSelection()
	local newText = string.usub(currentText, 1, math.min(curpos, selstart)) .. str .. string.usub(currentText, math.max(curpos, selstart) + 1, ulen(currentText))
	self.editor:setExpression(newText, math.min(curpos, selstart) + ulen(str))
	return true
end

-- Handle backspace. (No-op for now, because history deletion is scary.)
function MathEditor:backSpaceHandler()
    -- No-op or custom deletion logic (history removal not implemented)
end

-- Handle enter key. Just delegates to the real handler.
function MathEditor:enterHandler()
    -- Call the custom on.enterKey handler instead of missing global
    on.enterKey()
end

-- Draws horizontal lines under the editor, if we're feeling fancy.
function MathEditor:paint(gc)
	if showHLines and not self.result then
		gc:setColorRGB(100, 100, 100)
		local ycoord = self.y - (showEditorsBorders and 0 or 2)
		gc:drawLine(1, ycoord, platform.window:width() - sbv.w - 2, ycoord)
		gc:setColorRGB(0, 0, 0)
	end
end

function on.arrowUp()
  if theView then
    if theView:getFocus() == fctEditor then
      on.tabKey()
    else
      on.tabKey()
      if theView:getFocus() ~= fctEditor then on.tabKey() end
    end
    reposView()
  end
end

function on.arrowDown()
  if theView then
    on.backtabKey()
    if theView:getFocus() ~= fctEditor then on.backtabKey() end
    reposView()
  end
end

function on.arrowLeft()
  if theView then
    on.tabKey()
    reposView()
  end
end

function on.arrowRight()
  if theView then
    on.backtabKey()
    reposView()
  end
end

function on.charIn(ch)
  if theView then theView:sendStringToFocus(ch) end
end

function on.tabKey()
  if theView then theView:tabForward(); reposView() end
end

function on.backtabKey()
  if theView then theView:tabBackward(); reposView() end
end

function on.enterKey()
  if not fctEditor or not fctEditor.getExpression then return end

  -- Recall the current constant category (do not set default here)
  local recalled = var.recall and var.recall("current_constant_category")
  if recalled ~= nil then
    current_constant_category = recalled
    print("[INIT] Recalled constant category: " .. tostring(current_constant_category))
  else
    print("[INIT] Recall failed or value was nil; skipping default set")
  end

  local input = fctEditor:getExpression()
  -- Check for custom snarky responses
  local joke = _G.errors.get(input)
  if joke then
    result = joke
    addME(input, result, "normal")
    if fctEditor and fctEditor.editor then
      fctEditor.editor:setText("")
      fctEditor:fixContent()
    end
    if platform and platform.window and platform.window.invalidate then
      platform.window:invalidate()
    end
    return
  end
  -- Fix TI-style derivative notation like ((d)/(dx(x^2))) to diff(x^2, x)
  input = input:gsub("%(%(d%)%)%/%(d([a-zA-Z])%((.-)%)%)%)", function(var, inner)
    _G.__diff_var = var
    return inner
  end)
  if not input or input == "" then return end

  -- Remove all whitespace from input
  input = input:gsub("%s+", "")

  local result = ""
  _G.luaCASerror = false
  local function get_constant_value(fname)
    local physics_constants = _G.physics_constants or {}
    local avail = var.recall and var.recall("available_constants") or {}
    local is_enabled = (avail == nil) or (avail[fname] == true)
    -- Retrieve current category for this resolution
    local cat = var.recall and var.recall("current_constant_category")
    print("[DEBUG] Category set to:", tostring(cat))
    if physics_constants[fname]
      and is_enabled
      and physics_constants[fname].category == cat then
      return physics_constants[fname].value
    end
    return nil
  end
  local function eval_physics_func(fname)
    local physics_constants = _G.physics_constants or {}
    local avail = var.recall and var.recall("available_constants") or {}
    local is_enabled = (avail == nil) or (avail[fname] == true)
    -- Retrieve current category for this resolution
    local cat = var.recall and var.recall("current_constant_category")
    print("[DEBUG] Category set to:", tostring(cat))
    if physics_constants[fname]
      and is_enabled
      and physics_constants[fname].category == cat then
      return physics_constants[fname].value
    end
    return nil
  end

  local success, err = pcall(function()
    if input:sub(1,4) == "d/dx" or input:sub(1,4) == "d/dy" then
      local expr = input:match("d/d[xy]%((.+)%)")
      result = expr and derivative(expr, _G.__diff_var) or errors.invalid("diff")
      if result == errors.invalid("diff") then _G.luaCASerror = true end
    elseif input:sub(1,5) == "∂/∂x(" and input:sub(-1) == ")" then
      local expr = input:match("∂/∂x%((.+)%)")
      result = expr and derivative(expr, _G.__diff_var) or errors.invalid("diff")
      if result == errors.invalid("diff") then _G.luaCASerror = true end
    elseif input:match("^∂/∂[yz]%(.+%)$") then
      result = derivative(input, _G.__diff_var)
    elseif input:sub(1,3) == "∫(" and input:sub(-2) == ")x" then
      result = integrate(parse(input:sub(4, -3)))
    elseif input:sub(1,4) == "int(" and input:sub(-1) == ")" then
      local expr = input:match("int%((.+)%)")
      result = expr and integrate(parse(expr)) or errors.invalid("int")
      if result == errors.invalid("int") then _G.luaCASerror = true end
    elseif input:sub(1,6) == "solve(" and input:sub(-1) == ")" then
      local eqn = input:match("solve%((.+)%)")
      if eqn and not eqn:find("=") then
        eqn = eqn .. "=0"
      end
      result = eqn and solve(parse(eqn)) or errors.invalid("solve")
      if result == errors.invalid("solve") then _G.luaCASerror = true end
    elseif input:sub(1,4) == "let" then
      result = define(input)
    elseif input:sub(1,7) == "expand(" and input:sub(-1) == ")" then
        local inner = input:match("expand%((.+)%)")
        result = inner and expand(parse(inner)) or errors.invalid("expand")
        if result == errors.invalid("expand") then _G.luaCASerror = true end
    elseif input:sub(1,5) == "subs(" and input:sub(-1) == ")" then
        local inner, varname, val = input:match("subs%(([^,]+),([^,]+),([^%)]+)%)")
        result = (inner and varname and val) and subs(parse(inner), varname, val) or errors.invalid("subs")
        if result == errors.invalid("subs") then _G.luaCASerror = true end
    elseif input:sub(1,7) == "factor(" and input:sub(-1) == ")" then
        local inner = input:match("factor%((.+)%)")
        result = inner and factor(parse(inner)) or errors.invalid("factor")
        if result == errors.invalid("factor") then _G.luaCASerror = true end
    elseif input:sub(1,4) == "gcd(" and input:sub(-1) == ")" then
        local a, b = input:match("gcd%(([^,]+),([^%)]+)%)")
        result = (a and b) and gcd(parse(a), parse(b)) or errors.invalid("gcd")
        if result == errors.invalid("gcd") then _G.luaCASerror = true end
    elseif input:sub(1,4) == "lcm(" and input:sub(-1) == ")" then
        local a, b = input:match("lcm%(([^,]+),([^%)]+)%)")
        result = (a and b) and lcm(parse(a), parse(b)) or errors.invalid("lcm")
        if result == errors.invalid("lcm") then _G.luaCASerror = true end
    elseif input:sub(1,7) == "trigid(" and input:sub(-1) == ")" then
        local inner = input:match("trigid%((.+)%)")
        result = inner and trigid(parse(inner)) or errors.invalid("trigid")
        if result == errors.invalid("trigid") then _G.luaCASerror = true end
    elseif input:match("%w+%(.+%)") then
      print("[DEBUG] Category set to:", var.recall("current_constant_category"))
      result = simplify.simplify(parse(input))
    elseif input:sub(1,9) == "simplify(" and input:sub(-1) == ")" then
      local inner = input:match("simplify%((.+)%)")
      print("[DEBUG] Category set to:", var.recall("current_constant_category"))
      result = inner and simplify.simplify(parse(inner)) or errors.invalid("simplify")
      if result == errors.invalid("simplify") then _G.luaCASerror = true end
    -- Fallback parser for diff(...) and integrate(...)
    elseif input:match("^diff%(([^,]+),([^,%)]+)%)$") then
      local a, b = input:match("^diff%(([^,]+),([^,%)]+)%)$")
      result = (a and b) and derivative(parse(a), b) or errors.invalid("diff")
      if result == errors.invalid("diff") then _G.luaCASerror = true end
    elseif _G.__diff_var then
      result = derivative(input, _G.__diff_var)
      _G.__diff_var = nil
    elseif input:match("^integrate%(([^,]+),([^,%)]+)%)$") then
      local a, b = input:match("^integrate%(([^,]+),([^,%)]+)%)$")
      result = (a and b) and integrate(parse(a), b) or errors.invalid("int")
      if result == errors.invalid("int") then _G.luaCASerror = true end
    else
      -- Try constant resolution
      local constval = get_constant_value(input)
      if constval ~= nil then
        result = constval
      else
        print("[DEBUG] Category set to:", var.recall("current_constant_category"))
        result = simplify.simplify(parse(input))
      end
    end
    if result == "" or not result then
      result = "No result. Internal CAS fallback used."
    end
  end)
  if not success then
    result = "Error: " .. tostring(err)
    _G.luaCASerror = true
  end

  -- Add to history display
  local colorHint = (_G.luaCASerror and "error") or "normal"
  addME(input, result, colorHint)

  -- Clear the input editor and ready for next input
  if fctEditor and fctEditor.editor then
    fctEditor.editor:setText("")
    fctEditor:fixContent()
  end

  -- Redraw UI
  if platform and platform.window and platform.window.invalidate then
    platform.window:invalidate()
  end

  -- Optionally save last result globally if needed
  if type(result) == "table" then
    if _G.ast and _G.ast.tostring then
      result = _G.ast.tostring(result)
    else
      result = "(unrenderable result)"
    end
  end
  res = result
end

function on.returnKey()
  on.enterKey()
end

function on.mouseMove(x, y)
  if theView then theView:onMouseMove(x, y) end
end

function on.mouseDown(x, y)
  -- Modal close "X" button
  if _G.showSettingsModal and _G.modalCloseBtnRegion then
    local r = _G.modalCloseBtnRegion
    if x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
      _G.showSettingsModal = false
      platform.window:invalidate()
      return
    end
  end
  -- Handle custom settings icon button click
  if _G.settingsBtnRegion then
    local r = _G.settingsBtnRegion
    if x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
      if not _G.showSettingsModal then
        _G.showSettingsModal = true
        platform.window:invalidate()
      end
      return
    end
  end
  -- Modal ETK Button mouseDown
  if _G.showSettingsModal and _G.modalETKButton then
    local btn = _G.modalETKButton
    local btnW = btn.dimension.width or 80
    local btnH = btn.dimension.height or 28
    local modalW, modalH = 200, 120
    local modalX = (scrWidth - modalW) / 2
    local modalY = (scrHeight - modalH) / 2
    local btnX = modalX + (modalW - btnW) / 2
    local btnY = modalY + 54
    if x >= btnX and x <= btnX + btnW and y >= btnY and y <= btnY + btnH then
      btn:onMouseDown()
      platform.window:invalidate()
      return
    end
  end
  -- Toggle switch press effect when settings modal is open
  if _G.showSettingsModal and _G.switchRegion then
    local r = _G.switchRegion
    if x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
      _G.switchPressed = true
      platform.window:invalidate()
      return
    end
  end
  if theView then theView:onMouseDown(x, y) end
end

function on.mouseUp(x, y)
  -- Modal ETK Button mouseUp
  if _G.showSettingsModal and _G.modalETKButton then
    local btn = _G.modalETKButton
    local btnW = btn.dimension.width or 80
    local btnH = btn.dimension.height or 28
    local modalW, modalH = 200, 120
    local modalX = (scrWidth - modalW) / 2
    local modalY = (scrHeight - modalH) / 2
    local btnX = modalX + (modalW - btnW) / 2
    local btnY = modalY + 54
    if x >= btnX and x <= btnX + btnW and y >= btnY and y <= btnY + btnH then
      btn:onMouseUp(x - btnX, y - btnY, true)
      platform.window:invalidate()
      return
    end
  end
  if _G.showSettingsModal and _G.switchRegion and _G.switchPressed then
    local r = _G.switchRegion
    if x >= r.x and x <= r.x + r.w and y >= r.y and y <= r.y + r.h then
      _G.autoDecimal = not _G.autoDecimal
    end
    _G.switchPressed = false
    platform.window:invalidate()
    return
  end
  -- Custom handling for Constants UI in Settings modal
  if _G.showSettingsModal then
    local modalW, modalH = 200, 120
    local modalX = (scrWidth - modalW) / 2
    local modalY = (scrHeight - modalH) / 2
    local labelX = modalX + 10
    local labelY = modalY + 54
    local btnW, btnH = 48, 22
    -- Constants toggle button region
    local consBtnX = labelX + getStringWidth("Constants:") + 10
    local consBtnY = labelY + 8
    if x >= consBtnX and x <= consBtnX + btnW and y >= consBtnY and y <= consBtnY + btnH then
      -- Delegate to the Constants toggle button widget
      _G.constantsToggleBtn:onMouseUp(x - consBtnX, y - consBtnY, true)
      platform.window:invalidate()
      return
    end
    -- Category button click region
    local decLabelX = modalX + 10
    local decLabelY = modalY + 40
    local catBtnX = decLabelX + getStringWidth("Decimals:") + 10
    local catBtnY = decLabelY + 58
    local catBtnW, catBtnH = 90, 22
    if x >= catBtnX and x <= catBtnX + catBtnW
       and y >= catBtnY and y <= catBtnY + catBtnH then
      _G.categoryBtn:onMouseUp(x - catBtnX, y - catBtnY, true)
      platform.window:invalidate()
      return
    end
    -- Individual constant checkbox regions
    local avail = var.recall("available_constants") or {}
    local clist = get_constants_by_category(_G.currentConstCategory)
    for i, name in ipairs(clist) do
      local cy = consBtnY + 40 + (i - 1) * 15
      if y >= cy and y <= cy + 15 and x >= labelX and x <= labelX + 200 then
        -- Toggle this constant on/off
        avail[name] = not (avail[name] == true)
        var.store("available_constants", avail)
        platform.window:invalidate()
        return
      end
    end
  end
  if theView then theView:onMouseUp(x, y) end
end

function initFontGC(gc)
	gc:setFont(font, style, fsize)
end

function getStringHeightGC(text, gc)
	initFontGC(gc)
	return gc:getStringHeight(text)
end

function getStringHeight(text)
	return platform.withGC(getStringHeightGC, text)
end

function getStringWidthGC(text, gc)
	initFontGC(gc)
	return gc:getStringWidth(text)
end

function getStringWidth(text)
	return platform.withGC(getStringWidthGC, text)
end


----------------------------------------------------------------------
--                           History Layout                           --
----------------------------------------------------------------------

-- Find the “partner” editor for a history entry
function getParME(editor)
    for i = 1, #histME2 do
        if histME2[i].editor == editor then
            return histME1[i]
        end
    end
    return nil
end

-- Map a D2Editor instance back to its MathEditor wrapper
function getME(editor)
    if fctEditor and fctEditor.editor == editor then
        return fctEditor
    else
        for i = 1, #histME1 do
            if histME1[i].editor == editor then
                return histME1[i]
            end
        end
        for i = 1, #histME2 do
            if histME2[i].editor == editor then
                return histME2[i]
            end
        end
    end
    return nil
end

-- Get the “index” of a given MathEditor in the history stack
function getMEindex(me)
    if fctEditor and fctEditor.editor == me then
        return 0
    else
        local ti = 0
        for i = #histME1, 1, -1 do
            if histME1[i] == me then
                return ti
            end
            ti = ti + 1
        end
        ti = 0
        for i = #histME2, 1, -1 do
            if histME2[i] == me then
                return ti
            end
            ti = ti + 1
        end
    end
    return 0
end

-- Global offset for history scrolling
ioffset = 0

function reposView()
    local focusedME = theView:getFocus()
    if not focusedME or focusedME == fctEditor then return end

    local index = getMEindex(focusedME)
    local maxIterations = 10 -- prevent infinite loops
    for _ = 1, maxIterations do
        local y = focusedME.y
        local h = focusedME.h
        local y0 = fctEditor.y

        if y < 0 and ioffset < index then
            ioffset = ioffset + 1
            reposME()
        elseif y + h > y0 and ioffset > index then
            ioffset = ioffset - 1
            reposME()
        else
            break
        end
    end
end

-- When a history editor resizes, lay out paired entries side-by-side
function resizeMEpar(editor, w, h)
    local pare = getParME(editor)
    if pare then
        resizeMElim(editor, w, h, pare.w + (pare.dx1 or 0) * 2)
    else
        resizeME(editor, w, h)
    end
end

-- Generic resize for any MathEditor
function resizeME(editor, w, h)
    if not editor then return end
    resizeMElim(editor, w, h, scrWidth / 2)
end

-- Internal workhorse for resizing (limits width, then calls reposME)
function resizeMElim(editor, w, h, lim)
    if not editor then return end
    local met = getME(editor)
    if met then
        met.needw = w
        met.needh = h
        w = math.max(w, 0)
        w = math.min(w, scrWidth - (met.dx1 or 0) * 2)
        if met ~= fctEditor then
            w = math.min(w, (scrWidth - lim) - 2 * (met.dx1 or 0) + 1)
        end
        h = math.max(h, strFullHeight + 8)
        met:resize(w, h)
        reposME()
        theView:invalidate()
    end
    return editor
end

-- “Scroll” and reflow all history MathEditors on screen
function reposME()
    local totalh, beforeh, visih = 0, 0, 0

    -- First, position the input editor at the bottom
    fctEditor.y = scrHeight - fctEditor.h
    theView:repos(fctEditor)

    -- Update scrollbar to fill from input up
    sbv:setVConstraints("justify", scrHeight - fctEditor.y + border)
    theView:repos(sbv)

    local y = fctEditor.y
    local i0 = math.max(#histME1, #histME2)

    for i = i0, 1, -1 do
        local h1, h2 = 0, 0
        if i <= #histME1 then h1 = math.max(h1, histME1[i].h) end
        if i <= #histME2 then h2 = math.max(h2, histME2[i].h) end
        local h = math.max(h1, h2)

        local ry
        if (i0 - i) >= ioffset then
            if y >= 0 then
                if y >= h + border then
                    visih = visih + h + border
                else
                    visih = visih + y
                end
            end
            y = y - h - border
            ry = y
            totalh = totalh + h + border
        else
            ry = scrHeight
            beforeh = beforeh + h + border
            totalh = totalh + h + border
        end

        -- Place the “expression” editor on the left
        if i <= #histME1 then
            histME1[i].y = ry
            theView:repos(histME1[i])
        end
        -- Place its paired “result” editor on the right, vertically aligned
        if i <= #histME2 then
            histME2[i].y = ry + math.max(0, h1 - h2)
            theView:repos(histME2[i])
        end
    end

    if totalh == 0 then
        sbv.pos = 0
        sbv.siz = 100
    else
        sbv.pos = beforeh * 100 / totalh
        sbv.siz = visih * 100 / totalh
    end

    theView:invalidate()
end

function initGUI()
    showEditorsBorders = false
    showHLines = true
    -- local riscas = math.evalStr("iscas()")
    -- if (riscas == "true") then iscas = true end
    local id = math.eval("sslib\\getid()")
    if id then caslib = id end
    scrWidth = platform.window:width()
    scrHeight = platform.window:height()
    if scrWidth > 0 and scrHeight > 0 then
        theView = View(platform.window)

        -- Vertical scroll bar for history
        sbv = VScrollBar(theView, 0, -1, 5, scrHeight + 1)
        sbv:setHConstraints("right", 0)
        theView:add(sbv)

        -- Input editor at bottom (MathEditor)
        fctEditor = MathEditor(theView, 2, border, scrWidth - 4 - sbv.w, 30, "")
        fctEditor:setHConstraints("justify", 1)
        fctEditor:setVConstraints("bottom", 1)
        fctEditor.editor:setSizeChangeListener(function(editor, w, h)
            return resizeME(editor, w, h)
        end)
        theView:add(fctEditor)
        fctEditor.result = res
        fctEditor.editor:setText("")
        fctEditor:fixContent()

        -- First-focus is input editor
        theView:setFocus(fctEditor)
        inited = true
    end

    toolpalette.enableCopy(true)
    toolpalette.enablePaste(true)
end

function resizeGC(gc)
	scrWidth = platform.window:width()
	scrHeight = platform.window:height()
	if not inited then
		initGUI()
	end
	if inited then
		initFontGC(gc)
		strFullHeight = gc:getStringHeight("H")
		strHeight = strFullHeight - 3
		theView:resize()
		reposME()
		theView:invalidate()
	end
end

function on.resize()
	platform.withGC(resizeGC)
end

forcefocus = true

function on.activate()
	forcefocus = true
end

dispinfos = true

-- The main UI rendering phase: draws status, output, and all widgets.
-- If you’re looking for where the magic (or horror) happens, it’s here.
function on.paint(gc)
	
	if not inited then
		initGUI()
		initFontGC(gc)
		strFullHeight = gc:getStringHeight("H")
		strHeight = strFullHeight - 3
	end
	if inited then
		-- Removed display of "Last: ..." result at the top
		local obj = theView:getFocus()
		initFontGC(gc)
		if not obj then theView:setFocus(fctEditor) end
		if (forcefocus) then
			if obj == fctEditor then
				fctEditor.editor:setFocus(true)
				if fctEditor.editor:hasFocus() then forcefocus = false end
			else
				forcefocus = false
			end
		end
		if dispinfos then
			-- Draw status box: green if OK, red if error, always visible top left
			local engineStatus = "LuaCAS Engine: Enabled"
			local statusColor = {0, 127, 0} -- green
			if _G.luaCASerror then
				engineStatus = "LuaCAS Engine: NONE"
				statusColor = {200, 0, 0} -- red
			end
			local boxX, boxY = 8, 8
			local boxPaddingX, boxPaddingY = 10, 3
			local fontToUse = "sansserif"
			local fontStyle = "b"
			local fontSize = 11
			gc:setFont(fontToUse, fontStyle, fontSize)
			local textW = gc:getStringWidth(engineStatus)
			local textH = gc:getStringHeight(engineStatus)
			gc:setColorRGB(statusColor[1], statusColor[2], statusColor[3])
			gc:fillRect(boxX, boxY, textW + boxPaddingX * 2, textH + boxPaddingY * 2)
			gc:setColorRGB(255,255,255)
			gc:drawString(engineStatus, boxX + boxPaddingX, boxY + boxPaddingY, "top")
			-- restore font for rest of UI
			gc:setFont(font, style, fsize)
		end
		-- Output string fallback for "main" view
		if true then -- "main" view block
			local output = fctEditor and fctEditor.result
			-- local outputStr = output or ""
			local outputStr = (output and output ~= "") and output or "(no output)"
			-- If you want to draw the output somewhere, do so here.
			gc:setColorRGB(0, 127, 0)
			gc:drawString(outputStr, 10, scrHeight - 25, "top")
		end
    -- Draw custom settings icon button at top right if modal not open
    if not _G.showSettingsModal then
      local btnSize = 24
      local btnX = scrWidth - btnSize - 8
      local btnY = 8
      _G.settingsBtnRegion = {x = btnX, y = btnY, w = btnSize, h = btnSize}
      -- Button background (white square)
      gc:setColorRGB(255,255,255)
      gc:fillRect(btnX, btnY, btnSize, btnSize)
      gc:setColorRGB(94,103,111)
      gc:drawRect(btnX, btnY, btnSize, btnSize)
      -- Centered symbol (π for settings)
      local symbol = "π"   -- Change to "." or "⋅" or "⚙" for different icons
      gc:setFont("sansserif", "b", 16)
      local textW = gc:getStringWidth(symbol)
      local textH = gc:getStringHeight(symbol)
      local centerX = btnX + (btnSize - textW) / 2
      local centerY = btnY + (btnSize - textH) / 2
      gc:drawString(symbol, centerX, centerY, "top")
    end
		theView:paint(gc)

        -- Draw settings modal if enabled (using embedded ETK-styled button)
        if _G.showSettingsModal then
          -- Modal base geometry (no scale, just fade)
          local modalW, modalH = 200, 120
          local modalX = (scrWidth - modalW) / 2
          local modalY = (scrHeight - modalH) / 2
          -- Modal background
          gc:setColorRGB(240, 240, 240)
          gc:fillRect(modalX, modalY, modalW, modalH)
          -- Modal border and title
          gc:setColorRGB(0, 0, 0)
          gc:drawRect(modalX, modalY, modalW, modalH)
          gc:drawString("Settings", modalX + 10, modalY + 10, "top")
          -- X close button (top right)
          local closeBtnSize = 24
          local closeX = modalX + modalW - closeBtnSize - 6
          local closeY = modalY + 6
          _G.modalCloseBtnRegion = {x = closeX, y = closeY, w = closeBtnSize, h = closeBtnSize}
          gc:setColorRGB(200,40,40)
          gc:fillRect(closeX, closeY, closeBtnSize, closeBtnSize)
          gc:setColorRGB(255,255,255)
          gc:setFont("sansserif", "b", 16)
          local xw = gc:getStringWidth("×")
          local xh = gc:getStringHeight("×")
          gc:drawString("×", closeX + (closeBtnSize - xw)/2, closeY + (closeBtnSize - xh)/2, "top")
          gc:setColorRGB(0,0,0)
          -- Decimals label and toggle button in left-aligned row
          local labelX = modalX + 10
          local labelY = modalY + 40
          gc:setColorRGB(0,0,0)
          gc:setFont("sansserif", "r", 12)
          gc:drawString("Decimals:", labelX, labelY, "top")
          local btnW = 48
          local btnH = 22
          local btnX = labelX + gc:getStringWidth("Decimals:") + 10
          local btnY = labelY - 2
          -- Store toggle button X for alignment
          local toggleBtnX = btnX
          if not _G.modalETKButton then
            _G.modalETKButton = Widgets.Button{
              text = (_G.autoDecimal and "ON" or "OFF"),
              position = Dimension(btnW, btnH),
              parent = theView,
              onAction = function(self)
                _G.autoDecimal = not _G.autoDecimal
                self.text = (_G.autoDecimal and "ON" or "OFF")
                if var and var.store then
                  var.store("nLuaCAS_decimals_pref", _G.autoDecimal and 1 or 0)
                end
                platform.window:invalidate()
              end,
              style = {
                font = {
                  serif = "sansserif",
                  style = "r",
                  size = 12
                },
                backgroundColor = {{248,252,248},{248,252,248}},
                borderColor     = {{136,136,136},{160,160,160}},
                textColor       = {{0,0,0},{0,0,0}},
                focusColor      = {{40,148,184},{0,0,0}}
              }
            }
          else
            _G.modalETKButton.text = (_G.autoDecimal and "ON" or "OFF")
          end
          _G.modalETKButton:draw(gc, btnX, btnY, btnW, btnH)

          -- Global constants toggle
          local const_off = var.recall("constants_off") or false
          -- Ensure label is solid black
          gc:setColorRGB(0,0,0)
          gc:drawString("Constants:", labelX, labelY + 30, "top")
          local consBtnX = toggleBtnX
          local consBtnY = labelY + 28
          if not _G.constantsToggleBtn then
            _G.constantsToggleBtn = Widgets.Button{
              text = (not const_off and "ON" or "OFF"),
              position = Dimension(btnW, btnH),
              parent = theView,
              onAction = function(self)
                local new_off = not var.recall("constants_off")
                var.store("constants_off", new_off)
                self.text = (not new_off and "ON" or "OFF")
                platform.window:invalidate()
              end,
              style = _G.modalETKButton and _G.modalETKButton.style or nil
            }
          else
            _G.constantsToggleBtn.text = (not const_off and "ON" or "OFF")
          end
          _G.constantsToggleBtn:draw(gc, consBtnX, consBtnY, btnW, btnH)

          -- Category selector
		  local const_off = var.recall("constants_off") or false
          -- Draw "Category:" label
gc:setColorRGB(0,0,0)
gc:drawString("Category:", labelX, labelY + 60, "top")

-- Setup category list
local categories = get_constant_categories()
_G.currentConstCategory = _G.currentConstCategory or categories[1]

local catBtnStyle = _G.modalETKButton.style
if const_off then
  catBtnStyle = {
    textColor       = {{128,128,128},{128,128,128}},
    backgroundColor = {{200,200,200},{200,200,200}},
    borderColor     = {{150,150,150},{150,150,150}},
    focusColor      = {{128,128,128},{128,128,128}},
    font            = _G.modalETKButton.style.font
  }
end
local catBtnX, catBtnY = toggleBtnX, labelY + 58
local catBtnW, catBtnH = 90, 22

if not _G.categoryBtn then
      _G.categoryBtn = Widgets.Button{
        text     = _G.currentConstCategory,
        position = Dimension(catBtnW, catBtnH),
        parent   = theView,
        onAction = const_off and nil or function(self)
          local idx = nil
          for i,v in ipairs(categories) do
            if v == _G.currentConstCategory then idx = i end
          end
          idx = (idx or 1)
          local selected_category = categories[(idx % #categories) + 1]
          if selected_category and type(selected_category) == "string" and selected_category ~= "" then
            -- Only update if changed
            if selected_category ~= _G.current_constant_category then
              _G.current_constant_category = selected_category
              var.store("current_constant_category", selected_category)
              if var.recall("current_constant_category") ~= selected_category then
                print("[INIT] Warning: Stored category not recalled correctly. Likely due to document not saved.")
              end
              print("[GUI] Set constant category to:\t" .. selected_category)
              print("[GUI] Stored constant category into persistent memory:", selected_category)
              print("[GUI] Verifying store with immediate recall:", var.recall("current_constant_category"))
            end
            _G.currentConstCategory = selected_category
            self.text = _G.currentConstCategory
            platform.window:invalidate()
          end
          -- Always store the selected category when changed
          if selected_category then
            current_constant_category = selected_category
            var.store("current_constant_category", selected_category)
            if var.recall("current_constant_category") ~= selected_category then
              print("[INIT] Warning: Stored category not recalled correctly. Likely due to document not saved.")
            end
            print("[GUI] Stored constant category into persistent memory:", selected_category)
            print("[GUI] Verifying store with immediate recall:", var.recall("current_constant_category"))
          end
        end,
        style = _G.modalETKButton.style
      }
end
_G.categoryBtn.text = _G.currentConstCategory
-- Only store the selected category if it actually changed (avoid redundant writes/logs)
do
  local selected_category = _G.currentConstCategory
  -- Cache last stored category in _G._last_selected_category
  if selected_category and selected_category ~= _G._last_selected_category then
	-- Oh look, we're setting the global again. Maybe this time it'll behave.
    _G.current_constant_category = selected_category
    var.store("current_constant_category", selected_category)
	-- Let's throw this into persistent memory and hope it actually sticks this time.
    _G._last_selected_category = selected_category
    if var.recall("current_constant_category") ~= selected_category then
      print("[INIT] Warning: Stored category not recalled correctly. Likely due to document not saved.")
    end
    print("[GUI] Set constant category to:\t" .. selected_category)
    print("[GUI] Stored constant category into persistent memory:", selected_category)

    local post_recall = var.recall("current_constant_category")
    if post_recall == nil then
      print("[GUI] Warning: Post-store recall returned nil — variable might not persist until saved manually.")
    else
      print("[GUI] Post-store recall:", post_recall)
    end
  end
end
_G.categoryBtn:draw(gc, catBtnX, catBtnY, catBtnW, catBtnH)

          -- Constants list with checkboxes
          local avail = var.recall("available_constants") or {}
          local clist = get_constants_by_category(_G.currentConstCategory)
          for i, name in ipairs(clist) do
            local cy = labelY + 90 + (i - 1) * 15
            local enabled = (avail == nil) or (avail[name] == true)
            gc:drawString((enabled and "[✓] " or "[ ] ") .. name, labelX, cy, "top")
          end
        end
	end
end

font = "sansserif"
style = "r"
fsize = 9

scrWidth = 0
scrHeight = 0
inited = false
iscas = false
caslib = "NONE"
delim = " ≟ "
border = 3

strHeight = 0
strFullHeight = 0



-- Initialize empty history tables
histME1 = {}
histME2 = {}


-- Reminder: this is the thing that dumps both the input and result into history.
function addME(expr, res, colorHint)
	mee = MathEditor(theView, border, border, 50, 30, "")
	mee.readOnly = true
	table.insert(histME1, mee)
	mee:setHConstraints("left", border)
	mee.editor:setSizeChangeListener(function(editor, w, h)
		return resizeME(editor, w + 3, h)
	end)
	-- Set border color based on colorHint
	if colorHint == "error" then
		mee.editor:setBorderColor(0xFF0000) -- red
	else
		mee.editor:setBorderColor(0x000000)
	end
	mee.editor:setExpression("\\0el {" .. expr .. "}", 0)
	mee:fixCursor()
	mee.editor:setReadOnly(true)
	theView:add(mee)

	mer = MathEditor(theView, border, border, 50, 30, "")
    mer.result = true
    mer.readOnly = true
	table.insert(histME2, mer)
	mer:setHConstraints("right", scrWidth - sbv.x + border)
	mer.editor:setSizeChangeListener(function(editor, w, h)
				return resizeMEpar(editor, w + border, h)
	end)
	if colorHint == "error" then
		mer.editor:setBorderColor(0xFF0000) -- red
	else
		mer.editor:setBorderColor(0x000000)
	end
    local displayRes = ""
    if type(res) == "table" then
      if _G.simplify and _G.simplify.pretty_print then
        displayRes = _G.simplify.pretty_print(res)
      elseif _G.ast and _G.ast.tostring then
        displayRes = _G.ast.tostring(res)
      else
        displayRes = tostring(res)
      end
    else
      displayRes = tostring(res)
    end
    mer.editor:setExpression("\\0el {" .. displayRes .. "}", 0)
	mer:fixCursor()
	mer.editor:setReadOnly(true)
	theView:add(mer)
	reposME()

-- Any unhandled errors will cause LuaCAS Engine status to go NONE (red)
end
-- Make var globally accessible for parser/physics.lua
_G.var = var

-- End src/gui.lua

-- Integrated src/gui.lua: let’s hope it compiles this time.

-- Build wrapping up. Tossed build.lua in here—go ahead, run your tests.
